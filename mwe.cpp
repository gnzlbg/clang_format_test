  
#pragma clang module build std_config
  
# 1 "/aia/r018/scratch/gonzalo/toolchain/llvm/include/c++/v1/module.modulemap"
module std_config   [system] [extern_c] {   header "__config" { size 40779 mtime 1504087238 } }
     
#pragma clang module contents
extern "C" {   
#if 0 /* expanded by -frewrite-includes */
  
#include "__config"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std_config
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CONFIG_SITE
  
#define _LIBCPP_CONFIG_SITE
 /*   
#undef _LIBCPP_ABI_VERSION */
  
   
#endif // _LIBCPP_CONFIG_SITE
// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CONFIG
  
#define _LIBCPP_CONFIG
   
#if defined(_MSC_VER) && !defined(__clang__)
  
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#define _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
  
#endif
  
#endif
   
#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifdef __cplusplus
   
   
#define _LIBCPP_VERSION 6000
   
#ifndef _LIBCPP_ABI_VERSION
  
#define _LIBCPP_ABI_VERSION 1
  
#endif
   
#if defined(__ELF__)
  
#define _LIBCPP_OBJECT_FORMAT_ELF   1
  
#elif defined(__MACH__)
  
#define _LIBCPP_OBJECT_FORMAT_MACHO 1
#endif
   
#define __has_keyword(__x) !(__is_identifier(__x))
   
#ifdef __has_include
  
#define __libcpp_has_include(__x) __has_include(__x)
  
  
#define _LIBCPP_COMPILER_CLANG
  
# ifndef __apple_build_version__
  
#   define _LIBCPP_CLANG_VER (__clang_major__ * 100 + __clang_minor__)
  
# endif
  
#endif
 // Need to detect which libc we're using if we're on Linux.
  
#if defined(__linux__)
  
#if 0 /* expanded by -frewrite-includes */
  
#include <features.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
   
#ifndef	_FEATURES_H
  
 /* Convenience macros to test the versions of glibc and gcc.    Use them like this:      
#if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...      
#endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */
#if defined __GNUC__ && defined __GNUC_MINOR__
# define __GNUC_PREREQ(maj, min) \
	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
#else
# define __GNUC_PREREQ(maj, min) 0
#endif


/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
#ifdef _GNU_SOURCE
# undef  _ISOC95_SOURCE
# define _ISOC95_SOURCE	1
# undef  _ISOC99_SOURCE
# define _ISOC99_SOURCE	1
# undef  _ISOC11_SOURCE
# define _ISOC11_SOURCE	1
# undef	 _LARGEFILE64_SOURCE
# define _LARGEFILE64_SOURCE	1
# undef  _DEFAULT_SOURCE
# define _DEFAULT_SOURCE	1
# undef  _BSD_SOURCE
# define _BSD_SOURCE	1
# undef  _SVID_SOURCE
# define _SVID_SOURCE	1
# undef  _ATFILE_SOURCE
# define _ATFILE_SOURCE	1
#endif

/* If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
   define _DEFAULT_SOURCE, _BSD_SOURCE and _SVID_SOURCE.  */
#if (defined _DEFAULT_SOURCE					\
     || (!defined __STRICT_ANSI__				\
	 && !defined _ISOC99_SOURCE				\
	 && !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE	\
	 && !defined _XOPEN_SOURCE				\
	 && !defined _BSD_SOURCE && !defined _SVID_SOURCE))
# undef  _DEFAULT_SOURCE
# define _DEFAULT_SOURCE	1
# undef  _BSD_SOURCE
# define _BSD_SOURCE	1
# undef  _SVID_SOURCE
# define _SVID_SOURCE	1
#endif

/* This is to enable the ISO C11 extension.  */
#if (defined _ISOC11_SOURCE \
     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 201112L))
# define __USE_ISOC11	1
#endif

/* This is to enable the ISO C99 extension.  */
#if (defined _ISOC99_SOURCE || defined _ISOC11_SOURCE \
     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))
# define __USE_ISOC99	1
#endif

/* This is to enable the ISO C90 Amendment 1:1995 extension.  */
#if (defined _ISOC99_SOURCE || defined _ISOC11_SOURCE \
     || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199409L))
# define __USE_ISOC95	1
#endif

/* This is to enable compatibility for ISO C++11.

   So far g++ does not provide a macro.  Check the temporary macro for
   now, too.  */
#if ((defined __cplusplus && __cplusplus >= 201103L)			      \
     || defined __GXX_EXPERIMENTAL_CXX0X__)
# define __USE_ISOCXX11	1
#endif

/* If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
   is defined, use POSIX.1-2008 (or another version depending on
   _XOPEN_SOURCE).  */
#ifdef _DEFAULT_SOURCE
# if !defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE
#  define __USE_POSIX_IMPLICITLY	1
# endif
# if defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500
#  define _POSIX_C_SOURCE	2
# elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 600
#  define _POSIX_C_SOURCE	199506L
# elif defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 700
#  define _POSIX_C_SOURCE	200112L
# else
#  define _POSIX_C_SOURCE	200809L
# endif
# define __USE_POSIX_IMPLICITLY	1
#endif

#if defined _POSIX_SOURCE || _POSIX_C_SOURCE >= 1 || defined _XOPEN_SOURCE
# define __USE_POSIX	1
#endif

#if (_POSIX_C_SOURCE - 0) >= 199506L
# define __USE_POSIX199506	1
#endif

#if (_POSIX_C_SOURCE - 0) >= 200112L
# define __USE_XOPEN2K		1
# undef __USE_ISOC95
# define __USE_ISOC95		1
# undef __USE_ISOC99
# define __USE_ISOC99		1
#endif

#if (_POSIX_C_SOURCE - 0) >= 200809L
# define __USE_XOPEN2K8		1
# define __USE_LARGEFILE	1
#endif

#ifdef _LARGEFILE64_SOURCE
# define __USE_LARGEFILE64	1
#endif

#if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
# define __USE_FILE_OFFSET64	1
#endif

#if defined _BSD_SOURCE || defined _SVID_SOURCE
# define __USE_MISC	1
#endif

#ifdef	_BSD_SOURCE
# define __USE_BSD	1
#endif

#ifdef	_SVID_SOURCE
# define __USE_SVID	1
#endif

#ifdef	_ATFILE_SOURCE
# define __USE_ATFILE	1
#endif

#ifdef	_GNU_SOURCE
# define __USE_GNU	1
#endif

#if defined _REENTRANT || defined _THREAD_SAFE
# define __USE_REENTRANT	1
#endif

#if defined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0
# if !defined __OPTIMIZE__ || __OPTIMIZE__ <= 0
#  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
# elif !__GNUC_PREREQ (4, 1)
#  warning _FORTIFY_SOURCE requires GCC 4.1 or later
# elif _FORTIFY_SOURCE > 1
#  define __USE_FORTIFY_LEVEL 2
# else
#  define __USE_FORTIFY_LEVEL 1
# endif
#include <stdc-predef.h>
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef	_STDC_PREDEF_H
#define	_STDC_PREDEF_H	1

/* This header is separate from features.h so that the compiler can
#else
  
# define __STDC_IEC_559_COMPLEX__	1
  
#endif
 /* wchar_t uses ISO/IEC 10646 (2nd ed., published 2011-03-15) /   Unicode 6.0.  */
#define __STDC_ISO_10646__		201103L
 /* We do not support C11 <threads.h>.  */
#define __STDC_NO_THREADS__		1
   
#endif
 /* This macro indicates that the installed library is the GNU C Library.    For historic reasons the value now is 6 and this will stay from now    on.  The use of this variable is deprecated.  Use __GLIBC__ and    __GLIBC_MINOR__ now (see below) when you want to test for a specific    GNU C library version and use the values in <gnu/lib-names.h> to get    the sonames of the shared libraries.  */
#undef  __GNU_LIBRARY__
  
#define __GNU_LIBRARY__ 6
 /* Major and minor version number of the GNU C library package.  Use    these macros to test for features in specific releases.  */
#define	__GLIBC__	2
  
#define	__GLIBC_MINOR__	19
   
#define __GLIBC_PREREQ(maj, min) \
	((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))
 /* This is here only because every header file already includes this one.  */
#ifndef __ASSEMBLER__
  
# ifndef _SYS_CDEFS_H
  
#if 0 /* expanded by -frewrite-includes */
  
#  include <sys/cdefs.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1992-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
   
#ifndef	_SYS_CDEFS_H
  
#define	_SYS_CDEFS_H	1
 /* We are almost always included from features.h. */
#ifndef _FEATURES_H
  
#if 0 /* expanded by -frewrite-includes */
  
# include <features.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
#undef	__P
  
#undef	__PMT
   
#ifdef __GNUC__
 /* All functions, except those with callbacks or those that    synchronize memory, are leaf functions.  */
# if __GNUC_PREREQ (4, 6) && !defined _LIBC
  
#  define __THROWNL	__attribute__ ((__nothrow__))
  
#  define __NTH(fct)	__attribute__ ((__nothrow__ __LEAF)) fct
  
# else
  
#  if defined __cplusplus && __GNUC_PREREQ (2,8)
  
#   define __THROW	throw ()
  
#   define __THROWNL	throw ()
  
#   define __NTH(fct)	__LEAF_ATTR fct throw ()
  
#  else
#  endif
  
# endif
   
#else	/* Not GCC.  */
   
# define __inline		/* No inline functions.  */
   
# define __THROW
  
# define __THROWNL
  
# define __NTH(fct)	fct
   
#endif	/* GCC.  */
 /* These two macros are not used in glibc anymore.  They are kept here    only because some other projects expect the macros to be defined.  */
#define __P(args)	args
  
#define __PMT(args)	args
 /* For these things, GCC behaves the ANSI way normally,    and the non-ANSI way under -traditional.  */   
#define __CONCAT(x,y)	x ## y
  
#define __STRING(x)	#x
 /* This is not a typedef so `const __ptr_t' does the right thing.  */
#define __ptr_t void *
#define __long_double_t  long double


/* C++ needs to know that types and declarations are C, not C++.  */
#ifdef	__cplusplus
# define __BEGIN_DECLS	extern "C" {
# define __END_DECLS	}
#else
# define __BEGIN_DECLS
# define __END_DECLS
#endif


/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */
#if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES
# define __BEGIN_NAMESPACE_STD	namespace std {
# define __END_NAMESPACE_STD	}
# define __USING_NAMESPACE_STD(name) using std::name;
# define __BEGIN_NAMESPACE_C99	namespace __c99 {
# define __END_NAMESPACE_C99	}
# define __USING_NAMESPACE_C99(name) using __c99::name;
#else
/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
# define __BEGIN_NAMESPACE_STD
# define __END_NAMESPACE_STD
# define __USING_NAMESPACE_STD(name)
# define __BEGIN_NAMESPACE_C99
# define __END_NAMESPACE_C99
# define __USING_NAMESPACE_C99(name)
#endif


/* Fortify support.  */
#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
#define __bos0(ptr) __builtin_object_size (ptr, 0)
#define __fortify_function __extern_always_inline __attribute_artificial__

#if __GNUC_PREREQ (4,3)
#else
# ifdef __GNUC__
#  define __flexarr	[0]
# else
#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
#   define __flexarr	[]
#  else
/* Some other non-C99 compiler.  Approximate with [1].  */
#   define __flexarr	[1]
#  endif
# endif
#endif


/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do    preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).     Example:    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */   
#if defined __GNUC__ && __GNUC__ >= 2
   
# define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))
  
# ifdef __cplusplus
  
#  define __REDIRECT_NTH(name, proto, alias) \
     name proto __THROW __asm__ (__ASMNAME (#alias))
  
#  define __REDIRECT_NTHNL(name, proto, alias) \
     name proto __THROWNL __asm__ (__ASMNAME (#alias))
  
  
# endif
  
# define __ASMNAME(cname)  __ASMNAME2 (__USER_LABEL_PREFIX__, cname)
  
# define __ASMNAME2(prefix, cname) __STRING (prefix) cname
 /*   
#elif __SOME_OTHER_COMPILER__
#if !defined __GNUC__ || __GNUC__ < 2
  
# define __attribute__(xyz)	/* Ignore */
  
#endif
 /* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally    (although this would be possible) since it generates warnings.  */
#if __GNUC_PREREQ (2,96)
  
# define __attribute_malloc__ __attribute__ ((__malloc__))
  
#else
  
# define __attribute_malloc__ /* Ignore */
  
#endif
 /* Tell the compiler which arguments to an allocation function    indicate the size of the allocation.  */
#if __GNUC_PREREQ (4, 3)
  
# define __attribute_alloc_size__(params) \
  __attribute__ ((__alloc_size__ params))
  
#else
  
# define __attribute_alloc_size__(params) /* Ignore.  */
  
#endif
 /* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally    (although this would be possible) since it generates warnings.  */
#if __GNUC_PREREQ (2,96)
  
# define __attribute_pure__ __attribute__ ((__pure__))
  
#else
  
# define __attribute_pure__ /* Ignore */
  
#endif
 /* This declaration tells the compiler that the value is constant.  */
#if __GNUC_PREREQ (2,5)
  
# define __attribute_const__ __attribute__ ((__const__))
  
#else
  
# define __attribute_const__ /* Ignore */
  
#endif
 /* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally    (although this would be possible) since it generates warnings.  */
#if __GNUC_PREREQ (3,1)
  
# define __attribute_used__ __attribute__ ((__used__))
  
# define __attribute_noinline__ __attribute__ ((__noinline__))
# define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))
#else
# define __attribute_format_arg__(x) /* Ignore */
#endif

/* At some point during the gcc 2.97 development the `strfmon' format    attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */
/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */
#if __GNUC_PREREQ (3,3)
# define __nonnull(params) __attribute__ ((__nonnull__ params))
#else
# define __nonnull(params)
#endif

/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */
#if __GNUC_PREREQ (3,4)
# define __attribute_warn_unused_result__ \
   __attribute__ ((__warn_unused_result__))
# if __USE_FORTIFY_LEVEL > 0
#  define __wur __attribute_warn_unused_result__
# endif
#else
# define __attribute_warn_unused_result__ /* empty */
#endif
#ifndef __wur
# define __wur /* Ignore */
#endif

#ifdef __GNUC__
/* One of these will be defined if the __gnu_inline__ attribute is
   available.  In C++, __GNUC_GNU_INLINE__ will be defined even though
   __inline does not use the GNU inlining rules.  If neither macro is
   defined, this version of GCC only supports GNU inline semantics. */
# if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
#  define __extern_inline extern __inline __attribute__ ((__gnu_inline__))
#  define __extern_always_inline \
  extern __always_inline __attribute__ ((__gnu_inline__))
# else
#  define __extern_inline extern __inline
#  define __extern_always_inline extern __always_inline
# endif
#else /* Not GCC.  */
# define __extern_inline  /* Ignore */
# define __extern_always_inline /* Ignore */
  
# define __LDBL_REDIR_DECL(name)
  
# ifdef __REDIRECT
  
#  define __REDIRECT_LDBL(name, proto, alias) __REDIRECT (name, proto, alias)
  
#  define __REDIRECT_NTH_LDBL(name, proto, alias) \
  __REDIRECT_NTH (name, proto, alias)
  
# endif
  
#endif
   
#endif	 /* sys/cdefs.h */
  
# endif
 /* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */
# if defined __USE_FILE_OFFSET64 && !defined __REDIRECT
#  define __USE_LARGEFILE	1
#  define __USE_LARGEFILE64	1
# endif

  
#include <gnu/stubs.h>
  
#endif /* expanded by -frewrite-includes */
/* This file is automatically generated.    This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */


#if !defined __x86_64__
#if 0 /* expanded by -frewrite-includes */
# include <gnu/stubs-32.h>
#endif /* expanded by -frewrite-includes */
#endif
#if defined __x86_64__ && defined __LP64__
#if 0 /* expanded by -frewrite-includes */
# include <gnu/stubs-64.h>
#endif
   
#define __stub_bdflush
  
#define __stub_chflags
  
#define __stub_fattach
  
#endif
  
#if defined __x86_64__ && defined __ILP32__
  
#if 0 /* expanded by -frewrite-includes */
  
# include <gnu/stubs-x32.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
    
#endif	/* features.h  */
  
#if !defined(__GLIBC_PREREQ)
  
#define __GLIBC_PREREQ(a, b) 0
  
#endif // !defined(__GLIBC_PREREQ)
  
#endif // defined(__linux__)
   
#ifdef __LITTLE_ENDIAN__
  
# define _LIBCPP_USING_WIN32_RANDOM
  
#else
  
# define _LIBCPP_USING_DEV_RANDOM
  
#endif
   
#if !defined(_LIBCPP_LITTLE_ENDIAN) || !defined(_LIBCPP_BIG_ENDIAN)
  
#if 0 /* expanded by -frewrite-includes */
  
# include <endian.h>
  
#endif /* expanded by -frewrite-includes */
  
# if __BYTE_ORDER == __LITTLE_ENDIAN
  
#  define _LIBCPP_LITTLE_ENDIAN 1
  
#  define _LIBCPP_BIG_ENDIAN    0
  
# elif __BYTE_ORDER == __BIG_ENDIAN
#  error unable to determine endian
  
# endif
  
#endif  // !defined(_LIBCPP_LITTLE_ENDIAN) || !defined(_LIBCPP_BIG_ENDIAN)
   
#if __has_attribute(__no_sanitize__) && !defined(_LIBCPP_COMPILER_GCC)
  
#define _LIBCPP_NO_CFI __attribute__((__no_sanitize__("cfi")))
  
#else
  
#define _LIBCPP_NO_CFI
  
#endif
   
#if defined(_LIBCPP_COMPILER_CLANG)
 // _LIBCPP_ALTERNATE_STRING_LAYOUT is an old name for
// _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT left here for backward compatibility.
  
#if (defined(__APPLE__) && !defined(__i386__) && !defined(__x86_64__) &&       \
     (!defined(__arm__) || __ARM_ARCH_7K__ >= 2)) ||                           \
    defined(_LIBCPP_ALTERNATE_STRING_LAYOUT)
  
  
#  define _ALIGNAS(x) alignas(x)
  
#else
  
#  define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
  
#  define _ALIGNAS(x) __attribute__((__aligned__(x)))
  
#endif
   
#if !(__has_feature(cxx_decltype))
  
#define _LIBCPP_HAS_NO_DECLTYPE
  
#endif
   
#if __has_feature(cxx_attributes)
  
#  define _LIBCPP_NORETURN [[noreturn]]
  
#else
  
#  define _LIBCPP_NORETURN __attribute__ ((noreturn))
  
#endif
   
#if !(__has_feature(cxx_lambdas))
  
#define _LIBCPP_HAS_NO_LAMBDAS
  
#endif
#if !(__has_feature(cxx_rvalue_references))
  
#define _LIBCPP_HAS_NO_RVALUE_REFERENCES
  
#endif
   
#if !(__has_feature(cxx_auto_type))
#endif
   
#if __has_feature(is_base_of)
  
#  define _LIBCPP_HAS_IS_BASE_OF
  
#endif
   
#if __has_feature(is_final)
  
#  define _LIBCPP_HAS_IS_FINAL
  
#endif
 // Objective-C++ features (opt-in)
  
#if __has_feature(objc_arc)
#endif
   
#if !(__has_feature(cxx_relaxed_constexpr))
  
#define _LIBCPP_HAS_NO_CXX14_CONSTEXPR
  
#endif
   
#if !(__has_feature(cxx_variable_templates))
  
#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
  
#endif
   
#if __ISO_C_VISIBLE >= 2011 || __cplusplus >= 201103L
  
#if defined(__FreeBSD__)
  
#define _LIBCPP_HAS_QUICK_EXIT
  
#define _LIBCPP_HAS_C11_FEATURES
  
#elif defined(__Fuchsia__)
  
#define _LIBCPP_HAS_QUICK_EXIT
  
#define _LIBCPP_HAS_C11_FEATURES
  
#elif defined(__linux__)
  
#if !defined(_LIBCPP_HAS_MUSL_LIBC)
  
#if __GLIBC_PREREQ(2, 15) || defined(__BIONIC__)
  
#define _LIBCPP_HAS_QUICK_EXIT
  
#endif
  
#if __GLIBC_PREREQ(2, 17)
  
#define _LIBCPP_HAS_C11_FEATURES
  
#endif
  
#else // defined(_LIBCPP_HAS_MUSL_LIBC)
  
#define _LIBCPP_HAS_QUICK_EXIT
  
#define _LIBCPP_HAS_C11_FEATURES
  
#endif
  
#endif // __linux__
  
#endif
#if __has_feature(underlying_type)
  
#  define _LIBCPP_UNDERLYING_TYPE(T) __underlying_type(T)
  
#endif
   
#if __has_feature(is_literal)
  
#  define _LIBCPP_IS_LITERAL(T) __is_literal(T)
  
#endif
 // Inline namespaces are available in Clang regardless of C++ dialect.
  
#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std {inline namespace _LIBCPP_NAMESPACE {
  
#define _LIBCPP_END_NAMESPACE_STD  } }
  
#define _VSTD std::_LIBCPP_NAMESPACE
 namespace std {   inline namespace _LIBCPP_NAMESPACE {   } }    
#if !defined(_LIBCPP_HAS_NO_ASAN) && !__has_feature(address_sanitizer)
  
#define _LIBCPP_HAS_NO_ASAN
  
#endif 
   
#elif defined(_LIBCPP_COMPILER_GCC)
   
#define _ALIGNAS(x) __attribute__((__aligned__(x)))
  
#define _ALIGNAS_TYPE(x) __attribute__((__aligned__(__alignof(x))))
   
#define _LIBCPP_NORETURN __attribute__((noreturn))
   
#if _GNUC_VER >= 407
  
#define _LIBCPP_UNDERLYING_TYPE(T) __underlying_type(T)
  
#define _LIBCPP_IS_LITERAL(T) __is_literal_type(T)
  
  
#define _LIBCPP_HAS_NO_STRONG_ENUMS
  
#define _LIBCPP_HAS_NO_NOEXCEPT
   
#else  // __GXX_EXPERIMENTAL_CXX0X__
   
#if _GNUC_VER < 403
#endif
   
#endif  // __GXX_EXPERIMENTAL_CXX0X__
   
#define _LIBCPP_BEGIN_NAMESPACE_STD namespace std { inline namespace _LIBCPP_NAMESPACE {
  
#define _LIBCPP_END_NAMESPACE_STD  } }
#define _LIBCPP_HAS_IS_FINAL
  
#define _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
   
#if defined(_AIX)
  
#define __MULTILOCALE_API
  
  
#endif
  
#endif // defined(_LIBCPP_OBJECT_FORMAT_COFF)
   
#ifndef _LIBCPP_HIDDEN
  
#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
  
#define _LIBCPP_HIDDEN __attribute__ ((__visibility__("hidden")))
  
#else
  
#define _LIBCPP_HIDDEN
  
#endif
  
#endif
   
#ifndef _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
  
#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
// The inline should be removed once PR32114 is resolved
  
#define _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS inline _LIBCPP_HIDDEN
  
#else
  
#define _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS
  
#endif
  
#endif
   
#ifndef _LIBCPP_FUNC_VIS
  
#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
  
#define _LIBCPP_FUNC_VIS __attribute__ ((__visibility__("default")))
  
#else
  
#define _LIBCPP_FUNC_VIS
  
#endif
  
#endif
   
#ifndef _LIBCPP_TYPE_VIS
  
#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
  
#    define _LIBCPP_TYPE_VIS __attribute__ ((__visibility__("default")))
  
#  else
  
#    define _LIBCPP_TYPE_VIS
  
#  endif
  
#endif
   
#ifndef _LIBCPP_TEMPLATE_VIS
  
#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
  
#    if __has_attribute(__type_visibility__)
  
#      define _LIBCPP_TEMPLATE_VIS __attribute__ ((__type_visibility__("default")))
  
#    else
  
#      define _LIBCPP_TEMPLATE_VIS __attribute__ ((__visibility__("default")))
  
#    endif
  
#  else
  
#    define _LIBCPP_TEMPLATE_VIS
  
#  endif
  
#endif
   
#ifndef _LIBCPP_EXTERN_VIS
  
# define _LIBCPP_EXTERN_VIS
  
#endif
   
#ifndef _LIBCPP_OVERRIDABLE_FUNC_VIS
  
# define _LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_FUNC_VIS
  
#endif
   
#ifndef _LIBCPP_EXCEPTION_ABI
  
#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
  
#define _LIBCPP_EXCEPTION_ABI __attribute__ ((__visibility__("default")))
  
#else
  
#define _LIBCPP_EXCEPTION_ABI
  
#endif
  
#endif
   
#ifndef _LIBCPP_ENUM_VIS
  
#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS) && __has_attribute(__type_visibility__)
  
#    define _LIBCPP_ENUM_VIS __attribute__ ((__type_visibility__("default")))
  
#  else
  
#    define _LIBCPP_ENUM_VIS
  
#  endif
  
#endif
   
#ifndef _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
  
#  if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS) && __has_attribute(__type_visibility__)
  
#    define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __attribute__ ((__visibility__("default")))
  
#  else
  
#    define _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS
  
#  endif
  
#endif
   
#ifndef _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
  
#  define _LIBCPP_CLASS_TEMPLATE_INSTANTIATION_VIS
  
#endif
   
#ifndef _LIBCPP_INLINE_VISIBILITY
  
#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
  
#define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__visibility__("hidden"), __always_inline__))
  
#else
  
#define _LIBCPP_INLINE_VISIBILITY __attribute__ ((__always_inline__))
  
#endif
  
#endif
   
#ifndef _LIBCPP_ALWAYS_INLINE
  
#if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
  
#define _LIBCPP_ALWAYS_INLINE  __attribute__ ((__visibility__("hidden"), __always_inline__))
  
#else
  
#define _LIBCPP_ALWAYS_INLINE  __attribute__ ((__always_inline__))
  
#endif
  
#endif
   
#ifndef _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY
  
# if !defined(_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS)
  
#  define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __attribute__((__visibility__("default"), __always_inline__))
  
# else
  
#  define _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY __attribute__((__always_inline__))
  
# endif
  
#endif
   
#ifndef _LIBCPP_PREFERRED_OVERLOAD
  
#  if __has_attribute(__enable_if__)
  
#    define _LIBCPP_PREFERRED_OVERLOAD __attribute__ ((__enable_if__(true, "")))
  
#  endif
  
#endif
   
#ifndef _LIBCPP_HAS_NO_NOEXCEPT
  
#  define _NOEXCEPT noexcept
#  define _NOEXCEPT_(x)
  
#endif
   
#if defined(_LIBCPP_DEBUG_USE_EXCEPTIONS)
  
# if !defined(_LIBCPP_DEBUG)
  
#   error cannot use _LIBCPP_DEBUG_USE_EXCEPTIONS unless _LIBCPP_DEBUG is defined
  
# endif
  
# define _NOEXCEPT_DEBUG noexcept(false)
  
# define _NOEXCEPT_DEBUG_(x) noexcept(false)
  
#else
  
# define _NOEXCEPT_DEBUG _NOEXCEPT
  
# define _NOEXCEPT_DEBUG_(x) _NOEXCEPT_(x)
  
#endif
   
#ifdef _LIBCPP_HAS_NO_UNICODE_CHARS
typedef unsigned short char16_t; typedef unsigned int   char32_t;   
#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
   
#ifndef __SIZEOF_INT128__
  
#define _LIBCPP_HAS_NO_INT128
  
#endif
   
#ifdef _LIBCPP_CXX03_LANG
  
# if __has_extension(c_static_assert)
  
#   define static_assert(__b, __m) _Static_assert(__b, __m)
#endif
  
#endif
   
#ifdef _LIBCPP_HAS_NO_CONSTEXPR
  
#define _LIBCPP_CONSTEXPR
  
#else
  
#define _LIBCPP_CONSTEXPR constexpr
  
#endif
   
#ifdef _LIBCPP_CXX03_LANG
  
#define _LIBCPP_DEFAULT {}
  
#else
  
#define _LIBCPP_DEFAULT = default;
  
#endif
   
#ifdef _LIBCPP_CXX03_LANG
  
#define _LIBCPP_EQUAL_DELETE
  
#else
  
#define _LIBCPP_EQUAL_DELETE = delete
  
#define _NOALIAS
  
#endif
   
#if __has_feature(cxx_explicit_conversions) || defined(__IBMCPP__) || \
    (!defined(_LIBCPP_CXX03_LANG) && defined(__GNUC__)) // All supported GCC versions
  
#   define _LIBCPP_EXPLICIT explicit
  
#else
  
#   define _LIBCPP_EXPLICIT
  
#endif
#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS
  
#define _LIBCPP_DECLARE_STRONG_ENUM(x) struct _LIBCPP_TYPE_VIS x { enum __lx
  
#define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x) \
    __lx __v_; \
    _LIBCPP_ALWAYS_INLINE x(__lx __v) : __v_(__v) {} \
    _LIBCPP_ALWAYS_INLINE explicit x(int __v) : __v_(static_cast<__lx>(__v)) {} \
    _LIBCPP_ALWAYS_INLINE operator int() const {return __v_;} \
    };
  
#else  // _LIBCPP_HAS_NO_STRONG_ENUMS
  
#define _LIBCPP_DECLARE_STRONG_ENUM(x) enum class _LIBCPP_ENUM_VIS x
  
#define _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(x)
  
#endif  // _LIBCPP_HAS_NO_STRONG_ENUMS
   
#ifdef _LIBCPP_DEBUG
  
#   if _LIBCPP_DEBUG == 0
  
# endif
  
#endif
   
#ifdef _LIBCPP_DISABLE_EXTERN_TEMPLATE
  
#define _LIBCPP_EXTERN_TEMPLATE(...)
  
#define _LIBCPP_EXTERN_TEMPLATE2(...)
  
#endif
   
#ifndef _LIBCPP_EXTERN_TEMPLATE
  
#define _LIBCPP_EXTERN_TEMPLATE(...) extern template __VA_ARGS__;
  
#endif
   
#ifndef _LIBCPP_EXTERN_TEMPLATE2
  
#define _LIBCPP_EXTERN_TEMPLATE2(...) extern template __VA_ARGS__;
  
#endif
   
#if defined(__APPLE__) && defined(__LP64__) && !defined(__x86_64__)
  
#define _LIBCPP_NONUNIQUE_RTTI_BIT (1ULL << 63)
  
#endif
   
#if defined(__APPLE__) || defined(__FreeBSD__) || defined(_LIBCPP_MSVCRT) ||   \
    defined(__sun__) || defined(__NetBSD__) || defined(__CloudABI__)
  
#define _LIBCPP_LOCALE__L_EXTENSIONS 1
  
#endif
   
#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
  
#endif
   
#ifndef _LIBCPP_STD_VER
  
#  if  __cplusplus <= 201103L
  
#    define _LIBCPP_STD_VER 11
#    define _LIBCPP_STD_VER 17
  
#  else
  
#    define _LIBCPP_STD_VER 18  // current year, or date of c++2a ratification
  
#  endif
  
#define _LIBCPP_DEPRECATED
  
#endif
   
#if _LIBCPP_STD_VER <= 11
  
#define _LIBCPP_EXPLICIT_AFTER_CXX11
  
#define _LIBCPP_DEPRECATED_AFTER_CXX11
  
#else
  
#define _LIBCPP_EXPLICIT_AFTER_CXX11 explicit
  
#define _LIBCPP_DEPRECATED_AFTER_CXX11 [[deprecated]]
  
#define _LIBCPP_CONSTEXPR_AFTER_CXX11
  
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_CXX14_CONSTEXPR)
  
#define _LIBCPP_CONSTEXPR_AFTER_CXX14 constexpr
  
#else
  
#define _LIBCPP_CONSTEXPR_AFTER_CXX14
  
#endif
 // FIXME: Remove all usages of this macro once compilers catch up.
#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES
  
#  define _LIBCPP_EXPLICIT_MOVE(x) _VSTD::move(x)
  
#else
  
#  define _LIBCPP_EXPLICIT_MOVE(x) (x)
  
#endif
   
#ifndef _LIBCPP_HAS_NO_ASAN
_LIBCPP_FUNC_VIS extern "C" void __sanitizer_annotate_contiguous_container(   const void *, const void *, const void *, const void *);   
#endif
 // Try to find out if RTTI is disabled.
// g++ and cl.exe have RTTI on by default and define a macro when it is.
// g++ only defines the macro in 4.3.2 and onwards.
  
#if !defined(_LIBCPP_NO_RTTI)
  
#  if defined(__GNUC__) && ((__GNUC__ >= 5) || (__GNUC__ == 4 && \
   (__GNUC_MINOR__ >= 3 || __GNUC_PATCHLEVEL__ >= 2))) && !defined(__GXX_RTTI)
  
#    define _LIBCPP_NO_RTTI
  
#  elif defined(_LIBCPP_COMPILER_MSVC) && !defined(_CPPRTTI)
  
#    define _LIBCPP_NO_RTTI
  
#  endif
  
#endif
#if !defined(_LIBCPP_HAS_NO_THREADS) && \
    !defined(_LIBCPP_HAS_THREAD_API_PTHREAD) && \
    !defined(_LIBCPP_HAS_THREAD_API_WIN32) && \
    !defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
  
# if defined(__FreeBSD__) || \
    defined(__Fuchsia__) || \
    defined(__NetBSD__) || \
    defined(__linux__) || \
    defined(__APPLE__) || \
    defined(__CloudABI__) || \
    defined(__sun__) || \
    (defined(__MINGW32__) && __libcpp_has_include(<pthread.h>))
  
#   define _LIBCPP_HAS_THREAD_API_PTHREAD
  
# elif defined(_LIBCPP_WIN32API)
  
#  define _LIBCPP_HAS_THREAD_API_WIN32
  
# else
  
#  error "No thread API"
  
# endif // _LIBCPP_HAS_THREAD_API
  
#endif // _LIBCPP_HAS_NO_THREADS
   
#if defined(_LIBCPP_HAS_NO_THREADS) && defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
  
  
#endif
 // Systems that use capability-based security (FreeBSD with Capsicum,
// Nuxi CloudABI) may only provide local filesystem access (using *at()).
// Functions like open(), rename(), unlink() and stat() should not be
// used, as they attempt to access the global filesystem namespace.
  
#if __has_feature(cxx_atomic) || __has_extension(c_atomic) || __has_keyword(_Atomic)
  
#define _LIBCPP_HAS_C_ATOMIC_IMP
  
#elif _GNUC_VER > 407
  
#define _LIBCPP_HAS_GCC_ATOMIC_IMP
  
#endif
   
#if (!defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)) \
     || defined(_LIBCPP_HAS_NO_THREADS)
  
#define _LIBCPP_HAS_NO_ATOMIC_HEADER
  
#endif
   
#ifndef _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
  
#define _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK
  
#endif
   
#if defined(_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS)
    __attribute__((diagnose_if(__VA_ARGS__, "warning")))
  
# define _LIBCPP_DIAGNOSE_ERROR(...) \
    __attribute__((diagnose_if(__VA_ARGS__, "error")))
  
#else
  
# define _LIBCPP_DIAGNOSE_WARNING(...)
  
# define _LIBCPP_DIAGNOSE_ERROR(...)
  
#endif
   
#if __has_attribute(fallthough) || _GNUC_VER >= 700
// Use a function like macro to imply that it must be followed by a semicolon
  
#define _LIBCPP_FALLTHROUGH() __attribute__((__fallthrough__))
  
#else
  
#define _LIBCPP_FALLTHROUGH() ((void)0)
  
#endif
   
#if defined(_LIBCPP_ABI_MICROSOFT) && \
   (defined(_LIBCPP_COMPILER_MSVC) || __has_declspec_attribute(empty_bases))
  
# define _LIBCPP_DECLSPEC_EMPTY_BASES __declspec(empty_bases)
  
#else
  
# define _LIBCPP_DECLSPEC_EMPTY_BASES
  
#endif
   
#if defined(_LIBCPP_ENABLE_CXX17_REMOVED_FEATURES)
  
# define _LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR
  
# define _LIBCPP_ENABLE_CXX17_REMOVED_UNEXPECTED_FUNCTIONS
  
# define _LIBCPP_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE
  
# define _LIBCPP_ENABLE_CXX17_REMOVED_BINDERS
  
#endif // _LIBCPP_ENABLE_CXX17_REMOVED_FEATURES
#if !__has_keyword(__is_aggregate) && (_GNUC_VER_NEW < 7001)
  
# define _LIBCPP_HAS_NO_IS_AGGREGATE
  
#endif
   
#if !defined(__cpp_coroutines) || __cpp_coroutines < 201703L
  
#endif
 // Define availability macros.
  
#if defined(_LIBCPP_USE_AVAILABILITY_APPLE)
  
#define _LIBCPP_AVAILABILITY_SHARED_MUTEX                                      \
  __attribute__((availability(macosx,strict,introduced=10.12)))                \
  __attribute__((availability(macosx,strict,introduced=10.9)))                 \
  __attribute__((availability(ios,strict,introduced=7.0)))
  
#define _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR                                 \
  __attribute__((availability(macosx,strict,introduced=10.9)))                 \
  __attribute__((availability(ios,strict,introduced=7.0)))
  
#else
  
#define _LIBCPP_AVAILABILITY_SHARED_MUTEX
  
#define _LIBCPP_AVAILABILITY_BAD_OPTIONAL_ACCESS
  
#define _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH
  
#define _LIBCPP_AVAILABILITY_BAD_ANY_CAST
  
#define _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS
  
#define _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE
  
#define _LIBCPP_AVAILABILITY_FUTURE_ERROR
  
#define _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE
  
#define _LIBCPP_AVAILABILITY_LOCALE_CATEGORY
  
#define _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR
  
#endif
 // Define availability that depends on _LIBCPP_NO_EXCEPTIONS.
  
#ifdef _LIBCPP_NO_EXCEPTIONS
  
#define _LIBCPP_AVAILABILITY_DYNARRAY
  
#define _LIBCPP_AVAILABILITY_FUTURE
  
#define _LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
  
#else
  
#define _LIBCPP_AVAILABILITY_DYNARRAY _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH
  
#define _LIBCPP_AVAILABILITY_FUTURE _LIBCPP_AVAILABILITY_FUTURE_ERROR
  
#define _LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST                                \
  _LIBCPP_AVAILABILITY_BAD_ANY_CAST
  
#endif
 // Availability of stream API in the dylib got dropped and re-added.  The
// extern template should effectively be available at:
//    availability(macosx,introduced=10.9)
//    availability(ios,introduced=7.0)
  
   
#if defined(_LIBCPP_HAS_NO_PRAGMA_PUSH_POP_MACRO)
  
# define _LIBCPP_PUSH_MACROS
  
# define _LIBCPP_POP_MACROS
  
#else
  
# if defined(_LIBCPP_COMPILER_MSVC)
  
#   define _LIBCPP_PUSH_MACROS    \
      __pragma(push_macro("min")) \
      __pragma(push_macro("max"))
  
#   define _LIBCPP_POP_MACROS     \
      __pragma(pop_macro("min"))  \
      __pragma(pop_macro("max"))
  
# else
  
#   define _LIBCPP_PUSH_MACROS        \
      _Pragma("push_macro(\"min\")")  \
      _Pragma("push_macro(\"max\")")
  
#   define _LIBCPP_POP_MACROS         \
      _Pragma("pop_macro(\"min\")")   \
      _Pragma("pop_macro(\"max\")")
  
# endif
  
#endif // defined(_LIBCPP_HAS_NO_PRAGMA_PUSH_POP_MACRO)
    
#endif // __cplusplus
   
#endif // _LIBCPP_CONFIG
  
#pragma clang module end /*std_config*/
}
     
#pragma clang module endbuild /*std_config*/
  
#pragma clang module build std
  
# 1 "/aia/r018/scratch/gonzalo/toolchain/llvm/include/c++/v1/module.modulemap"
module std   [system] {   module depr     [system] [extern_c] {     module ctype_h       [system] [extern_c] {       header "ctype.h" { size 1136 mtime 1504087193 }       export *     }     module errno_h       [system] [extern_c] {       header "errno.h" { size 5131 mtime 1504087193 }       export *     }     module inttypes_h       [system] [extern_c] {       header "inttypes.h" { size 3597 mtime 1504087193 }       export stdint_h       export *     }     module locale_h       [system] [extern_c] {       header "locale.h" { size 763 mtime 1504087193 }       export *     }     module math_h       [system] [extern_c] {       header "math.h" { size 48240 mtime 1504087193 }       export *     }     module setjmp_h       [system] [extern_c] {       header "setjmp.h" { size 789 mtime 1504087193 }       export *     }     module stddef_h       [system] [extern_c] {       textual header "/aia/r018/scratch/gonzalo/toolchain/llvm/lib/clang/6.0.0/include/stddef.h" { size 4498 mtime 1504086285 }       textual header "stddef.h" { size 1297 mtime 1504087193 }     }     module stdint_h       [system] [extern_c] {       header "/aia/r018/scratch/gonzalo/toolchain/llvm/lib/clang/6.0.0/include/stdint.h" { size 23387 mtime 1504086285 }       textual header "stdint.h" { size 2038 mtime 1504087193 }       export *       export Darwin.C.stdint     }     module stdio_h       [system] [extern_c] {       textual header "stdio.h" { size 3644 mtime 1504087193 }       export *       export Darwin.C.stdio     }     module stdlib_h       [system] [extern_c] {       textual header "stdlib.h" { size 4399 mtime 1504087193 }       export *     }     module string_h       [system] [extern_c] {       header "string.h" { size 4661 mtime 1504087193 }       export *     }     module wchar_h       [system] [extern_c] {       textual header "wchar.h" { size 8275 mtime 1504087193 }       export *     }     module wctype_h       [system] [extern_c] {       header "wctype.h" { size 1541 mtime 1504087193 }       export *     }   }   module complex_h     [system] {     header "complex.h" { size 726 mtime 1504087193 }     export ccomplex     export *   }   module tgmath_h     [system] {     header "/aia/r018/scratch/gonzalo/toolchain/llvm/lib/clang/6.0.0/include/tgmath.h" { size 31300 mtime 1504086285 }     textual header "tgmath.h" { size 645 mtime 1504087193 }     export ccomplex     export cmath     export *   }   module compat     [system] {     module cassert       [system] {       textual header "cassert" { size 546 mtime 1504087193 }     }     module ccomplex       [system] {       header "ccomplex" { size 627 mtime 1504087193 }       export complex       export *     }     module cctype       [system] {       header "cctype" { size 1745 mtime 1504087193 }       export *     }     module cerrno       [system] {       header "cerrno" { size 656 mtime 1504087193 }       export *     }     module cfenv       [system] {       header "cfenv" { size 1588 mtime 1504087193 }       export *     }     module cfloat       [system] {       header "cfloat" { size 1134 mtime 1504087193 }       export *     }     module cinttypes       [system] {       header "cinttypes" { size 3490 mtime 1504087193 }       export cstdint       export *     }     module ciso646       [system] {       header "ciso646" { size 582 mtime 1504087193 }       export *     }     module climits       [system] {       header "climits" { size 894 mtime 1504087193 }       export *     }     module clocale       [system] {       header "clocale" { size 985 mtime 1504087193 }       export *     }     module cmath       [system] {       header "cmath" { size 14466 mtime 1504087193 }       export *     }     module csetjmp       [system] {       header "csetjmp" { size 800 mtime 1504087193 }       export *     }     module csignal       [system] {       header "csignal" { size 951 mtime 1504087193 }       export *     }     module cstdarg       [system] {       header "cstdarg" { size 890 mtime 1504087193 }       export *     }     module cstdbool       [system] {       header "cstdbool" { size 708 mtime 1504087193 }       export *     }     module cstddef       [system] {       header "cstddef" { size 2409 mtime 1504087193 }       export *     }     module cstdint       [system] {       header "cstdint" { size 2785 mtime 1504087193 }       export depr.stdint_h       export *     }     module cstdio       [system] {       header "cstdio" { size 4301 mtime 1504087193 }       export *     }     module cstdlib       [system] {       header "cstdlib" { size 4725 mtime 1504087193 }       export *     }     module cstring       [system] {       header "cstring" { size 2526 mtime 1504087193 }       export *     }     module ctgmath       [system] {       header "ctgmath" { size 637 mtime 1504087193 }       export ccomplex       export cmath       export *     }     module ctime       [system] {       header "ctime" { size 1413 mtime 1504087193 }       export *     }     module cwchar       [system] {       header "cwchar" { size 6272 mtime 1504087193 }       export depr.stdio_h       export *     }     module cwctype       [system] {       header "cwctype" { size 1678 mtime 1504087193 }       export *     }   }   module algorithm     [system] {     header "algorithm" { size 206013 mtime 1504087193 }     export initializer_list     export *   }   module any     [system] {     header "any" { size 18776 mtime 1504087193 }     export *   }   module array     [system] {     header "array" { size 12026 mtime 1504087193 }     export initializer_list     export *   }   module atomic     [system] {     header "atomic" { size 63626 mtime 1504087193 }     export *   }   module bitset     [system] {     header "bitset" { size 33156 mtime 1504087193 }     export string     export iosfwd     export *   }   module chrono     [system] {     header "chrono" { size 41479 mtime 1504087193 }     export *   }   module codecvt     [system] {     header "codecvt" { size 20443 mtime 1504087193 }     export *   }   module complex     [system] {     header "complex" { size 46335 mtime 1504087193 }     export *   }   module condition_variable     [system] {     header "condition_variable" { size 7593 mtime 1504087193 }     export *   }   module deque     [system] {     header "deque" { size 104358 mtime 1504087193 }     export initializer_list     export *   }   module exception     [system] {     header "exception" { size 9479 mtime 1504087193 }     export *   }   module forward_list     [system] {     header "forward_list" { size 58988 mtime 1504087193 }     export initializer_list     export *   }   module fstream     [system] {     header "fstream" { size 44788 mtime 1504087193 }     export *   }   module functional     [system] {     header "functional" { size 74920 mtime 1504087193 }     export *   }   module future     [system] {     header "future" { size 72580 mtime 1504087193 }     export *   }   module initializer_list     [system] {     header "initializer_list" { size 2813 mtime 1504087193 }     export *   }   module iomanip     [system] {     header "iomanip" { size 18251 mtime 1504087193 }     export *   }   module ios     [system] {     header "ios" { size 25523 mtime 1504087193 }     export iosfwd     export *   }   module iosfwd     [system] {     header "iosfwd" { size 7871 mtime 1504087193 }     export *   }   module iostream     [system] {     header "iostream" { size 1378 mtime 1504087193 }     export ios     export streambuf     export istream     export ostream     export *   }   module istream     [system] {     header "istream" { size 49032 mtime 1504087193 }     export *   }   module iterator     [system] {     header "iterator" { size 64354 mtime 1504087193 }     export *   }   module limits     [system] {     header "limits" { size 40572 mtime 1504087193 }     export *   }   module list     [system] {     header "list" { size 77329 mtime 1504087193 }     export initializer_list     export *   }   module locale     [system] {     header "locale" { size 152496 mtime 1504087193 }     export *   }   module map     [system] {     header "map" { size 70688 mtime 1504087193 }     export initializer_list     export *   }   module memory     [system] {     header "memory" { size 169628 mtime 1504087193 }     export *   }   module mutex     [system] {     header "mutex" { size 17223 mtime 1504087193 }     export *   }   module new     [system] {     header "new" { size 9596 mtime 1504087193 }     export *   }   module numeric     [system] {     header "numeric" { size 18377 mtime 1504087193 }     export *   }   module optional     [system] {     header "optional" { size 41909 mtime 1504087193 }     export *   }   module ostream     [system] {     header "ostream" { size 32326 mtime 1504087193 }     export *   }   module queue     [system] {     header "queue" { size 24946 mtime 1504087193 }     export initializer_list     export *   }   module random     [system] {     header "random" { size 225906 mtime 1504087193 }     export initializer_list     export *   }   module ratio     [system] {     header "ratio" { size 16260 mtime 1504087193 }     export *   }   module regex     [system] {     header "regex" { size 219316 mtime 1504087193 }     export initializer_list     export *   }   module scoped_allocator     [system] {     header "scoped_allocator" { size 25569 mtime 1504087193 }     export *   }   module set     [system] {     header "set" { size 45007 mtime 1504087193 }     export initializer_list     export *   }   module sstream     [system] {     header "sstream" { size 33128 mtime 1504087193 }     export *   }   module stack     [system] {     header "stack" { size 9238 mtime 1504087193 }     export initializer_list     export *   }   module stdexcept     [system] {     header "stdexcept" { size 6566 mtime 1504087193 }     export *   }   module streambuf     [system] {     header "streambuf" { size 14436 mtime 1504087193 }     export *   }   module string     [system] {     header "string" { size 152088 mtime 1504087193 }     export initializer_list     export string_view     export __string     export *   }   module string_view     [system] {     header "string_view" { size 30548 mtime 1504087193 }     export initializer_list     export __string     export *   }   module strstream     [system] {     header "strstream" { size 11132 mtime 1504087193 }     export *   }   module system_error     [system] {     header "system_error" { size 22558 mtime 1504087193 }     export *   }   module thread     [system] {     header "thread" { size 13141 mtime 1504087193 }     export *   }   module tuple     [system] {     header "tuple" { size 53733 mtime 1504087193 }     export *   }   module type_traits     [system] {     header "type_traits" { size 159515 mtime 1504087193 }     export *   }   module typeindex     [system] {     header "typeindex" { size 2818 mtime 1504087193 }     export *   }   module typeinfo     [system] {     header "typeinfo" { size 5173 mtime 1504087193 }     export *   }   module unordered_map     [system] {     header "unordered_map" { size 80121 mtime 1504087193 }     export initializer_list     export *   }   module unordered_set     [system] {     header "unordered_set" { size 53575 mtime 1504087193 }     export initializer_list     export *   }   module utility     [system] {     header "utility" { size 46821 mtime 1504087193 }     export initializer_list     export *   }   module valarray     [system] {     header "valarray" { size 133467 mtime 1504087193 }     export initializer_list     export *   }   module variant     [system] {     header "variant" { size 58123 mtime 1504087193 }     export *   }   module vector     [system] {     header "vector" { size 109350 mtime 1504087193 }     export initializer_list     export *   }   module __bit_reference     [system] {     header "__bit_reference" { size 52074 mtime 1504087193 }     export *   }   module __debug     [system] {     header "__debug" { size 8831 mtime 1504087193 }     export *   }   module __functional_base     [system] {     header "__functional_base" { size 17990 mtime 1504087193 }     export *   }   module __hash_table     [system] {     header "__hash_table" { size 95586 mtime 1504087193 }     export *   }   module __locale     [system] {     header "__locale" { size 46226 mtime 1504087193 }     export *   }   module __mutex_base     [system] {     header "__mutex_base" { size 12984 mtime 1504087193 }     export *   }   module __split_buffer     [system] {     header "__split_buffer" { size 21995 mtime 1504087193 }     export *   }   module __sso_allocator     [system] {     header "__sso_allocator" { size 2465 mtime 1504087193 }     export *   }   module __std_stream     [system] {     header "__std_stream" { size 10555 mtime 1504087193 }     export *   }   module __string     [system] {     header "__string" { size 27915 mtime 1504087193 }     export *   }   module __tree     [system] {     header "__tree" { size 99243 mtime 1504087193 }     export *   }   module __tuple     [system] {     header "__tuple" { size 20181 mtime 1504087193 }     export *   }   module __undef_macros     [system] {     header "__undef_macros" { size 1019 mtime 1504087193 }     export *   }   module experimental     [system] {     requires cplusplus11     module algorithm       [system] {       header "experimental/algorithm" { size 2126 mtime 1504087193 }       export *     }     module any       [system] {       header "experimental/any" { size 15071 mtime 1504087193 }       export *     }     module chrono       [system] {       header "experimental/chrono" { size 1370 mtime 1504087193 }       export *     }     module coroutine       [system] {       requires coroutines       header "experimental/coroutine" { size 8971 mtime 1504087193 }       export *     }     module deque       [system] {       header "experimental/deque" { size 1137 mtime 1504087193 }       export *     }     module dynarray       [system] {       header "experimental/dynarray" { size 11116 mtime 1504087193 }       export *     }     module filesystem       [system] {       header "experimental/filesystem" { size 66462 mtime 1504087193 }       export *     }     module forward_list       [system] {       header "experimental/forward_list" { size 1200 mtime 1504087193 }       export *     }     module functional       [system] {       header "experimental/functional" { size 17873 mtime 1504087193 }       export *     }     module iterator       [system] {       header "experimental/iterator" { size 3876 mtime 1504087193 }       export *     }     module list       [system] {       header "experimental/list" { size 1127 mtime 1504087193 }       export *     }     module map       [system] {       header "experimental/map" { size 1692 mtime 1504087193 }       export *     }     module memory_resource       [system] {       header "experimental/memory_resource" { size 13317 mtime 1504087193 }       export *     }     module numeric       [system] {       header "experimental/numeric" { size 3698 mtime 1504087193 }       export *     }     module optional       [system] {       header "experimental/optional" { size 25360 mtime 1504087193 }       export *     }     module propagate_const       [system] {       header "experimental/propagate_const" { size 20594 mtime 1504087193 }       export *     }     module ratio       [system] {       header "experimental/ratio" { size 2271 mtime 1504087193 }       export *     }     module regex       [system] {       header "experimental/regex" { size 1780 mtime 1504087193 }       export *     }     module set       [system] {       header "experimental/set" { size 1623 mtime 1504087193 }       export *     }     module string       [system] {       header "experimental/string" { size 1768 mtime 1504087193 }       export *     }     module string_view       [system] {       header "experimental/string_view" { size 35256 mtime 1504087193 }       export *     }     module system_error       [system] {       header "experimental/system_error" { size 1553 mtime 1504087193 }       export *     }     module tuple       [system] {       header "experimental/tuple" { size 2145 mtime 1504087193 }       export *     }     module type_traits       [system] {       header "experimental/type_traits" { size 19742 mtime 1504087193 }       export *     }     module unordered_map       [system] {       header "experimental/unordered_map" { size 2009 mtime 1504087193 }       export *     }     module unordered_set       [system] {       header "experimental/unordered_set" { size 1812 mtime 1504087193 }       export *     }     module utility       [system] {       header "experimental/utility" { size 1020 mtime 1504087193 }       export *     }     module vector       [system] {       header "experimental/vector" { size 1148 mtime 1504087193 }       export *     }     module __memory       [system] {       header "experimental/__memory" { size 2731 mtime 1504087193 }       export *     }   }   export std_config }
     
#pragma clang module contents
extern "C" {   
#if 0 /* expanded by -frewrite-includes */
  
#include "ctype.h"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.depr.ctype_h
// -*- C++ -*-
//===---------------------------- ctype.h ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CTYPE_H
  
#define _LIBCPP_CTYPE_H
  
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <ctype.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard 7.4: Character handling	<ctype.h>  */   
#ifndef	_CTYPE_H
  
#define	_CTYPE_H	1
   
#ifndef	_FEATURES_H
  
#define	_FEATURES_H	1
 /* These are defined by the user (or the compiler)    to specify the desired environment:     __STRICT_ANSI__	ISO Standard C.    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.    _POSIX_SOURCE	IEEE Std 1003.1.    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2; 			if >=199309L, add IEEE Std 1003.1b-1993; 			if >=199506L, add IEEE Std 1003.1c-1995; 			if >=200112L, all of IEEE 1003.1-2004 			if >=200809L, all of IEEE 1003.1-2008    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if 			Single Unix conformance is wanted, to 600 for the 			sixth revision, to 700 for the seventh revision.    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.    _FILE_OFFSET_BITS=N	Select default filesystem interface.    _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.    _SVID_SOURCE		ISO C, POSIX, and SVID things.    _ATFILE_SOURCE	Additional *at interfaces.    _GNU_SOURCE		All of the above, plus GNU extensions.    _DEFAULT_SOURCE	The default set of features (taking precedence over 			__STRICT_ANSI__).    _REENTRANT		Select additionally reentrant object.    _THREAD_SAFE		Same as _REENTRANT, often used by other systems.    _FORTIFY_SOURCE	If set to numeric value > 0 additional security 			measures are defined, according to level.     The `-ansi' switch to the GNU C compiler, and standards conformance
   options such as `-std=c99', define __STRICT_ANSI__.  If none of    these are defined, or if _DEFAULT_SOURCE is defined, the default is    to have _SVID_SOURCE, _BSD_SOURCE, and _POSIX_SOURCE set to one and    _POSIX_C_SOURCE set to 200809L.  If more than one of these are    defined, they accumulate.  For example __STRICT_ANSI__,    _POSIX_SOURCE and _POSIX_C_SOURCE together give you ISO C, 1003.1,    and 1003.2, but nothing else.     These are defined by this file and are used by the    header files to decide what to declare or define:     __USE_ISOC11		Define ISO C11 things.    __USE_ISOC99		Define ISO C99 things.    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.    __USE_POSIX		Define IEEE Std 1003.1 things.    __USE_POSIX2		Define IEEE Std 1003.2 things.    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.    __USE_XOPEN		Define XPG things.    __USE_XOPEN_EXTENDED	Define X/Open Unix things.    __USE_UNIX98		Define Single Unix V2 things.    __USE_XOPEN2K        Define XPG6 things.    __USE_XOPEN2KXSI     Define XPG6 XSI things.    __USE_XOPEN2K8       Define XPG7 things.    __USE_XOPEN2K8XSI    Define XPG7 XSI things.    __USE_LARGEFILE	Define correct standard I/O things.    __USE_LARGEFILE64	Define LFS things with separate names.    __USE_FILE_OFFSET64	Define 64bit interface as default.    __USE_BSD		Define 4.3BSD things.    __USE_SVID		Define SVID things.    __USE_MISC		Define things common to BSD and System V Unix.    __USE_ATFILE		Define *at interfaces and AT_* constants for them.    __USE_GNU		Define GNU extensions.    __USE_REENTRANT	Define reentrant/thread-safe *_r functions.    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.     The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided    only for compatibility.  All new code should use the other symbols    to test for features.     All macros listed above as possibly being defined by this file are    explicitly undefined if they are not explicitly defined.    Feature-test macros that are not defined by the user or compiler    but are implied by the other feature-test macros defined (or by the    lack of any definitions) are defined by the file.  */  /* Undefine everything, so we get a clean slate.  */
#undef	__USE_ISOC11
  
#undef	__USE_FORTIFY_LEVEL
  
#undef	__KERNEL_STRICT_NAMES
 /* Suppress kernel-name space pollution unless user expressedly asks    for it.  */
#ifndef _LOOSE_KERNEL_NAMES
  
  
#endif /* expanded by -frewrite-includes */
    
#endif	/* features.h  */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/types.h>
  
#endif /* expanded by -frewrite-includes */
/* bits/types.h -- definitions of __*_t types underlying *_t types.    Copyright (C) 2002-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
 /*  * Never include this file directly; use <sys/types.h> instead.  */   
#ifndef	_BITS_TYPES_H
  
#define	_BITS_TYPES_H	1
   
#if 0 /* expanded by -frewrite-includes */
  
#include <features.h>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/wordsize.h>
  
#endif /* expanded by -frewrite-includes */
/* Determine the wordsize from the preprocessor defines.  */   
#if defined __x86_64__ && !defined __ILP32__
  
# define __WORDSIZE	64
  
# define __WORDSIZE_TIME64_COMPAT32	1
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# define __SYSCALL_WORDSIZE		64
  
#endif
 /* Convenience types.  */typedef unsigned char __u_char; typedef unsigned short int __u_short; typedef unsigned int __u_int; typedef unsigned long int __u_long;  /* Fixed-size types, underlying types depend on word size and compiler.  */typedef signed char __int8_t; typedef unsigned char __uint8_t; typedef signed short int __int16_t; typedef unsigned short int __uint16_t; typedef signed int __int32_t; typedef unsigned int __uint32_t;   
#if __WORDSIZE == 64
__extension__ typedef long long int __quad_t; __extension__ typedef unsigned long long int __u_quad_t;   
#endif
  /* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE    macros for each of the OS types we define below.  The definitions    of those macros must use the following macros for underlying types.    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned    variants of each of the following integer types on this machine.  	16		-- "natural" 16-bit type (always short) 	32		-- "natural" 32-bit type (always int) 	64		-- "natural" 64-bit type (long or long long) 	LONG32		-- 32-bit type, traditionally long 	QUAD		-- 64-bit type, always long long 	WORD		-- natural type of __WORDSIZE bits (int or long) 	LONGWORD	-- type of __WORDSIZE bits, traditionally long     We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the    conventional uses of `long' or `long long' type modifiers match the    types we define, even when a less-adorned type would be the same size.    This matters for (somewhat) portably writing printf/scanf formats for    these types, where using the appropriate l or ll format modifiers can    make the typedefs and the formats match up across all GNU platforms.  If    we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.     Here we assume what is presently the case in all the GCC configurations    we support: long long is always 64 bits, long is always word/address size,    and int is always 32 bits.  */   
#define	__S16_TYPE		short int
  
#define __U16_TYPE		unsigned short int
  
#define	__S32_TYPE		int
  
#define __U32_TYPE		unsigned int
  
#define __SLONGWORD_TYPE	long int
  
#define __ULONGWORD_TYPE	unsigned long int
  
#if __WORDSIZE == 32
  
# define __SQUAD_TYPE		__quad_t
  
# define __STD_TYPE		__extension__ typedef
  
#elif __WORDSIZE == 64
  
# define __SQUAD_TYPE		long int
  
# define __UQUAD_TYPE		unsigned long int
  
# define __SWORD_TYPE		long int
  
# define __UWORD_TYPE		unsigned long int
  
# define __SLONG32_TYPE		int
  
# define __ULONG32_TYPE		unsigned int
  
# define __S64_TYPE		long int
  
# define __U64_TYPE		unsigned long int
/* No need to mark the typedef with __extension__.   */
# define __STD_TYPE		typedef
  
#else
  
#endif
   
#ifndef	_BITS_TYPESIZES_H
  
#define	_BITS_TYPESIZES_H	1
 /* See <bits/types.h> for the meaning of these macros.  This file exists so    that <bits/types.h> need not vary across different GNU platforms.  */ /* X32 kernel interface is 64-bit.  */
#if defined __x86_64__ && defined __ILP32__
  
# define __SYSCALL_SLONG_TYPE	__SQUAD_TYPE
  
# define __SYSCALL_ULONG_TYPE	__UQUAD_TYPE
  
#else
  
# define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
  
# define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
  
#endif
   
#define __DEV_T_TYPE		__UQUAD_TYPE
  
#define __UID_T_TYPE		__U32_TYPE
  
#define __GID_T_TYPE		__U32_TYPE
  
#define __INO_T_TYPE		__SYSCALL_ULONG_TYPE
  
#define __INO64_T_TYPE		__UQUAD_TYPE
  
#define __MODE_T_TYPE		__U32_TYPE
  
#ifdef __x86_64__
  
# define __NLINK_T_TYPE		__SYSCALL_ULONG_TYPE
  
# define __FSWORD_T_TYPE	__SYSCALL_SLONG_TYPE
  
#else
  
# define __NLINK_T_TYPE		__UWORD_TYPE
  
# define __FSWORD_T_TYPE	__SWORD_TYPE
  
#endif
  
#define __OFF_T_TYPE		__SYSCALL_SLONG_TYPE
  
#define __OFF64_T_TYPE		__SQUAD_TYPE
  
#define __PID_T_TYPE		__S32_TYPE
  
#define __RLIM_T_TYPE		__SYSCALL_ULONG_TYPE
  
#define __RLIM64_T_TYPE		__UQUAD_TYPE
  
#define __BLKCNT_T_TYPE		__SYSCALL_SLONG_TYPE
  
#define __BLKCNT64_T_TYPE	__SQUAD_TYPE
  
#define __FSBLKCNT_T_TYPE	__SYSCALL_ULONG_TYPE
  
#define __FSBLKCNT64_T_TYPE	__UQUAD_TYPE
  
#define __FSFILCNT_T_TYPE	__SYSCALL_ULONG_TYPE
  
#define __FSFILCNT64_T_TYPE	__UQUAD_TYPE
  
#define __ID_T_TYPE		__U32_TYPE
  
#define __CLOCK_T_TYPE		__SYSCALL_SLONG_TYPE
  
#define __TIME_T_TYPE		__SYSCALL_SLONG_TYPE
  
#define __USECONDS_T_TYPE	__U32_TYPE
  
#define __SUSECONDS_T_TYPE	__SYSCALL_SLONG_TYPE
  
#define __DADDR_T_TYPE		__S32_TYPE
  
#define __KEY_T_TYPE		__S32_TYPE
  
#define __CLOCKID_T_TYPE	__S32_TYPE
  
#define __TIMER_T_TYPE		void *
  
#define __BLKSIZE_T_TYPE	__SYSCALL_SLONG_TYPE
  
#define __FSID_T_TYPE		struct { int __val[2]; }
  
#define __SSIZE_T_TYPE		__SWORD_TYPE
 /* Number of descriptors that can fit in an `fd_set'.  */
#define __FD_SETSIZE		1024


#endif /* bits/typesizes.h */


__STD_TYPE __DEV_T_TYPE __dev_t;	/* Type of device numbers.  */
__STD_TYPE __UID_T_TYPE __uid_t;	/* Type of user identifications.  */
__STD_TYPE __GID_T_TYPE __gid_t;	/* Type of group identifications.  */
__STD_TYPE __INO_T_TYPE __ino_t;	/* Type of file serial numbers.  */
__STD_TYPE __INO64_T_TYPE __ino64_t;	/* Type of file serial numbers (LFS).*/
__STD_TYPE __MODE_T_TYPE __mode_t;	/* Type of file attribute bitmasks.  */
__STD_TYPE __NLINK_T_TYPE __nlink_t;	/* Type of file link counts.  */
__STD_TYPE __OFF_T_TYPE __off_t;	/* Type of file sizes and offsets.  */
__STD_TYPE __OFF64_T_TYPE __off64_t;	/* Type of file sizes and offsets (LFS).  */
__STD_TYPE __PID_T_TYPE __pid_t;	/* Type of process identifications.  */
__STD_TYPE __FSID_T_TYPE __fsid_t;	/* Type of file system IDs.  */
__STD_TYPE __CLOCK_T_TYPE __clock_t;	/* Type of CPU usage counts.  */
__STD_TYPE __RLIM_T_TYPE __rlim_t;	/* Type for resource measurement.  */
__STD_TYPE __RLIM64_T_TYPE __rlim64_t;	/* Type for resource measurement (LFS).  */
__STD_TYPE __ID_T_TYPE __id_t;		/* General type for IDs.  */
__STD_TYPE __TIME_T_TYPE __time_t;	/* Seconds since the Epoch.  */
__STD_TYPE __USECONDS_T_TYPE __useconds_t; /* Count of microseconds.  */
__STD_TYPE __SUSECONDS_T_TYPE __suseconds_t; /* Signed count of microseconds.  */

__STD_TYPE __DADDR_T_TYPE __daddr_t;	/* The type of a disk address.  */
__STD_TYPE __KEY_T_TYPE __key_t;	/* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
__STD_TYPE __CLOCKID_T_TYPE __clockid_t;

/* Timer ID returned by `timer_create'.  */__STD_TYPE __TIMER_T_TYPE __timer_t;  /* Type to represent block size.  */__STD_TYPE __BLKSIZE_T_TYPE __blksize_t;  /* Types from the Large File Support interface.  */ /* Type to count number of disk blocks.  */__STD_TYPE __BLKCNT_T_TYPE __blkcnt_t; __STD_TYPE __BLKCNT64_T_TYPE __blkcnt64_t;  /* Type to count file system blocks.  */__STD_TYPE __FSBLKCNT_T_TYPE __fsblkcnt_t; __STD_TYPE __FSBLKCNT64_T_TYPE __fsblkcnt64_t;  /* Type to count file system nodes.  */__STD_TYPE __FSFILCNT_T_TYPE __fsfilcnt_t; __STD_TYPE __FSFILCNT64_T_TYPE __fsfilcnt64_t;  /* Type of miscellaneous file system fields.  */__STD_TYPE __FSWORD_T_TYPE __fsword_t;  __STD_TYPE __SSIZE_T_TYPE __ssize_t; /* Type of a byte count, or error.  */ /* Signed long type used in system calls.  */__STD_TYPE __SYSCALL_SLONG_TYPE __syscall_slong_t; /* Unsigned long type used in system calls.  */__STD_TYPE __SYSCALL_ULONG_TYPE __syscall_ulong_t;  /* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __off64_t __loff_t;	/* Type of file sizes and offsets (LFS).  */
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

/* Duplicates info from stdint.h but this is used in unistd.h.  */

#endif /* bits/types.h */

__BEGIN_DECLS

#ifndef _ISbit
/* These are all the characteristics of characters.
   If there get to be more than 16 distinct characteristics,
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef	_ENDIAN_H
#define	__BIG_ENDIAN	4321
#define	__PDP_ENDIAN	3412

/* This file defines `__BYTE_ORDER' for the particular machine.  */
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/endian.h>
  
   
#if !defined _BYTESWAP_H && !defined _NETINET_IN_H && !defined _ENDIAN_H
  
# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
  
#endif
   
#ifndef _BITS_BYTESWAP_H
   
#ifdef __GNUC__
  
# if __GNUC__ >= 2
  
#  define __bswap_16(x) \
     (__extension__							      \
	 __bswap_constant_16 (__x); }))
  
# endif
  
#else
static __inline unsigned short int __bswap_16 (unsigned short int __bsx) {   return __bswap_constant_16 (__bsx); }   
#endif
 /* Swap bytes in 32 bit value.  */
#define __bswap_constant_32(x) \
     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
   
#ifdef __GNUC__
  
# if __GNUC_PREREQ (4, 3)
static __inline unsigned int __bswap_32 (unsigned int __bsx) {   return __builtin_bswap32 (__bsx); }   
# elif __GNUC__ >= 2
  
#  if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__	      \
			   || defined __pentiumpro__ || defined __pentium4__  \
			   || defined __k8__ || defined __athlon__	      \
			   || defined __k6__ || defined __nocona__	      \
			   || defined __core2__ || defined __geode__	      \
			   || defined __amdfam10__)
#  endif
# else
#  define __bswap_32(x) \
     (__extension__							      \
      ({ unsigned int __x = (x); __bswap_constant_32 (__x); }))
# endif
#else
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __bswap_constant_32 (__bsx);
}
#endif


#if __GNUC_PREREQ (2, 0)
/* Swap bytes in 64 bit value.  */
# define __bswap_constant_64(x) \
     (__extension__ ((((x) & 0xff00000000000000ull) >> 56)		      \
		     | (((x) & 0x00ff000000000000ull) >> 40)		      \
		     | (((x) & 0x0000ff0000000000ull) >> 24)		      \
		     | (((x) & 0x000000ff00000000ull) >> 8)		      \
		     | (((x) & 0x00000000ff000000ull) << 8)		      \
		     | (((x) & 0x0000000000ff0000ull) << 24)		      \
		     | (((x) & 0x000000000000ff00ull) << 40)		      \
		     | (((x) & 0x00000000000000ffull) << 56)))

# if __GNUC_PREREQ (4, 3)
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
	   }                                                                  \
	 __r.__ll; }))
# endif
#else
# define __bswap_constant_64(x) \
     ((((x) & 0xff00000000000000ull) >> 56)				      \
      | (((x) & 0x00ff000000000000ull) >> 40)				      \
__bswap_64 (__uint64_t __bsx)
{
  return __bswap_constant_64 (__bsx);
}
#endif

#endif /* _BITS_BYTESWAP_H */

# if __BYTE_ORDER == __LITTLE_ENDIAN
#  define htobe16(x) __bswap_16 (x)
#  define htole16(x) (x)
#  define be16toh(x) __bswap_16 (x)
#  define le16toh(x) (x)

#  define htobe32(x) __bswap_32 (x)
#  define le64toh(x) __bswap_64 (x)
# endif
#endif

#endif	/* endian.h */
# if __BYTE_ORDER == __BIG_ENDIAN
#  define _ISbit(bit)	(1 << (bit))
# else /* __BYTE_ORDER == __LITTLE_ENDIAN */
#  define _ISbit(bit)	((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))
# endif

enum
{
  _ISupper = _ISbit (0),	/* UPPERCASE.  */
  _ISlower = _ISbit (1),	/* lowercase.  */
  _ISalpha = _ISbit (2),	/* Alphabetic.  */
  _ISdigit = _ISbit (3),	/* Numeric.  */
  _ISxdigit = _ISbit (4),	/* Hexadecimal numeric.  */
  _ISspace = _ISbit (5),	/* Whitespace.  */
  _ISprint = _ISbit (6),	/* Printing.  */
  _ISgraph = _ISbit (7),	/* Graphical.  */
  _ISblank = _ISbit (8),	/* Blank (usually SPC and TAB).  */
  _IScntrl = _ISbit (9),	/* Control character.  */
  _ISpunct = _ISbit (10),	/* Punctuation.  */
  _ISalnum = _ISbit (11)	/* Alphanumeric.  */
};
#endif /* ! _ISbit  */

/* These are defined in ctype-info.c.
   The declarations here must match those in localeinfo.h.
  
#endif
   
#define	__isascii(c)	(((c) & ~0x7f) == 0)	/* If C is a 7 bit value.  */
  
#define	__toascii(c)	((c) & 0x7f)		/* Mask off high bits.  */
   
#define	__exctype(name)	extern int name (int) __THROW
 __BEGIN_NAMESPACE_STD  /* The following names are all functions:      int isCHARACTERISTIC(int c);    which return nonzero iff C has CHARACTERISTIC.    For the meaning of the characteristic names, see the `enum' above.  */
__exctype (isalnum);
__exctype (isalpha);
__exctype (iscntrl);
__exctype (isdigit);
__exctype (islower);
__exctype (isgraph);
__exctype (isprint);
__exctype (ispunct);
__exctype (isspace);
__exctype (isupper);
__exctype (isxdigit);


/* Return the lowercase version of C.  */
extern int tolower (int __c) __THROW;

/* Return the uppercase version of C.  */
extern int toupper (int __c) __THROW;

__END_NAMESPACE_STD


/* ISO C99 introduced one new function.  */
#ifdef	__USE_ISOC99
__BEGIN_NAMESPACE_C99

__exctype (isblank);

__END_NAMESPACE_C99
#endif

#ifdef __USE_GNU
/* Test C for a set of character classes according to MASK.  */
extern int isctype (int __c, int __mask) __THROW;
#endif

#if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN

/* Return nonzero iff C is in the ASCII set
   (i.e., is no more than 7 bits wide).  */
extern int isascii (int __c) __THROW;

/* Return the part of C that is in the ASCII set
   (i.e., the low-order 7 bits of C).  */
extern int toascii (int __c) __THROW;

/* These are the same as `toupper' and `tolower' except that they do not
   check the argument for being in the range of a `char'.  */__exctype (_toupper); __exctype (_tolower);   
#endif /* Use SVID or use misc.  */
 /* This code is needed for the optimized mapping functions.  */
#define __tobody(c, f, a, args) \
  (__extension__							      \
	  else								      \
	    __res = f args;						      \
	}								      \
      else								      \
	__res = (a)[(int) (c)];						      \
      __res; }))
   
#if !defined __NO_CTYPE
  
# ifdef __isctype_f
__isctype_f (alnum) __isctype_f (alpha) __isctype_f (cntrl) __isctype_f (digit) __isctype_f (lower) __isctype_f (graph) __isctype_f (print) __isctype_f (punct) __isctype_f (space) __isctype_f (upper) __isctype_f (xdigit)   
#  ifdef __USE_ISOC99
__isctype_f (blank)   
#  endif
  
# include <xlocale.h>
  
#endif /* expanded by -frewrite-includes */
/* Definition of locale datatype.    Copyright (C) 1997-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
   
#ifndef _XLOCALE_H
  
#define _XLOCALE_H	1
 /* Structure for reentrant locale using functions.  This is an    (almost) opaque type for the user level programs.  The file and    this data structure is not standardized.  Don't rely on it.  It can
   go away without warning.  */
typedef struct __locale_struct
{
  /* Note: LC_ALL is not a valid index into this array.  */
  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */

} *__locale_t;

/* POSIX 2008 makes locale_t official.  */
typedef __locale_t locale_t;

#endif /* xlocale.h */

/* These definitions are similar to the ones above but all functions
   take as an argument a handle for the locale which shall be used.  */
#  define __isctype_l(c, type, locale) \
  ((locale)->__ctype_b[(int) (c)] & (unsigned short int) type)

# define __exctype_l(name) 						      \
  extern int name (int, __locale_t) __THROW

/* The following names are all functions:
     int isCHARACTERISTIC(int c, locale_t *locale);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */__exctype_l (isalnum_l); __exctype_l (isalpha_l); __exctype_l (iscntrl_l); __exctype_l (isdigit_l); __exctype_l (islower_l); __exctype_l (isgraph_l); __exctype_l (isprint_l); __exctype_l (ispunct_l); __exctype_l (isspace_l); __exctype_l (isupper_l); __exctype_l (isxdigit_l);  __exctype_l (isblank_l);   /* Return the lowercase version of C in locale L.  */extern int __tolower_l (int __c, __locale_t __l) __THROW; extern int tolower_l (int __c, __locale_t __l) __THROW;  /* Return the uppercase version of C.  */extern int __toupper_l (int __c, __locale_t __l) __THROW; extern int toupper_l (int __c, __locale_t __l) __THROW;    
# if __GNUC__ >= 2 && defined __OPTIMIZE__ && !defined __cplusplus
  
#  define __tolower_l(c, locale) \
  __tobody (c, __tolower_l, (locale)->__ctype_tolower, (c, locale))
  
#  define isupper_l(c,l)	__isupper_l ((c), (l))
  
#  define isxdigit_l(c,l)	__isxdigit_l ((c), (l))
   
#  define isblank_l(c,l)	__isblank_l ((c), (l))
   
#  if defined __USE_SVID || defined __USE_MISC
  
#   define isascii_l(c,l)	__isascii_l ((c), (l))
  
#   define toascii_l(c,l)	__toascii_l ((c), (l))
  
#  endif
   
# endif /* Not __NO_CTYPE.  */
   
#endif /* Use POSIX 2008.  */
 __END_DECLS    
#endif /* ctype.h  */
   
#ifdef __cplusplus
   
  
#undef tolower
  
#undef toupper
   
#endif
   
#endif  // _LIBCPP_CTYPE_H
  
#pragma clang module end /*std.depr.ctype_h*/
}
   extern "C" {   
#if 0 /* expanded by -frewrite-includes */
  
#include "errno.h"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.depr.errno_h
// -*- C++ -*-
//===-------------------------- errno.h -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ERRNO_H
  
  
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <errno.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard: 7.5 Errors	<errno.h>  */   
#ifndef	_ERRNO_H
 /* The includer defined __need_Emath if he wants only the definitions    of EDOM and ERANGE, and not everything else.  */
#ifndef	__need_Emath
  
# define _ERRNO_H	1
  
#if 0 /* expanded by -frewrite-includes */
  
# include <features.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
 __BEGIN_DECLS  /* Get the error number constants from the system-specific file.    This file will test __need_Emath and _ERRNO_H.  */
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/errno.h>
  
#endif /* expanded by -frewrite-includes */
/* Error constants.  Linux specific version.    Copyright (C) 1996-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
   
#ifdef _ERRNO_H
   
# undef EDOM
  
# undef EILSEQ
#if 0 /* expanded by -frewrite-includes */
  
#include <asm-generic/errno.h>
  
#endif /* expanded by -frewrite-includes */
  
#ifndef _ASM_GENERIC_ERRNO_H
  
  
#ifndef _ASM_GENERIC_ERRNO_BASE_H
  
#define _ASM_GENERIC_ERRNO_BASE_H
   
#define	EPERM		 1	/* Operation not permitted */
  
#define	ENOENT		 2	/* No such file or directory */
  
#define	ESRCH		 3	/* No such process */
  
#define	EINTR		 4	/* Interrupted system call */
  
#define	EIO		 5	/* I/O error */
  
#define	ENXIO		 6	/* No such device or address */
  
#define	E2BIG		 7	/* Argument list too long */
  
#define	ENOEXEC		 8	/* Exec format error */
  
#define	EBADF		 9	/* Bad file number */
  
#define	ECHILD		10	/* No child processes */
  
#define	EAGAIN		11	/* Try again */
  
#define	ENOMEM		12	/* Out of memory */
  
#define	EACCES		13	/* Permission denied */
  
#define	EFAULT		14	/* Bad address */
  
#define	ENOTBLK		15	/* Block device required */
  
#define	EBUSY		16	/* Device or resource busy */
  
#define	EEXIST		17	/* File exists */
  
#define	EXDEV		18	/* Cross-device link */
  
#define	ENODEV		19	/* No such device */
  
#define	ENOTDIR		20	/* Not a directory */
  
#define	EISDIR		21	/* Is a directory */
  
#define	EINVAL		22	/* Invalid argument */
  
#define	ENFILE		23	/* File table overflow */
  
#define	EMFILE		24	/* Too many open files */
  
#define	ENOTTY		25	/* Not a typewriter */
  
#define	ETXTBSY		26	/* Text file busy */
  
#define	EFBIG		27	/* File too large */
  
#define	ENOSPC		28	/* No space left on device */
  
#define	ESPIPE		29	/* Illegal seek */
  
#define	EROFS		30	/* Read-only file system */
  
#define	EMLINK		31	/* Too many links */
  
#define	EPIPE		32	/* Broken pipe */
  
#define	EDOM		33	/* Math argument out of domain of func */
  
#define	ERANGE		34	/* Math result not representable */
   
#endif
   
#define	EDEADLK		35	/* Resource deadlock would occur */
  
#define	ENAMETOOLONG	36	/* File name too long */
  
#define	ENOLCK		37	/* No record locks available */
  
#define	ENOSYS		38	/* Function not implemented */
  
#define	ENOTEMPTY	39	/* Directory not empty */
  
#define	ELOOP		40	/* Too many symbolic links encountered */
  
#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
  
#define	ENOMSG		42	/* No message of desired type */
  
#define	EIDRM		43	/* Identifier removed */
  
#define	ENOLINK		67	/* Link has been severed */
  
#define	EADV		68	/* Advertise error */
  
#define	ESRMNT		69	/* Srmount error */
  
#define	ECOMM		70	/* Communication error on send */
  
#define	EPROTO		71	/* Protocol error */
  
#define	EMULTIHOP	72	/* Multihop attempted */
  
#define	EDOTDOT		73	/* RFS specific error */
  
#define	EBADMSG		74	/* Not a data message */
  
#define	EOVERFLOW	75	/* Value too large for defined data type */
  
#define	ENOTUNIQ	76	/* Name not unique on network */
  
#define	EBADFD		77	/* File descriptor in bad state */
  
#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
  
#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
  
#define	EILSEQ		84	/* Illegal byte sequence */
  
#define	ERESTART	85	/* Interrupted system call should be restarted */
  
#define	ESTRPIPE	86	/* Streams pipe error */
  
#define	EUSERS		87	/* Too many users */
  
#define	ENOTSOCK	88	/* Socket operation on non-socket */
  
#define	EDESTADDRREQ	89	/* Destination address required */
  
#define	EMSGSIZE	90	/* Message too long */
  
#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
  
#define	ENOPROTOOPT	92	/* Protocol not available */
  
#define	EPROTONOSUPPORT	93	/* Protocol not supported */
  
#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
  
#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
  
#define	EPFNOSUPPORT	96	/* Protocol family not supported */
  
#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
  
#define	EADDRINUSE	98	/* Address already in use */
  
#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
  
#define	ENETDOWN	100	/* Network is down */
  
#define	ENETUNREACH	101	/* Network is unreachable */
  
#define	ENETRESET	102	/* Network dropped connection because of reset */
  
#define	ECONNABORTED	103	/* Software caused connection abort */
  
#define	ECONNRESET	104	/* Connection reset by peer */
  
#define	ENOBUFS		105	/* No buffer space available */
  
#define	EISCONN		106	/* Transport endpoint is already connected */
  
#define	ENOTCONN	107	/* Transport endpoint is not connected */
  
#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
  
#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
  
#define	ETIMEDOUT	110	/* Connection timed out */
  
#define	ECONNREFUSED	111	/* Connection refused */
  
#define	EHOSTDOWN	112	/* Host is down */
  
#define	EHOSTUNREACH	113	/* No route to host */
  
#define	EALREADY	114	/* Operation already in progress */
  
#define	EINPROGRESS	115	/* Operation now in progress */
  
#define	ESTALE		116	/* Stale file handle */
#define ERFKILL		132	/* Operation not possible due to RF-kill */
   
#define EHWPOISON	133	/* Memory page has hardware error */
   
#endif
 /* Linux has no ENOTSUP error code.  */
# define ENOTSUP EOPNOTSUPP
 /* Older Linux versions also had no ECANCELED error code.  */
# ifndef ECANCELED
  
#  define ECANCELED	125
  
# endif
 /* Support for error codes to support robust mutexes was added later, too.  */
# ifndef EOWNERDEAD
#  define EHWPOISON		133
  
# endif
   
# ifndef __ASSEMBLER__
/* Function to get address of global `errno' variable.  */
extern int *__errno_location (void) __THROW __attribute__ ((__const__));

#  if !defined _LIBC || defined _LIBC_REENTRANT
/* When using threads, errno is a per-thread value.  */
#   define errno (*__errno_location ())
#  endif
# endif /* !__ASSEMBLER__ */
#endif /* _ERRNO_H */

#undef	__need_Emath

#ifdef	_ERRNO_H

/* Declare the `errno' variable, unless it's defined as a macro by
   bits/errno.h.  This is the case in GNU, where it is a per-thread
   variable.  This redeclaration using the macro still works, but it
   will be a function declaration without a prototype and may trigger
   a -Wstrict-prototypes warning.  */
#ifndef	errno
extern int errno;
#endif

#ifdef __USE_GNU

/* The full and simple forms of the name with which the program was
   invoked.  These variables are set up automatically at startup based on
   the value of ARGV[0] (this works only if you use GNU ld).  */
extern char *program_invocation_name, *program_invocation_short_name;
#endif /* __USE_GNU */
#endif /* _ERRNO_H */

__END_DECLS

#if !defined(EOWNERDEAD) || !defined(ENOTRECOVERABLE)

#ifdef ELAST

static const int __elast1 = ELAST+1;
static const int __elast2 = ELAST+2;

#else

static const int __elast1 = 104;
static const int __elast2 = 105;

#endif

#ifdef ENOTRECOVERABLE

#define EOWNERDEAD __elast1

#ifdef ELAST
#undef ELAST
#define ELAST EOWNERDEAD
#endif

#else  // defined(EOWNERDEAD)

#define EOWNERDEAD __elast1
#define ENOTRECOVERABLE __elast2
#ifdef ELAST
#undef ELAST
#define ELAST ENOTRECOVERABLE
#endif

#endif  // defined(EOWNERDEAD)

#endif  // !defined(EOWNERDEAD) || !defined(ENOTRECOVERABLE)

//  supply errno values likely to be missing, particularly on Windows

#ifndef EBADMSG
#define EBADMSG 9905
#endif

#ifndef ECONNABORTED
#define ECONNABORTED 9906

#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1997-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>  */ 
#ifndef _INTTYPES_H

#define _INTTYPES_H	1
 
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_STDINT_H

#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 /* C99 stdlib (e.g. glibc < 2.18) does not provide macros needed    for C++11 unless __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS    are defined */
#if defined(__cplusplus) && !defined(__STDC_LIMIT_MACROS)

#   define __STDC_LIMIT_MACROS
#endif
 
#if 0 /* expanded by -frewrite-includes */

#include_next <stdint.h>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.depr.stdint_h
/*===---- stdint.h - Standard header for sized integer types --------------===*\  *  * Copyright (c) 2009 Chris Lattner  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN  * THE SOFTWARE.  * \*===----------------------------------------------------------------------===*/ 
#ifndef __CLANG_STDINT_H

#define __CLANG_STDINT_H
 /* If we're hosted, fall back to the system's stdint.h, which might have  * additional definitions.  */
#if __STDC_HOSTED__ && (1)/*__has_include_next(<stdint.h>)*/
 /*  *	ISO C99: 7.18 Integer types <stdint.h>  */ 
#ifndef _STDINT_H

#define _STDINT_H	1
 
#if 0 /* expanded by -frewrite-includes */

#include <features.h>
#endif /* expanded by -frewrite-includes */
/* wchar_t type related definitions.    Copyright (C) 2000-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
 
#ifndef _BITS_WCHAR_H

#define _BITS_WCHAR_H	1
 /* The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__    are not defined, give the right value and type as long as both int    and wchar_t are 32-bit types.  Adding L'\0' to a constant value    ensures that the type is correct; it is necessary to use (L'\0' +    0) rather than just L'\0' so that the type in C++ is the promoted    version of wchar_t rather than the distinct wchar_t type itself.    Because wchar_t in preprocessor 
#if expressions is treated as
 
#ifdef __x86_64__

# define __WORDSIZE_TIME64_COMPAT32	1
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# define __SYSCALL_WORDSIZE		64

#endif
 /* Exact integral types.  */ /* Signed.  */ /* There is some amount of overlap with <sys/types.h> as known by inet code */
#ifndef __int8_t_defined

# define __int8_t_defined
typedef signed char		int8_t; typedef short int		int16_t; typedef int			int32_t; 
# if __WORDSIZE == 64
typedef long int		int64_t; 
# else
__extension__ typedef long long int		int64_t; 
# endif

#endif
 /* Unsigned.  */typedef unsigned char		uint8_t; typedef unsigned short int	uint16_t; 
#ifndef __uint32_t_defined
typedef unsigned int		uint32_t; 
# define __uint32_t_defined

#endif

#if __WORDSIZE == 64
typedef unsigned long int	uint64_t; 
#else
__extension__ typedef unsigned long long int	uint64_t; 
#endif
  /* Small types.  */ /* Signed.  */typedef signed char		int_least8_t; typedef short int		int_least16_t; typedef int			int_least32_t; 
#if __WORDSIZE == 64
typedef long int		int_least64_t; 
#else
__extension__ typedef long long int		int_least64_t; 
#endif
 /* Unsigned.  */typedef unsigned char		uint_least8_t; typedef unsigned short int	uint_least16_t; typedef unsigned int		uint_least32_t; 
#if __WORDSIZE == 64
typedef unsigned long int	uint_least64_t; 
#else
__extension__ typedef unsigned long long int	uint_least64_t; 
#endif
  /* Fast types.  */ /* Signed.  */typedef signed char		int_fast8_t; 
#if __WORDSIZE == 64
typedef long int		int_fast16_t; typedef long int		int_fast32_t; typedef long int		int_fast64_t; 
#else
typedef int			int_fast16_t; typedef int			int_fast32_t; __extension__ typedef long long int		int_fast64_t; 
#endif
 /* Unsigned.  */typedef unsigned char		uint_fast8_t; 
#if __WORDSIZE == 64
typedef unsigned long int	uint_fast16_t; typedef unsigned long int	uint_fast32_t; typedef unsigned long int	uint_fast64_t; 
#else
typedef unsigned int		uint_fast16_t; typedef unsigned int		uint_fast32_t; __extension__ typedef unsigned long long int	uint_fast64_t; 
#endif
  /* Types for `void *' pointers.  */
#if __WORDSIZE == 64
 
# ifndef __intptr_t_defined
typedef long int		intptr_t;  
#  define __intptr_t_defined
#  define __intptr_t_defined
 
# endif
typedef unsigned int		uintptr_t;  
#endif
  /* Largest integral types.  */
#if __WORDSIZE == 64
typedef long int		intmax_t; typedef unsigned long int	uintmax_t;  
 
# endif
 /* Limits of integral types.  */ /* Minimum of signed integral types.  */
# define INT8_MIN		(-128)
 
# define INT16_MIN		(-32767-1)
 
# define INT32_MIN		(-2147483647-1)
# if __WORDSIZE == 64
 
#  define INT_FAST16_MIN	(-9223372036854775807L-1)
 
#  define INT_FAST32_MIN	(-9223372036854775807L-1)
 
# else
 
#  define SIZE_MAX		(4294967295U)
 
# endif
 /* Limits of `wchar_t'.  */
# ifndef WCHAR_MIN
/* These constants might also be defined in <wchar.h>.  */
#  define WCHAR_MIN		__WCHAR_MIN

#  define WCHAR_MAX		__WCHAR_MAX

# endif
 /* Limits of `wint_t'.  */
# define WINT_MIN		(0u)
 
# define WINT_MAX		(4294967295u)
 /* Signed.  */
  
#endif /* __INT_LEAST8_MIN */
 /* Some utility macros */
#define  __INTN_MIN(n)  __stdint_join3( INT, n, _MIN)
  
#define  __INTN_MAX(n)  __stdint_join3( INT, n, _MAX)
  
#define __UINTN_MAX(n)  __stdint_join3(UINT, n, _MAX)
  
#define SIG_ATOMIC_MAX __INTN_MAX(__SIG_ATOMIC_WIDTH__)
  
#ifdef __WINT_UNSIGNED__
  
# define WINT_MIN       __UINTN_C(__WINT_WIDTH__, 0)
  
#endif
   
#ifndef WCHAR_MAX
  
# define WCHAR_MAX __WCHAR_MAX__
  
#endif
  
#ifndef WCHAR_MIN
  
# if __WCHAR_MAX__ == __INTN_MAX(__WCHAR_WIDTH__)
  
#  define WCHAR_MIN __INTN_MIN(__WCHAR_WIDTH__)
  
# else
  
#  define WCHAR_MIN __UINTN_C(__WCHAR_WIDTH__, 0)
  
# endif
  
#endif
 /* 7.18.4.2 Macros for greatest-width integer constants. */
#define  INTMAX_C(v) __int_c(v,  __INTMAX_C_SUFFIX__)
  
#define UINTMAX_C(v) __int_c(v, __UINTMAX_C_SUFFIX__)
   
#endif /* __STDC_HOSTED__ */
  
#endif /* __CLANG_STDINT_H */
  
#pragma clang module end /*std.depr.stdint_h*/
   
#endif  // _LIBCPP_STDINT_H
 /* Get a definition for wchar_t.  But we must not define wchar_t itself.  */
#ifndef ____gwchar_t_defined
  
# ifdef __cplusplus
  
#if 0 /* expanded by -frewrite-includes */
  
#  include <stddef.h>
  
#endif /* expanded by -frewrite-includes */
typedef wchar_t __gwchar_t;   
# endif
  
# endif
 /* Macros for printing format specifiers.  */ /* Decimal notation.  */
# define PRId8		"d"
  
# define PRId16		"d"
  
# define PRId32		"d"
# define PRIXFAST64	__PRI64_PREFIX "X"
  /* Macros for printing `intmax_t' and `uintmax_t'.  */
# define PRIdMAX	__PRI64_PREFIX "d"
  
# define PRIiMAX	__PRI64_PREFIX "i"
   
# define SCNxPTR	__PRIPTR_PREFIX "x"
  __BEGIN_DECLS    
extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
			    __gwchar_t ** __restrict __endptr, int __base)
     __THROW;

#ifdef __USE_EXTERN_INLINES

# if __WORDSIZE == 64
{
  return __wcstoull_internal (nptr, endptr, base, 0);
}

# endif	/* __WORDSIZE == 32	*/
#endif	/* Use extern inlines.  */

__END_DECLS
#define SCNoFAST32 "o"
#define SCNu32 "u"
#define SCNuLEAST32 "u"
#define SCNuFAST32 "u"
#define SCNx32 "x"
#define SCNxLEAST32 "x"
#define SCNxFAST32 "x"
#endif

#endif /* __CLANG_INTTYPES_H */

#ifdef __cplusplus

#if 0 /* expanded by -frewrite-includes */
#include <stdint.h>
#endif /* expanded by -frewrite-includes */

#undef imaxabs
#undef imaxdiv

#endif // __cplusplus

#endif  // _LIBCPP_INTTYPES_H

#ifndef _LIBCPP_LOCALE_H
#define _LIBCPP_LOCALE_H

/*
    locale.h synopsis

   setlocale
   localeconv

*/

#if 0 /* expanded by -frewrite-includes */
#include <__config>
#endif /* expanded by -frewrite-includes */

#ifndef	_LOCALE_H
#define	_LOCALE_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */

#define __need_NULL
#if 0 /* expanded by -frewrite-includes */
#include <stddef.h>
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===--------------------------- stddef.h ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
#endif

#if 0 /* expanded by -frewrite-includes */
#include_next <stddef.h>
#endif /* expanded by -frewrite-includes */
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
#if !__has_feature(modules)
#define _SIZE_T
#endif
typedef __SIZE_TYPE__ size_t;
#endif
#undef __need_size_t
#endif /*defined(__need_size_t) */

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
typedef __WCHAR_TYPE__ wchar_t;
#endif
#endif
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
#    define NULL 0
#  endif
#else
#endif
#undef __need_NULL
#endif /* defined(__need_NULL) */

#if defined(__need_STDDEF_H_misc)
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
#if 0 /* expanded by -frewrite-includes */
#include "__stddef_max_align_t.h"
#endif /* expanded by -frewrite-includes */
#endif
#define offsetof(t, d) __builtin_offsetof(t, d)
#undef __need_STDDEF_H_misc
#endif  /* defined(__need_STDDEF_H_misc) */

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
#endif
#undef __need_wint_t
#endif /* __need_wint_t */

#endif

#elif !defined(_LIBCPP_STDDEF_H)
#define _LIBCPP_STDDEF_H

/*
    stddef.h synopsis

Macros:

    offsetof(type,member-designator)
    NULL
#endif
   
#endif
   
#endif  // _LIBCPP_STDDEF_H
  
#if 0 /* expanded by -frewrite-includes */
  
  
#endif
   
#ifndef _BITS_LOCALE_H
  
#define _BITS_LOCALE_H	1
   
#define __LC_CTYPE		 0
  
#define __LC_NUMERIC		 1
  
#define __LC_TIME		 2
  
#define __LC_COLLATE		 3
  
#define __LC_MONETARY		 4
  
#define __LC_MESSAGES		 5
  
#define __LC_ALL		 6
  
#define __LC_PAPER		 7
  
#define __LC_IDENTIFICATION	12
   
#endif	/* bits/locale.h */
 __BEGIN_DECLS  /* These are the possibilities for the first argument to setlocale.    The code assumes that the lowest LC_* symbol has the value zero.  */
#define LC_CTYPE          __LC_CTYPE
  
#define LC_NUMERIC        __LC_NUMERIC
  
  
#define LC_TELEPHONE	  __LC_TELEPHONE
  
#define LC_MEASUREMENT	  __LC_MEASUREMENT
  
#define LC_IDENTIFICATION __LC_IDENTIFICATION
  __BEGIN_NAMESPACE_STD  /* Structure giving information about numeric and monetary notation.  */struct lconv {   /* Numeric (non-monetary) information.  */   char *decimal_point;		/* Decimal point character.  */  char *thousands_sep;		/* Thousands separator.  */  /* Each element is the number of digits in each group;      elements with higher indices are farther left.      An element with value CHAR_MAX means that no further grouping is done.      An element with value 0 means that the previous element is used      for all groups farther left.  */  char *grouping;    /* Monetary information.  */   /* First three chars are a currency symbol from ISO 4217.      Fourth char is the separator.  Fifth char is '\0'.  */  char *int_curr_symbol;   char *currency_symbol;	/* Local currency symbol.  */  char *mon_decimal_point;	/* Decimal point character.  */  char *mon_thousands_sep;	/* Thousands separator.  */  char *mon_grouping;		/* Like `grouping' element (above).  */
  char *positive_sign;		/* Sign for positive values.  */
  char *negative_sign;		/* Sign for negative values.  */
  char int_frac_digits;		/* Int'l fractional digits.  */  char frac_digits;		/* Local fractional digits.  */  /* 1 if currency_symbol precedes a positive value, 0 if succeeds.  */  char p_cs_precedes;   /* 1 iff a space separates currency_symbol from a positive value.  */  char p_sep_by_space;   /* 1 if currency_symbol precedes a negative value, 0 if succeeds.  */  char n_cs_precedes;   /* 1 iff a space separates currency_symbol from a negative value.  */  char n_sep_by_space;   /* Positive and negative sign positions:      0 Parentheses surround the quantity and currency_symbol.      1 The sign string precedes the quantity and currency_symbol.      2 The sign string follows the quantity and currency_symbol.      3 The sign string immediately precedes the currency_symbol.      4 The sign string immediately follows the currency_symbol.  */  char p_sign_posn;   char n_sign_posn;   
#ifdef __USE_ISOC99
  /* 1 if int_curr_symbol precedes a positive value, 0 if succeeds.  */  char int_p_cs_precedes;   /* 1 iff a space separates int_curr_symbol from a positive value.  */  char int_p_sep_by_space;   /* 1 if int_curr_symbol precedes a negative value, 0 if succeeds.  */  char int_n_cs_precedes;   /* 1 iff a space separates int_curr_symbol from a negative value.  */  char int_n_sep_by_space;   /* Positive and negative sign positions:      0 Parentheses surround the quantity and int_curr_symbol.      1 The sign string precedes the quantity and int_curr_symbol.      2 The sign string follows the quantity and int_curr_symbol.      3 The sign string immediately precedes the int_curr_symbol.      4 The sign string immediately follows the int_curr_symbol.  */  char int_p_sign_posn;   char int_n_sign_posn;   
#else
  char __int_p_cs_precedes;   char __int_p_sep_by_space;   char __int_n_cs_precedes;   char __int_n_sep_by_space;   char __int_p_sign_posn;   char __int_n_sign_posn;   
#endif
};   /* Set and/or return the current locale.  */extern char *setlocale (int __category, const char *__locale) __THROW;  /* Return the numeric/monetary information for the current locale.  */extern struct lconv *localeconv (void) __THROW;  __END_NAMESPACE_STD     
#ifdef	__USE_XOPEN2K8
/* The concept of one static locale per category is not very well    thought out.  Many applications will need to process its data using    information from several different locales.  Another application is    the implementation of the internationalization handling in the    upcoming ISO C++ standard library.  To support this another set of    the functions using locale data exist which have an additional    argument.     Attention: all these functions are *not* standardized in any form.    This is a proof-of-concept implementation.  */ /* Get locale datatype definition.  */
#if 0 /* expanded by -frewrite-includes */
  
# include <xlocale.h>
  
#endif /* expanded by -frewrite-includes */
 /* Return a reference to a data structure representing a set of locale    datasets.  Unlike for the CATEGORY parameter for `setlocale' the
   CATEGORY_MASK parameter here uses a single bit for each category,
   made by OR'ing together LC_*_MASK bits above.  */extern __locale_t newlocale (int __category_mask, const char *__locale, 			     __locale_t __base) __THROW;  /* These are the bits that can be set in the CATEGORY_MASK argument to    `newlocale'.  In the GNU implementation, LC_FOO_MASK has the value
   of (1 << LC_FOO), but this is not a part of the interface that
   callers can assume will be true.  */
# define LC_CTYPE_MASK		(1 << __LC_CTYPE)
# define LC_NUMERIC_MASK	(1 << __LC_NUMERIC)
# define LC_TIME_MASK		(1 << __LC_TIME)
# define LC_COLLATE_MASK	(1 << __LC_COLLATE)
# define LC_MONETARY_MASK	(1 << __LC_MONETARY)
# define LC_MESSAGES_MASK	(1 << __LC_MESSAGES)
# define LC_PAPER_MASK		(1 << __LC_PAPER)
# define LC_NAME_MASK		(1 << __LC_NAME)
# define LC_ADDRESS_MASK	(1 << __LC_ADDRESS)
# define LC_TELEPHONE_MASK	(1 << __LC_TELEPHONE)

/* Return a duplicate of the set of locale in DATASET.  All usage
   counters are increased if necessary.  */
extern __locale_t duplocale (__locale_t __dataset) __THROW;

/* Free the data associated with a locale dataset previously returned
   by a call to `setlocale_r'.  */extern void freelocale (__locale_t __dataset) __THROW;  /* Switch the current thread's locale to DATASET.
   If DATASET is null, instead just return the current setting.
   The special value LC_GLOBAL_LOCALE is the initial setting
   for all threads and can also be installed any time, meaning
   the thread uses the global settings controlled by `setlocale'.  */extern __locale_t uselocale (__locale_t __dataset) __THROW;  /* This value can be passed to `uselocale' and may be returned by it.
   Passing this value to any other function has undefined behavior.  */
# define LC_GLOBAL_LOCALE	((__locale_t) -1L)

#endif

__END_DECLS

#endif /* locale.h  */

#endif  // _LIBCPP_LOCALE_H
#pragma clang module end /*std.depr.locale_h*/
}
extern "C" {
#if 0 /* expanded by -frewrite-includes */
#include "math.h"
#endif /* expanded by -frewrite-includes */
#pragma clang module begin std.depr.math_h
// -*- C++ -*-
//===---------------------------- math.h ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_MATH_H
#define _LIBCPP_MATH_H

/*
    math.h synopsis

Macros:


   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 */

#ifndef	_MATH_H
#define	_MATH_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */

__BEGIN_DECLS

/* Get machine-dependent HUGE_VAL value (returned on overflow).
   On all IEEE754 machines, this is +Infinity.  */
#if 0 /* expanded by -frewrite-includes */
#include <bits/huge_val.h>
#endif /* expanded by -frewrite-includes */
#if __GNUC_PREREQ(3,3)
  
# define HUGE_VAL	(__builtin_huge_val())
  
#elif __GNUC_PREREQ(2,96)
  
# define HUGE_VAL	(__extension__ 0x1.0p2047)
 typedef union { unsigned char __c[8]; double __d; } __huge_val_t;    
# if __BYTE_ORDER == __BIG_ENDIAN
  
#  define __HUGE_VAL_bytes	{ 0x7f, 0xf0, 0, 0, 0, 0, 0, 0 }
  
# endif
  
# if __BYTE_ORDER == __LITTLE_ENDIAN
  
#  define __HUGE_VAL_bytes	{ 0, 0, 0, 0, 0, 0, 0xf0, 0x7f }
  
# endif
 static __huge_val_t __huge_val = { __HUGE_VAL_bytes };   
# define HUGE_VAL	(__huge_val.__d)
   
#endif	/* GCC.  */
  
#ifdef __USE_ISOC99
  
#if 0 /* expanded by -frewrite-includes */
  
# include <bits/huge_valf.h>
  
#endif /* expanded by -frewrite-includes */
   
#if __GNUC_PREREQ(3,3)
  
# define HUGE_VALL	(__builtin_huge_vall())
  
#elif __GNUC_PREREQ(2,96)
  
#endif

/* IEEE positive infinity.  */

#if __GNUC_PREREQ(3,3)
# define INFINITY	(__builtin_inff())
#else
# define INFINITY	HUGE_VALF
#endif

/* Get machine-dependent NAN value (returned for some domain errors).  */
#if 0 /* expanded by -frewrite-includes */
# include <bits/nan.h>
#endif /* expanded by -frewrite-includes */
/* `NAN' constant for IEEE 754 machines.    Copyright (C) 1992-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
   
#ifndef _MATH_H
  
# error "Never use <bits/nan.h> directly; include <math.h> instead."
  
#endif
  /* IEEE Not A Number.  */   
#if __GNUC_PREREQ(3,3)
   
#endif	/* GCC.  */
  
#endif /* __USE_ISOC99 */
 /* Get general and ISO C99 specific information.  */
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/mathdef.h>

/* The values returned by `ilogb' for 0 and NaN respectively.  */
# define FP_ILOGB0	(-2147483647 - 1)
  
# define FP_ILOGBNAN	(-2147483647 - 1)
 /* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}    builtins are supported.  */
# if __FP_FAST_FMA
# endif
   
#endif	/* ISO C99 */
 /* The file <bits/mathcalls.h> contains the prototypes for all the    actual math functions.  These macros are used for those prototypes,    so we can easily declare each function as both `name' and `__name',    and can declare the float versions `namef' and `__namef'.  */   
#define __MATHCALL(function,suffix, args)	\
  __MATHDECL (_Mdouble_,function,suffix, args)
  
#define __MATHDECL(type, function,suffix, args) \
  __MATHDECL_1(type, function,suffix, args); \
  __MATHDECL_1(type, __CONCAT(__,function),suffix, args)
  
#define __MATHCALLX(function,suffix, args, attrib)	\
  __MATHDECLX (_Mdouble_,function,suffix, args, attrib)
  
#define __MATHDECLX(type, function,suffix, args, attrib) \
  __MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); \
  __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)
  
#define __MATHDECL_1(type, function,suffix, args) \
  extern type __MATH_PRECNAME(function,suffix) args __THROW
   
#define _Mdouble_		double
  
#define __MATH_PRECNAME(name,r)	__CONCAT(name,r)
  
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_STD
  
#define _Mdouble_END_NAMESPACE   __END_NAMESPACE_STD
  
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/mathcalls.h>
  
#endif /* expanded by -frewrite-includes */
/* Prototype declarations for math functions; helper file for <math.h>.    Copyright (C) 1996-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see    <http://www.gnu.org/licenses/>.  */
 /* NOTE: Because of the special way this file is used by <math.h>, this    file must NOT be protected from multiple inclusion as header files    usually are.     This file provides prototype declarations for the math functions.    Most functions are declared using the macro:     __MATHCALL (NAME,[_r], (ARGS...));     This means there is a function `NAME' returning `double' and a function    `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.
/* Arc cosine of X.  */
__MATHCALL (acos,, (_Mdouble_ __x));
/* Arc sine of X.  */
__MATHCALL (asin,, (_Mdouble_ __x));
/* Arc tangent of X.  */
__MATHCALL (atan,, (_Mdouble_ __x));
/* Arc tangent of Y/X.  */
__MATHCALL (atan2,, (_Mdouble_ __y, _Mdouble_ __x));

/* Cosine of X.  */
__MATHCALL (cos,, (_Mdouble_ __x));
/* Sine of X.  */
__MATHCALL (sin,, (_Mdouble_ __x));
/* Tangent of X.  */
__MATHCALL (tan,, (_Mdouble_ __x));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
__MATHCALL (cosh,, (_Mdouble_ __x));
/* Hyperbolic sine of X.  */
__MATHCALL (sinh,, (_Mdouble_ __x));
/* Hyperbolic tangent of X.  */

#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Hyperbolic arc cosine of X.  */
__MATHCALL (acosh,, (_Mdouble_ __x));
/* Hyperbolic arc sine of X.  */
__MATHCALL (asinh,, (_Mdouble_ __x));
/* Hyperbolic arc tangent of X.  */
__MATHCALL (atanh,, (_Mdouble_ __x));
__END_NAMESPACE_C99
#endif

/* Exponential and logarithmic functions.  */

_Mdouble_BEGIN_NAMESPACE
/* Exponential function of X.  */
__MATHCALL (exp,, (_Mdouble_ __x));

/* Break VALUE into a normalized fraction and an integral power of 2.  */
__MATHCALL (frexp,, (_Mdouble_ __x, int *__exponent));

/* X times (two to the EXP power).  */
__MATHCALL (ldexp,, (_Mdouble_ __x, int __exponent));

/* Natural logarithm of X.  */
__MATHCALL (log,, (_Mdouble_ __x));

/* Base-ten logarithm of X.  */
__MATHCALL (log10,, (_Mdouble_ __x));

/* Break VALUE into integral and fractional parts.  */
__MATHCALL (modf,, (_Mdouble_ __x, _Mdouble_ *__iptr)) __nonnull ((2));
_Mdouble_END_NAMESPACE

#ifdef __USE_GNU
/* A function missing in all standards: compute exponent to base ten.  */
__MATHCALL (exp10,, (_Mdouble_ __x));
__END_NAMESPACE_C99
#endif


/* Power functions.  */

_Mdouble_BEGIN_NAMESPACE
/* Return X to the Y power.  */
__MATHCALL (pow,, (_Mdouble_ __x, _Mdouble_ __y));

/* Return the square root of X.  */
__MATHCALL (sqrt,, (_Mdouble_ __x));
_Mdouble_END_NAMESPACE

#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Return `sqrt(X*X + Y*Y)'.  */__MATHCALL (hypot,, (_Mdouble_ __x, _Mdouble_ __y)); __END_NAMESPACE_C99   
#endif
   
#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99 /* Return the cube root of X.  */__MATHCALL (cbrt,, (_Mdouble_ __x)); __END_NAMESPACE_C99   
#endif
  /* Nearest integer, absolute value, and remainder functions.  */ _Mdouble_BEGIN_NAMESPACE /* Smallest integral value not less than X.  */__MATHCALLX (ceil,, (_Mdouble_ __x), (__const__));  /* Absolute value of X.  */__MATHCALLX (fabs,, (_Mdouble_ __x), (__const__));  /* Largest integer not greater than X.  */__MATHCALLX (floor,, (_Mdouble_ __x), (__const__));  /* Floating-point modulo remainder of X/Y.  */__MATHCALL (fmod,, (_Mdouble_ __x, _Mdouble_ __y));   /* Return 0 if VALUE is finite or NaN, +1 if it    is +Infinity, -1 if it is -Infinity.  */__MATHDECL_1 (int,__isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));  /* Return nonzero if VALUE is finite and not NaN.  */__MATHDECL_1 (int,__finite,, (_Mdouble_ __value)) __attribute__ ((__const__)); _Mdouble_END_NAMESPACE    
#ifdef __USE_MISC
/* Return 0 if VALUE is finite or NaN, +1 if it    is +Infinity, -1 if it is -Infinity.  */__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));  /* Return nonzero if VALUE is finite and not NaN.  */__MATHDECL_1 (int,finite,, (_Mdouble_ __value)) __attribute__ ((__const__));  /* Return the remainder of X/Y.  */__MATHCALL (drem,, (_Mdouble_ __x, _Mdouble_ __y));   /* Return the fractional part of X after dividing out `ilogb (X)'.  */
__MATHCALL (significand,, (_Mdouble_ __x));
#endif /* Use misc.  */

#if defined __USE_MISC || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Return X with its signed changed to Y's.  */__MATHCALLX (copysign,, (_Mdouble_ __x, _Mdouble_ __y), (__const__)); __END_NAMESPACE_C99   
__BEGIN_NAMESPACE_C99 /* True gamma function.  */__MATHCALL (tgamma,, (_Mdouble_)); __END_NAMESPACE_C99   
#endif
   
#if defined __USE_MISC || defined __USE_XOPEN
/* Obsolete alias for `lgamma'.  */
__MATHCALL (gamma,, (_Mdouble_));
#endif

#ifdef __USE_MISC
/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores    the value through it.  */__MATHCALL (lgamma,_r, (_Mdouble_, int *__signgamp));   
#endif
    
#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99 /* Return the integer nearest X in the direction of the    prevailing rounding mode.  */__MATHCALL (rint,, (_Mdouble_ __x));  /* Return X + epsilon if X < Y, X - epsilon if X > Y.  */__MATHCALLX (nextafter,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));   
# if defined __USE_ISOC99 && !defined __LDBL_COMPAT
__MATHCALLX (nexttoward,, (_Mdouble_ __x, long double __y), (__const__));   
# endif
 /* Return the remainder of integer divison X / Y with infinite precision.  */__MATHCALL (remainder,, (_Mdouble_ __x, _Mdouble_ __y));    
# if defined __USE_MISC || defined __USE_ISOC99
/* Return X times (2 to the Nth power).  */__MATHCALL (scalbn,, (_Mdouble_ __x, int __n));   
# endif
 /* Return the binary exponent of X, which must be nonzero.  */__MATHDECL (int,ilogb,, (_Mdouble_ __x));   
#endif
   
#ifdef __USE_ISOC99
/* Return X times (2 to the Nth power).  */__MATHCALL (scalbln,, (_Mdouble_ __x, long int __n));  /* Round X to integral value in floating-point format using current    rounding direction, but do not raise inexact exception.  */__MATHCALL (nearbyint,, (_Mdouble_ __x));  /* Round X to nearest integral value, rounding halfway cases away from    zero.  */__MATHCALLX (round,, (_Mdouble_ __x), (__const__));  /* Round X to the integral value in floating-point format nearest but    not larger in magnitude.  */__MATHCALLX (trunc,, (_Mdouble_ __x), (__const__));  /* Compute remainder of X and Y and put in *QUO a value with sign of x/y    and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
__MATHCALL (remquo,, (_Mdouble_ __x, _Mdouble_ __y, int *__quo));



# ifndef _Mfloat_
#  define _Mfloat_		float
# endif
# define _Mdouble_		_Mfloat_
# define __MATH_PRECNAME(name,r) name##f##r
# define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
# define _Mdouble_END_NAMESPACE   __END_NAMESPACE_C99
#if 0 /* expanded by -frewrite-includes */
# include <bits/mathcalls.h>
#endif /* expanded by -frewrite-includes */
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

  
# error "Never include <bits/mathcalls.h> directly; include <math.h> instead."
  
#endif
  /* Trigonometric functions.  */ _Mdouble_BEGIN_NAMESPACE /* Arc cosine of X.  */__MATHCALL (acos,, (_Mdouble_ __x)); /* Arc sine of X.  */__MATHCALL (asin,, (_Mdouble_ __x)); /* Arc tangent of X.  */__MATHCALL (atan,, (_Mdouble_ __x)); /* Arc tangent of Y/X.  */__MATHCALL (atan2,, (_Mdouble_ __y, _Mdouble_ __x));  /* Cosine of X.  */__MATHCALL (cos,, (_Mdouble_ __x)); /* Sine of X.  */__MATHCALL (sin,, (_Mdouble_ __x)); /* Tangent of X.  */__MATHCALL (tan,, (_Mdouble_ __x));  /* Hyperbolic functions.  */ /* Hyperbolic cosine of X.  */__MATHCALL (cosh,, (_Mdouble_ __x)); /* Hyperbolic sine of X.  */__MATHCALL (sinh,, (_Mdouble_ __x)); /* Hyperbolic tangent of X.  */__MATHCALL (tanh,, (_Mdouble_ __x)); _Mdouble_END_NAMESPACE    
#ifdef __USE_GNU
/* Cosine and sine of X.  */__MATHDECL (void,sincos,, 	    (_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx));   
#endif
   
#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99 /* Hyperbolic arc cosine of X.  */__MATHCALL (acosh,, (_Mdouble_ __x)); /* Hyperbolic arc sine of X.  */__MATHCALL (asinh,, (_Mdouble_ __x)); /* Hyperbolic arc tangent of X.  */__MATHCALL (atanh,, (_Mdouble_ __x)); __END_NAMESPACE_C99   
#endif
 /* Exponential and logarithmic functions.  */ _Mdouble_BEGIN_NAMESPACE /* Exponential function of X.  */__MATHCALL (exp,, (_Mdouble_ __x));  /* Break VALUE into a normalized fraction and an integral power of 2.  */__MATHCALL (frexp,, (_Mdouble_ __x, int *__exponent));  /* X times (two to the EXP power).  */__MATHCALL (ldexp,, (_Mdouble_ __x, int __exponent));  /* Natural logarithm of X.  */__MATHCALL (log,, (_Mdouble_ __x));  /* Base-ten logarithm of X.  */__MATHCALL (log10,, (_Mdouble_ __x));  /* Break VALUE into integral and fractional parts.  */__MATHCALL (modf,, (_Mdouble_ __x, _Mdouble_ *__iptr)) __nonnull ((2)); _Mdouble_END_NAMESPACE    
#ifdef __USE_GNU
/* A function missing in all standards: compute exponent to base ten.  */__MATHCALL (exp10,, (_Mdouble_ __x)); /* Another name occasionally used.  */__MATHCALL (pow10,, (_Mdouble_ __x));   
__BEGIN_NAMESPACE_C99 /* Compute base-2 exponential of X.  */__MATHCALL (exp2,, (_Mdouble_ __x));  /* Compute base-2 logarithm of X.  */__MATHCALL (log2,, (_Mdouble_ __x)); __END_NAMESPACE_C99   
#endif
  /* Power functions.  */ _Mdouble_BEGIN_NAMESPACE /* Return X to the Y power.  */__MATHCALL (pow,, (_Mdouble_ __x, _Mdouble_ __y));  /* Return the square root of X.  */__MATHCALL (sqrt,, (_Mdouble_ __x)); _Mdouble_END_NAMESPACE    
#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99 /* Return `sqrt(X*X + Y*Y)'.  */
__MATHCALL (hypot,, (_Mdouble_ __x, _Mdouble_ __y));
__END_NAMESPACE_C99
#endif
/* Absolute value of X.  */
__MATHCALLX (fabs,, (_Mdouble_ __x), (__const__));

/* Largest integer not greater than X.  */
__MATHCALLX (floor,, (_Mdouble_ __x), (__const__));

/* Floating-point modulo remainder of X/Y.  */
__MATHCALL (fmod,, (_Mdouble_ __x, _Mdouble_ __y));
_Mdouble_END_NAMESPACE

#ifdef __USE_MISC
/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));

#endif /* Use misc.  */
   
#if defined __USE_MISC || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99 /* Return X with its signed changed to Y's.  */
__MATHCALLX (copysign,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
__END_NAMESPACE_C99
#endif



#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Error and gamma functions.  */
__MATHCALL (erf,, (_Mdouble_));
__MATHCALL (erfc,, (_Mdouble_));
__MATHCALL (lgamma,, (_Mdouble_));
__END_NAMESPACE_C99
#endif

#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* True gamma function.  */
__MATHCALL (tgamma,, (_Mdouble_));
__END_NAMESPACE_C99
/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
__MATHCALL (rint,, (_Mdouble_ __x));

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
__MATHCALLX (nextafter,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
# if defined __USE_ISOC99 && !defined __LDBL_COMPAT
__MATHCALL (scalbn,, (_Mdouble_ __x, int __n));
# endif

/* Return the binary exponent of X, which must be nonzero.  */
__MATHDECL (int,ilogb,, (_Mdouble_ __x));
#endif

#ifdef __USE_ISOC99
/* Return X times (2 to the Nth power).  */
__MATHCALL (scalbln,, (_Mdouble_ __x, long int __n));

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
__MATHCALL (nearbyint,, (_Mdouble_ __x));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
__MATHCALLX (round,, (_Mdouble_ __x), (__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
__MATHCALLX (trunc,, (_Mdouble_ __x), (__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral    quotient x/y, with n >= 3.  */__MATHCALL (remquo,, (_Mdouble_ __x, _Mdouble_ __y, int *__quo));   /* Conversion functions.  */ /* Round X to nearest integral value according to current rounding    direction.  */__MATHDECL (long int,lrint,, (_Mdouble_ __x)); __extension__ __MATHDECL (long long int,llrint,, (_Mdouble_ __x));  /* Round X to nearest integral value, rounding halfway cases away from    zero.  */__MATHDECL (long int,lround,, (_Mdouble_ __x)); __extension__ __MATHDECL (long long int,llround,, (_Mdouble_ __x));   /* Return positive difference between X and Y.  */__MATHCALL (fdim,, (_Mdouble_ __x, _Mdouble_ __y));  /* Return maximum numeric value from X and Y.  */__MATHCALLX (fmax,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));  /* Return minimum numeric value from X and Y.  */__MATHCALLX (fmin,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));   /* Classify given number.  */__MATHDECL_1 (int, __fpclassify,, (_Mdouble_ __value))      __attribute__ ((__const__));  /* Test for negative number.  */__MATHDECL_1 (int, __signbit,, (_Mdouble_ __value))      __attribute__ ((__const__));   /* Multiply-add function computed as a ternary operation.  */__MATHCALL (fma,, (_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z));   
#endif /* Use ISO C99.  */
   
#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
__END_NAMESPACE_C99   
#endif
   
   
# if !(defined __NO_LONG_DOUBLE_MATH && defined _LIBC) \
     || defined __LDBL_COMPAT
  
#  ifdef __LDBL_COMPAT
   
#   ifdef __USE_ISOC99
extern float __nldbl_nexttowardf (float __x, long double __y) 				  __THROW __attribute__ ((__const__));   
#    ifdef __REDIRECT_NTH
extern float __REDIRECT_NTH (nexttowardf, (float __x, long double __y), 			     __nldbl_nexttowardf)      __attribute__ ((__const__)); extern double __REDIRECT_NTH (nexttoward, (double __x, long double __y), 			      nextafter) __attribute__ ((__const__)); extern long double __REDIRECT_NTH (nexttowardl, 				   (long double __x, long double __y), 				   nextafter) __attribute__ ((__const__));   
#    endif
  
#   endif
   
#   undef __MATHDECL_1
  
#  endif
 /* Include the file of declarations again, this time using `long double'
   instead of `double' and appending l to each function name.  */   
#  ifndef _Mlong_double_
  
#   define _Mlong_double_	long double
  
#  endif
  
#  define _Mdouble_		_Mlong_double_
  
#  define __MATH_PRECNAME(name,r) name##l##r
  
#  define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
  
#  define _Mdouble_END_NAMESPACE   __END_NAMESPACE_C99


/* Trigonometric functions.  */

_Mdouble_BEGIN_NAMESPACE
/* Arc cosine of X.  */
__MATHCALL (acos,, (_Mdouble_ __x));
/* Arc sine of X.  */
__MATHCALL (asin,, (_Mdouble_ __x));
/* Arc tangent of X.  */
__MATHCALL (atan,, (_Mdouble_ __x));
/* Arc tangent of Y/X.  */
__MATHCALL (atan2,, (_Mdouble_ __y, _Mdouble_ __x));

/* Cosine of X.  */
__MATHCALL (cos,, (_Mdouble_ __x));
/* Sine of X.  */
__MATHCALL (sin,, (_Mdouble_ __x));
/* Tangent of X.  */
__MATHCALL (tan,, (_Mdouble_ __x));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
__MATHCALL (cosh,, (_Mdouble_ __x));
/* Hyperbolic sine of X.  */
__MATHCALL (sinh,, (_Mdouble_ __x));
/* Hyperbolic tangent of X.  */
__MATHCALL (tanh,, (_Mdouble_ __x));
_Mdouble_END_NAMESPACE

#ifdef __USE_GNU
/* Cosine and sine of X.  */
__MATHDECL (void,sincos,,
	    (_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx));
#endif

#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
#endif

/* Exponential and logarithmic functions.  */

_Mdouble_BEGIN_NAMESPACE
/* Exponential function of X.  */
__MATHCALL (exp,, (_Mdouble_ __x));
#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Return exp(X) - 1.  */
__MATHCALL (expm1,, (_Mdouble_ __x));

/* Return log(1 + X).  */
__MATHCALL (log1p,, (_Mdouble_ __x));
/* Compute base-2 exponential of X.  */
__MATHCALL (exp2,, (_Mdouble_ __x));

/* Compute base-2 logarithm of X.  */
__MATHCALL (log2,, (_Mdouble_ __x));
__END_NAMESPACE_C99
#endif

__MATHCALL (sqrt,, (_Mdouble_ __x));
_Mdouble_END_NAMESPACE

#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Return `sqrt(X*X + Y*Y)'.  */__MATHCALL (hypot,, (_Mdouble_ __x, _Mdouble_ __y)); __END_NAMESPACE_C99   
#endif
   
#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99 /* Return the cube root of X.  */__MATHCALL (cbrt,, (_Mdouble_ __x)); __END_NAMESPACE_C99   
#endif
  /* Nearest integer, absolute value, and remainder functions.  */ _Mdouble_BEGIN_NAMESPACE /* Smallest integral value not less than X.  */__MATHCALLX (ceil,, (_Mdouble_ __x), (__const__));  /* Absolute value of X.  */__MATHCALLX (fabs,, (_Mdouble_ __x), (__const__));  /* Largest integer not greater than X.  */__MATHCALLX (floor,, (_Mdouble_ __x), (__const__));  /* Floating-point modulo remainder of X/Y.  */__MATHCALL (fmod,, (_Mdouble_ __x, _Mdouble_ __y));   /* Return 0 if VALUE is finite or NaN, +1 if it    is +Infinity, -1 if it is -Infinity.  */__MATHDECL_1 (int,__isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));  /* Return nonzero if VALUE is finite and not NaN.  */__MATHDECL_1 (int,__finite,, (_Mdouble_ __value)) __attribute__ ((__const__)); _Mdouble_END_NAMESPACE    
#ifdef __USE_MISC
/* Return 0 if VALUE is finite or NaN, +1 if it    is +Infinity, -1 if it is -Infinity.  */__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));  /* Return nonzero if VALUE is finite and not NaN.  */__MATHDECL_1 (int,finite,, (_Mdouble_ __value)) __attribute__ ((__const__));  /* Return the remainder of X/Y.  */__MATHCALL (drem,, (_Mdouble_ __x, _Mdouble_ __y));   /* Return the fractional part of X after dividing out `ilogb (X)'.  */
__MATHCALL (significand,, (_Mdouble_ __x));
#endif /* Use misc.  */

#if defined __USE_MISC || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Return X with its signed changed to Y's.  */__MATHCALLX (copysign,, (_Mdouble_ __x, _Mdouble_ __y), (__const__)); __END_NAMESPACE_C99   
#endif
   
#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99 /* Error and gamma functions.  */__MATHCALL (erf,, (_Mdouble_)); __MATHCALL (erfc,, (_Mdouble_)); __MATHCALL (lgamma,, (_Mdouble_)); __END_NAMESPACE_C99   
#endif
   
#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99 /* True gamma function.  */__MATHCALL (tgamma,, (_Mdouble_)); __END_NAMESPACE_C99   
#endif
   
#if defined __USE_MISC || defined __USE_XOPEN
/* Obsolete alias for `lgamma'.  */
__MATHCALL (gamma,, (_Mdouble_));
#endif

#ifdef __USE_MISC
/* Reentrant version of lgamma.  This function uses the global variable
 /* Return the remainder of integer divison X / Y with infinite precision.  */__MATHCALL (remainder,, (_Mdouble_ __x, _Mdouble_ __y));    
# if defined __USE_MISC || defined __USE_ISOC99
/* Return X times (2 to the Nth power).  */__MATHCALL (scalbn,, (_Mdouble_ __x, int __n));   
# endif
 /* Return the binary exponent of X, which must be nonzero.  */__MATHDECL (int,ilogb,, (_Mdouble_ __x));   
#endif
   
#ifdef __USE_ISOC99
/* Return X times (2 to the Nth power).  */__MATHCALL (scalbln,, (_Mdouble_ __x, long int __n));  /* Round X to integral value in floating-point format using current    rounding direction, but do not raise inexact exception.  */__MATHCALL (nearbyint,, (_Mdouble_ __x));  /* Round X to nearest integral value, rounding halfway cases away from    zero.  */__MATHCALLX (round,, (_Mdouble_ __x), (__const__));  /* Round X to the integral value in floating-point format nearest but    not larger in magnitude.  */__MATHCALLX (trunc,, (_Mdouble_ __x), (__const__));  /* Compute remainder of X and Y and put in *QUO a value with sign of x/y    and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
__MATHCALL (remquo,, (_Mdouble_ __x, _Mdouble_ __y, int *__quo));


/* Conversion functions.  */

#endif

#ifdef __USE_GNU
/* Test for signaling NaN.  */
__MATHDECL_1 (int, __issignaling,, (_Mdouble_ __value))
     __attribute__ ((__const__));
#endif


# endif /* !(__NO_LONG_DOUBLE_MATH && _LIBC) || __LDBL_COMPAT */

#endif	/* Use misc or ISO C99.  */
#undef	__MATHDECL_1
#undef	__MATHDECL
#undef	__MATHCALL
/* ISO C99 defines some generic macros which work on any data type.  */
#ifdef __USE_ISOC99

/* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    float_t	floating-point type at least as wide as `float' used 		to evaluate `float' expressions
    INFINITY	representation of the infinity value of type `float'      FP_FAST_FMA     FP_FAST_FMAF     FP_FAST_FMAL 		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is 		implemented directly with a hardware multiply-add instructions.      FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.      DECIMAL_DIG	Number of decimal digits supported by conversion between 		decimal and all internal floating-point formats.  */ /* All floating-point numbers can be put in one of these categories.  */enum   {     FP_NAN =   
# define FP_NAN 0
      FP_NAN,     FP_INFINITE =   
# define FP_INFINITE 1
      FP_INFINITE,     FP_ZERO =   
# define FP_ZERO 2
      FP_ZERO,     FP_SUBNORMAL =   
# define FP_SUBNORMAL 3
      FP_SUBNORMAL,     FP_NORMAL =   
# define FP_NORMAL 4
      FP_NORMAL   };  /* Return number of classification appropriate for X.  */
# ifdef __NO_LONG_DOUBLE_MATH
  
#  define fpclassify(x) \
     (sizeof (x) == sizeof (float) ? __fpclassifyf (x) : __fpclassify (x))
  
# else
  
#  define fpclassify(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __fpclassifyf (x)						      \
      : sizeof (x) == sizeof (double)					      \
      ? __fpclassify (x) : __fpclassifyl (x))
  
# endif
 /* Return nonzero value if sign of X is negative.  */
# ifdef __NO_LONG_DOUBLE_MATH
  
#  define signbit(x) \
     (sizeof (x) == sizeof (float) ? __signbitf (x) : __signbit (x))
  
# else
  
#  define signbit(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __signbitf (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __signbit (x) : __signbitl (x))
  
# endif
 /* Return nonzero value if X is not +-Inf or NaN.  */
# ifdef __NO_LONG_DOUBLE_MATH
  
      : sizeof (x) == sizeof (double)					      \
      ? __finite (x) : __finitel (x))
  
# endif
 /* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */
# define isnormal(x) (fpclassify (x) == FP_NORMAL)
 /* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  */

#endif /* Use ISO C99.  */

#ifdef __USE_GNU
/* Return nonzero value if X is a signaling NaN.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define issignaling(x) \
     (sizeof (x) == sizeof (float) ? __issignalingf (x) : __issignaling (x))
# else
#  define issignaling(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __issignalingf (x)						      \
      : sizeof (x) == sizeof (double)					      \
      ? __issignaling (x) : __issignalingl (x))
# endif
#endif /* Use GNU.  */

#ifdef	__USE_MISC
/* Support for various different standard error handling behaviors.  */
typedef enum
{
  _IEEE_ = -1,	/* According to IEEE 754/IEEE 854.  */
  _SVID_,	/* According to System V, release 4.  */
  _XOPEN_,	/* Nowadays also Unix98.  */
  _POSIX_,
  _ISOC_	/* Actually this is ISO C99.  */
} _LIB_VERSION_TYPE;

/* This variable can be changed at run-time to any of the values above to
   affect floating point error handling behavior (it may also be necessary
extern int matherr (struct exception *__exc);
# endif

# define X_TLOSS	1.41484755040568800000e+16

/* Types of exceptions in the `type' field.  */
# define DOMAIN		1
# ifdef __USE_XOPEN
/* X/Open wants another strange constant.  */
#  define MAXFLOAT	3.40282347e+38F
  
# endif
   
#endif	/* SVID */
  /* Some useful constants.  */
#if defined __USE_BSD || defined __USE_XOPEN
  
# define M_E		2.7182818284590452354	/* e */
  
# define M_LOG2E	1.4426950408889634074	/* log_2 e */
  
# define M_LOG10E	0.43429448190325182765	/* log_10 e */
  
# define M_SQRT2	1.41421356237309504880	/* sqrt(2) */
  
# define M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */
  
#endif
 /* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */
#ifdef __USE_GNU
# define M_El		2.718281828459045235360287471352662498L /* e */
# define M_LOG2El	1.442695040888963407359924681001892137L /* log_2 e */
# define M_LOG10El	0.434294481903251827651128918916605082L /* log_10 e */
# define M_LN2l		0.693147180559945309417232121458176568L /* log_e 2 */
# define M_LN10l	2.302585092994045684017991454684364208L /* log_e 10 */
#endif
   
#ifdef __USE_ISOC99
/* If we've still got undefined comparison macros, provide defaults.  */

/* Return nonzero value if X is greater than Y.  */
# ifndef isgreater
#  define islessequal(x, y) \
  (__extension__							      \
   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
      !isunordered (__x, __y) && __x <= __y; }))
# endif

/* Return nonzero value if either X is less than Y or Y is less than X.  */
# ifndef isunordered
#  define isunordered(u, v) \
  (__extension__							      \
   ({ __typeof__(u) __u = (u); __typeof__(v) __v = (v);			      \
      fpclassify (__u) == FP_NAN || fpclassify (__v) == FP_NAN; }))
# endif

#endif

__END_DECLS


#endif /* math.h  */

#ifdef __cplusplus

// We support including .h headers inside 'extern "C"' contexts, so switch
// back to C++ linkage before including these C++ headers.
extern "C++" {

#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_TYPE_TRAITS
#define _LIBCPP_TYPE_TRAITS

/*
#endif /* expanded by -frewrite-includes */
#pragma clang module begin std.compat.cstddef
// -*- C++ -*-
//===--------------------------- cstddef ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_CSTDDEF
#define _LIBCPP_CSTDDEF

/*
    cstddef synopsis

Macros:

    offsetof(type,member-designator)
    NULL
    max_align_t
    nullptr_t
    byte // C++17

}  // std

*/

#if 0 /* expanded by -frewrite-includes */
#include <__config>
#endif /* expanded by -frewrite-includes */
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
#endif

// Don't include our own <stddef.h>; we don't want to declare ::nullptr_t.
#if 0 /* expanded by -frewrite-includes */
#include_next <stddef.h>
#endif /* expanded by -frewrite-includes */
//===----------------------------------------------------------------------===//

#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
#endif

#if 0 /* expanded by -frewrite-includes */
#include_next <stddef.h>
#endif /* expanded by -frewrite-includes */

#elif !defined(_LIBCPP_STDDEF_H)
#define _LIBCPP_STDDEF_H

/*
    stddef.h synopsis

Macros:
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
#define __need_ptrdiff_t
#define __need_size_t
#define __need_wchar_t
#define __need_NULL
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
#endif

#if defined(__need_ptrdiff_t)
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
#if !__has_feature(modules)
#define _PTRDIFF_T
#endif
typedef __PTRDIFF_TYPE__ ptrdiff_t;
#endif
#undef __need_ptrdiff_t
#endif /* defined(__need_ptrdiff_t) */

#if defined(__need_size_t)
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
#if !__has_feature(modules)
#define _SIZE_T
#endif
typedef __SIZE_TYPE__ size_t;
#endif
#undef __need_size_t
#endif /*defined(__need_size_t) */

#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
typedef __SIZE_TYPE__ rsize_t;
#endif
#endif /* defined(__need_STDDEF_H_misc) */

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WCHAR_T
#if defined(_MSC_EXTENSIONS)
#define _WCHAR_T_DEFINED
#endif
#endif
typedef __WCHAR_TYPE__ wchar_t;
#endif
#endif
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
#    define NULL 0
#  endif
#else
 *===-----------------------------------------------------------------------===
 */

#ifndef __CLANG_MAX_ALIGN_T_DEFINED
#define __CLANG_MAX_ALIGN_T_DEFINED

#if defined(_MSC_VER)
typedef double max_align_t;
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
#endif

#endif
#endif
#define offsetof(t, d) __builtin_offsetof(t, d)
#if !defined(_WINT_T) || __has_feature(modules)
#if !__has_feature(modules)
#define _WINT_T
#endif
typedef __WINT_TYPE__ wint_t;
#endif
#undef __need_wint_t
#endif /* __need_wint_t */

#endif

#ifdef __cplusplus

extern "C++" {
#if 0 /* expanded by -frewrite-includes */
#include <__nullptr>
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===--------------------------- __nullptr --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_NULLPTR
#define _LIBCPP_NULLPTR

#if 0 /* expanded by -frewrite-includes */

#define nullptr _VSTD::__get_nullptr_t()

_LIBCPP_END_NAMESPACE_STD

#else  // _LIBCPP_HAS_NO_NULLPTR

namespace std
{
    typedef decltype(nullptr) nullptr_t;
}

#endif  // _LIBCPP_HAS_NO_NULLPTR

#endif  // _LIBCPP_NULLPTR
using std::nullptr_t;
}

// Re-use the compiler's <stddef.h> max_align_t where possible.   
#if !defined(__CLANG_MAX_ALIGN_T_DEFINED) && !defined(_GCC_MAX_ALIGN_T) && \
    !defined(__DEFINED_max_align_t)
typedef long double max_align_t;   
#endif
   
#endif
   
#endif  // _LIBCPP_STDDEF_H
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__nullptr>
  
#endif /* expanded by -frewrite-includes */
 _LIBCPP_BEGIN_NAMESPACE_STD  using ::ptrdiff_t; using ::size_t;    
#if defined(__CLANG_MAX_ALIGN_T_DEFINED) || defined(_GCC_MAX_ALIGN_T) || \
    defined(__DEFINED_max_align_t)
// Re-use the compiler's <stddef.h> max_align_t where possible.
using ::max_align_t;   
#else
typedef long double max_align_t;   
#endif
 _LIBCPP_END_NAMESPACE_STD    
#if _LIBCPP_STD_VER > 14
namespace std  // purposefully not versioned
{ enum class byte : unsigned char {};  constexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept { return __lhs = byte(static_cast<unsigned char>(__lhs) | static_cast<unsigned char>(__rhs)); } constexpr byte  operator| (byte  __lhs, byte __rhs) noexcept { return         byte(static_cast<unsigned char>(__lhs) | static_cast<unsigned char>(__rhs)); }  constexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept { return __lhs = byte(static_cast<unsigned char>(__lhs) & static_cast<unsigned char>(__rhs)); } constexpr byte  operator& (byte  __lhs, byte __rhs) noexcept { return         byte(static_cast<unsigned char>(__lhs) & static_cast<unsigned char>(__rhs)); }  constexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept  { return __lhs = byte(static_cast<unsigned char>(__lhs) ^ static_cast<unsigned char>(__rhs)); } constexpr byte  operator^ (byte  __lhs, byte __rhs) noexcept { return         byte(static_cast<unsigned char>(__lhs) ^ static_cast<unsigned char>(__rhs)); }  constexpr byte  operator~ (byte __b) noexcept { return  byte(~static_cast<unsigned char>(__b)); }  }    
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>  // rest of byte
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
// -*- C++ -*-
   
#ifndef _LIBCPP_TYPE_TRAITS
  
#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {      // helper class:
    template <class T, T v> struct integral_constant;     typedef integral_constant<bool, true>  true_type;   // C++11
    typedef integral_constant<bool, false> false_type;  // C++11
         template <bool B>                                   // C++14
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair; template <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;  template <class> struct __void_t { typedef void type; };  template <class _Tp> struct __identity { typedef _Tp type; };  template <class _Tp, bool> struct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};  template <bool _Bp, class _If, class _Then>     struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;}; template <class _If, class _Then>     struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};    
 // is_member_pointer
 template <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {}; template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer     : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v     = is_member_pointer<_Tp>::value;   
#endif
 // is_member_object_pointer
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer     : public integral_constant<bool, is_member_pointer<_Tp>::value &&                                     !is_member_function_pointer<_Tp>::value> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
#endif  // _LIBCPP_CXX03_LANG
   
#if _LIBCPP_STD_VER > 14
   
#define __cpp_lib_void_t 201411
template <class...> using void_t = void;    
# ifndef _LIBCPP_HAS_NO_VARIADICS
template <class... _Args> struct conjunction : __and_<_Args...> {}; template<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;  template <class... _Args> struct disjunction : __or_<_Args...> {}; template<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;  template <class _Tp> struct negation : __not_<_Tp> {}; template<class _Tp> constexpr bool negation_v = negation<_Tp>::value;   
# endif // _LIBCPP_HAS_NO_VARIADICS
  
#endif  // _LIBCPP_STD_VER > 14
 // These traits are used in __tree and __hash_table
  
#ifndef _LIBCPP_CXX03_LANG
struct __extract_key_fail_tag {}; struct __extract_key_self_tag {}; struct __extract_key_first_tag {};  template <class _ValTy, class _Key,           class _RawValTy = typename __unconstref<_ValTy>::type> struct __can_extract_key     : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,                   __extract_key_fail_tag>::type {};  template <class _Pair, class _Key, class _First, class _Second> struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>     : conditional<is_same<typename remove_const<_First>::type, _Key>::value,                   __extract_key_first_tag, __extract_key_fail_tag>::type {};  // __can_extract_map_key uses true_type/false_type instead of the tags.
// std::byte
namespace std  // purposefully not versioned
{ template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &   operator<<=(byte& __lhs, _Integer __shift) noexcept   { return __lhs = byte(static_cast<unsigned char>(__lhs) << __shift); }    template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type   operator<< (byte  __lhs, _Integer __shift) noexcept   { return         byte(static_cast<unsigned char>(__lhs) << __shift); }  template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &   operator>>=(byte& __lhs, _Integer __shift) noexcept   { return __lhs = byte(static_cast<unsigned char>(__lhs) >> __shift); }  template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type   operator>> (byte  __lhs, _Integer __shift) noexcept   { return         byte(static_cast<unsigned char>(__lhs) >> __shift); }    template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type   to_integer(byte __b) noexcept { return _Integer(__b); }  }   
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
  
#endif
   
#endif  // _LIBCPP_CSTDDEF
  
#pragma clang module end /*std.compat.cstddef*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair; template <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;  template <class> struct __void_t { typedef void type; };  template <class _Tp> struct __identity { typedef _Tp type; };  template <class _Tp, bool> struct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};  template <bool _Bp, class _If, class _Then>     struct _LIBCPP_TEMPLATE_VIS conditional {typedef _If type;}; template <class _If, class _Then>     struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {typedef _Then type;};    
#if _LIBCPP_STD_VER > 11
template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;   
#endif
 template <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};  template <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};    
#if _LIBCPP_STD_VER > 11
template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;   
#endif
 // addressof
  
#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
 template <class _Tp> inline _LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY _Tp* addressof(_Tp& __x) _NOEXCEPT {     return __builtin_addressof(__x); }    
#else
 template <class _Tp> inline _LIBCPP_NO_CFI _LIBCPP_INLINE_VISIBILITY _Tp* addressof(_Tp& __x) _NOEXCEPT {   return reinterpret_cast<_Tp *>(       const_cast<char *>(&reinterpret_cast<const volatile char &>(__x))); }    
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;   
#endif
 struct __two {char __lx[2];};  // helper class:
 template <class _Tp, _Tp __v> struct _LIBCPP_TEMPLATE_VIS integral_constant {     static _LIBCPP_CONSTEXPR const _Tp      value = __v;     typedef _Tp               value_type;     typedef integral_constant type;     _LIBCPP_INLINE_VISIBILITY         _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}   
#if _LIBCPP_STD_VER > 11
    _LIBCPP_INLINE_VISIBILITY          constexpr value_type operator ()() const _NOEXCEPT {return value;}   
#endif
};  template <class _Tp, _Tp __v> _LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;    
#if _LIBCPP_STD_VER > 14
template <bool __b> using bool_constant = integral_constant<bool, __b>;   
#define _LIBCPP_BOOL_CONSTANT(__b) bool_constant<(__b)>
  
#else
  
#define _LIBCPP_BOOL_CONSTANT(__b) integral_constant<bool,(__b)>
  
#endif
 typedef _LIBCPP_BOOL_CONSTANT(true)  true_type; typedef _LIBCPP_BOOL_CONSTANT(false) false_type;    
#if !defined(_LIBCPP_CXX03_LANG)
 // __lazy_and
 template <bool _Last, class ..._Preds> struct __lazy_and_impl;  template <class ..._Preds> struct __lazy_and_impl<false, _Preds...> : false_type {};  template <> struct __lazy_and_impl<true> : true_type {};  template <class _Pred> struct __lazy_and_impl<true, _Pred> : integral_constant<bool, _Pred::type::value> {};  template <class _Hp, class ..._Tp> struct __lazy_and_impl<true, _Hp, _Tp...> : __lazy_and_impl<_Hp::type::value, _Tp...> {};  template <class _P1, class ..._Pr> struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};  // __lazy_or
 template <bool _List, class ..._Preds> struct __lazy_or_impl;  template <class ..._Preds> struct __lazy_or_impl<true, _Preds...> : true_type {};  template <> struct __lazy_or_impl<false> : false_type {};  template <class _Hp, class ..._Tp> struct __lazy_or_impl<false, _Hp, _Tp...>         : __lazy_or_impl<_Hp::type::value, _Tp...> {};  template <class _P1, class ..._Pr> struct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};  // __lazy_not
 template <class _Pred> struct __lazy_not : integral_constant<bool, !_Pred::type::value> {};  // __and_
template<class...> struct __and_; template<> struct __and_<> : true_type {};  template<class _B0> struct __and_<_B0> : _B0 {};  template<class _B0, class _B1> struct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};  template<class _B0, class _B1, class _B2, class... _Bn> struct __and_<_B0, _B1, _B2, _Bn...>          : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};  // __or_
template<class...> struct __or_; template<> struct __or_<> : false_type {};  template<class _B0> struct __or_<_B0> : _B0 {};  template<class _B0, class _B1> struct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};  template<class _B0, class _B1, class _B2, class... _Bn> struct __or_<_B0, _B1, _B2, _Bn...>          : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...> >::type {};  // __not_
template<class _Tp>  struct __not_ : conditional<_Tp::value, false_type, true_type>::type {};    
#endif // !defined(_LIBCPP_CXX03_LANG)
 // is_const
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_const_v     = is_const<_Tp>::value;   
#endif
 // is_volatile
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile               : public false_type {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_volatile<_Tp volatile> : public true_type {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_volatile_v     = is_volatile<_Tp>::value;   
#endif
 // remove_const
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const            {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_const<const _Tp> {typedef _Tp type;};   
#if _LIBCPP_STD_VER > 11
template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;   
#endif
 // remove_volatile
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile               {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_volatile<volatile _Tp> {typedef _Tp type;};   
#if _LIBCPP_STD_VER > 11
template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;   
#endif
 // remove_cv
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_cv {typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};   
#if _LIBCPP_STD_VER > 11
template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;   
#endif
 // is_void
 template <class _Tp> struct __libcpp_is_void       : public false_type {}; template <>          struct __libcpp_is_void<void> : public true_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_void     : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v     = is_void<_Tp>::value;   
#endif
 // __is_nullptr_t
 template <class _Tp> struct __is_nullptr_t_impl       : public false_type {}; template <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __is_nullptr_t     : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_null_pointer     : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v     = is_null_pointer<_Tp>::value;   
#endif
  
#endif
 // is_integral
 template <class _Tp> struct __libcpp_is_integral                     : public false_type {}; template <>          struct __libcpp_is_integral<bool>               : public true_type {}; template <>          struct __libcpp_is_integral<char>               : public true_type {}; template <>          struct __libcpp_is_integral<signed char>        : public true_type {}; template <>          struct __libcpp_is_integral<unsigned char>      : public true_type {}; template <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};   
#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
template <>          struct __libcpp_is_integral<char16_t>           : public true_type {}; template <>          struct __libcpp_is_integral<char32_t>           : public true_type {};   
#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
template <>          struct __libcpp_is_integral<short>              : public true_type {}; template <>          struct __libcpp_is_integral<unsigned short>     : public true_type {}; template <>          struct __libcpp_is_integral<int>                : public true_type {}; template <>          struct __libcpp_is_integral<unsigned int>       : public true_type {}; template <>          struct __libcpp_is_integral<long>               : public true_type {}; template <>          struct __libcpp_is_integral<unsigned long>      : public true_type {}; template <>          struct __libcpp_is_integral<long long>          : public true_type {}; template <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};   
#ifndef _LIBCPP_HAS_NO_INT128
template <>          struct __libcpp_is_integral<__int128_t>         : public true_type {}; template <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};   
#endif
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_integral     : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v     = is_integral<_Tp>::value;   
#endif
 // is_floating_point
 template <class _Tp> struct __libcpp_is_floating_point              : public false_type {}; template <>          struct __libcpp_is_floating_point<float>       : public true_type {}; template <>          struct __libcpp_is_floating_point<double>      : public true_type {}; template <>          struct __libcpp_is_floating_point<long double> : public true_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_floating_point     : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v     = is_floating_point<_Tp>::value;   
#endif
 // is_array
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array     : public false_type {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>     : public true_type {}; template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>     : public true_type {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_array_v     = is_array<_Tp>::value;   
#endif
 // is_pointer
 template <class _Tp> struct __libcpp_is_pointer       : public false_type {}; template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer     : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_pointer_v     = is_pointer<_Tp>::value;   
#endif
 // is_reference
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference       : public false_type {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {};   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {};   
#endif
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference        : public false_type {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&>  : public true_type {};   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_reference<_Tp&&> : public true_type {};   
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_reference_v     = is_reference<_Tp>::value;  template <class _Tp> _LIBCPP_CONSTEXPR bool is_lvalue_reference_v     = is_lvalue_reference<_Tp>::value;  template <class _Tp> _LIBCPP_CONSTEXPR bool is_rvalue_reference_v     = is_rvalue_reference<_Tp>::value;   
#endif
// is_union
   
#if __has_feature(is_union) || (_GNUC_VER >= 403)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union     : public integral_constant<bool, __is_union(_Tp)> {};    
#else
 template <class _Tp> struct __libcpp_union : public false_type {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_union     : public __libcpp_union<typename remove_cv<_Tp>::type> {};    
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
 namespace __is_class_imp { template <class _Tp> char  __test(int _Tp::*); template <class _Tp> __two __test(...); }  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_class     : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};    
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_class_v     = is_class<_Tp>::value;   
#endif
 // is_same
 template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {}; template <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v     = is_same<_Tp, _Up>::value;   
#endif
 // is_function
 namespace __libcpp_is_function_imp { struct __dummy_type {}; template <class _Tp> char  __test(_Tp*); template <class _Tp> char __test(__dummy_type); template <class _Tp> __two __test(...); template <class _Tp> _Tp&  __source(int); template <class _Tp> __dummy_type __source(...); }  template <class _Tp, bool = is_class<_Tp>::value ||                             is_union<_Tp>::value ||                             is_void<_Tp>::value  ||                             is_reference<_Tp>::value ||                             __is_nullptr_t<_Tp>::value > struct __libcpp_is_function     : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>     {}; template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_function     : public __libcpp_is_function<_Tp> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_function_v     = is_function<_Tp>::value;   
#endif
 // is_member_function_pointer
 // template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};
// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
// 
 template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr> struct __member_pointer_traits_imp {  // forward declaration; specializations later
};   template <class _Tp> struct __libcpp_is_member_function_pointer     : public false_type {};  template <class _Ret, class _Class> struct __libcpp_is_member_function_pointer<_Ret _Class::*>     : public is_function<_Ret> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_function_pointer     : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type>::type {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_member_function_pointer_v     = is_member_function_pointer<_Tp>::value;   
#endif
 // is_member_pointer
 template <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {}; template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer     : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v     = is_member_pointer<_Tp>::value;   
#endif
 // is_member_object_pointer
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_object_pointer     : public integral_constant<bool, is_member_pointer<_Tp>::value &&                                     !is_member_function_pointer<_Tp>::value> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_member_object_pointer_v     = is_member_object_pointer<_Tp>::value;   
#endif
 // is_enum
   
#if __has_feature(is_enum) || (_GNUC_VER >= 403)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum     : public integral_constant<bool, __is_enum(_Tp)> {};    
#else
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_enum     : public integral_constant<bool, !is_void<_Tp>::value             &&                                      !is_integral<_Tp>::value         &&                                      !is_floating_point<_Tp>::value   &&                                      !is_array<_Tp>::value            &&                                      !is_pointer<_Tp>::value          &&                                      !is_reference<_Tp>::value        &&                                      !is_member_pointer<_Tp>::value   &&                                      !is_union<_Tp>::value            &&                                      !is_class<_Tp>::value            &&                                      !is_function<_Tp>::value         > {};    
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_enum_v     = is_enum<_Tp>::value;   
#endif
 // is_arithmetic
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_arithmetic     : public integral_constant<bool, is_integral<_Tp>::value      ||                                      is_floating_point<_Tp>::value> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_arithmetic_v     = is_arithmetic<_Tp>::value;   
#endif
 // is_fundamental
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_fundamental     : public integral_constant<bool, is_void<_Tp>::value        ||                                      __is_nullptr_t<_Tp>::value ||                                      is_arithmetic<_Tp>::value> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_fundamental_v     = is_fundamental<_Tp>::value;   
#endif
 // is_scalar
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_scalar     : public integral_constant<bool, is_arithmetic<_Tp>::value     ||                                      is_member_pointer<_Tp>::value ||                                      is_pointer<_Tp>::value        ||                                      __is_nullptr_t<_Tp>::value    ||                                      is_enum<_Tp>::value           > {};  template <> struct _LIBCPP_TEMPLATE_VIS is_scalar<nullptr_t> : public true_type {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_scalar_v     = is_scalar<_Tp>::value;   
#endif
 // is_object
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_object     : public integral_constant<bool, is_scalar<_Tp>::value ||                                      is_array<_Tp>::value  ||                                      is_union<_Tp>::value  ||                                      is_class<_Tp>::value  > {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_object_v     = is_object<_Tp>::value;   
#endif
 // is_compound
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_compound     : public integral_constant<bool, !is_fundamental<_Tp>::value> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_compound_v     = is_compound<_Tp>::value;   
#endif
  // __is_referenceable  [defns.referenceable]
 struct __is_referenceable_impl {     template <class _Tp> static _Tp& __test(int);     template <class _Tp> static __two __test(...); };  template <class _Tp> struct __is_referenceable : integral_constant<bool,     !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)), __two>::value> {};   // add_const
 template <class _Tp, bool = is_reference<_Tp>::value ||                             is_function<_Tp>::value  ||                             is_const<_Tp>::value     > struct __add_const             {typedef _Tp type;};  template <class _Tp> struct __add_const<_Tp, false> {typedef const _Tp type;};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_const     {typedef typename __add_const<_Tp>::type type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using add_const_t = typename add_const<_Tp>::type;   
#endif
 // add_volatile
 template <class _Tp, bool = is_reference<_Tp>::value ||                             is_function<_Tp>::value  ||                             is_volatile<_Tp>::value  > struct __add_volatile             {typedef _Tp type;};  template <class _Tp> struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_volatile     {typedef typename __add_volatile<_Tp>::type type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;   
#endif
 // add_cv
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_cv     {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;   
#endif
 // remove_reference
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference        {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&>  {typedef _Tp type;};   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_reference<_Tp&&> {typedef _Tp type;};   
#endif
   
#if _LIBCPP_STD_VER > 11
template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;   
#endif
 // add_lvalue_reference
 template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_impl            { typedef _Tp  type; }; template <class _Tp                                       > struct __add_lvalue_reference_impl<_Tp, true> { typedef _Tp& type; };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_lvalue_reference {typedef typename __add_lvalue_reference_impl<_Tp>::type type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;   
#endif
   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_impl            { typedef _Tp   type; }; template <class _Tp                                       > struct __add_rvalue_reference_impl<_Tp, true> { typedef _Tp&& type; };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_rvalue_reference {typedef typename __add_rvalue_reference_impl<_Tp>::type type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;   
#endif
   
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> _Tp&& __declval(int); template <class _Tp> _Tp   __declval(long);  template <class _Tp> decltype(_VSTD::__declval<_Tp>(0)) declval() _NOEXCEPT;    
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> typename add_lvalue_reference<_Tp>::type declval();    
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
 // __uncvref
 template <class _Tp> struct __uncvref  {     typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type; };  template <class _Tp> struct __unconstref {     typedef typename remove_const<typename remove_reference<_Tp>::type>::type type; };    
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp> using __uncvref_t = typename __uncvref<_Tp>::type;   
#endif
 // __is_same_uncvref
 template <class _Tp, class _Up> struct __is_same_uncvref : is_same<typename __uncvref<_Tp>::type,                                    typename __uncvref<_Up>::type> {};  struct __any {     __any(...); };  // remove_pointer
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer                      {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp*>                {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const>          {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* volatile>       {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_pointer<_Tp* const volatile> {typedef _Tp type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;   
#endif
 // add_pointer
 template <class _Tp,          bool = __is_referenceable<_Tp>::value ||                  is_same<typename remove_cv<_Tp>::type, void>::value> struct __add_pointer_impl     {typedef typename remove_reference<_Tp>::type* type;}; template <class _Tp> struct __add_pointer_impl<_Tp, false>      {typedef _Tp type;};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS add_pointer     {typedef typename __add_pointer_impl<_Tp>::type type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;   
#endif
 // is_signed
 template <class _Tp, bool = is_integral<_Tp>::value> struct __libcpp_is_signed_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(-1) < _Tp(0)) {};  template <class _Tp> struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point
 template <class _Tp, bool = is_arithmetic<_Tp>::value> struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};  template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_signed : public __libcpp_is_signed<_Tp> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_signed_v     = is_signed<_Tp>::value;   
#endif
 // is_unsigned
 template <class _Tp, bool = is_integral<_Tp>::value> struct __libcpp_is_unsigned_impl : public _LIBCPP_BOOL_CONSTANT(_Tp(0) < _Tp(-1)) {};  template <class _Tp> struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point
 template <class _Tp, bool = is_arithmetic<_Tp>::value> struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};  template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_unsigned : public __libcpp_is_unsigned<_Tp> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_unsigned_v     = is_unsigned<_Tp>::value;   
#endif
 // rank
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank     : public integral_constant<size_t, 0> {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[]>     : public integral_constant<size_t, rank<_Tp>::value + 1> {}; template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS rank<_Tp[_Np]>     : public integral_constant<size_t, rank<_Tp>::value + 1> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR size_t rank_v     = rank<_Tp>::value;   
#endif
 // extent
 template <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TEMPLATE_VIS extent     : public integral_constant<size_t, 0> {}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], 0>     : public integral_constant<size_t, 0> {}; template <class _Tp, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[], _Ip>     : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {}; template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], 0>     : public integral_constant<size_t, _Np> {}; template <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TEMPLATE_VIS extent<_Tp[_Np], _Ip>     : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp, unsigned _Ip = 0> _LIBCPP_CONSTEXPR size_t extent_v     = extent<_Tp, _Ip>::value;   
#endif
 // remove_extent
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent     {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[]>     {typedef _Tp type;}; template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_extent<_Tp[_Np]>     {typedef _Tp type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;   
#endif
 // remove_all_extents
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents     {typedef _Tp type;}; template <class _Tp> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[]>     {typedef typename remove_all_extents<_Tp>::type type;}; template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS remove_all_extents<_Tp[_Np]>     {typedef typename remove_all_extents<_Tp>::type type;};    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;   
#endif
 // decay
 template <class _Up, bool> struct __decay {     typedef typename remove_cv<_Up>::type type; };  template <class _Up> struct __decay<_Up, true> { public:     typedef typename conditional                      <                          is_array<_Up>::value,                          typename remove_extent<_Up>::type*,                          typename conditional                          <                               is_function<_Up>::value,                               typename add_pointer<_Up>::type,                               typename remove_cv<_Up>::type                          >::type                      >::type type; };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS decay { private:     typedef typename remove_reference<_Tp>::type _Up; public:     typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type; };    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using decay_t = typename decay<_Tp>::type;   
#endif
 // is_abstract
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_abstract     : public integral_constant<bool, __is_abstract(_Tp)> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_abstract_v     = is_abstract<_Tp>::value;   
#endif
 // is_final
   
#if defined(_LIBCPP_HAS_IS_FINAL)
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};   
#else
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __libcpp_is_final : public false_type {};   
#endif
   
#if defined(_LIBCPP_HAS_IS_FINAL) && _LIBCPP_STD_VER > 11
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_final : public integral_constant<bool, __is_final(_Tp)> {};   
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};    
#if !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;   
#endif
   
#endif // _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_IS_AGGREGATE)
 // is_base_of
   
#ifdef _LIBCPP_HAS_IS_BASE_OF
 template <class _Bp, class _Dp> struct _LIBCPP_TEMPLATE_VIS is_base_of     : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};    
#else  // _LIBCPP_HAS_IS_BASE_OF
 namespace __is_base_of_imp { template <class _Tp> struct _Dst {     _Dst(const volatile _Tp &); }; template <class _Tp> struct _Src {     operator const volatile _Tp &();     template <class _Up> operator const _Dst<_Up> &(); }; template <size_t> struct __one { typedef char type; }; template <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int); template <class _Bp, class _Dp> __two __test(...); }  template <class _Bp, class _Dp> struct _LIBCPP_TEMPLATE_VIS is_base_of     : public integral_constant<bool, is_class<_Bp>::value &&                                      sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};    
#endif  // _LIBCPP_HAS_IS_BASE_OF
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Bp, class _Dp> _LIBCPP_CONSTEXPR bool is_base_of_v     = is_base_of<_Bp, _Dp>::value;   
#endif
 // is_convertible
   
#if __has_feature(is_convertible_to) && !defined(_LIBCPP_USE_IS_CONVERTIBLE_FALLBACK)
 template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible     : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&                                      !is_abstract<_T2>::value> {};    
#else  // __has_feature(is_convertible_to)
 namespace __is_convertible_imp { template <class _Tp> void  __test_convert(_Tp);  template <class _From, class _To, class = void> struct __is_convertible_test : public false_type {};  template <class _From, class _To> struct __is_convertible_test<_From, _To,     decltype(_VSTD::__is_convertible_imp::__test_convert<_To>(_VSTD::declval<_From>()))> : public true_type {};  template <class _Tp, bool _IsArray =    is_array<_Tp>::value,                      bool _IsFunction = is_function<_Tp>::value,                      bool _IsVoid =     is_void<_Tp>::value>                      struct __is_array_function_or_void                          {enum {value = 0};}; template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};}; template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};}; template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};}; }  template <class _Tp,     unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value> struct __is_convertible_check {     static const size_t __v = 0; };  template <class _Tp> struct __is_convertible_check<_Tp, 0> {     static const size_t __v = sizeof(_Tp); };  template <class _T1, class _T2,     unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,     unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value> struct __is_convertible     : public integral_constant<bool,         __is_convertible_imp::__is_convertible_test<_T1, _T2>::value   
#if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value               && (!is_const<typename remove_reference<_T2>::type>::value                   || is_volatile<typename remove_reference<_T2>::type>::value)                   && (is_same<typename remove_cv<_T1>::type,                               typename remove_cv<typename remove_reference<_T2>::type>::type>::value                       || is_base_of<typename remove_reference<_T2>::type, _T1>::value))   
#endif
    > {};  template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};  template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};  template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {}; template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};  template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS is_convertible     : public __is_convertible<_T1, _T2> {     static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;     static const size_t __complete_check2 = __is_convertible_check<_T2>::__v; };    
#endif  // __has_feature(is_convertible_to)
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _From, class _To> _LIBCPP_CONSTEXPR bool is_convertible_v     = is_convertible<_From, _To>::value;   
#endif
 // is_empty
   
#if __has_feature(is_empty) || (_GNUC_VER >= 407)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty     : public integral_constant<bool, __is_empty(_Tp)> {};    
#else  // __has_feature(is_empty)
 template <class _Tp> struct __is_empty1     : public _Tp {     double __lx; };  struct __is_empty2 {     double __lx; };  template <class _Tp, bool = is_class<_Tp>::value> struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};  template <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_empty : public __libcpp_empty<_Tp> {};    
#endif  // __has_feature(is_empty)
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_empty_v     = is_empty<_Tp>::value;   
#endif
 // is_polymorphic
   
#if __has_feature(is_polymorphic) || defined(_LIBCPP_COMPILER_MSVC)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic     : public integral_constant<bool, __is_polymorphic(_Tp)> {};    
#else
 template<typename _Tp> char &__is_polymorphic_impl(     typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,                        int>::type); template<typename _Tp> __two &__is_polymorphic_impl(...);  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_polymorphic     : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};    
#endif // __has_feature(is_polymorphic)
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_polymorphic_v     = is_polymorphic<_Tp>::value;   
#endif
 // has_virtual_destructor
   
#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor     : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};    
#else
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS has_virtual_destructor     : public false_type {};    
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool has_virtual_destructor_v     = has_virtual_destructor<_Tp>::value;   
#endif
 // alignment_of
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS alignment_of     : public integral_constant<size_t, __alignof__(_Tp)> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR size_t alignment_of_v     = alignment_of<_Tp>::value;   
#endif
 // aligned_storage
 template <class _Hp, class _Tp> struct __type_list {     typedef _Hp _Head;     typedef _Tp _Tail; };  struct __nat {   
#ifndef _LIBCPP_CXX03_LANG
    __nat() = delete;     __nat(const __nat&) = delete;     __nat& operator=(const __nat&) = delete;     ~__nat() = delete;   
#endif
};  template <class _Tp> struct __align_type {     static const size_t value = alignment_of<_Tp>::value;     typedef _Tp type; };  struct __struct_double {long double __lx;}; struct __struct_double4 {double __lx[4];};  typedef     __type_list<__align_type<unsigned char>,     __type_list<__align_type<unsigned short>,     __type_list<__align_type<unsigned int>,     __type_list<__align_type<unsigned long>,     __type_list<__align_type<unsigned long long>,     __type_list<__align_type<double>,     __type_list<__align_type<long double>,     __type_list<__align_type<__struct_double>,     __type_list<__align_type<__struct_double4>,     __type_list<__align_type<int*>,     __nat     > > > > > > > > > > __all_types;  template <class _TL, size_t _Align> struct __find_pod;  template <class _Hp, size_t _Align> struct __find_pod<__type_list<_Hp, __nat>, _Align> {     typedef typename conditional<                              _Align == _Hp::value,                              typename _Hp::type,                              void                          >::type type; };  template <class _Hp, class _Tp, size_t _Align> struct __find_pod<__type_list<_Hp, _Tp>, _Align> {     typedef typename conditional<                              _Align == _Hp::value,                              typename _Hp::type,                              typename __find_pod<_Tp, _Align>::type                          >::type type; };  template <class _TL, size_t _Len> struct __find_max_align;  template <class _Hp, size_t _Len> struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};  template <size_t _Len, size_t _A1, size_t _A2> struct __select_align { private:     static const size_t __min = _A2 < _A1 ? _A2 : _A1;     static const size_t __max = _A1 < _A2 ? _A2 : _A1; public:     static const size_t value = _Len < __max ? __min : __max; };  template <class _Hp, class _Tp, size_t _Len> struct __find_max_align<__type_list<_Hp, _Tp>, _Len>     : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};  template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value> struct _LIBCPP_TEMPLATE_VIS aligned_storage {     typedef typename __find_pod<__all_types, _Align>::type _Aligner;     static_assert(!is_void<_Aligner>::value, "");     union type     {         _Aligner __align;         unsigned char __data[(_Len + _Align - 1)/_Align * _Align];     }; };    
#if _LIBCPP_STD_VER > 11
template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>     using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;   
#endif
   
#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \
template <size_t _Len>\
struct _LIBCPP_TEMPLATE_VIS aligned_storage<_Len, n>\
{\
    struct _ALIGNAS(n) type\
    {\
        unsigned char __lx[(_Len + n - 1)/n * n];\
    };\
}
 _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000); _CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000); // PE/COFF does not support alignment beyond 8192 (=0x2000)
  
#if !defined(_LIBCPP_OBJECT_FORMAT_COFF)
_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);   
#endif // !defined(_LIBCPP_OBJECT_FORMAT_COFF)
   
#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
 // aligned_union
 template <size_t _I0, size_t ..._In> struct __static_max;  template <size_t _I0> struct __static_max<_I0> {     static const size_t value = _I0; };  template <size_t _I0, size_t _I1, size_t ..._In> struct __static_max<_I0, _I1, _In...> {     static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :                                              __static_max<_I1, _In...>::value; };  template <size_t _Len, class _Type0, class ..._Types> struct aligned_union {     static const size_t alignment_value = __static_max<__alignof__(_Type0),                                                        __alignof__(_Types)...>::value;     static const size_t __len = __static_max<_Len, sizeof(_Type0),                                              sizeof(_Types)...>::value;     typedef typename aligned_storage<__len, alignment_value>::type type; };    
#if _LIBCPP_STD_VER > 11
template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;   
#endif
   
#endif  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Tp> struct __numeric_type {    static void __test(...);    static float __test(float);    static double __test(char);    static double __test(int);    static double __test(unsigned);    static double __test(long);    static double __test(unsigned long);    static double __test(long long);    static double __test(unsigned long long);    static double __test(double);    static long double __test(long double);     typedef decltype(__test(declval<_Tp>())) type;    static const bool value = !is_same<type, void>::value; };  template <> struct __numeric_type<void> {    static const bool value = true; };  // __promote
 template <class _A1, class _A2 = void, class _A3 = void,           bool = __numeric_type<_A1>::value &&                  __numeric_type<_A2>::value &&                  __numeric_type<_A3>::value> class __promote_imp { public:     static const bool value = false; };  template <class _A1, class _A2, class _A3> class __promote_imp<_A1, _A2, _A3, true> { private:     typedef typename __promote_imp<_A1>::type __type1;     typedef typename __promote_imp<_A2>::type __type2;     typedef typename __promote_imp<_A3>::type __type3; public:     typedef decltype(__type1() + __type2() + __type3()) type;     static const bool value = true; };  template <class _A1, class _A2> class __promote_imp<_A1, _A2, void, true> { private:     typedef typename __promote_imp<_A1>::type __type1;     typedef typename __promote_imp<_A2>::type __type2; public:     typedef decltype(__type1() + __type2()) type;     static const bool value = true; };  template <class _A1> class __promote_imp<_A1, void, void, true> { public:     typedef typename __numeric_type<_A1>::type type;     static const bool value = true; };  template <class _A1, class _A2 = void, class _A3 = void> class __promote : public __promote_imp<_A1, _A2, _A3> {};  // make_signed / make_unsigned
 typedef     __type_list<signed char,     __type_list<signed short,     __type_list<signed int,     __type_list<signed long,     __type_list<signed long long,   
#ifndef _LIBCPP_HAS_NO_INT128
    __type_list<__int128_t,   
#endif
    __nat   
#ifndef _LIBCPP_HAS_NO_INT128
    >   
#endif
    > > > > > __signed_types;  typedef     __type_list<unsigned char,     __type_list<unsigned short,     __type_list<unsigned int,     __type_list<unsigned long,     __type_list<unsigned long long,   
#ifndef _LIBCPP_HAS_NO_INT128
    __type_list<__uint128_t,   
#endif
    __nat   
#ifndef _LIBCPP_HAS_NO_INT128
    >   
#endif
    > > > > > __unsigned_types;  template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;  template <class _Hp, class _Tp, size_t _Size> struct __find_first<__type_list<_Hp, _Tp>, _Size, true> {     typedef _Hp type; };  template <class _Hp, class _Tp, size_t _Size> struct __find_first<__type_list<_Hp, _Tp>, _Size, false> {     typedef typename __find_first<_Tp, _Size>::type type; };  template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,                              bool = is_volatile<typename remove_reference<_Tp>::type>::value> struct __apply_cv {     typedef _Up type; };  template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, false> {     typedef const _Up type; };  template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, false, true> {     typedef volatile _Up type; };  template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, true> {     typedef const volatile _Up type; };  template <class _Tp, class _Up> struct __apply_cv<_Tp&, _Up, false, false> {     typedef _Up& type; };  template <class _Tp, class _Up> struct __apply_cv<_Tp&, _Up, true, false> {     typedef const _Up& type; };  template <class _Tp, class _Up> struct __apply_cv<_Tp&, _Up, false, true> {     typedef volatile _Up& type; };  template <class _Tp, class _Up> struct __apply_cv<_Tp&, _Up, true, true> {     typedef const volatile _Up& type; };  template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value> struct __make_signed {};  template <class _Tp> struct __make_signed<_Tp, true> {     typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type; };  template <> struct __make_signed<bool,               true> {}; template <> struct __make_signed<  signed short,     true> {typedef short     type;}; template <> struct __make_signed<unsigned short,     true> {typedef short     type;}; template <> struct __make_signed<  signed int,       true> {typedef int       type;}; template <> struct __make_signed<unsigned int,       true> {typedef int       type;}; template <> struct __make_signed<  signed long,      true> {typedef long      type;}; template <> struct __make_signed<unsigned long,      true> {typedef long      type;}; template <> struct __make_signed<  signed long long, true> {typedef long long type;}; template <> struct __make_signed<unsigned long long, true> {typedef long long type;};   
#ifndef _LIBCPP_HAS_NO_INT128
template <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;}; template <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};   
#endif
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS make_signed {     typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type; };    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;   
#endif
 template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value> struct __make_unsigned {};  template <class _Tp> struct __make_unsigned<_Tp, true> {     typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type; };  template <> struct __make_unsigned<bool,               true> {}; template <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;}; template <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;}; template <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;}; template <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;}; template <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;}; template <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;}; template <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;}; template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};   
#ifndef _LIBCPP_HAS_NO_INT128
template <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;}; template <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};   
#endif
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS make_unsigned {     typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type; };    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;   
#endif
   
#ifdef _LIBCPP_HAS_NO_VARIADICS
 template <class _Tp, class _Up = void, class _Vp = void> struct _LIBCPP_TEMPLATE_VIS common_type { public:     typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp>::type type; };  template <> struct _LIBCPP_TEMPLATE_VIS common_type<void, void, void> { public:     typedef void type; };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, void, void> { public:     typedef typename common_type<_Tp, _Tp>::type type; };  template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, void> {     typedef typename decay<decltype(         true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()       )>::type type; };    
#else  // _LIBCPP_HAS_NO_VARIADICS
 // bullet 1 - sizeof...(Tp) == 0
 template <class ..._Tp> struct _LIBCPP_TEMPLATE_VIS common_type {};  // bullet 2 - sizeof...(Tp) == 1
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS common_type<_Tp>     : public common_type<_Tp, _Tp> {};  // bullet 3 - sizeof...(Tp) == 2
 template <class _Tp, class _Up, class = void> struct __common_type2_imp {};  template <class _Tp, class _Up> struct __common_type2_imp<_Tp, _Up,     typename __void_t<decltype(         true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()     )>::type> {     typedef typename decay<decltype(         true ? _VSTD::declval<_Tp>() : _VSTD::declval<_Up>()     )>::type type; };  template <class _Tp, class _Up,           class _DTp = typename decay<_Tp>::type,           class _DUp = typename decay<_Up>::type> using __common_type2 =   typename conditional<     is_same<_Tp, _DTp>::value && is_same<_Up, _DUp>::value,     __common_type2_imp<_Tp, _Up>,     common_type<_DTp, _DUp>   >::type;  template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up>     : __common_type2<_Tp, _Up> {};  // bullet 4 - sizeof...(Tp) > 2
 template <class ...Tp> struct __common_types;  template <class, class = void> struct __common_type_impl {};  template <class _Tp, class _Up> struct __common_type_impl<     __common_types<_Tp, _Up>,     typename __void_t<typename common_type<_Tp, _Up>::type>::type> {   typedef typename common_type<_Tp, _Up>::type type; };  template <class _Tp, class _Up, class ..._Vp> struct __common_type_impl<__common_types<_Tp, _Up, _Vp...>,     typename __void_t<typename common_type<_Tp, _Up>::type>::type>   : __common_type_impl<       __common_types<typename common_type<_Tp, _Up>::type, _Vp...> > {  };  template <class _Tp, class _Up, class ..._Vp> struct _LIBCPP_TEMPLATE_VIS common_type<_Tp, _Up, _Vp...>     : __common_type_impl<__common_types<_Tp, _Up, _Vp...> > {};    
#if _LIBCPP_STD_VER > 11
template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;   
#endif
   
#endif  // _LIBCPP_HAS_NO_VARIADICS
 // is_assignable
 template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };  template <class _Tp, class _Arg> typename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type __is_assignable_test(int);  template <class, class> false_type __is_assignable_test(...);   template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value> struct __is_assignable_imp     : public decltype((_VSTD::__is_assignable_test<_Tp, _Arg>(0))) {};  template <class _Tp, class _Arg> struct __is_assignable_imp<_Tp, _Arg, true>     : public false_type { };  template <class _Tp, class _Arg> struct is_assignable     : public __is_assignable_imp<_Tp, _Arg> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_assignable_v     = is_assignable<_Tp, _Arg>::value;   
#endif
 // is_copy_assignable
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_assignable     : public is_assignable<typename add_lvalue_reference<_Tp>::type,                   typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_assignable_v     = is_copy_assignable<_Tp>::value;   
#endif
 // is_move_assignable
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_assignable   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,                            typename add_rvalue_reference<_Tp>::type> {};   
#else
    : public is_copy_assignable<_Tp> {};   
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_move_assignable_v     = is_move_assignable<_Tp>::value;   
#endif
 // is_destructible
 //  if it's a reference, return true
//  if it's a function, return false
//  if it's   void,     return false
//  if it's an array of unknown bound, return false
//  Otherwise, return "std::declval<_Up&>().~_Up()" is well-formed
//    where _Up is remove_all_extents<_Tp>::type
 template <class> struct __is_destructible_apply { typedef int type; };  template <typename _Tp> struct __is_destructor_wellformed {     template <typename _Tp1>     static char  __test (         typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type     );      template <typename _Tp1>     static __two __test (...);          static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char); };  template <class _Tp, bool> struct __destructible_imp;  template <class _Tp> struct __destructible_imp<_Tp, false>     : public _VSTD::integral_constant<bool,          __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};  template <class _Tp> struct __destructible_imp<_Tp, true>     : public _VSTD::true_type {};  template <class _Tp, bool> struct __destructible_false;  template <class _Tp> struct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};  template <class _Tp> struct __destructible_false<_Tp, true> : public _VSTD::false_type {};  template <class _Tp> struct is_destructible     : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};  template <class _Tp> struct is_destructible<_Tp[]>     : public _VSTD::false_type {};  template <> struct is_destructible<void>     : public _VSTD::false_type {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v     = is_destructible<_Tp>::value;   
#endif
 // move
   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename remove_reference<_Tp>::type&& move(_Tp&& __t) _NOEXCEPT {     typedef typename remove_reference<_Tp>::type _Up;     return static_cast<_Up&&>(__t); }  template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR _Tp&& forward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT {     return static_cast<_Tp&&>(__t); }  template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR _Tp&& forward(typename remove_reference<_Tp>::type&& __t) _NOEXCEPT {     static_assert(!is_lvalue_reference<_Tp>::value,                   "can not forward an rvalue as an lvalue");     return static_cast<_Tp&&>(__t); }    
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _Tp& move(_Tp& __t) {     return __t; }  template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY const _Tp& move(const _Tp& __t) {     return __t; }  template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _Tp& forward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT {     return __t; }   template <class _Tp> class __rv {     typedef typename remove_reference<_Tp>::type _Trr;     _Trr& t_; public:     _LIBCPP_INLINE_VISIBILITY     _Trr* operator->() {return &t_;}     _LIBCPP_INLINE_VISIBILITY     explicit __rv(_Trr& __t) : t_(__t) {} };    
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename decay<_Tp>::type __decay_copy(_Tp&& __t) {     return _VSTD::forward<_Tp>(__t); }    
#else
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename decay<_Tp>::type __decay_copy(const _Tp& __t) {     return _VSTD::forward<_Tp>(__t); }    
#endif
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
 template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };    
#if __has_feature(cxx_reference_qualified_functions) || \
    (defined(_GNUC_VER) && _GNUC_VER >= 409)
 template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false> {     typedef _Class& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false> {     typedef _Class& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false> {     typedef _Class const& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false> {     typedef _Class const& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false> {     typedef _Class volatile& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false> {     typedef _Class volatile& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false> {     typedef _Class const volatile& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false> {     typedef _Class const volatile& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false> {     typedef _Class&& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false> {     typedef _Class&& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false> {     typedef _Class const&& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false> {     typedef _Class const&& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false> {     typedef _Class volatile&& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false> {     typedef _Class volatile&& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false> {     typedef _Class const volatile&& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param...); };  template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false> {     typedef _Class const volatile&& _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_Param..., ...); };    
#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409
   
#else  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (); };  template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (...); };  template <class _Rp, class _Class, class _P0> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0); };  template <class _Rp, class _Class, class _P0> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, ...); };  template <class _Rp, class _Class, class _P0, class _P1> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1); };  template <class _Rp, class _Class, class _P0, class _P1> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, ...); };  template <class _Rp, class _Class, class _P0, class _P1, class _P2> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, _P2); };  template <class _Rp, class _Class, class _P0, class _P1, class _P2> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false> {     typedef _Class _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, _P2, ...); };  template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (); };  template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (...); };  template <class _Rp, class _Class, class _P0> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0); };  template <class _Rp, class _Class, class _P0> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, ...); };  template <class _Rp, class _Class, class _P0, class _P1> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1); };  template <class _Rp, class _Class, class _P0, class _P1> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, ...); };  template <class _Rp, class _Class, class _P0, class _P1, class _P2> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, _P2); };  template <class _Rp, class _Class, class _P0, class _P1, class _P2> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false> {     typedef _Class const _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, _P2, ...); };  template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (); };  template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (...); };  template <class _Rp, class _Class, class _P0> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0); };  template <class _Rp, class _Class, class _P0> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, ...); };  template <class _Rp, class _Class, class _P0, class _P1> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1); };  template <class _Rp, class _Class, class _P0, class _P1> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, ...); };  template <class _Rp, class _Class, class _P0, class _P1, class _P2> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, _P2); };  template <class _Rp, class _Class, class _P0, class _P1, class _P2> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false> {     typedef _Class volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, _P2, ...); };  template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (); };  template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (...); };  template <class _Rp, class _Class, class _P0> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0); };  template <class _Rp, class _Class, class _P0> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, ...); };  template <class _Rp, class _Class, class _P0, class _P1> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1); };  template <class _Rp, class _Class, class _P0, class _P1> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, ...); };  template <class _Rp, class _Class, class _P0, class _P1, class _P2> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, _P2); };  template <class _Rp, class _Class, class _P0, class _P1, class _P2> struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false> {     typedef _Class const volatile _ClassType;     typedef _Rp _ReturnType;     typedef _Rp (_FnType) (_P0, _P1, _P2, ...); };    
#endif  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Rp, class _Class> struct __member_pointer_traits_imp<_Rp _Class::*, false, true> {     typedef _Class _ClassType;     typedef _Rp _ReturnType; };  template <class _MP> struct __member_pointer_traits     : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,                     is_member_function_pointer<_MP>::value,                     is_member_object_pointer<_MP>::value> { //     typedef ... _ClassType;
//     typedef ... _ReturnType;
//     typedef ... _FnType;
};   template <class _DecayedFp> struct __member_pointer_class_type {};  template <class _Ret, class _ClassType> struct __member_pointer_class_type<_Ret _ClassType::*> {   typedef _ClassType type; };  // result_of
 template <class _Callable> class result_of;    
#ifdef _LIBCPP_HAS_NO_VARIADICS
 template <class _Fn, bool, bool> class __result_of { };  template <class _Fn> class __result_of<_Fn(), true, false> { public:     typedef decltype(declval<_Fn>()()) type; };  template <class _Fn, class _A0> class __result_of<_Fn(_A0), true, false> { public:     typedef decltype(declval<_Fn>()(declval<_A0>())) type; };  template <class _Fn, class _A0, class _A1> class __result_of<_Fn(_A0, _A1), true, false> { public:     typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type; };  template <class _Fn, class _A0, class _A1, class _A2> class __result_of<_Fn(_A0, _A1, _A2), true, false> { public:     typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type; };  template <class _MP, class _Tp, bool _IsMemberFunctionPtr> struct __result_of_mp;  // member function pointer
 template <class _MP, class _Tp> struct __result_of_mp<_MP, _Tp, true>     : public __identity<typename __member_pointer_traits<_MP>::_ReturnType> { };  // member data pointer
 template <class _MP, class _Tp, bool> struct __result_of_mdp;  template <class _Rp, class _Class, class _Tp> struct __result_of_mdp<_Rp _Class::*, _Tp, false> {     typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type; };  template <class _Rp, class _Class, class _Tp> struct __result_of_mdp<_Rp _Class::*, _Tp, true> {     typedef typename __apply_cv<_Tp, _Rp>::type& type; };  template <class _Rp, class _Class, class _Tp> struct __result_of_mp<_Rp _Class::*, _Tp, false>     : public __result_of_mdp<_Rp _Class::*, _Tp,             is_base_of<_Class, typename remove_reference<_Tp>::type>::value> { };    template <class _Fn, class _Tp> class __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
    : public __result_of_mp<typename remove_reference<_Fn>::type,                             _Tp,                             is_member_function_pointer<typename remove_reference<_Fn>::type>::value> { };  template <class _Fn, class _Tp, class _A0> class __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer
    : public __result_of_mp<typename remove_reference<_Fn>::type,                             _Tp,                             is_member_function_pointer<typename remove_reference<_Fn>::type>::value> { };  template <class _Fn, class _Tp, class _A0, class _A1> class __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer
    : public __result_of_mp<typename remove_reference<_Fn>::type,                             _Tp,                             is_member_function_pointer<typename remove_reference<_Fn>::type>::value> { };  template <class _Fn, class _Tp, class _A0, class _A1, class _A2> class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer
    : public __result_of_mp<typename remove_reference<_Fn>::type,                             _Tp,                             is_member_function_pointer<typename remove_reference<_Fn>::type>::value> { };  // result_of
    // Example: static_cast<int&&>(declval<double>());
    // NOTE: The static_cast implementation below is required to support
    //  classes with explicit conversion operators.
    template <class _To, class _From,               class = decltype(__eat<_To>(_VSTD::declval<_From>()))>     static true_type __test_cast(int);      template <class _To, class _From,               class = decltype(static_cast<_To>(_VSTD::declval<_From>()))>     static integral_constant<bool,         !__is_invalid_base_to_derived_cast<_To, _From>::value &&         !__is_invalid_lvalue_to_rvalue_cast<_To, _From>::value     > __test_cast(long);      template <class, class>     static false_type __test_cast(...);      template <class _Tp, class ..._Args,         class = decltype(_Tp(_VSTD::declval<_Args>()...))>     static true_type __test_nary(int);     template <class _Tp, class...>     static false_type __test_nary(...);      template <class _Tp, class _A0, class = decltype(::new _Tp(_VSTD::declval<_A0>()))>     static is_destructible<_Tp> __test_unary(int);     template <class, class>     static false_type __test_unary(...); };  template <class _Tp, bool = is_void<_Tp>::value> struct __is_default_constructible     : decltype(__is_constructible_helper::__test_nary<_Tp>(0)) {};  template <class _Tp> struct __is_default_constructible<_Tp, true> : false_type {};  template <class _Tp> struct __is_default_constructible<_Tp[], false> : false_type {};  template <class _Tp, size_t _Nx> struct __is_default_constructible<_Tp[_Nx], false>     : __is_default_constructible<typename remove_all_extents<_Tp>::type>  {};  template <class _Tp, class... _Args> struct __libcpp_is_constructible {   static_assert(sizeof...(_Args) > 1, "Wrong specialization");   typedef decltype(__is_constructible_helper::__test_nary<_Tp, _Args...>(0))       type; };  template <class _Tp> struct __libcpp_is_constructible<_Tp> : __is_default_constructible<_Tp> {};  template <class _Tp, class _A0> struct __libcpp_is_constructible<_Tp, _A0>     : public decltype(__is_constructible_helper::__test_unary<_Tp, _A0>(0)) {};  template <class _Tp, class _A0> struct __libcpp_is_constructible<_Tp&, _A0>     : public decltype(__is_constructible_helper::     __test_cast<_Tp&, _A0>(0)) {};  template <class _Tp, class _A0> struct __libcpp_is_constructible<_Tp&&, _A0>     : public decltype(__is_constructible_helper::     __test_cast<_Tp&&, _A0>(0)) {};    
#endif
   
#if __has_feature(is_constructible)
template <class _Tp, class ..._Args> struct _LIBCPP_TEMPLATE_VIS is_constructible     : public integral_constant<bool, __is_constructible(_Tp, _Args...)>     {};   
#elif !defined(_LIBCPP_CXX03_LANG)
template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_constructible     : public __libcpp_is_constructible<_Tp, _Args...>::type {};   
#else
// template <class T> struct is_constructible0;
 //      main is_constructible0 test
 template <class _Tp> decltype((_Tp(), true_type())) __is_constructible0_test(_Tp&);  false_type __is_constructible0_test(__any);  template <class _Tp, class _A0> decltype((_Tp(_VSTD::declval<_A0>()), true_type())) __is_constructible1_test(_Tp&, _A0&);  template <class _A0> false_type __is_constructible1_test(__any, _A0&);  template <class _Tp, class _A0, class _A1> decltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type())) __is_constructible2_test(_Tp&, _A0&, _A1&);  template <class _A0, class _A1> false_type __is_constructible2_test(__any, _A0&, _A1&);  template <bool, class _Tp> struct __is_constructible0_imp // false, _Tp is not a scalar
    : public common_type              <                  decltype(__is_constructible0_test(declval<_Tp&>()))              >::type     {};  template <bool, class _Tp, class _A0> struct __is_constructible1_imp // false, _Tp is not a scalar
 template <class _Ap, size_t _Np> struct __is_constructible0_imp<false, _Ap[_Np]>     : public is_constructible<typename remove_all_extents<_Ap>::type>     {};  template <class _Ap, size_t _Np, class _A0> struct __is_constructible1_imp<false, _Ap[_Np], _A0>     : public false_type     {};  template <class _Ap, size_t _Np, class _A0, class _A1> struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>     : public false_type     {};  //      Incomplete array types are not constructible
 template <class _Ap> struct __is_constructible0_imp<false, _Ap[]>     : public false_type     {};  template <class _Ap, class _A0> struct __is_constructible1_imp<false, _Ap[], _A0>     : public false_type     {};  template <class _Ap, class _A0, class _A1> struct __is_constructible2_imp<false, _Ap[], _A0, _A1>     : public false_type     {};    
#endif // __has_feature(is_constructible)
    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
template <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v     = is_constructible<_Tp, _Args...>::value;   
#endif
 // is_default_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_default_constructible     : public is_constructible<_Tp>     {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_default_constructible_v     = is_default_constructible<_Tp>::value;   
#endif
 // is_copy_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_copy_constructible     : public is_constructible<_Tp,                    typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_copy_constructible_v     = is_copy_constructible<_Tp>::value;   
#endif
 // is_move_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_move_constructible   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>   
#else
    : public is_copy_constructible<_Tp>   
#endif
    {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v     = is_move_constructible<_Tp>::value;   
#endif
 // is_trivially_constructible
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
   
#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> { };    
#else  // !__has_feature(is_trivially_constructible)
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : false_type { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>   
#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_trivial_constructor(_Tp)>   
#else
#endif
    : integral_constant<bool, is_scalar<_Tp>::value> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>     : integral_constant<bool, is_scalar<_Tp>::value> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>     : integral_constant<bool, is_scalar<_Tp>::value> { };    
#endif  // !__has_feature(is_trivially_constructible)
   
#else  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Tp, class _A0 = __is_construct::__nat,                      class _A1 = __is_construct::__nat> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : false_type { };    
#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,                                                        __is_construct::__nat>     : integral_constant<bool, __is_trivially_constructible(_Tp)> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,                                                        __is_construct::__nat>     : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,                                                        __is_construct::__nat>     : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,                                                        __is_construct::__nat>     : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)> { };    
#else  // !__has_feature(is_trivially_constructible)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,                                                        __is_construct::__nat>     : integral_constant<bool, is_scalar<_Tp>::value> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,                                                        __is_construct::__nat>     : integral_constant<bool, is_scalar<_Tp>::value> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,                                                        __is_construct::__nat>     : integral_constant<bool, is_scalar<_Tp>::value> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,                                                        __is_construct::__nat>     : integral_constant<bool, is_scalar<_Tp>::value> { };    
#endif  // !__has_feature(is_trivially_constructible)
   
#endif  // _LIBCPP_HAS_NO_VARIADICS
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
template <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v     = is_trivially_constructible<_Tp, _Args...>::value;   
#endif
 // is_trivially_default_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_default_constructible     : public is_trivially_constructible<_Tp>     {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_default_constructible_v     = is_trivially_default_constructible<_Tp>::value;   
#endif
 // is_trivially_copy_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_constructible     : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>     {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_constructible_v     = is_trivially_copy_constructible<_Tp>::value;   
#endif
 // is_trivially_move_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>   
#else
    : public is_trivially_copy_constructible<_Tp>   
#endif
    {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_constructible_v     = is_trivially_move_constructible<_Tp>::value;   
#endif
 // is_trivially_assignable
   
#if __has_feature(is_trivially_assignable) || _GNUC_VER >= 501
 template <class _Tp, class _Arg> struct is_trivially_assignable     : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)> { };    
#else  // !__has_feature(is_trivially_assignable)
 template <class _Tp, class _Arg> struct is_trivially_assignable     : public false_type {};  template <class _Tp> struct is_trivially_assignable<_Tp&, _Tp>     : integral_constant<bool, is_scalar<_Tp>::value> {};  template <class _Tp> struct is_trivially_assignable<_Tp&, _Tp&>     : integral_constant<bool, is_scalar<_Tp>::value> {};  template <class _Tp> struct is_trivially_assignable<_Tp&, const _Tp&>     : integral_constant<bool, is_scalar<_Tp>::value> {};    
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> struct is_trivially_assignable<_Tp&, _Tp&&>     : integral_constant<bool, is_scalar<_Tp>::value> {};    
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
   
#endif  // !__has_feature(is_trivially_assignable)
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_trivially_assignable_v     = is_trivially_assignable<_Tp, _Arg>::value;   
#endif
 // is_trivially_copy_assignable
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copy_assignable     : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,                   typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copy_assignable_v     = is_trivially_copy_assignable<_Tp>::value;   
#endif
 // is_trivially_move_assignable
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_assignable     : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
                                     typename add_rvalue_reference<_Tp>::type>   
#else
                                     typename add_lvalue_reference<_Tp>::type>   
#endif
    {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v     = is_trivially_move_assignable<_Tp>::value;   
#endif
 // is_trivially_destructible
   
#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible     : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};    
#else
 template <class _Tp> struct __libcpp_trivial_destructor     : public integral_constant<bool, is_scalar<_Tp>::value ||                                      is_reference<_Tp>::value> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible     : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>     : public false_type {};    
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v     = is_trivially_destructible<_Tp>::value;   
#endif
 // is_nothrow_constructible
   
#if 0
template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible     : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))> { };    
#else
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
   
#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
 template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;  template <class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>     : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))> { };  template <class _Tp> void __implicit_conversion_to(_Tp) noexcept { }  template <class _Tp, class _Arg> struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/true, _Tp, _Arg>     : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(declval<_Arg>()))> { };  template <class _Tp, bool _IsReference, class... _Args> struct __libcpp_is_nothrow_constructible</*is constructible*/false, _IsReference, _Tp, _Args...>     : public false_type { };  template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible     : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, is_reference<_Tp>::value, _Tp, _Args...> { };  template <class _Tp, size_t _Ns> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>     : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp> { };    
#else  // __has_feature(cxx_noexcept)
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible     : false_type { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>   
#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_constructor(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{ };  template <class _Tp>   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{ };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&>   
#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_copy(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
#endif  // __has_feature(cxx_noexcept)
   
#else  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Tp, class _A0 = __is_construct::__nat,                      class _A1 = __is_construct::__nat> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible     : false_type { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,                                                        __is_construct::__nat>   
#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_constructor(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{ };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,                                                        __is_construct::__nat>   
#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_copy(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{ };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, const _Tp&,                                                        __is_construct::__nat>   
#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_copy(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{ };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp&,                                                        __is_construct::__nat>   
#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_copy(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{ };    
#endif  // _LIBCPP_HAS_NO_VARIADICS
  
#endif  // __has_feature(is_nothrow_constructible)
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
template <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v     = is_nothrow_constructible<_Tp, _Args...>::value;   
#endif
 // is_nothrow_default_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible     : public is_nothrow_constructible<_Tp>     {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_default_constructible_v     = is_nothrow_default_constructible<_Tp>::value;   
#endif
 // is_nothrow_copy_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_constructible     : public is_nothrow_constructible<_Tp,                   typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_constructible_v     = is_nothrow_copy_constructible<_Tp>::value;   
#endif
 // is_nothrow_move_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_constructible   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>   
#else
    : public is_nothrow_copy_constructible<_Tp>   
#endif
    {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_constructible_v     = is_nothrow_move_constructible<_Tp>::value;   
#endif
 // is_nothrow_assignable
   
#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
 template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;  template <class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>     : public false_type { };  template <class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>     : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) > { };  template <class _Tp, class _Arg> struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable     : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg> { };    
#else  // __has_feature(cxx_noexcept)
 template <class _Tp, class _Arg> struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable     : public false_type {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp>   
#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};   
#else
    : integral_constant<bool, is_scalar<_Tp>::value> {};   
#endif
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable<_Tp&, _Tp&>   
#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
    : integral_constant<bool, is_scalar<_Tp>::value> {};   
#endif
   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> struct is_nothrow_assignable<_Tp&, _Tp&&>   
#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};   
#else
    : integral_constant<bool, is_scalar<_Tp>::value> {};   
#endif
   
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
   
#endif  // __has_feature(cxx_noexcept)
   
 // is_nothrow_move_assignable
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable     : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
                                     typename add_rvalue_reference<_Tp>::type>   
#else
                                     typename add_lvalue_reference<_Tp>::type>   
#endif
    {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_move_assignable_v     = is_nothrow_move_assignable<_Tp>::value;   
#endif
 // is_nothrow_destructible
   
#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
 template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;  template <class _Tp> struct __libcpp_is_nothrow_destructible<false, _Tp>     : public false_type { };  template <class _Tp> struct __libcpp_is_nothrow_destructible<true, _Tp>     : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) > { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible     : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp> { };  template <class _Tp, size_t _Ns> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[_Ns]>     : public is_nothrow_destructible<_Tp> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&>     : public true_type { };    
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp&&>     : public true_type { };    
#endif
   
#else
 template <class _Tp> struct __libcpp_nothrow_destructor     : public integral_constant<bool, is_scalar<_Tp>::value ||                                      is_reference<_Tp>::value> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible     : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>     : public false_type {};    
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v     = is_nothrow_destructible<_Tp>::value;   
#endif
 // is_pod
   
#if __has_feature(is_pod) || (_GNUC_VER >= 403)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pod     : public integral_constant<bool, __is_pod(_Tp)> {};    
#else
template <class _Tp> _LIBCPP_CONSTEXPR bool is_literal_type_v     = is_literal_type<_Tp>::value;   
#endif
 // is_standard_layout;
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_standard_layout   
#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)
    : public integral_constant<bool, __is_standard_layout(_Tp)>   
#else
    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>   
#endif
    {};        
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_standard_layout_v     = is_standard_layout<_Tp>::value;   
#endif
 // is_trivially_copyable;
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_copyable   
#if __has_feature(is_trivially_copyable)
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>   
#elif _GNUC_VER >= 501
    : public integral_constant<bool, !is_volatile<_Tp>::value && __is_trivially_copyable(_Tp)>   
#else
    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>   
#endif
    {};        
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v     = is_trivially_copyable<_Tp>::value;   
#endif
 // is_trivial;
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial   
#if __has_feature(is_trivial) || _GNUC_VER >= 407
    : public integral_constant<bool, __is_trivial(_Tp)>   
#else
    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&                                  is_trivially_default_constructible<_Tp>::value>   
#endif
    {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivial_v     = is_trivial<_Tp>::value;   
#endif
 template <class _Tp> struct __is_reference_wrapper_impl : public false_type {}; template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {}; template <class _Tp> struct __is_reference_wrapper     : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};    
#ifndef _LIBCPP_CXX03_LANG
 // Check for complete types
 template <class ..._Tp> struct __check_complete;  template <> struct __check_complete<> { };  template <class _Hp, class _T0, class ..._Tp> struct __check_complete<_Hp, _T0, _Tp...>     : private __check_complete<_Hp>,       private __check_complete<_T0, _Tp...> { };  template <class _Hp> struct __check_complete<_Hp, _Hp>     : private __check_complete<_Hp> { };  template <class _Tp> struct __check_complete<_Tp> {     static_assert(sizeof(_Tp) > 0, "Type must be complete."); };  template <class _Tp> struct __check_complete<_Tp&>     : private __check_complete<_Tp> { };  template <class _Tp> struct __check_complete<_Tp&&>     : private __check_complete<_Tp> { };  template <class _Rp, class ..._Param> struct __check_complete<_Rp (*)(_Param...)>     : private __check_complete<_Rp> { };  template <class ..._Param> struct __check_complete<void (*)(_Param...)> { };  template <class _Rp, class ..._Param> struct __check_complete<_Rp (_Param...)>     : private __check_complete<_Rp> { };  template <class ..._Param> struct __check_complete<void (_Param...)> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...)>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) const>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) volatile>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) &>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) const&>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) &&>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) const&&>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>     : private __check_complete<_Class> { };  template <class _Rp, class _Class, class ..._Param> struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>     : private __check_complete<_Class> { };  template <class _Rp, class _Class> struct __check_complete<_Rp _Class::*>     : private __check_complete<_Class> { };   template <class _Fp, class _A0,          class _DecayFp = typename decay<_Fp>::type,          class _DecayA0 = typename decay<_A0>::type,          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type> using __enable_if_bullet1 = typename enable_if     <         is_member_function_pointer<_DecayFp>::value         && is_base_of<_ClassT, _DecayA0>::value     >::type;  template <class _Fp, class _A0,          class _DecayFp = typename decay<_Fp>::type,          class _DecayA0 = typename decay<_A0>::type> using __enable_if_bullet2 = typename enable_if     <         is_member_function_pointer<_DecayFp>::value         && __is_reference_wrapper<_DecayA0>::value     >::type;  template <class _Fp, class _A0,          class _DecayFp = typename decay<_Fp>::type,          class _DecayA0 = typename decay<_A0>::type,          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type> using __enable_if_bullet3 = typename enable_if     <         is_member_function_pointer<_DecayFp>::value         && !is_base_of<_ClassT, _DecayA0>::value         && !__is_reference_wrapper<_DecayA0>::value     >::type;  template <class _Fp, class _A0,          class _DecayFp = typename decay<_Fp>::type,          class _DecayA0 = typename decay<_A0>::type,          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type> using __enable_if_bullet4 = typename enable_if     <         is_member_object_pointer<_DecayFp>::value         && is_base_of<_ClassT, _DecayA0>::value     >::type;  template <class _Fp, class _A0,          class _DecayFp = typename decay<_Fp>::type,          class _DecayA0 = typename decay<_A0>::type> using __enable_if_bullet5 = typename enable_if     <         is_member_object_pointer<_DecayFp>::value         && __is_reference_wrapper<_DecayA0>::value     >::type;  template <class _Fp, class _A0,          class _DecayFp = typename decay<_Fp>::type,          class _DecayA0 = typename decay<_A0>::type,          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type> using __enable_if_bullet6 = typename enable_if     <         is_member_object_pointer<_DecayFp>::value         && !is_base_of<_ClassT, _DecayA0>::value         && !__is_reference_wrapper<_DecayA0>::value     >::type;  // __invoke forward declarations
 // fall back - none of the bullets
   
#define _LIBCPP_INVOKE_RETURN(...) \
    noexcept(noexcept(__VA_ARGS__)) -> decltype(__VA_ARGS__) \
    { return __VA_ARGS__; }
 template <class ..._Args> auto __invoke(__any, _Args&& ...__args) -> __nat;  template <class ..._Args> auto __invoke_constexpr(__any, _Args&& ...__args) -> __nat;  // bullets 1, 2 and 3
 template <class _Fp, class _A0, class ..._Args,           class = __enable_if_bullet1<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY auto __invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args) _LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))  template <class _Fp, class _A0, class ..._Args,           class = __enable_if_bullet1<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR auto __invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args) _LIBCPP_INVOKE_RETURN((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))  template <class _Fp, class _A0, class ..._Args,           class = __enable_if_bullet2<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY auto __invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args) _LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))  template <class _Fp, class _A0, class ..._Args,           class = __enable_if_bullet2<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR auto __invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args) _LIBCPP_INVOKE_RETURN((__a0.get().*__f)(_VSTD::forward<_Args>(__args)...))  template <class _Fp, class _A0, class ..._Args,           class = __enable_if_bullet3<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY auto __invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args) _LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))  template <class _Fp, class _A0, class ..._Args,           class = __enable_if_bullet3<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR auto __invoke_constexpr(_Fp&& __f, _A0&& __a0, _Args&& ...__args) _LIBCPP_INVOKE_RETURN(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))  // bullets 4, 5 and 6
 template <class _Fp, class _A0,           class = __enable_if_bullet4<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY auto __invoke(_Fp&& __f, _A0&& __a0) _LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)  template <class _Fp, class _A0,           class = __enable_if_bullet4<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR auto __invoke_constexpr(_Fp&& __f, _A0&& __a0) _LIBCPP_INVOKE_RETURN(_VSTD::forward<_A0>(__a0).*__f)  template <class _Fp, class _A0,           class = __enable_if_bullet5<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY auto __invoke(_Fp&& __f, _A0&& __a0) _LIBCPP_INVOKE_RETURN(__a0.get().*__f)  template <class _Fp, class _A0,           class = __enable_if_bullet5<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR auto __invoke_constexpr(_Fp&& __f, _A0&& __a0) _LIBCPP_INVOKE_RETURN(__a0.get().*__f)  template <class _Fp, class _A0,           class = __enable_if_bullet6<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY auto __invoke(_Fp&& __f, _A0&& __a0) _LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)  template <class _Fp, class _A0,           class = __enable_if_bullet6<_Fp, _A0>> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR auto __invoke_constexpr(_Fp&& __f, _A0&& __a0) _LIBCPP_INVOKE_RETURN((*_VSTD::forward<_A0>(__a0)).*__f)  // bullet 7
 template <class _Fp, class ..._Args> inline _LIBCPP_INLINE_VISIBILITY auto __invoke(_Fp&& __f, _Args&& ...__args) _LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))  template <class _Fp, class ..._Args> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR auto __invoke_constexpr(_Fp&& __f, _Args&& ...__args) _LIBCPP_INVOKE_RETURN(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))    
#undef _LIBCPP_INVOKE_RETURN
 // __invokable
 template <class _Ret, class _Fp, class ..._Args> struct __invokable_r     : private __check_complete<_Fp> {     using _Result = decltype(         _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...));      static const bool value =         conditional<             !is_same<_Result, __nat>::value,             typename conditional<                 is_void<_Ret>::value,                 true_type,                 is_convertible<_Result, _Ret>             >::type,             false_type         >::type::value; };  template <class _Fp, class ..._Args> using __invokable = __invokable_r<void, _Fp, _Args...>;  template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args> struct __nothrow_invokable_r_imp {   static const bool value = false; };  template <class _Ret, class _Fp, class ..._Args> struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...> {     typedef __nothrow_invokable_r_imp _ThisT;      template <class _Tp>     static void __test_noexcept(_Tp) noexcept;      static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(         _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...))); };  template <class _Ret, class _Fp, class ..._Args> struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...> {     static const bool value = noexcept(         _VSTD::__invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)); };  template <class _Ret, class _Fp, class ..._Args> using __nothrow_invokable_r =     __nothrow_invokable_r_imp<             __invokable_r<_Ret, _Fp, _Args...>::value,             is_void<_Ret>::value,             _Ret, _Fp, _Args...     >;  template <class _Fp, class ..._Args> struct __invoke_of     : public enable_if<         __invokable<_Fp, _Args...>::value,         typename __invokable_r<void, _Fp, _Args...>::_Result> { };  // result_of
 template <class _Fp, class ..._Args> class _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>     : public __invoke_of<_Fp, _Args...> { };    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using result_of_t = typename result_of<_Tp>::type;   
#endif
   
#if _LIBCPP_STD_VER > 14
 // is_callable
 template <class _Fn, class _Ret = void> struct _LIBCPP_TEMPLATE_VIS is_callable;  template <class _Fn, class ..._Args, class _Ret> struct _LIBCPP_TEMPLATE_VIS is_callable<_Fn(_Args...), _Ret>     : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};  template <class _Fn, class _Ret = void> constexpr bool is_callable_v = is_callable<_Fn, _Ret>::value;  // is_nothrow_callable
 template <class _Fn, class _Ret = void> struct _LIBCPP_TEMPLATE_VIS is_nothrow_callable;  template <class _Fn, class ..._Args, class _Ret> struct _LIBCPP_TEMPLATE_VIS is_nothrow_callable<_Fn(_Args...), _Ret>     : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};  template <class _Fn, class _Ret = void> constexpr bool is_nothrow_callable_v = is_nothrow_callable<_Fn, _Ret>::value;    
#endif // _LIBCPP_STD_VER > 14
   
#endif  // !defined(_LIBCPP_CXX03_LANG)
 template <class _Tp> struct __is_swappable; template <class _Tp> struct __is_nothrow_swappable;  template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY   
#ifndef _LIBCPP_CXX03_LANG
typename enable_if <     is_move_constructible<_Tp>::value &&     is_move_assignable<_Tp>::value >::type   
#else
void   
#endif
swap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&                                     is_nothrow_move_assignable<_Tp>::value) {     _Tp __t(_VSTD::move(__x));     __x = _VSTD::move(__y);     __y = _VSTD::move(__t); }  template<class _Tp, size_t _Np> inline _LIBCPP_INLINE_VISIBILITY typename enable_if<     __is_swappable<_Tp>::value >::type swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);  template <class _ForwardIterator1, class _ForwardIterator2> inline _LIBCPP_INLINE_VISIBILITY void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)     //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),                                           *_VSTD::declval<_ForwardIterator2>()))) {     swap(*__a, *__b); }  // __swappable
 namespace __detail { // ALL generic swap overloads MUST already have a declaration available at this point.
 template <class _Tp, class _Up = _Tp,           bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value> struct __swappable_with {     template <class _LHS, class _RHS>     static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))     __test_swap(int);     template <class, class>     static __nat __test_swap(long);      // Extra parens are needed for the C++03 definition of decltype.
    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;     typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;      static const bool value = !is_same<__swap1, __nat>::value                            && !is_same<__swap2, __nat>::value; };  template <class _Tp, class _Up> struct __swappable_with<_Tp, _Up,  false> : false_type {};  template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value> struct __nothrow_swappable_with {   static const bool value =   
#ifndef _LIBCPP_HAS_NO_NOEXCEPT
      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))   &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));   
#else
      false;   
#endif
};  template <class _Tp, class _Up> struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};  }  // __detail
 template <class _Tp> struct __is_swappable     : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value> { };  template <class _Tp> struct __is_nothrow_swappable     : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value> { };    
#if _LIBCPP_STD_VER > 14
 template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_swappable_with     : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_swappable     : public conditional<         __is_referenceable<_Tp>::value,         is_swappable_with<             typename add_lvalue_reference<_Tp>::type,             typename add_lvalue_reference<_Tp>::type>,         false_type     >::type { };  template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with     : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value> { };  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable     : public conditional<         __is_referenceable<_Tp>::value,         is_nothrow_swappable_with<             typename add_lvalue_reference<_Tp>::type,             typename add_lvalue_reference<_Tp>::type>,         false_type     >::type { };  template <class _Tp, class _Up> constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;  template <class _Tp> constexpr bool is_swappable_v = is_swappable<_Tp>::value;  template <class _Tp, class _Up> constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;  template <class _Tp> constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;    
#endif // _LIBCPP_STD_VER > 14
   
#ifdef _LIBCPP_UNDERLYING_TYPE
 template <class _Tp> struct underlying_type {     typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type; };    
#if _LIBCPP_STD_VER > 11
template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;   
#endif
#define __cpp_lib_void_t 201411
template <class...> using void_t = void;    
# ifndef _LIBCPP_HAS_NO_VARIADICS
template <class... _Args> struct conjunction : __and_<_Args...> {}; template<class... _Args> constexpr bool conjunction_v = conjunction<_Args...>::value;  template <class... _Args> struct disjunction : __or_<_Args...> {}; template<class... _Args> constexpr bool disjunction_v = disjunction<_Args...>::value;  template <class _Tp> struct negation : __not_<_Tp> {}; template<class _Tp> constexpr bool negation_v = negation<_Tp>::value;   
# endif // _LIBCPP_HAS_NO_VARIADICS
  
#endif  // _LIBCPP_STD_VER > 14
 // These traits are used in __tree and __hash_table
  
#ifndef _LIBCPP_CXX03_LANG
struct __extract_key_fail_tag {}; struct __extract_key_self_tag {}; struct __extract_key_first_tag {};  template <class _ValTy, class _Key,           class _RawValTy = typename __unconstref<_ValTy>::type> struct __can_extract_key     : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,                   __extract_key_fail_tag>::type {};  template <class _Pair, class _Key, class _First, class _Second> struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>     : conditional<is_same<typename remove_const<_First>::type, _Key>::value,                   __extract_key_first_tag, __extract_key_fail_tag>::type {};  // __can_extract_map_key uses true_type/false_type instead of the tags.
// It returns true if _Key != _ContainerValueTy (the container is a map not a set)
// and _ValTy == _Key.
template <class _ValTy, class _Key, class _ContainerValueTy,           class _RawValTy = typename __unconstref<_ValTy>::type> struct __can_extract_map_key     : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};  // This specialization returns __extract_key_fail_tag for non-map containers
// because _Key == _ContainerValueTy
template <class _ValTy, class _Key, class _RawValTy> struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>     : false_type {};    
#endif
 _LIBCPP_END_NAMESPACE_STD    
#if _LIBCPP_STD_VER > 14
// std::byte
namespace std  // purposefully not versioned
{ template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &   operator<<=(byte& __lhs, _Integer __shift) noexcept   { return __lhs = byte(static_cast<unsigned char>(__lhs) << __shift); }    template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type   operator<< (byte  __lhs, _Integer __shift) noexcept   { return         byte(static_cast<unsigned char>(__lhs) << __shift); }  template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &   operator>>=(byte& __lhs, _Integer __shift) noexcept   { return __lhs = byte(static_cast<unsigned char>(__lhs) >> __shift); }  template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type   operator>> (byte  __lhs, _Integer __shift) noexcept   { return         byte(static_cast<unsigned char>(__lhs) >> __shift); }    template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type   to_integer(byte __b) noexcept { return _Integer(__b); }  }   
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <limits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.limits
// -*- C++ -*-
//===---------------------------- limits ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_LIMITS
  
#define _LIBCPP_LIMITS
 /*     limits synopsis  namespace std {  template<class T> class numeric_limits { public:     static constexpr bool is_specialized = false;     static constexpr T min() noexcept;     static constexpr T max() noexcept;     static constexpr T lowest() noexcept;      static constexpr int  digits = 0;     static constexpr int  digits10 = 0;     static constexpr int  max_digits10 = 0;     static constexpr bool is_signed = false;     static constexpr bool is_integer = false;     static constexpr bool is_exact = false;     static constexpr int  radix = 0;     static constexpr T epsilon() noexcept;     static constexpr T round_error() noexcept;      static constexpr int  min_exponent = 0;     static constexpr int  min_exponent10 = 0;     static constexpr int  max_exponent = 0;     static constexpr int  max_exponent10 = 0;      static constexpr bool has_infinity = false;     static constexpr bool has_quiet_NaN = false;     static constexpr bool has_signaling_NaN = false;     static constexpr float_denorm_style has_denorm = denorm_absent;     static constexpr bool has_denorm_loss = false;     static constexpr T infinity() noexcept;     static constexpr T quiet_NaN() noexcept;     static constexpr T signaling_NaN() noexcept;     static constexpr T denorm_min() noexcept;      static constexpr bool is_iec559 = false;     static constexpr bool is_bounded = false;     static constexpr bool is_modulo = false;      static constexpr bool traps = false;     static constexpr bool tinyness_before = false;     static constexpr float_round_style round_style = round_toward_zero; };  enum float_round_style {     round_indeterminate       = -1,     round_toward_zero         =  0,     round_to_nearest          =  1,     round_toward_infinity     =  2,     round_toward_neg_infinity =  3 };  enum float_denorm_style {     denorm_indeterminate = -1,     denorm_absent = 0,     denorm_present = 1 };  template<> class numeric_limits<cv bool>;  template<> class numeric_limits<cv char>; template<> class numeric_limits<cv signed char>; template<> class numeric_limits<cv unsigned char>; template<> class numeric_limits<cv wchar_t>; template<> class numeric_limits<cv char16_t>; template<> class numeric_limits<cv char32_t>;  template<> class numeric_limits<cv short>; template<> class numeric_limits<cv int>; template<> class numeric_limits<cv long>; template<> class numeric_limits<cv long long>; template<> class numeric_limits<cv unsigned short>; template<> class numeric_limits<cv unsigned int>; template<> class numeric_limits<cv unsigned long>; template<> class numeric_limits<cv unsigned long long>;  template<> class numeric_limits<cv float>; template<> class numeric_limits<cv double>; template<> class numeric_limits<cv long double>;  }  // std
 */
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TYPE_TRAITS
  
      template<class... B> struct conjunction;                           // C++17
      template<class... B>          constexpr bool conjunction_v = conjunction<B...>::value;         // C++17
      template<class... B> struct disjunction;                           // C++17
      template<class... B>         constexpr bool disjunction_v = disjunction<B...>::value;         // C++17
      template<class B> struct negation;                                 // C++17
      template<class B>          constexpr bool negation_v = negation<B>::value;                  // C++17
 }  */
#if 0 /* expanded by -frewrite-includes */
                                     typename add_lvalue_reference<_Tp>::type>   
#endif
    {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v     = is_trivially_move_assignable<_Tp>::value;   
#endif
 // is_trivially_destructible
   
#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible     : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};    
#else
 template <class _Tp> struct __libcpp_trivial_destructor     : public integral_constant<bool, is_scalar<_Tp>::value ||                                      is_reference<_Tp>::value> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible     : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible<_Tp[]>     : public false_type {};    
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_destructible_v     = is_trivially_destructible<_Tp>::value;   
#endif
 // is_nothrow_constructible
   
#if 0
template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible     : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))> { };    
#else
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
   
#endif  // __has_feature(cxx_noexcept)
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp, class _Arg> _LIBCPP_CONSTEXPR bool is_nothrow_assignable_v     = is_nothrow_assignable<_Tp, _Arg>::value;   
#endif
 // is_nothrow_copy_assignable
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable     : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,                   typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v     = is_nothrow_copy_assignable<_Tp>::value;   
#endif
 // is_nothrow_move_assignable
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable     : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
#else
 template <class _Tp> struct __libcpp_nothrow_destructor     : public integral_constant<bool, is_scalar<_Tp>::value ||                                      is_reference<_Tp>::value> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible     : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};  template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>     : public false_type {};    
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_destructible_v     = is_nothrow_destructible<_Tp>::value;   
#endif
               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),                                           *_VSTD::declval<_ForwardIterator2>()))) {     swap(*__a, *__b); }  // __swappable
 namespace __detail { // ALL generic swap overloads MUST already have a declaration available at this point.
 template <class _Tp, class _Up = _Tp,           bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value> struct __swappable_with {     template <class _LHS, class _RHS>     static decltype(swap(_VSTD::declval<_LHS>(), _VSTD::declval<_RHS>()))     __test_swap(int);     template <class, class>     static __nat __test_swap(long);      // Extra parens are needed for the C++03 definition of decltype.
    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;     typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;      static const bool value = !is_same<__swap1, __nat>::value                            && !is_same<__swap2, __nat>::value; };  template <class _Tp, class _Up> struct __swappable_with<_Tp, _Up,  false> : false_type {};  template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value> struct __nothrow_swappable_with {   static const bool value =   
#ifndef _LIBCPP_HAS_NO_NOEXCEPT
      noexcept(swap(_VSTD::declval<_Tp>(), _VSTD::declval<_Up>()))   &&  noexcept(swap(_VSTD::declval<_Up>(), _VSTD::declval<_Tp>()));   
#else
      false;   
// std::byte
namespace std  // purposefully not versioned
{ template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &   operator<<=(byte& __lhs, _Integer __shift) noexcept   { return __lhs = byte(static_cast<unsigned char>(__lhs) << __shift); }    template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type   operator<< (byte  __lhs, _Integer __shift) noexcept   { return         byte(static_cast<unsigned char>(__lhs) << __shift); }  template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type &   operator>>=(byte& __lhs, _Integer __shift) noexcept   { return __lhs = byte(static_cast<unsigned char>(__lhs) >> __shift); }  template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, byte>::type   operator>> (byte  __lhs, _Integer __shift) noexcept   { return         byte(static_cast<unsigned char>(__lhs) >> __shift); }    template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type   to_integer(byte __b) noexcept { return _Integer(__b); }  }   
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
   
#if defined(_LIBCPP_COMPILER_MSVC)
  
#if 0 /* expanded by -frewrite-includes */
  
#include "support/win32/limits_msvc_win32.h"
  
  
#include "support/ibm/limits.h"
  
#endif /* expanded by -frewrite-includes */
  
#endif // __IBMCPP__
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max")   
#else
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  enum float_round_style {     round_indeterminate       = -1,     round_toward_zero         =  0,     round_to_nearest          =  1,     round_toward_infinity     =  2,     round_toward_neg_infinity =  3 };  enum float_denorm_style {     denorm_indeterminate = -1,     denorm_absent = 0,     denorm_present = 1 };  template <class _Tp, bool = is_arithmetic<_Tp>::value> class __libcpp_numeric_limits { protected:     typedef _Tp type;      static _LIBCPP_CONSTEXPR const  bool is_specialized = false;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return type();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return type();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return type();}      static _LIBCPP_CONSTEXPR const int  digits = 0;     static _LIBCPP_CONSTEXPR const int  digits10 = 0;     static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;     static _LIBCPP_CONSTEXPR const bool is_signed = false;     static _LIBCPP_CONSTEXPR const bool is_integer = false;     static _LIBCPP_CONSTEXPR const bool is_exact = false;     static _LIBCPP_CONSTEXPR const int  radix = 0;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type();}      static _LIBCPP_CONSTEXPR const int  min_exponent = 0;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;     static _LIBCPP_CONSTEXPR const int  max_exponent = 0;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;      static _LIBCPP_CONSTEXPR const bool has_infinity = false;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type();}      static _LIBCPP_CONSTEXPR const bool is_iec559 = false;     static _LIBCPP_CONSTEXPR const bool is_bounded = false;     static _LIBCPP_CONSTEXPR const bool is_modulo = false;      static _LIBCPP_CONSTEXPR const bool traps = false;     static _LIBCPP_CONSTEXPR const bool tinyness_before = false;     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero; };  template <class _Tp, int __digits, bool _IsSigned> struct __libcpp_compute_min {     static _LIBCPP_CONSTEXPR const _Tp value = _Tp(_Tp(1) << __digits); };  template <class _Tp, int __digits> struct __libcpp_compute_min<_Tp, __digits, false> {     static _LIBCPP_CONSTEXPR const _Tp value = _Tp(0); };  template <class _Tp> class __libcpp_numeric_limits<_Tp, true> { protected:     typedef _Tp type;      static _LIBCPP_CONSTEXPR const bool is_specialized = true;      static _LIBCPP_CONSTEXPR const bool is_signed = type(-1) < type(0);     static _LIBCPP_CONSTEXPR const int  digits = static_cast<int>(sizeof(type) * __CHAR_BIT__ - is_signed);     static _LIBCPP_CONSTEXPR const int  digits10 = digits * 3 / 10;     static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;     static _LIBCPP_CONSTEXPR const type __min = __libcpp_compute_min<type, digits, is_signed>::value;     static _LIBCPP_CONSTEXPR const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}      static _LIBCPP_CONSTEXPR const bool is_integer = true;     static _LIBCPP_CONSTEXPR const bool is_exact = true;     static _LIBCPP_CONSTEXPR const int  radix = 2;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}      static _LIBCPP_CONSTEXPR const int  min_exponent = 0;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;     static _LIBCPP_CONSTEXPR const int  max_exponent = 0;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;      static _LIBCPP_CONSTEXPR const bool has_infinity = false;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}      static _LIBCPP_CONSTEXPR const bool is_iec559 = false;     static _LIBCPP_CONSTEXPR const bool is_bounded = true;     static _LIBCPP_CONSTEXPR const bool is_modulo = !_VSTD::is_signed<_Tp>::value;    
#if defined(__i386__) || defined(__x86_64__) || defined(__pnacl__) || \
    defined(__wasm__)
    static _LIBCPP_CONSTEXPR const bool traps = true;   
#else
    static _LIBCPP_CONSTEXPR const bool traps = false;   
#endif
    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero; };  template <> class __libcpp_numeric_limits<bool, true> { protected:     typedef bool type;      static _LIBCPP_CONSTEXPR const bool is_specialized = true;      static _LIBCPP_CONSTEXPR const bool is_signed = false;     static _LIBCPP_CONSTEXPR const int  digits = 1;     static _LIBCPP_CONSTEXPR const int  digits10 = 0;     static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;     static _LIBCPP_CONSTEXPR const type __min = false;     static _LIBCPP_CONSTEXPR const type __max = true;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}      static _LIBCPP_CONSTEXPR const bool is_integer = true;     static _LIBCPP_CONSTEXPR const bool is_exact = true;     static _LIBCPP_CONSTEXPR const int  radix = 2;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}      static _LIBCPP_CONSTEXPR const int  min_exponent = 0;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;     static _LIBCPP_CONSTEXPR const int  max_exponent = 0;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;      static _LIBCPP_CONSTEXPR const bool has_infinity = false;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}      static _LIBCPP_CONSTEXPR const bool is_iec559 = false;     static _LIBCPP_CONSTEXPR const bool is_bounded = true;     static _LIBCPP_CONSTEXPR const bool is_modulo = false;      static _LIBCPP_CONSTEXPR const bool traps = false;     static _LIBCPP_CONSTEXPR const bool tinyness_before = false;     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero; };  template <> class __libcpp_numeric_limits<float, true> { protected:     typedef float type;      static _LIBCPP_CONSTEXPR const bool is_specialized = true;      static _LIBCPP_CONSTEXPR const bool is_signed = true;     static _LIBCPP_CONSTEXPR const int  digits = __FLT_MANT_DIG__;     static _LIBCPP_CONSTEXPR const int  digits10 = __FLT_DIG__;     static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __FLT_MIN__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __FLT_MAX__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}      static _LIBCPP_CONSTEXPR const bool is_integer = false;     static _LIBCPP_CONSTEXPR const bool is_exact = false;     static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __FLT_EPSILON__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5F;}      static _LIBCPP_CONSTEXPR const int  min_exponent = __FLT_MIN_EXP__;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = __FLT_MIN_10_EXP__;     static _LIBCPP_CONSTEXPR const int  max_exponent = __FLT_MAX_EXP__;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = __FLT_MAX_10_EXP__;      static _LIBCPP_CONSTEXPR const bool has_infinity = true;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valf();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf("");}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf("");}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __FLT_DENORM_MIN__;}      static _LIBCPP_CONSTEXPR const bool is_iec559 = true;     static _LIBCPP_CONSTEXPR const bool is_bounded = true;     static _LIBCPP_CONSTEXPR const bool is_modulo = false;      static _LIBCPP_CONSTEXPR const bool traps = false;     static _LIBCPP_CONSTEXPR const bool tinyness_before = false;     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest; };  template <> class __libcpp_numeric_limits<double, true> { protected:     typedef double type;      static _LIBCPP_CONSTEXPR const bool is_specialized = true;      static _LIBCPP_CONSTEXPR const bool is_signed = true;     static _LIBCPP_CONSTEXPR const int  digits = __DBL_MANT_DIG__;     static _LIBCPP_CONSTEXPR const int  digits10 = __DBL_DIG__;     static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __DBL_MIN__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __DBL_MAX__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}      static _LIBCPP_CONSTEXPR const bool is_integer = false;     static _LIBCPP_CONSTEXPR const bool is_exact = false;     static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __DBL_EPSILON__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}      static _LIBCPP_CONSTEXPR const int  min_exponent = __DBL_MIN_EXP__;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = __DBL_MIN_10_EXP__;     static _LIBCPP_CONSTEXPR const int  max_exponent = __DBL_MAX_EXP__;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = __DBL_MAX_10_EXP__;      static _LIBCPP_CONSTEXPR const bool has_infinity = true;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_val();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan("");}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans("");}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __DBL_DENORM_MIN__;}      static _LIBCPP_CONSTEXPR const bool is_iec559 = true;     static _LIBCPP_CONSTEXPR const bool is_bounded = true;     static _LIBCPP_CONSTEXPR const bool is_modulo = false;      static _LIBCPP_CONSTEXPR const bool traps = false;     static _LIBCPP_CONSTEXPR const bool tinyness_before = false;     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest; };  template <> class __libcpp_numeric_limits<long double, true> { protected:     typedef long double type;      static _LIBCPP_CONSTEXPR const bool is_specialized = true;      static _LIBCPP_CONSTEXPR const bool is_signed = true;     static _LIBCPP_CONSTEXPR const int  digits = __LDBL_MANT_DIG__;     static _LIBCPP_CONSTEXPR const int  digits10 = __LDBL_DIG__;     static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103l)/100000l;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __LDBL_MIN__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __LDBL_MAX__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}      static _LIBCPP_CONSTEXPR const bool is_integer = false;     static _LIBCPP_CONSTEXPR const bool is_exact = false;     static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __LDBL_EPSILON__;}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}      static _LIBCPP_CONSTEXPR const int  min_exponent = __LDBL_MIN_EXP__;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = __LDBL_MIN_10_EXP__;     static _LIBCPP_CONSTEXPR const int  max_exponent = __LDBL_MAX_EXP__;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = __LDBL_MAX_10_EXP__;      static _LIBCPP_CONSTEXPR const bool has_infinity = true;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_vall();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl("");}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl("");}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __LDBL_DENORM_MIN__;}    
#if (defined(__ppc__) || defined(__ppc64__))
    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;   
#else
    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;   
#endif
    static _LIBCPP_CONSTEXPR const bool is_bounded = true;     static _LIBCPP_CONSTEXPR const bool is_modulo = false;      static _LIBCPP_CONSTEXPR const bool traps = false;     static _LIBCPP_CONSTEXPR const bool tinyness_before = false;     static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest; };  template <class _Tp> class _LIBCPP_TEMPLATE_VIS numeric_limits     : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type> {     typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;     typedef typename __base::type type; public:     static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}      static _LIBCPP_CONSTEXPR const int  digits = __base::digits;     static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;     static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;     static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;     static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;     static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;     static _LIBCPP_CONSTEXPR const int  radix = __base::radix;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}      static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;     static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;      static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}      static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;     static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;     static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;      static _LIBCPP_CONSTEXPR const bool traps = __base::traps;     static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style; };  template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_specialized; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits10; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_digits10; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_signed; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_integer; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_exact; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::radix; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent10; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent10; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_infinity; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_quiet_NaN; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_signaling_NaN; template <class _Tp>     _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<_Tp>::has_denorm; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_denorm_loss; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_iec559; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_bounded; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_modulo; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::traps; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::tinyness_before; template <class _Tp>     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<_Tp>::round_style;  template <class _Tp> class _LIBCPP_TEMPLATE_VIS numeric_limits<const _Tp>     : private numeric_limits<_Tp> {     typedef numeric_limits<_Tp> __base;     typedef _Tp type; public:     static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}      static _LIBCPP_CONSTEXPR const int  digits = __base::digits;     static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;     static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;     static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;     static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;     static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;     static _LIBCPP_CONSTEXPR const int  radix = __base::radix;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}      static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;     static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;      static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}      static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;     static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;     static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;      static _LIBCPP_CONSTEXPR const bool traps = __base::traps;     static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style; };  template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_specialized; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits10; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_digits10; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_signed; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_integer; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_exact; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::radix; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent10; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent10; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_infinity; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_quiet_NaN; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_signaling_NaN; template <class _Tp>     _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const _Tp>::has_denorm; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_denorm_loss; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_iec559; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_bounded; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_modulo; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::traps; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::tinyness_before; template <class _Tp>     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const _Tp>::round_style;  template <class _Tp> class _LIBCPP_TEMPLATE_VIS numeric_limits<volatile _Tp>     : private numeric_limits<_Tp> {     typedef numeric_limits<_Tp> __base;     typedef _Tp type; public:     static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}      static _LIBCPP_CONSTEXPR const int  digits = __base::digits;     static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;     static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;     static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;     static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;     static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;     static _LIBCPP_CONSTEXPR const int  radix = __base::radix;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}      static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;     static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;      static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}      static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;     static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;     static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;      static _LIBCPP_CONSTEXPR const bool traps = __base::traps;     static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style; };  template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_specialized; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits10; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_digits10; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_signed; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_integer; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_exact; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::radix; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent10; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent10; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_infinity; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_quiet_NaN; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_signaling_NaN; template <class _Tp>     _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<volatile _Tp>::has_denorm; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_denorm_loss; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_iec559; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_bounded; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_modulo; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::traps; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::tinyness_before; template <class _Tp>     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<volatile _Tp>::round_style;  template <class _Tp> class _LIBCPP_TEMPLATE_VIS numeric_limits<const volatile _Tp>     : private numeric_limits<_Tp> {     typedef numeric_limits<_Tp> __base;     typedef _Tp type; public:     static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}      static _LIBCPP_CONSTEXPR const int  digits = __base::digits;     static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;     static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;     static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;     static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;     static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;     static _LIBCPP_CONSTEXPR const int  radix = __base::radix;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}      static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;     static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;     static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;     static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;      static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;     static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;     static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;     static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;     static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}      static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;     static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;     static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;      static _LIBCPP_CONSTEXPR const bool traps = __base::traps;     static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;     static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style; };  template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_specialized; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits10; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_digits10; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_signed; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_integer; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_exact; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::radix; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent10; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent; template <class _Tp>     _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent10; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_infinity; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_quiet_NaN; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_signaling_NaN; template <class _Tp>     _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_denorm_loss; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_iec559; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_bounded; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_modulo; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::traps; template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before; template <class _Tp>     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;  _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_LIMITS
  
#pragma clang module end /*std.limits*/
 // signbit
   
#ifdef signbit
 template <class _A1> _LIBCPP_ALWAYS_INLINE bool __libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT {     return signbit(__lcpp_x); }    
#undef signbit
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type signbit(_A1 __lcpp_x) _NOEXCEPT {     return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x); }  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<     std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type signbit(_A1 __lcpp_x) _NOEXCEPT { return __lcpp_x < 0; }  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<     std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type signbit(_A1) _NOEXCEPT { return false; }    
#elif defined(_LIBCPP_MSVCRT)
 template <typename _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type signbit(_A1 __lcpp_x) _NOEXCEPT {   return ::signbit(static_cast<typename std::__promote<_A1>::type>(__lcpp_x)); }  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<     std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type signbit(_A1 __lcpp_x) _NOEXCEPT { return __lcpp_x < 0; }  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<     std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type signbit(_A1) _NOEXCEPT { return false; }    
#endif  // signbit
 // fpclassify
   
#ifdef fpclassify
 template <class _A1> _LIBCPP_ALWAYS_INLINE int __libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT {     return fpclassify(__lcpp_x); }    
#undef fpclassify
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_floating_point<_A1>::value, int>::type fpclassify(_A1 __lcpp_x) _NOEXCEPT {     return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x); }  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, int>::type fpclassify(_A1 __lcpp_x) _NOEXCEPT { return __lcpp_x == 0 ? FP_ZERO : FP_NORMAL; }    
#elif defined(_LIBCPP_MSVCRT)
 template <typename _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type fpclassify(_A1 __lcpp_x) _NOEXCEPT {   return ::fpclassify(static_cast<typename std::__promote<_A1>::type>(__lcpp_x)); }  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, int>::type fpclassify(_A1 __lcpp_x) _NOEXCEPT { return __lcpp_x == 0 ? FP_ZERO : FP_NORMAL; }    
#endif  // fpclassify
 // isfinite
   
#ifdef isfinite
 template <class _A1> _LIBCPP_ALWAYS_INLINE bool __libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT {     return isfinite(__lcpp_x); }    
#undef isfinite
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<     std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity,     bool>::type isfinite(_A1 __lcpp_x) _NOEXCEPT {     return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x); }  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<     std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity,     bool>::type isfinite(_A1) _NOEXCEPT { return true; }    
#endif  // isfinite
 // isinf
   
#ifdef isinf
#endif  // isless
 // islessequal
   
#ifdef islessequal
 template <class _A1, class _A2> _LIBCPP_ALWAYS_INLINE bool __libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT {     return islessequal(__lcpp_x, __lcpp_y); }    
#undef islessequal
 template <class _A1, class _A2> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if <     std::is_arithmetic<_A1>::value &&     std::is_arithmetic<_A2>::value,     bool >::type islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT {     typedef typename std::__promote<_A1, _A2>::type type;     return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y); }    
#endif  // islessequal
   
#if !(defined(_AIX) || defined(__sun__))
inline _LIBCPP_INLINE_VISIBILITY float abs(float __lcpp_x) _NOEXCEPT {return ::fabsf(__lcpp_x);}  inline _LIBCPP_INLINE_VISIBILITY double abs(double __lcpp_x) _NOEXCEPT {return ::fabs(__lcpp_x);}  inline _LIBCPP_INLINE_VISIBILITY long double abs(long double __lcpp_x) _NOEXCEPT {return ::fabsl(__lcpp_x);}   
#endif // !(defined(_AIX) || defined(__sun__))
 // acos
   
#if !(defined(_AIX) || defined(__sun__))
inline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return ::acosf(__lcpp_x);} inline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return ::acosl(__lcpp_x);}   
#endif
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type acos(_A1 __lcpp_x) _NOEXCEPT {return ::acos((double)__lcpp_x);}  // asin
   
#if !(defined(_AIX) || defined(__sun__))
inline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return ::asinf(__lcpp_x);} inline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return ::asinl(__lcpp_x);}   
#endif
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type asin(_A1 __lcpp_x) _NOEXCEPT {return ::asin((double)__lcpp_x);}  // atan
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type sinh(_A1 __lcpp_x) _NOEXCEPT {return ::sinh((double)__lcpp_x);}  // sqrt
   
#if !(defined(_AIX) || defined(__sun__))
inline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return ::sqrtf(__lcpp_x);} inline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return ::sqrtl(__lcpp_x);}   
#endif
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type sqrt(_A1 __lcpp_x) _NOEXCEPT {return ::sqrt((double)__lcpp_x);}  // tan
   
#if !(defined(_AIX) || defined(__sun__))
inline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return ::tanf(__lcpp_x);} inline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return ::tanl(__lcpp_x);}   
#endif
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type tan(_A1 __lcpp_x) _NOEXCEPT {return ::tan((double)__lcpp_x);}  // tanh
   
#if !(defined(_AIX) || defined(__sun__))
inline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return ::tanhf(__lcpp_x);} inline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return ::tanhl(__lcpp_x);}   
#endif
 inline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return ::roundf(__lcpp_x);} inline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return ::roundl(__lcpp_x);}  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type round(_A1 __lcpp_x) _NOEXCEPT {return ::round((double)__lcpp_x);}  // scalbln
 inline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return ::scalblnf(__lcpp_x, __lcpp_y);} inline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return ::scalblnl(__lcpp_x, __lcpp_y);}  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type scalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return ::scalbln((double)__lcpp_x, __lcpp_y);}  // scalbn
 inline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return ::scalbnf(__lcpp_x, __lcpp_y);} inline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return ::scalbnl(__lcpp_x, __lcpp_y);}  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type scalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return ::scalbn((double)__lcpp_x, __lcpp_y);}  // tgamma
 inline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return ::tgammaf(__lcpp_x);} inline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return ::tgammal(__lcpp_x);}  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type tgamma(_A1 __lcpp_x) _NOEXCEPT {return ::tgamma((double)__lcpp_x);}  // trunc
 inline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return ::truncf(__lcpp_x);} inline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return ::truncl(__lcpp_x);}  template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type trunc(_A1 __lcpp_x) _NOEXCEPT {return ::trunc((double)__lcpp_x);}  }
   // extern "C++"
   
#endif // __cplusplus
   
#endif  // _LIBCPP_MATH_H
  
#pragma clang module end /*std.depr.math_h*/
}
   extern "C" {
     
#if 0 /* expanded by -frewrite-includes */
  
#include "setjmp.h"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.depr.setjmp_h
// -*- C++ -*-
//===--------------------------- setjmp.h ---------------------------------===//
   
#ifndef _LIBCPP_SETJMP_H
  
#define _LIBCPP_SETJMP_H
 /*     setjmp.h synopsis  Macros:      setjmp  Types:      jmp_buf  void longjmp(jmp_buf env, int val);
    */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
 __BEGIN_DECLS    
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/setjmp.h>		/* Get `__jmp_buf'.  */
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 2001-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /* Define the machine-dependent type `jmp_buf'.  x86-64 version.  */
#ifndef _BITS_SETJMP_H
#define _BITS_SETJMP_H  1

#ifdef __x86_64__
# define __WORDSIZE_TIME64_COMPAT32	1
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# define __SYSCALL_WORDSIZE		64
#endif

#ifndef _ASM

# if __WORDSIZE == 64
typedef long int __jmp_buf[8];
# elif defined  __x86_64__
__extension__ typedef long long int __jmp_buf[8];
# else
typedef int __jmp_buf[6];
# endif

#endif

#endif  /* bits/setjmp.h */
#if 0 /* expanded by -frewrite-includes */
#include <bits/sigset.h>		/* Get `__sigset_t'.  */
  
#endif /* expanded by -frewrite-includes */
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.    Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
   
#ifndef	_SIGSET_H_types
  
# define _SIGSET_H_types	1
 typedef int __sig_atomic_t;
    /* A `sigset_t' has a bit for each signal.  */

# define _SIGSET_NWORDS	(1024 / (8 * sizeof (unsigned long int)))
typedef struct
  {
    unsigned long int __val[_SIGSET_NWORDS];
  } __sigset_t;

#endif


/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But    trouble can be caused by functions being defined (e.g., any global    register vars declared later will cause compilation errors).  */
   
#if !defined _SIGSET_H_fns && defined _SIGNAL_H
  
# define _SIGSET_H_fns 1
   
# ifndef _EXTERN_INLINE
  
		    while (--__cnt >= 0) __set->__val[__cnt] = ~0UL;	      \
		    0; }))
   
#  ifdef __USE_GNU
/* The POSIX does not specify for handling the whole signal set in one    command.  This is often wanted and so we define three more functions    here.  */
  
#   define __sigisemptyset(set) \
  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
					      | __right->__val[__cnt]);	      \
		    0; }))
  
#  endif
  
# endif
 /* These functions needn't check for a bogus signal number -- error
   checking is done in the non __ versions.  */

extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);

# ifdef __USE_EXTERN_INLINES
#  define __SIGSETFN(NAME, BODY, CONST)					      \
  _EXTERN_INLINE int							      \
__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
__SIGSETFN (__sigdelset, ((__set->__val[__word] &= ~__mask), 0), )

#  undef __SIGSETFN
# endif


#endif /* ! _SIGSET_H_fns.  */


/* Calling environment, plus possibly a saved signal mask.  */
struct __jmp_buf_tag
  {
    /* NOTE: The machine-dependent definitions of `__sigsetjmp'        assume that a `jmp_buf' begins with a `__jmp_buf' and that        `__mask_was_saved' follows it.  Do not move these members
       or add others before it.  */
    __jmp_buf __jmpbuf;		/* Calling environment.  */
    int __mask_was_saved;	/* Saved the signal mask?  */
    __sigset_t __saved_mask;	/* Saved signal mask.  */
  };


__BEGIN_NAMESPACE_STD

    
#ifdef	__USE_POSIX
/* Use the same type for `jmp_buf' and `sigjmp_buf'.    The `__mask_was_saved' flag determines whether
   or not `longjmp' will restore the signal mask.  */
typedef struct __jmp_buf_tag sigjmp_buf[1];
    /* Store the calling environment in ENV, also saving the    signal mask if SAVEMASK is nonzero.  Return 0.  */
  
# define sigsetjmp(env, savemask)	__sigsetjmp (env, savemask)
 /* Jump to the environment saved in ENV, making the    sigsetjmp call there return VAL, or 1 if VAL is 0.    Restore the signal mask if that sigsetjmp call saved it.    This is just an alias `longjmp'.  */
extern void siglongjmp (sigjmp_buf __env, int __val)
     __THROWNL __attribute__ ((__noreturn__));
#endif /* Use POSIX.  */


/* Define helper functions to catch unsafe code.  */
#if __USE_FORTIFY_LEVEL > 0
#if 0 /* expanded by -frewrite-includes */
# include <bits/setjmp2.h>
#endif /* expanded by -frewrite-includes */
#endif

__END_DECLS

#endif // __cplusplus

#endif  // _LIBCPP_SETJMP_H
#pragma clang module end /*std.depr.setjmp_h*/
}
extern "C" {
#if 0 /* expanded by -frewrite-includes */
#include "/aia/r018/scratch/gonzalo/toolchain/llvm/lib/clang/6.0.0/include/stdint.h"
#endif /* expanded by -frewrite-includes */
#pragma clang module begin std.depr.stdint_h
/*===---- stdint.h - Standard header for sized integer types --------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/

#ifndef __CLANG_STDINT_H
#define __CLANG_STDINT_H

/* If we're hosted, fall back to the system's stdint.h, which might have
 * additional definitions.
 */
#if __STDC_HOSTED__ && (1)/*__has_include_next(<stdint.h>)*/

// C99 7.18.3 Limits of other integer types
//
//  Footnote 219, 220: C++ implementations should define these macros only when
# ifdef __cplusplus
#  if !defined(__STDC_LIMIT_MACROS)
#   define __STDC_LIMIT_MACROS
#   define __STDC_LIMIT_MACROS_DEFINED_BY_CLANG
#  endif
#  if !defined(__STDC_CONSTANT_MACROS)
#   define __STDC_CONSTANT_MACROS
#   define __STDC_CONSTANT_MACROS_DEFINED_BY_CLANG
#  endif
# endif

#if 0 /* expanded by -frewrite-includes */
# include_next <stdint.h>
#endif /* expanded by -frewrite-includes */


#else

/* C99 7.18.1.1 Exact-width integer types.
 * C99 7.18.1.2 Minimum-width integer types.
 * C99 7.18.1.3 Fastest minimum-width integer types.
 *

#endif
 /* 7.18.4.2 Macros for greatest-width integer constants. */

#define  INTMAX_C(v) __int_c(v,  __INTMAX_C_SUFFIX__)

#define UINTMAX_C(v) __int_c(v, __UINTMAX_C_SUFFIX__)
 
#endif /* __STDC_HOSTED__ */

#endif /* __CLANG_STDINT_H */

#pragma clang module end /*std.depr.stdint_h*/
}
 extern "C" {
 
#if 0 /* expanded by -frewrite-includes */

#include "string.h"

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.depr.string_h
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_STRING_H

#define _LIBCPP_STRING_H
 /*     string.h synopsis  Macros:      NULL  Types:      size_t  void* memcpy(void* restrict s1, const void* restrict s2, size_t n);
 void* memmove(void* s1, const void* s2, size_t n);
 char* strcpy (char* restrict s1, const char* restrict s2);
 if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard: 7.21 String handling	<string.h>  */
 
#ifndef	_STRING_H

#define	_STRING_H	1
 
#if 0 /* expanded by -frewrite-includes */

#include <features.h>

#endif /* expanded by -frewrite-includes */
 __BEGIN_DECLS  /* Get size_t and NULL from <stddef.h>.  */

#define	__need_size_t
//
//===----------------------------------------------------------------------===//
 
#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)
 
#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */

#endif
 
#if defined(__need_ptrdiff_t)

#if !defined(_PTRDIFF_T) || __has_feature(modules)
typedef __PTRDIFF_TYPE__ ptrdiff_t;
 
#endif

#undef __need_ptrdiff_t

#endif /* defined(__need_ptrdiff_t) */
 
#if defined(__need_size_t)

#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */

#if !__has_feature(modules)

#define _SIZE_T

#endif
typedef __SIZE_TYPE__ size_t;
 
#endif

#undef __need_size_t

#endif /*defined(__need_size_t) */
 
#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is  * enabled. */

#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)

#endif

#undef __need_NULL

#endif /* defined(__need_NULL) */
 
#if defined(__need_STDDEF_H_misc)

#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L

#if 0 /* expanded by -frewrite-includes */

#include "__stddef_max_align_t.h"

#endif /* expanded by -frewrite-includes */

#endif

#define offsetof(t, d) __builtin_offsetof(t, d)

#undef __need_STDDEF_H_misc

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 
#if 0 /* expanded by -frewrite-includes */

#include_next <stddef.h>

#endif /* expanded by -frewrite-includes */
 
#ifdef __cplusplus
 extern "C++" { 
#if 0 /* expanded by -frewrite-includes */

#include <__nullptr>

#endif /* expanded by -frewrite-includes */
using std::nullptr_t; }
  // Re-use the compiler's <stddef.h> max_align_t where possible.   
#if !defined(__CLANG_MAX_ALIGN_T_DEFINED) && !defined(_GCC_MAX_ALIGN_T) && \
    !defined(__DEFINED_max_align_t)
typedef long double max_align_t;
     
#endif
   
#endif
   
#endif
  __BEGIN_NAMESPACE_STD /* Copy N bytes of SRC to DEST.  */
extern void *memcpy (void *__restrict __dest, const void *__restrict __src, 		     size_t __n) __THROW __nonnull ((1, 2));
   /* Copy N bytes of SRC to DEST, guaranteeing    correct behavior for overlapping strings.  */
extern void *memmove (void *__dest, const void *__src, size_t __n)      __THROW __nonnull ((1, 2));
   __END_NAMESPACE_STD  /* Copy no more than N bytes of SRC to DEST, stopping when C is found.    Return the position in DEST one byte past where C was copied,    or NULL if C was not found in the first N bytes of SRC.  */
  
#if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN
extern void *memccpy (void *__restrict __dest, const void *__restrict __src, 		      int __c, size_t __n)      __THROW __nonnull ((1, 2));
     
#endif /* SVID.  */
  __BEGIN_NAMESPACE_STD /* Set N bytes of S to C.  */
extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1));
    /* Compare N bytes of S1 and S2.  */
extern int memcmp (const void *__s1, const void *__s2, size_t __n)      __THROW __attribute_pure__ __nonnull ((1, 2));
    /* Search N bytes of S for C.  */
  
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" { extern void *memchr (void *__s, int __c, size_t __n)       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1)); extern const void *memchr (const void *__s, int __c, size_t __n)       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));    
# ifdef __OPTIMIZE__
__extern_always_inline void * memchr (void *__s, int __c, size_t __n) __THROW {   return __builtin_memchr (__s, __c, __n); }  __extern_always_inline const void * memchr (const void *__s, int __c, size_t __n) __THROW {   return __builtin_memchr (__s, __c, __n); }   
# endif
}
     
#else
extern void *memchr (const void *__s, int __c, size_t __n)       __THROW __attribute_pure__ __nonnull ((1));
     
#endif
__END_NAMESPACE_STD    
#ifdef __USE_GNU
/* Search in S for C.  This is similar to `memchr' but there is no
     __THROW __attribute_pure__ __nonnull ((1));
# endif

/* Search N bytes of S for the final occurrence of C.  */
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1));
# else
extern void *memrchr (const void *__s, int __c, size_t __n)
      __THROW __attribute_pure__ __nonnull ((1));
# endif
#endif


__BEGIN_NAMESPACE_STD
/* Copy SRC to DEST.  */
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __THROW __nonnull ((1, 2));
/* Copy no more than N characters of SRC to DEST.  */
extern char *strncpy (char *__restrict __dest,
		      const char *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));

/* Append SRC onto DEST.  */
extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __THROW __nonnull ((1, 2));
/* Append no more than N characters from SRC onto DEST.  */
extern char *strncat (char *__restrict __dest, const char *__restrict __src,
		      size_t __n) __THROW __nonnull ((1, 2));

/* Compare S1 and S2.  */
extern int strcmp (const char *__s1, const char *__s2)
     __THROW __attribute_pure__ __nonnull ((1, 2));
/* Compare N characters of S1 and S2.  */
extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __THROW __attribute_pure__ __nonnull ((1, 2));

#if defined __USE_GNU && defined __GNUC__
/* Duplicate S, returning an identical alloca'd string.  */
  
# define strdupa(s)							      \
  (__extension__							      \
    ({									      \
    ({									      \
      const char *__old = (s);						      \
      size_t __len = strnlen (__old, (n));				      \
      char *__new = (char *) __builtin_alloca (__len + 1);		      \
      __new[__len] = '\0';						      \
      (char *) memcpy (__new, __old, __len);				      \
    }))
#endif

__BEGIN_NAMESPACE_STD
/* Find the first occurrence of C in S.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern char *strchr (char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
extern const char *strchr (const char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strchr (char *__s, int __c) __THROW
{
# endif
}
#else
extern char *strchr (const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#endif
/* Find the last occurrence of C in S.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++"
{
extern char *strrchr (char *__s, int __c)
     __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));
extern const char *strrchr (const char *__s, int __c)
     __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strrchr (char *__s, int __c) __THROW
{
  return __builtin_strrchr (__s, __c);
}

__extern_always_inline const char *
strrchr (const char *__s, int __c) __THROW
{
  return __builtin_strrchr (__s, __c);
}
# endif
}
#else
  
#endif
 __BEGIN_NAMESPACE_STD /* Return the length of the initial segment of S which    consists entirely of characters not in REJECT.  */
extern size_t strcspn (const char *__s, const char *__reject)      __THROW __attribute_pure__ __nonnull ((1, 2));
   /* Return the length of the initial segment of S which    consists entirely of characters in ACCEPT.  */
extern size_t strspn (const char *__s, const char *__accept)      __THROW __attribute_pure__ __nonnull ((1, 2));
   /* Find the first occurrence in S of any character in ACCEPT.  */
  
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" { extern char *strpbrk (char *__s, const char *__accept)      __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2)); extern const char *strpbrk (const char *__s, const char *__accept)      __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));    
# ifdef __OPTIMIZE__
__extern_always_inline char * strpbrk (char *__s, const char *__accept) __THROW {   return __builtin_strpbrk (__s, __accept); }  __extern_always_inline const char * strpbrk (const char *__s, const char *__accept) __THROW {   return __builtin_strpbrk (__s, __accept); }   
# endif
}
     
extern char *strtok_r (char *__restrict __s, const char *__restrict __delim, 		       char **__restrict __save_ptr)      __THROW __nonnull ((2, 3));
     
#endif
   
#ifdef __USE_GNU
/* Similar to `strstr' but this function ignores the case of both strings.  */
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
extern "C++" const char *strcasestr (const char *__haystack,
				     const char *__needle)
     __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
# else
extern char *strcasestr (const char *__haystack, const char *__needle)
     __THROW __attribute_pure__ __nonnull ((1, 2));
# endif
#endif

#ifdef __USE_GNU
/* Find the first occurrence of NEEDLE in HAYSTACK.
   NEEDLE is NEEDLELEN bytes long;
   HAYSTACK is HAYSTACKLEN bytes long.  */
extern void *memmem (const void *__haystack, size_t __haystacklen,
		     const void *__needle, size_t __needlelen)
     __THROW __attribute_pure__ __nonnull ((1, 3));

/* Copy N bytes of SRC to DEST, return pointer to bytes after the
   last written byte.  */
extern void *__mempcpy (void *__restrict __dest,
			const void *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));
extern void *mempcpy (void *__restrict __dest,
		      const void *__restrict __src, size_t __n)
     __THROW __nonnull ((1, 2));
#endif


__BEGIN_NAMESPACE_STD
/* Return the length of S.  */
extern size_t strlen (const char *__s)
     __THROW __attribute_pure__ __nonnull ((1));
__END_NAMESPACE_STD

#ifdef	__USE_XOPEN2K8
/* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  */
extern size_t strnlen (const char *__string, size_t __maxlen)
     __THROW __attribute_pure__ __nonnull ((1));
#endif


__BEGIN_NAMESPACE_STD
/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
extern char *strerror (int __errnum) __THROW;
/* We define this function always since `bzero' is sometimes needed when    the namespace rules does not allow this.  */
extern void __bzero (void *__s, size_t __n) __THROW __nonnull ((1));
      
#ifdef __USE_BSD
/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
extern void bcopy (const void *__src, void *__dest, size_t __n)      __THROW __nonnull ((1, 2));
    /* Set N bytes of S to 0.  */
extern void bzero (void *__s, size_t __n) __THROW __nonnull ((1));
    /* Compare N bytes of S1 and S2 (same as memcmp).  */
extern int bcmp (const void *__s1, const void *__s2, size_t __n)      __THROW __attribute_pure__ __nonnull ((1, 2));
    /* Find the first occurrence of C in S (same as strchr).  */
  
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" { extern char *index (char *__s, int __c)      __THROW __asm ("index") __attribute_pure__ __nonnull ((1)); extern const char *index (const char *__s, int __c)      __THROW __asm ("index") __attribute_pure__ __nonnull ((1));    
#  if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRINGS_H_PROTO
__extern_always_inline char * index (char *__s, int __c) __THROW {   return __builtin_index (__s, __c); }  __extern_always_inline const char * index (const char *__s, int __c) __THROW {   return __builtin_index (__s, __c); }   
#  endif
}
     
# else
extern char *index (const char *__s, int __c)      __THROW __attribute_pure__ __nonnull ((1));
     
# endif
 /* Find the last occurrence of C in S (same as strrchr).  */
  
# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" { extern char *rindex (char *__s, int __c)      __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1)); extern const char *rindex (const char *__s, int __c)      __THROW __asm ("rindex") __attribute_pure__ __nonnull ((1));    
#  if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRINGS_H_PROTO
__extern_always_inline char * rindex (char *__s, int __c) __THROW {   return __builtin_rindex (__s, __c); }  __extern_always_inline const char * rindex (const char *__s, int __c) __THROW {   return __builtin_rindex (__s, __c); }   
#endif
}
     
# else
extern char *rindex (const char *__s, int __c)      __THROW __attribute_pure__ __nonnull ((1));
     
# endif
 /* Return the position of the first bit set in I, or 0 if none are set.    The least-significant bit is position 1, the most-significant 32.  */
extern int ffs (int __i) __THROW __attribute__ ((__const__));
extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)      __THROW __nonnull ((1, 2));
   extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)      __THROW __nonnull ((1, 2));
    /* Copy no more than N characters of SRC to DEST, returning the address of    the last character written into DEST.  */
extern char *__stpncpy (char *__restrict __dest, 			const char *__restrict __src, size_t __n)      __THROW __nonnull ((1, 2));
   extern char *stpncpy (char *__restrict __dest, 		      const char *__restrict __src, size_t __n)      __THROW __nonnull ((1, 2));
     
#endif
   
#ifdef	__USE_GNU
/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
extern int strverscmp (const char *__s1, const char *__s2)      __THROW __attribute_pure__ __nonnull ((1, 2));
    /* Sautee STRING briskly.  */
extern char *strfry (char *__string) __THROW __nonnull ((1));
    /* Frobnicate N bytes of S.  */
extern void *memfrob (void *__s, size_t __n) __THROW __nonnull ((1));
      
# ifndef basename
/* Return the file name within directory of FILENAME.  We don't
   declare the function if the `basename' macro is available (defined    in <libgen.h>) which makes the XPG version of this function    available.  */
  
#  ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
extern "C++" char *basename (char *__filename)      __THROW __asm ("basename") __nonnull ((1));
   extern "C++" const char *basename (const char *__filename)      __THROW __asm ("basename") __nonnull ((1));
     
#  else
extern char *basename (const char *__filename) __THROW __nonnull ((1));
     
#  endif
  
# endif
  
#endif
    
#if defined __GNUC__ && __GNUC__ >= 2
  
# if defined __OPTIMIZE__ && !defined __OPTIMIZE_SIZE__ \
     && !defined __NO_INLINE__ && !defined __cplusplus
/* When using GNU CC we provide some optimized versions of selected    functions from this header.  There are two kinds of optimizations:     - machine-dependent optimizations, most probably using inline      assembler code;
#  include <bits/string3.h>
  
#endif /* expanded by -frewrite-includes */
  
# endif
  
#endif
 __END_DECLS    
#endif
   
#endif  // _LIBCPP_STRING_H
  
#pragma clang module end /*std.depr.string_h*/
}
   extern "C" {
     
#if 0 /* expanded by -frewrite-includes */
  
#include "wctype.h"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.depr.wctype_h
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_WCTYPE_H
  
#define _LIBCPP_WCTYPE_H
 /*     wctype.h synopsis  Macros:      WEOF  Types:      wint_t     wctrans_t     wctype_t  int iswalnum(wint_t wc);
   int iswalpha(wint_t wc);
   int iswblank(wint_t wc);
#endif /* expanded by -frewrite-includes */
  
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <wctype.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1996-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard: 7.25  *	Wide character classification and mapping utilities  <wctype.h>  */
   
#ifndef _WCTYPE_H
   
#if 0 /* expanded by -frewrite-includes */
  
#include <features.h>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/types.h>
  
#endif /* expanded by -frewrite-includes */
   
#ifndef __need_iswxxx
  
# define _WCTYPE_H	1
 /* Get wint_t from <wchar.h>.  */
  
# define __need_wint_t
#if defined(__need_wint_t) || defined(__need_mbstate_t)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
    defined(__need_NULL) || defined(__need_wint_t)
   
#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
  
#if !__has_feature(modules)
  
#define __STDDEF_H
  
#endif
  
#define __need_ptrdiff_t
  
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
  
#if !__has_feature(modules)
  
#define _SIZE_T
  
#endif
  
#if !defined(_WCHAR_T) || __has_feature(modules)
  
#if !__has_feature(modules)
  
#define _WCHAR_T
  
#if defined(_MSC_EXTENSIONS)
  
#define _WCHAR_T_DEFINED
  
#endif
  
#endif
typedef __WCHAR_TYPE__ wchar_t;
     
  
#    define NULL __null
  
#  else
  
#    define NULL 0
  
#  endif
#endif
  
#undef __need_NULL
  
#endif /* defined(__need_NULL) */
   
#if defined(__need_STDDEF_H_misc)
  
  
#undef __need_wint_t
  
#endif /* __need_wint_t */
   
#endif
   
#elif !defined(_LIBCPP_STDDEF_H)
  
#define _LIBCPP_STDDEF_H
 /*     stddef.h synopsis  Macros:      offsetof(type,member-designator)     NULL  Types:      ptrdiff_t     size_t     max_align_t     nullptr_t  */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
#include_next <stddef.h>
  
#endif /* expanded by -frewrite-includes */
   
#ifdef __cplusplus
 extern "C++" {   
#if 0 /* expanded by -frewrite-includes */
  
typedef long double max_align_t;
     
#endif
   
#endif
   
#endif  // _LIBCPP_STDDEF_H
 /* We try to get wint_t from <stddef.h>, but not all GCC versions define it    there.  So define it ourselves if it remains undefined.  */
  
# ifndef _WINT_T
/* Integral type unchanged by default argument promotions that can    hold any value corresponding to members of the extended character    set, as well as at least one value that does not correspond to any    member of the extended character set.  */
  
#  define _WINT_T
typedef unsigned int wint_t;
     
# else
/* Work around problems with the <stddef.h> file which doesn't put
   wint_t in the std namespace.  */
#  if defined __cplusplus && defined _GLIBCPP_USE_NAMESPACES \
      && defined __WINT_TYPE__
__BEGIN_NAMESPACE_STD
typedef __WINT_TYPE__ wint_t;
__END_NAMESPACE_STD
#  endif
# endif

/* Tell the caller that we provide correct C++ prototypes.  */
# if defined __cplusplus && __GNUC_PREREQ (4, 4)
#  define __CORRECT_ISO_CPP_WCHAR_H_PROTO
# endif
    char __wchb[4];
  } __value;		/* Value so far.  */
} __mbstate_t;
#endif
#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
#ifdef _WCHAR_H

# ifndef __mbstate_t_defined
__BEGIN_NAMESPACE_C99
/* Public type.  */
typedef __mbstate_t mbstate_t;
__END_NAMESPACE_C99
     
#endif
  __BEGIN_NAMESPACE_STD /* Determine whether C constitutes a valid (one-byte) multibyte    character.  */
extern wint_t btowc (int __c) __THROW;
    /* Determine whether C corresponds to a member of the extended    character set whose multibyte representation is a single byte.  */
extern int wctob (wint_t __c) __THROW;
    /* Determine whether PS points to an object representing the initial    state.  */
  /* The following functions are extensions found in X/Open CAE.  */
  
#ifdef __USE_XOPEN
/* Determine number of column positions required for C.  */
extern int wcwidth (wchar_t __c) __THROW;
    /* Determine number of column positions required for first N wide    characters (or fewer if S ends before this) in S.  */
extern int wcswidth (const wchar_t *__s, size_t __n) __THROW;
     
/* Read formatted input from S.  */
extern int swscanf (const wchar_t *__restrict __s,
		    const wchar_t *__restrict __format, ...)
     __THROW /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;

# if defined __USE_ISOC99 && !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (fwscanf, (__FILE *__restrict __stream,
				 const wchar_t *__restrict __format, ...),
		       __isoc99_fwscanf)
     /* __attribute__ ((__format__ (__wscanf__, 2, 3))) */;
			      __gnuc_va_list __arg) __THROW;
#   define vfwscanf __isoc99_vfwscanf
#   define vwscanf __isoc99_vwscanf
#   define vswscanf __isoc99_vswscanf
#  endif
# endif

__END_NAMESPACE_C99
#endif /* Use ISO C99. */


__BEGIN_NAMESPACE_STD
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
  
#if defined __USE_UNIX98 && !defined __USE_GNU
  
# define __need_iswxxx
  
#if 0 /* expanded by -frewrite-includes */
  
# include <wctype.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
 /* Define some macros helping to catch buffer overflows.  */
  
#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
#endif
   
#ifdef __LDBL_COMPAT
  
#if 0 /* expanded by -frewrite-includes */
  
# include <bits/wchar-ldbl.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
 __END_DECLS    
#endif	/* _WCHAR_H defined */
   
#endif /* wchar.h  */
 /* Undefine all __need_* constants in case we are included to get those    constants but the whole file was already read.  */
  
#undef __need_mbstate_t
  
#undef __need_wint_t
   
#elif !defined(_LIBCPP_WCHAR_H)
  
#define _LIBCPP_WCHAR_H
 /*     wchar.h synopsis  Macros:      NULL     WCHAR_MAX     WCHAR_MIN     WEOF  Types:      mbstate_t     size_t     tm     wint_t  int fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
   int fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
   int swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
   int swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
   int vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
   int vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
    // C99
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifdef __cplusplus
  
#define __CORRECT_ISO_CPP_WCHAR_H_PROTO
extern "C" { size_t mbsnrtowcs(wchar_t *__restrict dst, const char **__restrict src,                   size_t nmc, size_t len, mbstate_t *__restrict ps); size_t wcsnrtombs(char *__restrict dst, const wchar_t **__restrict src,                   size_t nwc, size_t len, mbstate_t *__restrict ps); }
    // extern "C++"
  
#endif  // __cplusplus && _LIBCPP_MSVCRT
   
#endif  // _LIBCPP_WCHAR_H
 /* Constant expression of type `wint_t' whose value does not correspond
   to any member of the extended character set.  */
# ifndef WEOF
#  define WEOF (0xffffffffu)
# endif
#endif
#undef __need_iswxxx


/* The following part is also used in the <wcsmbs.h> header when compiled
   in the Unix98 compatibility mode.  */
#ifndef __iswxxx_defined
# define __iswxxx_defined	1

__BEGIN_NAMESPACE_C99
/* Scalar type that can hold values which represent locale-specific
   character classifications.  */
typedef unsigned long int wctype_t;
__END_NAMESPACE_C99

# ifndef _ISwbit
/* The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */
   
#if 0 /* expanded by -frewrite-includes */
  
#  include <endian.h>
  
#endif /* expanded by -frewrite-includes */
  
#  if __BYTE_ORDER == __BIG_ENDIAN
  
#   define _ISwbit(bit)	(1 << (bit))
  
#  else /* __BYTE_ORDER == __LITTLE_ENDIAN */
  
#   define _ISwbit(bit)	\
	((bit) < 8 ? (int) ((1UL << (bit)) << 24)			      \
	 : ((bit) < 16 ? (int) ((1UL << (bit)) << 8)			      \
	    : ((bit) < 24 ? (int) ((1UL << (bit)) >> 8)			      \
	       : (int) ((1UL << (bit)) >> 24))))
  
#  endif
 enum {   __ISwupper = 0,			/* UPPERCASE.  */  __ISwlower = 1,			/* lowercase.  */  __ISwalpha = 2,			/* Alphabetic.  */  __ISwdigit = 3,			/* Numeric.  */  __ISwxdigit = 4,			/* Hexadecimal numeric.  */  __ISwspace = 5,			/* Whitespace.  */  __ISwprint = 6,			/* Printing.  */  __ISwgraph = 7,			/* Graphical.  */  __ISwblank = 8,			/* Blank (usually SPC and TAB).  */  __ISwcntrl = 9,			/* Control character.  */  __ISwpunct = 10,			/* Punctuation.  */  __ISwalnum = 11,			/* Alphanumeric.  */   _ISwupper = _ISwbit (__ISwupper),	/* UPPERCASE.  */  _ISwlower = _ISwbit (__ISwlower),	/* lowercase.  */  _ISwalpha = _ISwbit (__ISwalpha),	/* Alphabetic.  */  _ISwdigit = _ISwbit (__ISwdigit),	/* Numeric.  */  _ISwxdigit = _ISwbit (__ISwxdigit),	/* Hexadecimal numeric.  */  _ISwspace = _ISwbit (__ISwspace),	/* Whitespace.  */  _ISwprint = _ISwbit (__ISwprint),	/* Printing.  */  _ISwgraph = _ISwbit (__ISwgraph),	/* Graphical.  */  _ISwblank = _ISwbit (__ISwblank),	/* Blank (usually SPC and TAB).  */  _ISwcntrl = _ISwbit (__ISwcntrl),	/* Control character.  */  _ISwpunct = _ISwbit (__ISwpunct),	/* Punctuation.  */  _ISwalnum = _ISwbit (__ISwalnum)	/* Alphanumeric.  */};
     
# endif /* Not _ISwbit  */
  __BEGIN_DECLS  __BEGIN_NAMESPACE_C99 /*  * Wide-character classification functions: 7.15.2.1.  */
 /* Test for any wide character for which `iswalpha' or `iswdigit' is    true.  */
extern int iswalnum (wint_t __wc) __THROW;
    /* Test for any wide character for which `iswupper' or 'iswlower' is
   true, or any wide character that is one of a locale-specific set of
   wide-characters for which none of `iswcntrl', `iswdigit',
   `iswpunct', or `iswspace' is true.  */
extern int iswalpha (wint_t __wc) __THROW;

__BEGIN_NAMESPACE_C99
/* Scalar type that can hold values which represent locale-specific
   character mappings.  */
typedef const __int32_t *wctrans_t;
__END_NAMESPACE_C99
#ifdef __USE_GNU
__USING_NAMESPACE_C99(wctrans_t)
#endif

__BEGIN_NAMESPACE_C99
/* Converts an uppercase letter to the corresponding lowercase letter.  */
extern wint_t towlower (wint_t __wc) __THROW;

/* Converts an lowercase letter to the corresponding uppercase letter.  */
extern wint_t towupper (wint_t __wc) __THROW;
__END_NAMESPACE_C99

__END_DECLS

#endif	/* need iswxxx.  */


/* The remaining definitions and declarations must not appear in the
   <wchar.h> header.  */
#ifdef _WCTYPE_H

/*
 * Extensible wide-character mapping functions: 7.15.3.2.
 */

__BEGIN_DECLS

__BEGIN_NAMESPACE_C99
/* Construct value that describes a mapping between wide characters
   identified by the string argument PROPERTY.  */
extern wctrans_t wctrans (const char *__property) __THROW;

/* Map the wide character WC using the mapping described by DESC.  */
extern wint_t towctrans (wint_t __wc, wctrans_t __desc) __THROW;
__END_NAMESPACE_C99

# ifdef __USE_XOPEN2K8
/* Declare the interface to extended locale model.  */
#if 0 /* expanded by -frewrite-includes */
#  include <xlocale.h>
#endif /* expanded by -frewrite-includes */
extern wint_t towupper_l (wint_t __wc, __locale_t __locale) __THROW;
    /* Construct value that describes a mapping between wide characters    identified by the string argument PROPERTY.  */
extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)      __THROW;
    /* Map the wide character WC using the mapping described by DESC.  */
extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc, 			   __locale_t __locale) __THROW;
      
# endif /* Use POSIX 2008.  */
 __END_DECLS    
#endif	/* __WCTYPE_H defined.  */
   
#endif /* wctype.h  */
   
#ifdef __cplusplus
   
#undef iswalnum
#undef towctrans
  
#undef wctrans
   
#endif  // __cplusplus
   
#endif  // _LIBCPP_WCTYPE_H
  
#pragma clang module end /*std.depr.wctype_h*/
}
     
#if 0 /* expanded by -frewrite-includes */
  
#include "complex.h"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.complex_h
// -*- C++ -*-
//===--------------------------- complex.h --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_COMPLEX_H
  
#define _LIBCPP_COMPLEX_H
 /*     complex.h synopsis    
#include <ccomplex>
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifdef __cplusplus
   
#if 0 /* expanded by -frewrite-includes */
  
#include <ccomplex>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.ccomplex
// -*- C++ -*-
//===--------------------------- ccomplex ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CCOMPLEX
  
#define _LIBCPP_CCOMPLEX
 /*     ccomplex synopsis    
#include <complex>
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <complex>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.complex
// -*- C++ -*-
//===--------------------------- complex ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_COMPLEX
  
#define _LIBCPP_COMPLEX
 /*     complex synopsis  namespace std {
    template<class T> class complex { public:     typedef T value_type;      complex(const T& re = T(), const T& im = T()); // constexpr in C++14
    complex(const complex&);  // constexpr in C++14
    template<class X> complex(const complex<X>&);  // constexpr in C++14
     T real() const; // constexpr in C++14
    T imag() const; // constexpr in C++14
     void real(T);     void imag(T);      complex<T>& operator= (const T&);     complex<T>& operator+=(const T&);     complex<T>& operator-=(const T&);     complex<T>& operator*=(const T&);     complex<T>& operator/=(const T&);      complex& operator=(const complex&);     template<class X> complex<T>& operator= (const complex<X>&);     template<class X> complex<T>& operator+=(const complex<X>&);     template<class X> complex<T>& operator-=(const complex<X>&);     template<class X> complex<T>& operator*=(const complex<X>&);     template<class X> complex<T>& operator/=(const complex<X>&); };
   template<class T> complex<T> tan (const complex<T>&);
   template<class T> complex<T> tanh (const complex<T>&);
    template<class T, class charT, class traits>   basic_istream<charT, traits>&   operator>>(basic_istream<charT, traits>& is, complex<T>& x);
    template<class T, class charT, class traits>   basic_ostream<charT, traits>&   operator<<(basic_ostream<charT, traits>& o, const complex<T>& x);
    }
    // std
 */
   
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TYPE_TRAITS
  
#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {
        // helper class:
           // C++17
      template<class B> struct negation;
                                   // C++17
      template<class B>          constexpr bool negation_v = negation<B>::value;
                    // C++17
 }
    */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {
   };
      
#else  // !__has_feature(is_trivially_constructible)
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : false_type {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>   
#endif  // !__has_feature(is_trivially_constructible)
   
#endif  // _LIBCPP_HAS_NO_VARIADICS
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
template <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v     = is_trivially_constructible<_Tp, _Args...>::value;
     
#endif
 // is_trivially_move_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_move_constructible   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>   
#else
    : public is_trivially_copy_constructible<_Tp>   
#endif
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_move_assignable_v     = is_trivially_move_assignable<_Tp>::value;
     
#endif
 // is_trivially_destructible
   
#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_destructible     : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
   
#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
 template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
    template <class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>     : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))> {
   };
    template <class _Tp> void __implicit_conversion_to(_Tp) noexcept {
    template <class _Tp, size_t _Ns> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp[_Ns]>     : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, is_reference<_Tp>::value, _Tp> {
   };
      
#else  // __has_feature(cxx_noexcept)
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible     : false_type {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp>   
#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{
   };
      
#endif  // __has_feature(cxx_noexcept)
   
#else  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Tp, class _A0 = __is_construct::__nat,                      class _A1 = __is_construct::__nat> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible     : false_type {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, __is_construct::__nat,                                                        __is_construct::__nat>   
#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_constructor(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,                                                        __is_construct::__nat>   
#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_copy(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{
   };
      
#endif  // _LIBCPP_HAS_NO_VARIADICS
  
 template <class _Tp> struct __libcpp_nothrow_destructor     : public integral_constant<bool, is_scalar<_Tp>::value ||                                      is_reference<_Tp>::value> {
  };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible     : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {
  };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_destructible<_Tp[]>     : public false_type {
  };
      
#endif
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v     = is_trivially_copyable<_Tp>::value;
     
#endif
 // is_trivial;
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial   
#if __has_feature(is_trivial) || _GNUC_VER >= 407
  }
    }
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <stdexcept>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.stdexcept
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_STDEXCEPT
  
#define _LIBCPP_STDEXCEPT
 /*     stdexcept synopsis  namespace std {
    class logic_error;
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.exception
// -*- C++ -*-
//===-------------------------- exception ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXCEPTION
  
#define _LIBCPP_EXCEPTION
 /*     exception synopsis  namespace std {
    class exception {
  public:     exception() noexcept;
      exception(const exception&) noexcept;
      exception& operator=(const exception&) noexcept;
      virtual ~exception() noexcept;
      virtual const char* what() const noexcept;
  
#endif
   
#endif  // _LIBCPP_CSTDDEF
  
#pragma clang module end /*std.compat.cstddef*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdlib>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cstdlib
// -*- C++ -*-
   
#ifndef _LIBCPP_CSTDLIB
  
#define _LIBCPP_CSTDLIB
 /*     cstdlib synopsis  Macros:      EXIT_FAILURE     EXIT_SUCCESS     MB_CUR_MAX     NULL     RAND_MAX  namespace std {
    Types:      size_t     div_t     ldiv_t     lldiv_t                                                               // C99
 double    atof (const char* nptr);
   int       atoi (const char* nptr);
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===--------------------------- stdlib.h ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#if defined(__need_malloc_and_calloc)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <stdlib.h>
  
#endif /* expanded by -frewrite-includes */
   
#elif !defined(_LIBCPP_STDLIB_H)
  
#define _LIBCPP_STDLIB_H
 /*     stdlib.h synopsis  Macros:      EXIT_FAILURE     EXIT_SUCCESS     MB_CUR_MAX     NULL     RAND_MAX  Types:      size_t     div_t     ldiv_t     lldiv_t                                                               // C99
 double    atof (const char* nptr);
   int       atoi (const char* nptr);
   long      atol (const char* nptr);
   long long atoll(const char* nptr);
                                          // C99
double             strtod  (const char* restrict nptr, char** restrict endptr);
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>  */
   
#ifndef	_STDLIB_H
   
#if 0 /* expanded by -frewrite-includes */
  
#include <features.h>
  
#endif /* expanded by -frewrite-includes */
 /* Get size_t, wchar_t and NULL from <stddef.h>.  */
  
#define		__need_size_t
  
#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <stddef.h>
#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
  
#if !__has_feature(modules)
  
#define __STDDEF_H
  
#endif
  
#define __need_ptrdiff_t
  
#define __need_size_t
  
#define __need_wchar_t
  
#define __need_NULL
  
#define __need_STDDEF_H_misc
/* __need_wint_t is intentionally not defined here. */
  
#endif
   
#if defined(__need_ptrdiff_t)
  
#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */
  
#if !__has_feature(modules)
  
#define _PTRDIFF_T
  
#endif
typedef __PTRDIFF_TYPE__ ptrdiff_t;
     
#endif
  
#undef __need_ptrdiff_t
  
#endif /* defined(__need_ptrdiff_t) */
   
#if defined(__need_size_t)
  
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
     
#endif
  
#undef __need_size_t
  
#endif /*defined(__need_size_t) */
   
#if defined(__need_STDDEF_H_misc)
#endif /* defined(__need_STDDEF_H_misc) */
   
#if defined(__need_wchar_t)
  
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
  
#if !defined(_WCHAR_T) || __has_feature(modules)
  
#if !__has_feature(modules)
  
#define _WCHAR_T
  
#if defined(_MSC_EXTENSIONS)
  
#define _WCHAR_T_DEFINED
  
#endif
  
#endif
typedef __WCHAR_TYPE__ wchar_t;
     
#endif
  
#endif
  
#undef __need_wchar_t
  
#endif /* defined(__need_wchar_t) */
   
#if defined(__need_NULL)
  
#undef NULL
  
#ifdef __cplusplus
  
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
  
#    define NULL __null
  
#  else
  
#    define NULL 0
  
#  endif
  
     
#endif
  
#undef __need_wint_t
  
#endif /* __need_wint_t */
   
#endif
   
#elif !defined(_LIBCPP_STDDEF_H)
  
#define _LIBCPP_STDDEF_H
 /*     stddef.h synopsis  Macros:      offsetof(type,member-designator)     NULL  Types:      ptrdiff_t     size_t     max_align_t     nullptr_t  */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
#endif
   
#endif  // _LIBCPP_STDDEF_H
 __BEGIN_DECLS    
#ifndef __need_malloc_and_calloc
  
#define	_STDLIB_H	1
   
#if (defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H
/* XPG requires a few symbols from <sys/wait.h> being defined.  */
  
#if 0 /* expanded by -frewrite-includes */
  
# include <bits/waitflags.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif	/* X/Open or XPG7 and <sys/wait.h> not included.  */
 __BEGIN_NAMESPACE_STD /* Returned by `div'.  */
typedef struct
  {
    int quot;			/* Quotient.  */
    int rem;			/* Remainder.  */
  } div_t;

/* Returned by `ldiv'.  */
  
#ifndef __ldiv_t_defined
typedef struct   {
       long int quot;
  		/* Quotient.  */
    long int rem;
  		/* Remainder.  */
  }
   ldiv_t;
     
# define __ldiv_t_defined	1
  
#endif
__END_NAMESPACE_STD    
#if defined __USE_ISOC99 && !defined __lldiv_t_defined
__BEGIN_NAMESPACE_C99 /* Returned by `lldiv'.  */
__extension__ typedef struct
  {
    long long int quot;		/* Quotient.  */
    long long int rem;		/* Remainder.  */
  } lldiv_t;
# define __lldiv_t_defined	1
__END_NAMESPACE_C99
#endif


/* The largest number rand will return (same as INT_MAX).  */
#define	RAND_MAX	2147483647
  /* Maximum length of a multibyte character in the current locale.  */
  
#define	MB_CUR_MAX	(__ctype_get_mb_cur_max ())
extern size_t __ctype_get_mb_cur_max (void) __THROW __wur;
     __BEGIN_NAMESPACE_STD /* Convert a string to a floating-point number.  */
extern double atof (const char *__nptr)      __THROW __attribute_pure__ __nonnull ((1)) __wur;
   /* Convert a string to an integer.  */
extern int atoi (const char *__nptr)      __THROW __attribute_pure__ __nonnull ((1)) __wur;
#ifdef __USE_GNU
/* The concept of one static locale per category is not very well    thought out.  Many applications will need to process its data using    information from several different locales.  Another problem is    the implementation of the internationalization handling in the    ISO C++ standard library.  To support this another set of    the functions using locale data exist which take an additional    argument.     Attention: even though several *_l interfaces are part of POSIX:2008,    these are not.  */
 /* Structure for reentrant locale using functions.  This is an    (almost) opaque type for the user level programs.  */
  
#if 0 /* expanded by -frewrite-includes */
  
# include <xlocale.h>
  
#endif /* expanded by -frewrite-includes */
 /* Special versions of the functions above which take the locale to    use as an additional parameter.  */
extern long int strtol_l (const char *__restrict __nptr, 			  char **__restrict __endptr, int __base, 			  __locale_t __loc) __THROW __nonnull ((1, 4));
    extern unsigned long int strtoul_l (const char *__restrict __nptr, 				    char **__restrict __endptr, 				    int __base, __locale_t __loc)      __THROW __nonnull ((1, 4));
    __extension__ extern long long int strtoll_l (const char *__restrict __nptr, 				char **__restrict __endptr, int __base, 				__locale_t __loc)      __THROW __nonnull ((1, 4));
    __extension__ extern unsigned long long int strtoull_l (const char *__restrict __nptr, 					  char **__restrict __endptr, 					  int __base, __locale_t __loc)      __THROW __nonnull ((1, 4));
    extern double strtod_l (const char *__restrict __nptr, 			char **__restrict __endptr, __locale_t __loc)      __THROW __nonnull ((1, 3));
    extern float strtof_l (const char *__restrict __nptr, 		       char **__restrict __endptr, __locale_t __loc)      __THROW __nonnull ((1, 3));
    extern long double strtold_l (const char *__restrict __nptr, 			      char **__restrict __endptr, 			      __locale_t __loc)      __THROW __nonnull ((1, 3));
     
#endif /* GNU */
    
#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD __extern_inline int __NTH (atoi (const char *__nptr)) {
     return (int) strtol (__nptr, (char **) NULL, 10);
   }
   __extern_inline long int __NTH (atol (const char *__nptr)) {
     return strtol (__nptr, (char **) NULL, 10);
   }
   __END_NAMESPACE_STD    
# if defined __USE_MISC || defined __USE_ISOC99
__BEGIN_NAMESPACE_C99 __extension__ __extern_inline long long int __NTH (atoll (const char *__nptr)) {
     return strtoll (__nptr, (char **) NULL, 10);
   }
   __END_NAMESPACE_C99   
# endif
  
#endif /* Optimizing and Inlining.  */
    
#if defined __USE_SVID || defined __USE_XOPEN_EXTENDED
  
#if 0 /* expanded by -frewrite-includes */
  
# include <sys/types.h>	/* we need int32_t... */
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>  */
   
#ifndef	_SYS_TYPES_H
  
 __BEGIN_DECLS    
#if 0 /* expanded by -frewrite-includes */
  
#include <bits/types.h>
  
#endif /* expanded by -frewrite-includes */
   
#ifdef	__USE_BSD
  
# ifndef __u_char_defined
typedef __u_char u_char;
   typedef __u_short u_short;
   typedef __u_int u_int;
   typedef __u_long u_long;
   typedef __quad_t quad_t;
   typedef __u_quad_t u_quad_t;
   typedef __fsid_t fsid_t;
     
#  define __u_char_defined
  
# endif
  
#endif
 typedef __loff_t loff_t;
#ifndef __dev_t_defined
typedef __dev_t dev_t;
     
# define __dev_t_defined
  
#endif
   
#ifndef __gid_t_defined
# define __uid_t_defined
  
#endif
   
#ifndef __off_t_defined
  
# ifndef __USE_FILE_OFFSET64
typedef __off_t off_t;
     
# else
typedef __off64_t off_t;
     
# endif
  
# define __off_t_defined
#endif
   
#ifndef __pid_t_defined
typedef __pid_t pid_t;
     
# define __pid_t_defined
  
#endif
   
#ifdef	__USE_BSD
  
# ifndef __daddr_t_defined
typedef __daddr_t daddr_t;
   typedef __caddr_t caddr_t;
     
#  define __daddr_t_defined
  
# endif
  
#endif
   
#if (defined __USE_SVID || defined __USE_XOPEN) && !defined __key_t_defined
typedef __key_t key_t;
     
#undef	__need_timer_t


#if (!defined __timespec_defined					\
     && ((defined _TIME_H						\
	  && (defined __USE_POSIX199309 || defined __USE_MISC		\
	      || defined __USE_ISOC11))					\
	 || defined __need_timespec))
# define __timespec_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>	/* This defines __time_t for us.  */
#endif /* expanded by -frewrite-includes */

/* POSIX.1b structure for a time value.  This is like a `struct timeval' but    has nanoseconds instead of microseconds.  */
extern size_t strftime (char *__restrict __s, size_t __maxsize,
			const char *__restrict __format,
			const struct tm *__restrict __tp) __THROW;
__END_NAMESPACE_STD

# ifdef __USE_XOPEN
/* Parse S according to FORMAT and store binary time information in TP.
   the provided locale and not the global locale.  */
#if 0 /* expanded by -frewrite-includes */
# include <xlocale.h>
#endif /* expanded by -frewrite-includes */

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
			  const char *__restrict __format,
#  endif
  
# endif
 /* But these were defined by ISO C without the first `_'.  */
typedef	unsigned char u_int8_t;
typedef	unsigned short int u_int16_t;
typedef	unsigned int u_int32_t;


/* Some code from BIND tests this macro to see if the types above are
   defined.  */
#endif
#define __BIT_TYPES_DEFINED__	1


#ifdef	__USE_BSD
/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */
#if 0 /* expanded by -frewrite-includes */
# include <endian.h>
#endif /* expanded by -frewrite-includes */

/* It also defines `fd_set' and the FD_* macros for `select'.  */
#if 0 /* expanded by -frewrite-includes */
# include <sys/select.h>
#endif /* expanded by -frewrite-includes */
/* `fd_set' type and related macros, and `select'/`pselect' declarations.    Copyright (C) 1996-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */
   
#ifndef _SYS_SELECT_H
  
#define _SYS_SELECT_H	1
   
#if 0 /* expanded by -frewrite-includes */
  
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1997-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
   
    
#if defined __GNUC__ && __GNUC__ >= 2
   
# if __WORDSIZE == 64
  
#  define __FD_ZERO_STOS "stosq"
  
# else
  
#  define __FD_ZERO_STOS "stosl"
  
# endif
   
# define __FD_ZERO(fdsp) \
  do {									      \
  } while (0)
   
#else	/* ! GNU CC */
 /* We don't use `memset' because this would require a prototype and    the array isn't too big.  */
# define __FD_ZERO(set)  \
  do {									      \
    unsigned int __i;							      \
    fd_set *__arr = (set);						      \
#include <bits/sigset.h>
#endif /* expanded by -frewrite-includes */
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef	_SIGSET_H_types
# define _SIGSET_H_types	1

# define __sigmask(sig) \
  (((unsigned long int) 1) << (((sig) - 1) % (8 * sizeof (unsigned long int))))

/* Return the word index for SIG.  */
# define __sigword(sig)	(((sig) - 1) / (8 * sizeof (unsigned long int)))

# if defined __GNUC__ && __GNUC__ >= 2
		    while (--__cnt >= 0) __set->__val[__cnt] = ~0UL;	      \
		    0; }))

#  ifdef __USE_GNU
/* The POSIX does not specify for handling the whole signal set in one
   command.  This is often wanted and so we define three more functions
   here.  */
#   define __sigisemptyset(set) \
		    0; }))
#  endif
# endif

/* These functions needn't check for a bogus signal number -- error    checking is done in the non __ versions.  */
 extern int __sigismember (const __sigset_t *, int);
   extern int __sigaddset (__sigset_t *, int);
   extern int __sigdelset (__sigset_t *, int);
      
# ifdef __USE_EXTERN_INLINES
  
#  define __SIGSETFN(NAME, BODY, CONST)					      \
  _EXTERN_INLINE int							      \
  NAME (CONST __sigset_t *__set, int __sig)				      \
  {									      \
    unsigned long int __mask = __sigmask (__sig);			      \
    unsigned long int __word = __sigword (__sig);			      \
    return BODY;							      \
  }
 __SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, const) __SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), ) __SIGSETFN (__sigdelset, ((__set->__val[__word] &= ~__mask), 0), )    
#  undef __SIGSETFN
  
# endif
    
#endif /* ! _SIGSET_H_fns.  */
   
#ifndef __sigset_t_defined
  
# define __sigset_t_defined
typedef __sigset_t sigset_t;
     
#endif
 /* Get definition of timer specification structures.  */
  
#define __need_time_t
  
#define __need_timespec
  
#if 0 /* expanded by -frewrite-includes */
  
#include <time.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard: 7.23 Date and time	<time.h>  */
   
#ifndef	_TIME_H
   
#if (! defined __need_time_t && !defined __need_clock_t && \
     ! defined __need_timespec)
  
# define _TIME_H	1
  
#if 0 /* expanded by -frewrite-includes */
  
# include <features.h>
  
#endif /* expanded by -frewrite-includes */
 /* This is the obsolete POSIX.1-1988 name for the same constant.  */
  
# if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
  
#  ifndef CLK_TCK
  
#   define CLK_TCK	CLOCKS_PER_SEC
  
#  endif
  
# endif
   
#endif /* <time.h> included.  */
   
#if !defined __clock_t_defined && (defined _TIME_H || defined __need_clock_t)
#endif /* clock_t not defined and <time.h> or need clock_t.  */
#undef	__need_clock_t

#if !defined __time_t_defined && (defined _TIME_H || defined __need_time_t)
# define __time_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
#endif /* expanded by -frewrite-includes */

__BEGIN_NAMESPACE_STD
/* Returned by `time'.  */
typedef __time_t time_t;
   __END_NAMESPACE_STD   
#if defined __USE_POSIX || defined __USE_MISC || defined __USE_SVID
__USING_NAMESPACE_STD(time_t)   
#endif
   
#endif /* time_t not defined and <time.h> or need time_t.  */
  
#undef	__need_time_t
   
#if !defined __clockid_t_defined && \
   ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_clockid_t)
  
# define __clockid_t_defined	1
   
#if 0 /* expanded by -frewrite-includes */
  
# include <bits/types.h>
  
#endif /* expanded by -frewrite-includes */
 /* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;
      
#endif /* clockid_t not defined and <time.h> or need clockid_t.  */
  
#undef	__clockid_time_t


#if (!defined __timespec_defined					\
     && ((defined _TIME_H						\
	  && (defined __USE_POSIX199309 || defined __USE_MISC		\
	      || defined __USE_ISOC11))					\
	 || defined __need_timespec))
# define __timespec_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>	/* This defines __time_t for us.  */
#endif /* expanded by -frewrite-includes */

/* POSIX.1b structure for a time value.  This is like a `struct timeval' but    has nanoseconds instead of microseconds.  */
struct timespec   {
       __time_t tv_sec;
  		/* Seconds.  */
    __syscall_slong_t tv_nsec;
  	/* Nanoseconds.  */
  };
      
#endif /* timespec not defined and <time.h> or need timespec.  */
  
#undef	__need_timespec
    
#ifdef	_TIME_H
__BEGIN_NAMESPACE_STD /* Used by other time functions.  */
struct tm {
     int tm_sec;
  			/* Seconds.	[0-60] (1 leap second) */
  int tm_min;
#  if (!defined __STRICT_ANSI__ || defined __USE_POSIX) \
   && !defined __USE_XOPEN2K
/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK    presents the real value for clock ticks per second for the system.  */
  
#if 0 /* expanded by -frewrite-includes */
  
#   include <bits/types.h>
  
#endif /* expanded by -frewrite-includes */
extern long int __sysconf (int);
     
#   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
  
#  endif
   
#  ifdef __USE_POSIX199309
/* Identifier for system-wide realtime clock.  */
  
#   define CLOCK_REALTIME		0
/* Monotonic system-wide clock.  */
  
#   define CLOCK_MONOTONIC		1
/* High-resolution timer from the CPU.  */
/* Like CLOCK_REALTIME but in International Atomic Time.  */
  
#   define CLOCK_TAI			11
 /* Flag to indicate time is absolute.  */
  
#   define TIMER_ABSTIME		1
  
#  endif
   
#  ifdef __USE_GNU
  
#if 0 /* expanded by -frewrite-includes */
  
#   include <bits/timex.h>
  
#endif /* expanded by -frewrite-includes */
 __BEGIN_DECLS  /* Tune a POSIX clock.  */
extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __THROW;
    __END_DECLS   
#  endif /* use GNU */
   
# endif	/* bits/time.h */
  
#endif
   
#undef __need_timeval
   
#ifndef __suseconds_t_defined
typedef __suseconds_t suseconds_t;
     
# define __suseconds_t_defined
  
#endif
  /* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;
    /* Some versions of <linux/posix_types.h> define this macros.  */
  
#undef	__NFDBITS
/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
#define __NFDBITS	(8 * (int) sizeof (__fd_mask))
#define	__FD_ELT(d)	((d) / __NFDBITS)
#define	__FD_MASK(d)	((__fd_mask) 1 << ((d) % __NFDBITS))

/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */
#ifdef __USE_XOPEN
    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->fds_bits)
#else
    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)->__fds_bits)
#endif
  } fd_set;

/* Maximum number of file descriptors in `fd_set'.  */
  
#define	FD_SETSIZE		__FD_SETSIZE
   
#ifdef __USE_MISC
/* Sometimes the fd_set member is assumed to have this type.  */
typedef __fd_mask fd_mask;
    /* Number of bits per word of `fd_set' (some code assumes this is 32).  */
# define NFDBITS		__NFDBITS
#endif


/* Access macros for `fd_set'.  */
#define	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)
  __BEGIN_DECLS  /* Check the first NFDS descriptors each in READFDS (if not NULL) for read    readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS    (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out    after waiting the interval specified therein.  Returns the number of ready    descriptors, or -1 for errors.     This function is a cancellation point and therefore not marked with    __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds, 		   fd_set *__restrict __writefds, 		   fd_set *__restrict __exceptfds, 		   struct timeval *__restrict __timeout);
      
#ifdef __USE_XOPEN2K
/* Same as above only that the TIMEOUT value is given with higher    resolution and a sigmask which is been set temporarily.  This version    should be used.     This function is a cancellation point and therefore not marked with    __THROW.  */
extern int pselect (int __nfds, fd_set *__restrict __readfds, 		    fd_set *__restrict __writefds, 		    fd_set *__restrict __exceptfds, 		    const struct timespec *__restrict __timeout, 		    const __sigset_t *__restrict __sigmask);
     
#endif
  /* Define some inlines helping to catch common problems.  */
  
#if __USE_FORTIFY_LEVEL > 0 && defined __GNUC__
  
#if 0 /* expanded by -frewrite-includes */
  
# include <bits/select2.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
 __END_DECLS    
#endif /* sys/select.h */
 /* BSD defines these symbols, so we follow.  */
  
#if 0 /* expanded by -frewrite-includes */
  
# include <sys/sysmacros.h>
  
#endif /* expanded by -frewrite-includes */
/* Definitions of macros to access `dev_t' values.
   Copyright (C) 1996-2014 Free Software Foundation, Inc.
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef _SYS_SYSMACROS_H
#define _SYS_SYSMACROS_H	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
#endif /* expanded by -frewrite-includes */

__BEGIN_DECLS

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __THROW __attribute_const__;
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __THROW __attribute_const__;
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
					       unsigned int __minor)
     __THROW __attribute_const__;

#ifdef __USE_EXTERN_INLINES
__extension__ __extern_inline __attribute_const__ unsigned int
__NTH (gnu_dev_major (unsigned long long int __dev))
	  | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
#endif
__END_DECLS

/* Access the functions with their traditional names.  */
#define major(dev) gnu_dev_major (dev)
#define minor(dev) gnu_dev_minor (dev)
#define makedev(maj, min) gnu_dev_makedev (maj, min)

#endif /* sys/sysmacros.h */
#endif /* Use BSD.  */


#if (defined __USE_UNIX98 || defined __USE_XOPEN2K8) \
    && !defined __blksize_t_defined

#ifndef _BITS_PTHREADTYPES_H
#define _BITS_PTHREADTYPES_H	1

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
#ifdef __x86_64__
# define __WORDSIZE_TIME64_COMPAT32	1
/* Both x86-64 and x32 use the 64-bit system call interface.  */
# define __SYSCALL_WORDSIZE		64
#endif

#ifdef __x86_64__
# if __WORDSIZE == 64
#  define __SIZEOF_PTHREAD_ATTR_T 56
#  define __SIZEOF_PTHREAD_MUTEX_T 40
#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
#  define __SIZEOF_PTHREAD_COND_T 48
#  define __SIZEOF_PTHREAD_CONDATTR_T 4
#  define __SIZEOF_PTHREAD_RWLOCK_T 56
#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
#  define __SIZEOF_PTHREAD_CONDATTR_T 4
#  define __SIZEOF_PTHREAD_RWLOCK_T 44
#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
#  define __SIZEOF_PTHREAD_BARRIER_T 20
#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
# endif
#else
# define __SIZEOF_PTHREAD_ATTR_T 36
#endif


/* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  */
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[__SIZEOF_PTHREAD_ATTR_T];
  long int __align;
};
#ifndef __have_pthread_attr_t
typedef union pthread_attr_t pthread_attr_t;
# define __have_pthread_attr_t	1
#endif


#ifdef __x86_64__
typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
#else
typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
#endif


/* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  */
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;
#ifdef __x86_64__
    unsigned int __nusers;
#endif
    /* KIND must stay at this position in the structure to maintain
       binary compatibility.  */
    int __kind;
#ifdef __x86_64__
    short __spins;
    short __elision;
    __pthread_list_t __list;
# define __PTHREAD_MUTEX_HAVE_PREV	1
# define __PTHREAD_MUTEX_HAVE_ELISION   1
#else
    unsigned int __nusers;
    __extension__ union
    {
      struct
      {
	short __espins;
	short __elision;
# define __spins d.__espins
# define __elision d.__elision
# define __PTHREAD_MUTEX_HAVE_ELISION   2
      } d;
      __pthread_slist_t __list;
    };
#endif
  } __data;
  char __size[__SIZEOF_PTHREAD_MUTEX_T];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
  int __align;
} pthread_mutexattr_t;


/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[__SIZEOF_PTHREAD_COND_T];
  __extension__ long long int __align;
} pthread_cond_t;

/* Keys for thread-specific data */
typedef unsigned int pthread_key_t;


/* Once-only execution */
typedef int pthread_once_t;


#if defined __USE_UNIX98 || defined __USE_XOPEN2K
/* Data structure for read-write lock variable handling.  The
   structure of the attribute type is not exposed on purpose.  */
typedef union
{
# ifdef __x86_64__
  struct
  {
    unsigned long int __pad1;
    unsigned long int __pad2;
    /* FLAGS must stay at this position in the structure to maintain
       binary compatibility.  */
    unsigned int __flags;
# define __PTHREAD_RWLOCK_INT_FLAGS_SHARED	1
  } __data;
# else
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    int __writer;
  } __data;
# endif
  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
  long int __align;
} pthread_rwlockattr_t;
#endif


#ifdef __USE_XOPEN2K
/* POSIX spinlock data type.  */
typedef volatile int pthread_spinlock_t;


/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  */
typedef union
{
  char __size[__SIZEOF_PTHREAD_BARRIER_T];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
  int __align;
} pthread_barrierattr_t;
#endif


#ifndef __x86_64__
/* Extra attributes for the cleanup functions.  */
# define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
#endif

#endif	/* bits/pthreadtypes.h */
#endif

__END_DECLS

#endif /* sys/types.h */

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
extern long int random (void) __THROW;
#endif	/* Use SVID || extended X/Open || BSD. */


__BEGIN_NAMESPACE_STD
/* Return a random integer between 0 and RAND_MAX inclusive.  */
extern int rand (void) __THROW;
/* Seed the random number generator with the given number.  */

#if defined __USE_SVID || defined __USE_XOPEN
/* System V style 48-bit random number generator functions.  */

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern double drand48 (void) __THROW;
extern double erand48 (unsigned short int __xsubi[3]) __THROW __nonnull ((1));
extern void lcong48 (unsigned short int __param[7]) __THROW __nonnull ((1));

# ifdef __USE_MISC
/* Data structure for communication with thread safe versions.  This
   type is to be regarded as opaque.  It's only exported because users    have to allocate objects of this type.  */
struct drand48_data   {
       unsigned short int __x[3];
  	/* Current state.  */
  };
    /* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern int drand48_r (struct drand48_data *__restrict __buffer, 		      double *__restrict __result) __THROW __nonnull ((1, 2));
   extern int erand48_r (unsigned short int __xsubi[3], 		      struct drand48_data *__restrict __buffer, 		      double *__restrict __result) __THROW __nonnull ((1, 2));
    /* Return non-negative, long integer in [0,2^31).  */
extern int lrand48_r (struct drand48_data *__restrict __buffer, 		      long int *__restrict __result)      __THROW __nonnull ((1, 2));
   extern int nrand48_r (unsigned short int __xsubi[3], 		      struct drand48_data *__restrict __buffer, 		      long int *__restrict __result)      __THROW __nonnull ((1, 2));
    /* Return signed, long integers in [-2^31,2^31).  */
# endif	/* Use misc.  */
  
#endif	/* Use SVID or X/Open.  */
   
#endif /* don't just need malloc and calloc */
   
#ifndef __malloc_and_calloc_defined
  
# define __malloc_and_calloc_defined
__BEGIN_NAMESPACE_STD /* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;
   /* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)      __THROW __attribute_malloc__ __wur;
   __END_NAMESPACE_STD   
#endif
   
#ifndef __need_malloc_and_calloc
__BEGIN_NAMESPACE_STD /* Re-allocate the previously allocated block    in PTR, making the new block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns    the same pointer that was passed to it, aliasing needs to be allowed    between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)      __THROW __attribute_warn_unused_result__;
   /* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) __THROW;
__END_NAMESPACE_STD

#ifdef	__USE_MISC
/* Free a block.  An alias for `free'.	(Sun Unices).  */
extern void cfree (void *__ptr) __THROW;
     
#endif /* Use misc.  */
   
#if defined __USE_GNU || defined __USE_BSD || defined __USE_MISC
  
#if 0 /* expanded by -frewrite-includes */
  
# include <alloca.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1992-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
   
#ifndef	_ALLOCA_H
  
#define	_ALLOCA_H	1
   
#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
    defined(__need_NULL) || defined(__need_wint_t)
   
#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
  
#if !__has_feature(modules)
  
#define __STDDEF_H
  
#endif
  
#define __need_ptrdiff_t
  
#define __need_size_t
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */
  
#if !__has_feature(modules)
  
#define _SIZE_T
  
#endif
typedef __SIZE_TYPE__ size_t;
     
#endif
  
#undef __need_size_t
  
#endif /*defined(__need_size_t) */
   
#if defined(__need_STDDEF_H_misc)
/* ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is  * enabled. */
  
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
  
#if !defined(_WCHAR_T) || __has_feature(modules)
  
#if !__has_feature(modules)
  
#define _WCHAR_T
  
#if defined(_MSC_EXTENSIONS)
  
#define _WCHAR_T_DEFINED
  
#endif
  
#endif
typedef __WCHAR_TYPE__ wchar_t;
     
#  endif
  
#else
  
#  define NULL ((void*)0)
  
#endif
  
#ifdef __cplusplus
  
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std {
   typedef decltype(nullptr) nullptr_t;
   }
   using ::std::nullptr_t;
     
#endif
  
#endif
  
#undef __need_NULL
  
#endif /* defined(__need_NULL) */
   
   
#endif
   
#endif  // _LIBCPP_STDDEF_H
 __BEGIN_DECLS  /* Remove any previous definitions.  */
  
#undef	alloca
 /* Allocate a block that will be freed when the calling function exits.  */
 __END_DECLS    
#endif /* alloca.h */
  
#endif /* Use GNU, BSD, or misc.  */
   
#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \
    || defined __USE_BSD
/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
#endif
   
#ifdef __USE_ISOC11
/* ISO C variant of aligned allocation.  */
extern void *aligned_alloc (size_t __alignment, size_t __size)      __THROW __attribute_malloc__ __attribute_alloc_size__ ((2)) __wur;
     
#endif
 __BEGIN_NAMESPACE_STD /* Abort execution and generate a core-dump.  */
extern void abort (void) __THROW __attribute__ ((__noreturn__));
     /* Register a function to be called when `exit' is called.  */
extern int atexit (void (*__func) (void)) __THROW __nonnull ((1));

#if defined __USE_ISOC11 || defined __USE_ISOCXX11
/* Register a function to be called when `quick_exit' is called.  */
  
#endif
__END_NAMESPACE_STD    
#ifdef	__USE_MISC
/* Register a function to be called with the status    given to `exit' and the given argument.  */
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __THROW __nonnull ((1));
#endif

__BEGIN_NAMESPACE_STD
/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  */
extern void exit (int __status) __THROW __attribute__ ((__noreturn__));

#if defined __USE_ISOC11 || defined __USE_ISOCXX11
extern void _Exit (int __status) __THROW __attribute__ ((__noreturn__));
   __END_NAMESPACE_C99   
#endif
  __BEGIN_NAMESPACE_STD /* Return the value of envariable NAME, or NULL if it doesn't exist.  */
extern char *getenv (const char *__name) __THROW __nonnull ((1)) __wur;
__END_NAMESPACE_STD

#ifdef __USE_GNU
/* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  */
extern int clearenv (void) __THROW;
#endif


#if defined __USE_MISC \
    || (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)
/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Always returns TEMPLATE, it's either a temporary file name or a null    string if it cannot get a unique file name.  */
extern char *mktemp (char *__template) __THROW __nonnull ((1));
     
#endif
   
#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED \
    || defined __USE_XOPEN2K8
/* Generate a unique temporary file name from TEMPLATE.    The last six characters of TEMPLATE must be "XXXXXX";
      they are replaced with a string that makes the filename unique.    Returns a file descriptor open on the file for reading and writing,    or -1 if it cannot create a uniquely-named file.     This function is a possible cancellation point and therefore not    marked with __THROW.  */
  
# ifndef __USE_FILE_OFFSET64
extern int mkstemp (char *__template) __nonnull ((1)) __wur;
     
# else
  
#  ifdef __REDIRECT
extern int __REDIRECT (mkstemp, (char *__template), mkstemp64)      __nonnull ((1)) __wur;
     
#  else
  
#   define mkstemp mkstemp64
  
#  endif
  
# endif
  
/* Similar to mkstemp, but the template can have a suffix after the    XXXXXX.  The length of the suffix is specified in the second    parameter.     This function is a possible cancellation point and therefore not    marked with __THROW.  */
  
# ifndef __USE_FILE_OFFSET64
extern int mkstemps (char *__template, int __suffixlen) __nonnull ((1)) __wur;
     
# else
  
#  ifdef __REDIRECT
extern int __REDIRECT (mkstemps, (char *__template, int __suffixlen), 		       mkstemps64) __nonnull ((1)) __wur;
     
#  else
  
#   define mkstemps mkstemps64
  
#  endif
  
# endif
  
# ifdef __USE_LARGEFILE64
extern int mkstemps64 (char *__template, int __suffixlen)      __nonnull ((1)) __wur;
     
# endif
  
#endif
   
#if defined __USE_BSD || defined __USE_XOPEN2K8
/* Create a unique temporary directory from TEMPLATE.    The last six characters of TEMPLATE must be "XXXXXX";
      they are replaced with a string that makes the directory name unique.    Returns TEMPLATE, or a null pointer if it cannot get a unique name.    The directory is created mode 700.  */
extern char *mkdtemp (char *__template) __THROW __nonnull ((1)) __wur;
     
#endif
   
#ifdef __USE_GNU
/* Generate a unique temporary file name from TEMPLATE similar to    mkstemp.  But allow the caller to pass additional flags which are    used in the open call to create the file..     This function is a possible cancellation point and therefore not    marked with __THROW.  */
  
# ifndef __USE_FILE_OFFSET64
extern int mkostemp (char *__template, int __flags) __nonnull ((1)) __wur;
     
# else
  
# endif
  
# ifdef __USE_LARGEFILE64
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)      __nonnull ((1)) __wur;
     
# endif
  
#endif
  __BEGIN_NAMESPACE_STD /* Execute the given line as a shell command.     This function is a cancellation point and therefore not marked with    __THROW.  */
extern int system (const char *__command) __wur;
   __END_NAMESPACE_STD     
#ifdef	__USE_GNU
/* Return a malloc'd string containing the canonical absolute name of the
   existing named file.  */
extern char *canonicalize_file_name (const char *__name)
     __THROW __nonnull ((1)) __wur;
#endif

#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd;
   otherwise, if the canonical name is    PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  */
extern char *realpath (const char *__restrict __name,
		       char *__restrict __resolved) __THROW __wur;
#endif


/* Shorthand for type of comparison functions.  */
#ifndef __COMPAR_FN_T
# define __COMPAR_FN_T
typedef int (*__compar_fn_t) (const void *, const void *);

# ifdef	__USE_GNU
typedef __compar_fn_t comparison_fn_t;
# endif
#endif
#ifdef __USE_GNU
typedef int (*__compar_d_fn_t) (const void *, const void *, void *);
#endif

__BEGIN_NAMESPACE_STD
/* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  */
extern void *bsearch (const void *__key, const void *__base,
		      size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __nonnull ((1, 2, 5)) __wur;

#ifdef __USE_EXTERN_INLINES
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdlib-bsearch.h>
#endif /* expanded by -frewrite-includes */
#endif

/* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  */
extern void qsort (void *__base, size_t __nmemb, size_t __size,
		   __compar_fn_t __compar) __nonnull ((1, 4));
#ifdef __USE_GNU
extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
		     __compar_d_fn_t __compar, void *__arg)
  __nonnull ((1, 4));
#endif


/* Return the absolute value of X.  */
extern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;
extern long int labs (long int __x) __THROW __attribute__ ((__const__)) __wur;
__END_NAMESPACE_STD

#ifdef __USE_ISOC99
__extension__ extern long long int llabs (long long int __x)
     __THROW __attribute__ ((__const__)) __wur;
#endif


__BEGIN_NAMESPACE_STD
/* Return the `div_t', `ldiv_t' or `lldiv_t' representation    of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
extern div_t div (int __numer, int __denom)      __THROW __attribute__ ((__const__)) __wur;
   extern ldiv_t ldiv (long int __numer, long int __denom)      __THROW __attribute__ ((__const__)) __wur;
   __END_NAMESPACE_STD    
#ifdef __USE_ISOC99
__BEGIN_NAMESPACE_C99 __extension__ extern lldiv_t lldiv (long long int __numer, 				    long long int __denom)      __THROW __attribute__ ((__const__)) __wur;
   __END_NAMESPACE_C99   
#endif
    
#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \
    || defined __USE_SVID
     /* Reentrant version of the functions above which provide their own    buffers.  */
extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt, 		   int *__restrict __sign, char *__restrict __buf, 		   size_t __len) __THROW __nonnull ((3, 4, 5));
   extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt, 		   int *__restrict __sign, char *__restrict __buf, 		   size_t __len) __THROW __nonnull ((3, 4, 5));
    extern int qecvt_r (long double __value, int __ndigit, 		    int *__restrict __decpt, int *__restrict __sign, 		    char *__restrict __buf, size_t __len)      __THROW __nonnull ((3, 4, 5));
   extern int qfcvt_r (long double __value, int __ndigit, 		    int *__restrict __decpt, int *__restrict __sign, 		    char *__restrict __buf, size_t __len)      __THROW __nonnull ((3, 4, 5));
     
#endif	/* misc */
  __BEGIN_NAMESPACE_STD /* Return the length of the multibyte character    in S, which is no longer than N.  */
extern int mblen (const char *__s, size_t __n) __THROW;
   /* Return the length of the given multibyte character,    putting its `wchar_t' representation in *PWC.  */
extern int mbtowc (wchar_t *__restrict __pwc,
		   const char *__restrict __s, size_t __n) __THROW;
/* Put the multibyte character represented
   by WCHAR in S, returning its length.  */
extern int wctomb (char *__s, wchar_t __wchar) __THROW;


/* Convert a multibyte string to a wide char string.  */
extern size_t mbstowcs (wchar_t *__restrict  __pwcs,
			const char *__restrict __s, size_t __n) __THROW;
/* Convert a wide char string to multibyte string.  */
extern size_t wcstombs (char *__restrict __s,
			const wchar_t *__restrict __pwcs, size_t __n)
     __THROW;
__END_NAMESPACE_STD


#ifdef __USE_SVID
/* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if    negative, and -1 if not matching.  */
     
#endif
    
#ifdef __USE_XOPEN
/* Setup DES tables according KEY.  */
extern void setkey (const char *__key) __THROW __nonnull ((1));
     
#endif
   
#ifdef __USE_XOPEN
/* The next four functions all take a master pseudo-tty fd and    perform an operation on the associated slave:  */
 /* Chown the slave to the calling user.  */
extern int grantpt (int __fd) __THROW;
    /* Release an internal lock so the slave can be opened.    Call after grantpt().  */
extern int unlockpt (int __fd) __THROW;
    /* Return the pathname of the pseudo terminal slave associated with    the master FD is open on, or NULL on errors.    The returned storage is good until the next call to this function.  */
   __END_NAMESPACE_STD   
#endif /* Optimizing and Inlining.  */
 /* Define some macros helping to catch buffer overflows.  */
  
#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
  
#if 0 /* expanded by -frewrite-includes */
  
# include <bits/stdlib.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
  
#ifdef __LDBL_COMPAT
  
#if 0 /* expanded by -frewrite-includes */
  
# include <bits/stdlib-ldbl.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#endif /* don't just need malloc and calloc */
  
#undef __need_malloc_and_calloc
 __END_DECLS    
#endif /* stdlib.h  */
   
#ifdef __cplusplus
 extern "C++" {
      
#undef abs
  
#undef div
  
#undef labs
  
#undef ldiv
  
#ifndef _LIBCPP_HAS_NO_LONG_LONG
  
#undef llabs
  
#undef lldiv
 inline _LIBCPP_INLINE_VISIBILITY  ldiv_t div(     long __x,      long __y) _NOEXCEPT {
 return  ldiv(__x, __y);
 }
     
#ifndef _LIBCPP_HAS_NO_LONG_LONG
inline _LIBCPP_INLINE_VISIBILITY lldiv_t div(long long __x, long long __y) _NOEXCEPT {
 return lldiv(__x, __y);
 }
     
#endif // _LIBCPP_HAS_NO_LONG_LONG
  
#endif // _LIBCPP_MSVCRT / __sun__ / _AIX
 }
    // extern "C++"
   
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifdef __GNUC__
  
#define _LIBCPP_UNREACHABLE() __builtin_unreachable()
  
#else
  
#define _LIBCPP_UNREACHABLE() _VSTD::abort()
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  using ::size_t;
   using ::atexit;
   using ::exit;
   using ::_Exit;
     
#ifndef _LIBCPP_WINDOWS_STORE_APP
using ::getenv;
   using ::system;
     
#endif
using ::bsearch;
   using ::qsort;
   using ::abs;
   using ::labs;
     
#ifndef _LIBCPP_HAS_NO_LONG_LONG
using ::llabs;
     
#endif
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CSTDLIB
  
#pragma clang module end /*std.compat.cstdlib*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TYPE_TRAITS
  
#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {
        // helper class:
    template <class T, T v> struct integral_constant;
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;
   template <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;
      
#if _LIBCPP_STD_VER > 11
template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
     
#endif
 // addressof
  
#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
// itself is providing these definitions. Otherwise, we provide them.
template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY __strong _Tp* addressof(__strong _Tp& __x) _NOEXCEPT {
     return &__x;
   }
      
#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK
template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY __weak _Tp* addressof(__weak _Tp& __x) _NOEXCEPT {
     return &__x;
   }
     
#endif
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY __autoreleasing _Tp* addressof(__autoreleasing _Tp& __x) _NOEXCEPT {
     return &__x;
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY __unsafe_unretained _Tp* addressof(__unsafe_unretained _Tp& __x) _NOEXCEPT {
     return &__x;
   }
     
#endif
   
#if !defined(_LIBCPP_CXX03_LANG)
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;
     
#endif
      
#if _LIBCPP_STD_VER > 14
 template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_swappable_with     : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value> {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_swappable     : public conditional<         __is_referenceable<_Tp>::value,         is_swappable_with<             typename add_lvalue_reference<_Tp>::type,             typename add_lvalue_reference<_Tp>::type>,         false_type     >::type {
   };
    template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with     : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value> {
  return         byte(static_cast<unsigned char>(__lhs) >> __shift);
  }
      template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type   to_integer(byte __b) noexcept {
  return _Integer(__b);
  }
    }
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
   
#if defined(_LIBCPP_ABI_MICROSOFT)
  
#if 0 /* expanded by -frewrite-includes */
  
#include <vcruntime_exception.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 namespace std  // purposefully not using versioning namespace
{
      
#if !defined(_LIBCPP_ABI_MICROSOFT)
class _LIBCPP_EXCEPTION_ABI exception {
  public:     _LIBCPP_INLINE_VISIBILITY exception() _NOEXCEPT {}
      virtual ~exception() _NOEXCEPT;
      virtual const char* what() const _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI bad_exception     : public exception {
  public:     _LIBCPP_INLINE_VISIBILITY bad_exception() _NOEXCEPT {}
      virtual ~bad_exception() _NOEXCEPT;
      virtual const char* what() const _NOEXCEPT;
  };
     
#endif // !_LIBCPP_ABI_MICROSOFT
   
#if _LIBCPP_STD_VER <= 14 \
    || defined(_LIBCPP_ENABLE_CXX17_REMOVED_UNEXPECTED_FUNCTIONS) \
    || defined(_LIBCPP_BUILDING_LIBRARY)
typedef void (*unexpected_handler)();
   _LIBCPP_FUNC_VIS unexpected_handler set_unexpected(unexpected_handler) _NOEXCEPT;
   _LIBCPP_FUNC_VIS unexpected_handler get_unexpected() _NOEXCEPT;
   _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void unexpected();
     
#endif
 typedef void (*terminate_handler)();
   _LIBCPP_FUNC_VIS terminate_handler set_terminate(terminate_handler) _NOEXCEPT;
   _LIBCPP_FUNC_VIS terminate_handler get_terminate() _NOEXCEPT;
   _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void terminate() _NOEXCEPT;
    _LIBCPP_FUNC_VIS bool uncaught_exception() _NOEXCEPT;
   _LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS int uncaught_exceptions() _NOEXCEPT;
    class _LIBCPP_TYPE_VIS exception_ptr;
    _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;
   _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);
      
#ifndef _LIBCPP_ABI_MICROSOFT
 class _LIBCPP_TYPE_VIS exception_ptr {
      void* __ptr_;
  public:     _LIBCPP_INLINE_VISIBILITY exception_ptr() _NOEXCEPT : __ptr_() {}
      _LIBCPP_INLINE_VISIBILITY exception_ptr(nullptr_t) _NOEXCEPT : __ptr_() {}
       exception_ptr(const exception_ptr&) _NOEXCEPT;
      exception_ptr& operator=(const exception_ptr&) _NOEXCEPT;
      ~exception_ptr() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT     {return __ptr_ != nullptr;}
       friend _LIBCPP_INLINE_VISIBILITY     bool operator==(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT         {return __x.__ptr_ == __y.__ptr_;}
       friend _LIBCPP_INLINE_VISIBILITY     bool operator!=(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT         {return !(__x == __y);}
       friend _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;
      friend _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);
  };
    template<class _Ep> exception_ptr make_exception_ptr(_Ep __e) _NOEXCEPT {
    
#ifndef _LIBCPP_NO_EXCEPTIONS
#endif
}
      
#else // _LIBCPP_ABI_MICROSOFT
 class _LIBCPP_TYPE_VIS exception_ptr {
    
#if defined(__clang__)
  
#pragma clang diagnostic push
  
#pragma clang diagnostic ignored "-Wunused-private-field"
  
#endif
    void* __ptr1_;
      void* __ptr2_;
template <class _E> void *__GetExceptionInfo(_E);
    template<class _Ep> exception_ptr make_exception_ptr(_Ep __e) _NOEXCEPT {
    return __copy_exception_ptr(_VSTD::addressof(__e), __GetExceptionInfo(__e));
  }
      
#endif // _LIBCPP_ABI_MICROSOFT
// nested_exception
 class _LIBCPP_EXCEPTION_ABI nested_exception {
      exception_ptr __ptr_;
  public:     nested_exception() _NOEXCEPT;
  //     nested_exception(const nested_exception&) noexcept = default;
//     nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() _NOEXCEPT;
       // access functions
    _LIBCPP_NORETURN void rethrow_nested() const;
      _LIBCPP_INLINE_VISIBILITY exception_ptr nested_ptr() const _NOEXCEPT {return __ptr_;}
  };
    template <class _Tp> struct __nested     : public _Tp,       public nested_exception {
      _LIBCPP_INLINE_VISIBILITY explicit __nested(const _Tp& __t) : _Tp(__t) {}
  };
      
#ifndef _LIBCPP_NO_EXCEPTIONS
template <class _Tp, class _Up, bool> struct __throw_with_nested;
    template <class _Tp, class _Up> struct __throw_with_nested<_Tp, _Up, true> {
      _LIBCPP_NORETURN static inline _LIBCPP_ALWAYS_INLINE void   
#ifndef _LIBCPP_CXX03_LANG
    __do_throw(_Tp&& __t)   
#else
    __do_throw (_Tp& __t)   
#endif  // _LIBCPP_CXX03_LANG
    {         throw __nested<_Up>(_VSTD::forward<_Tp>(__t));     }
  };
    template <class _Tp, class _Up> struct __throw_with_nested<_Tp, _Up, false> {
      _LIBCPP_NORETURN static inline _LIBCPP_ALWAYS_INLINE void   
#ifndef _LIBCPP_CXX03_LANG
    __do_throw(_Tp&& __t)   
#else
    __do_throw (_Tp& __t)   
#endif  // _LIBCPP_CXX03_LANG
    {         throw _VSTD::forward<_Tp>(__t);     }
  };
     
#endif
 template <class _Tp> _LIBCPP_NORETURN void   
#ifndef _LIBCPP_CXX03_LANG
throw_with_nested(_Tp&& __t)   
#else
throw_with_nested (_Tp& __t)   
#endif // _LIBCPP_CXX03_LANG
{
    
#ifndef _LIBCPP_NO_EXCEPTIONS
    typedef typename decay<_Tp>::type _Up;
      static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
      __throw_with_nested<_Tp, _Up,         is_class<_Up>::value &&         !is_base_of<nested_exception, _Up>::value &&         !__libcpp_is_final<_Up>::value>::             __do_throw(_VSTD::forward<_Tp>(__t));
    
#else
    ((void)__t);
      // FIXME: Make this abort
  
#endif
}
    template <class _From, class _To> struct __can_dynamic_cast : public _LIBCPP_BOOL_CONSTANT(               is_polymorphic<_From>::value &&                  (!is_base_of<_To, _From>::value ||                    is_convertible<const _From*, const _To*>::value)) {
 };
    template <class _Ep> inline _LIBCPP_INLINE_VISIBILITY void rethrow_if_nested(const _Ep& __e,                   typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0) {
      const nested_exception* __nep = dynamic_cast<const nested_exception*>(_VSTD::addressof(__e));
      if (__nep)         __nep->rethrow_nested();
  }
    template <class _Ep> inline _LIBCPP_INLINE_VISIBILITY void rethrow_if_nested(const _Ep&,                   typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0) {
  }
    }
    // std
   
#endif  // _LIBCPP_EXCEPTION
  
#pragma clang module end /*std.exception*/
#pragma clang module begin std.iosfwd
// -*- C++ -*-
//===--------------------------- iosfwd -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_IOSFWD
  
#define _LIBCPP_IOSFWD
 /*     iosfwd synopsis  namespace std {
    }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#if 0 /* expanded by -frewrite-includes */
  
#include_next <wchar.h>
  
#endif /* expanded by -frewrite-includes */
   
#elif !defined(_LIBCPP_WCHAR_H)
  
#define _LIBCPP_WCHAR_H
 /*     wchar.h synopsis  Macros:      NULL     WCHAR_MAX     WCHAR_MIN     WEOF  Types:      mbstate_t     size_t     tm     wint_t  int fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
   int fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
   int swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
   int swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
   int vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
   int vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
   size_t mbrtowc(wchar_t* restrict pwc, const char* restrict s, size_t n, mbstate_t* restrict ps);
   size_t wcrtomb(char* restrict s, wchar_t wc, mbstate_t* restrict ps);
   size_t mbsrtowcs(wchar_t* restrict dst, const char** restrict src, size_t len,                  mbstate_t* restrict ps);
   size_t wcsrtombs(char* restrict dst, const wchar_t** restrict src, size_t len,                  mbstate_t* restrict ps);
    */
   
#if 0 /* expanded by -frewrite-includes */
#endif
   
#ifdef __cplusplus
  
#define __CORRECT_ISO_CPP_WCHAR_H_PROTO
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <wchar.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1995-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *      ISO C99 Standard: 7.24  *	Extended multibyte and wide character utilities	<wchar.h>  */
   
#ifndef _WCHAR_H
   
#if !defined __need_mbstate_t && !defined __need_wint_t
  
# define _WCHAR_H 1
  
#if 0 /* expanded by -frewrite-includes */
  
# include <features.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifdef _WCHAR_H
/* Get FILE definition.  */
  
# define __need___FILE
  
# if defined __USE_UNIX98 || defined __USE_XOPEN2K
  
#  define __need_FILE
  
# endif
  
#if 0 /* expanded by -frewrite-includes */
  
# include <stdio.h>
  
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===---------------------------- stdio.h ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#if defined(__need_FILE) || defined(__need___FILE)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
   
#if !defined __need_FILE && !defined __need___FILE
  
# define _STDIO_H	1
  
#if 0 /* expanded by -frewrite-includes */
  
# include <features.h>
  
#endif /* expanded by -frewrite-includes */
 __BEGIN_DECLS    
# define __need_size_t
  
# define __need_NULL
  
#endif /* Don't need FILE.  */
    
#if !defined __FILE_defined && defined __need_FILE
 /* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;
    __BEGIN_NAMESPACE_STD /* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;
  
#endif /* FILE not defined.  */
  
#undef	__need_FILE
    
#if !defined ____FILE_defined && defined __need___FILE
 /* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;
      
# define ____FILE_defined	1
  
#endif /* __FILE not defined.  */
  
#undef	__need___FILE
    
#ifdef	_STDIO_H

#ifdef __USE_MISC
/* This is the reentrant variant of `tmpnam'.  The only difference is    that it does not allow S to be NULL.  */
extern char *tmpnam_r (char *__s) __THROW __wur;
     
#endif
    
#if defined __USE_SVID || defined __USE_XOPEN
# define __need_getopt
#if 0 /* expanded by -frewrite-includes */
# include <getopt.h>
#endif /* expanded by -frewrite-includes */
#endif	/* X/Open, but not issue 6 and not for GNU.  */

/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */
#ifdef __USE_EXTERN_INLINES
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio.h>
#endif /* expanded by -frewrite-includes */
#endif
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio2.h>
#endif /* expanded by -frewrite-includes */
#endif
#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio-ldbl.h>
#endif /* expanded by -frewrite-includes */
#endif

__END_DECLS

#endif /* <stdio.h> included.  */

#endif /* !_STDIO_H */

#elif !defined(_LIBCPP_STDIO_H)
#define _LIBCPP_STDIO_H

/*
    stdio.h synopsis

Macros:

#include <__config>
#endif /* expanded by -frewrite-includes */

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
#endif

#if 0 /* expanded by -frewrite-includes */
#include_next <stdio.h>
#endif /* expanded by -frewrite-includes */

#ifdef __cplusplus

// snprintf
#undef clearerr
#undef feof
#undef ferror

#endif

#endif  // _LIBCPP_STDIO_H
/* Get va_list definition.  */
# define __need___va_list
#if 0 /* expanded by -frewrite-includes */
# include <stdarg.h>
#endif /* expanded by -frewrite-includes */
/*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __STDARG_H
#define __STDARG_H

#ifndef _VA_LIST
typedef __builtin_va_list va_list;
#define _VA_LIST
#endif
#define va_start(ap, param) __builtin_va_start(ap, param)
#define va_end(ap)          __builtin_va_end(ap)
#if __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
#define va_copy(dest, src)  __builtin_va_copy(dest, src)
#endif

#ifndef __GNUC_VA_LIST
#define __GNUC_VA_LIST 1
typedef __builtin_va_list __gnuc_va_list;
#endif
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
#endif

#if 0 /* expanded by -frewrite-includes */
#include_next <stddef.h>
#endif /* expanded by -frewrite-includes */
/*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 *===-----------------------------------------------------------------------===
 */

#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)

#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
/* Always define miscellaneous pieces when modules are available. */
#if !__has_feature(modules)
#define __STDDEF_H
#endif
#define __need_ptrdiff_t
 * enabled. */
#if (defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1 && \
     !defined(_RSIZE_T)) || __has_feature(modules)
/* Always define rsize_t when modules are available. */
#if !__has_feature(modules)
#define _RSIZE_T
#endif
typedef __SIZE_TYPE__ rsize_t;
#endif
#endif /* defined(__need_STDDEF_H_misc) */

#if defined(__need_wchar_t)
#ifndef __cplusplus
/* Always define wchar_t when modules are available. */
#if !defined(_WCHAR_T) || __has_feature(modules)
#endif
#endif
#undef __need_wchar_t
#endif /* defined(__need_wchar_t) */

#if defined(__need_NULL)
#undef NULL
#ifdef __cplusplus
#  if !defined(__MINGW32__) && !defined(_MSC_VER)
#    define NULL __null
#  else
#    define NULL 0
#  endif
#else
#  define NULL ((void*)0)
#endif
#ifdef __cplusplus
#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std { typedef decltype(nullptr) nullptr_t; }
using ::std::nullptr_t;
#endif
#endif
#undef __need_NULL
#endif /* defined(__need_NULL) */
__BEGIN_NAMESPACE_STD
typedef __WINT_TYPE__ wint_t;
__END_NAMESPACE_STD
#  endif
# endif

/* Tell the caller that we provide correct C++ prototypes.  */
typedef struct
{
  int __count;
  union
  {
# ifdef __WINT_TYPE__
    __WINT_TYPE__ __wch;
# else
    wint_t __wch;
# endif
    char __wchb[4];
  } __value;		/* Value so far.  */
} __mbstate_t;
#endif
#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
#ifdef _WCHAR_H

# ifndef __mbstate_t_defined
__BEGIN_NAMESPACE_C99
/* Public type.  */
typedef __mbstate_t mbstate_t;
__END_NAMESPACE_C99
#  define __mbstate_t_defined 1
# endif

#ifdef __USE_GNU
__USING_NAMESPACE_C99(mbstate_t)
#if 0 /* expanded by -frewrite-includes */
# include <wctype.h>
#endif /* expanded by -frewrite-includes */
#endif


__BEGIN_DECLS


__BEGIN_NAMESPACE_STD
/* Copy SRC to DEST.  */
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
			const wchar_t *__restrict __src) __THROW;
/* Copy no more than N wide-characters of SRC to DEST.  */
extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
			 const wchar_t *__restrict __src, size_t __n)
     __THROW;

/* Compare S1 and S2.  */
extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     __THROW __attribute_pure__;
/* Compare N wide-characters of S1 and S2.  */
extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __THROW __attribute_pure__;
__END_NAMESPACE_STD

#ifdef __USE_XOPEN2K8
/* Compare S1 and S2, ignoring case.  */
extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) __THROW;

   extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, 				     size_t __n)      __THROW __asm ("wmemchr") __attribute_pure__;
     
#else
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)      __THROW __attribute_pure__;
     
#endif
 /* Compare N wide characters of S1 and S2.  */
extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)      __THROW __attribute_pure__;
#ifdef __USE_GNU
/* Copy N wide characters of SRC to DEST and return pointer to following    wide character.  */
extern wchar_t *wmempcpy (wchar_t *__restrict __s1, 			  const wchar_t *__restrict __s2, size_t __n)      __THROW;
     
#endif
  __BEGIN_NAMESPACE_STD /* Determine whether C constitutes a valid (one-byte) multibyte    character.  */
extern wint_t btowc (int __c) __THROW;
    /* Determine whether C corresponds to a member of the extended    character set whose multibyte representation is a single byte.  */
extern int wctob (wint_t __c) __THROW;
    /* Determine whether PS points to an object representing the initial    state.  */
extern int mbsinit (const mbstate_t *__ps) __THROW __attribute_pure__;
    /* Write wide character representation of multibyte character pointed    to by S to PWC.  */
extern size_t mbrtowc (wchar_t *__restrict __pwc, 		       const char *__restrict __s, size_t __n, 		       mbstate_t *__restrict __p) __THROW;
    /* Write multibyte representation of wide character WC to S.  */
extern size_t wcrtomb (char *__restrict __s, wchar_t __wc, 		       mbstate_t *__restrict __ps) __THROW;
    /* Return number of bytes in multibyte character pointed to by S.  */
extern size_t __mbrlen (const char *__restrict __s, size_t __n, 			mbstate_t *__restrict __ps) __THROW;
   extern size_t mbrlen (const char *__restrict __s, size_t __n, 		      mbstate_t *__restrict __ps) __THROW;
   __END_NAMESPACE_STD    
#ifdef __USE_EXTERN_INLINES
/* Define inline function as optimization.  */
 /* We can use the BTOWC and WCTOB optimizations since we know that all    locales must use ASCII encoding for the values in the ASCII range    and because the wchar_t encoding is always ISO 10646.  */
extern wint_t __btowc_alias (int __c) __asm ("btowc");
   __extern_inline wint_t __NTH (btowc (int __c)) {
   return (__ps != NULL 	  ? mbrtowc (NULL, __s, __n, __ps) : __mbrlen (__s, __n, NULL));
   }
     
#endif
 __BEGIN_NAMESPACE_STD /* Write wide character representation of multibyte character string    SRC to DST.  */
extern size_t mbsrtowcs (wchar_t *__restrict __dst, 			 const char **__restrict __src, size_t __len, 			 mbstate_t *__restrict __ps) __THROW;
    /* Write multibyte character representation of wide character string    SRC to DST.  */
extern size_t wcsrtombs (char *__restrict __dst, 			 const wchar_t **__restrict __src, size_t __len, 			 mbstate_t *__restrict __ps) __THROW;
   __END_NAMESPACE_STD     
#ifdef	__USE_XOPEN2K8
/* Write wide character representation of at most NMC bytes of the    multibyte character string SRC to DST.  */
extern size_t mbsnrtowcs (wchar_t *__restrict __dst, 			  const char **__restrict __src, size_t __nmc, 			  size_t __len, mbstate_t *__restrict __ps) __THROW;
    /* Write multibyte character representation of at most NWC characters    from the wide character string SRC to DST.  */
extern size_t wcsnrtombs (char *__restrict __dst, 			  const wchar_t **__restrict __src, 			  size_t __nwc, size_t __len, 			  mbstate_t *__restrict __ps) __THROW;
     

# if defined __USE_ISOC99 && !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
#  endif
# endif

__END_NAMESPACE_C99
#endif /* Use ISO C99. */


/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
__END_NAMESPACE_STD


#ifdef __USE_GNU
extern wint_t putwchar_unlocked (wchar_t __wc);


/* This function does the same as `fgetws' but does not lock the stream.     This function is not part of POSIX and therefore no official    cancellation point.  But due to similarity with an POSIX interface    or due to the implementation it is a cancellation point and    therefore not marked with __THROW.  */
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n, 				 __FILE *__restrict __stream);
    /* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputws_unlocked (const wchar_t *__restrict __ws,
			    __FILE *__restrict __stream);
#endif


 /* Define some macros helping to catch buffer overflows.  */
  
#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
  
#if 0 /* expanded by -frewrite-includes */
  
# include <bits/wchar2.h>
  
# include <bits/wchar-ldbl.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
 __END_DECLS    
#endif	/* _WCHAR_H defined */
   
#endif /* wchar.h  */
 /* Undefine all __need_* constants in case we are included to get those    constants but the whole file was already read.  */
  
#undef __need_mbstate_t
  
#undef __need_wint_t
 // Determine whether we have const-correct overloads for wcschr and friends.
  
#if defined(_WCHAR_H_CPLUSPLUS_98_CONFORMANCE_)
  
#  define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1
  
#elif defined(__GLIBC_PREREQ)
  
#  if __GLIBC_PREREQ(2, 10)
  
#    define _LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS 1
  
#  endif
  
#endif
   
#if defined(__cplusplus) && !defined(_LIBCPP_WCHAR_H_HAS_CONST_OVERLOADS) && defined(_LIBCPP_PREFERRED_OVERLOAD)
extern "C++" {
   inline _LIBCPP_INLINE_VISIBILITY wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {
 return (wchar_t*)wcschr(__s, __c);
 }
   inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {
 return __libcpp_wcschr(__s, __c);
extern "C" {
   size_t mbsnrtowcs(wchar_t *__restrict dst, const char **__restrict src,                   size_t nmc, size_t len, mbstate_t *__restrict ps);
   size_t wcsnrtombs(char *__restrict dst, const wchar_t **__restrict src,                   size_t nwc, size_t len, mbstate_t *__restrict ps);
   }
    // extern "C++"
  
#endif  // __cplusplus && _LIBCPP_MSVCRT
   
#endif  // _LIBCPP_WCHAR_H
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  class _LIBCPP_TYPE_VIS ios_base;
    template<class _CharT>  struct _LIBCPP_TEMPLATE_VIS char_traits;
   template<class _Tp>     class _LIBCPP_TEMPLATE_VIS allocator;
    template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_ios;
    template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_streambuf;
   template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_istream;
   template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_ostream;
   template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_iostream;
    template <class _CharT, class _Traits = char_traits<_CharT>,           class _Allocator = allocator<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_stringbuf;
   template <class _CharT, class _Traits = char_traits<_CharT>,           class _Allocator = allocator<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_istringstream;
   template <class _CharT, class _Traits = char_traits<_CharT>,           class _Allocator = allocator<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_ostringstream;
   template <class _CharT, class _Traits = char_traits<_CharT>,           class _Allocator = allocator<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_stringstream;
    template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_filebuf;
   template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_ifstream;
   template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_ofstream;
   template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_fstream;
    template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS istreambuf_iterator;
   template <class _CharT, class _Traits = char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS ostreambuf_iterator;
    typedef basic_ios<char>              ios;
   typedef basic_ios<wchar_t>           wios;
    typedef basic_streambuf<char>        streambuf;
   typedef basic_istream<char>          istream;
   typedef basic_ostream<char>          ostream;
   typedef basic_iostream<char>         iostream;
    typedef basic_stringbuf<char>        stringbuf;
   typedef basic_istringstream<char>    istringstream;
   typedef basic_ostringstream<char>    ostringstream;
   typedef basic_ofstream<wchar_t>      wofstream;
   typedef basic_fstream<wchar_t>       wfstream;
    template <class _State>             class _LIBCPP_TEMPLATE_VIS fpos;
   typedef fpos<mbstate_t>    streampos;
   typedef fpos<mbstate_t>    wstreampos;
     
#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
typedef fpos<mbstate_t>    u16streampos;
   typedef fpos<mbstate_t>    u32streampos;
     
#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
   
#if defined(_NEWLIB_VERSION)
// On newlib, off_t is 'long int'
typedef long int streamoff;
           // for char_traits in <string>
  
#else
typedef long long streamoff;
          // for char_traits in <string>
  
#endif
 template <class _CharT,             // for <stdexcept>
          class _Traits = char_traits<_CharT>,           class _Allocator = allocator<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_string;
   typedef basic_string<char, char_traits<char>, allocator<char> > string;
   typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;
     // Include other forward declarations here
template <class _Tp, class _Alloc = allocator<_Tp> > class _LIBCPP_TEMPLATE_VIS vector;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_IOSFWD
  
#pragma clang module end /*std.iosfwd*/
  
#ifdef _LIBCPP_NO_EXCEPTIONS
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdlib>
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  class _LIBCPP_HIDDEN __libcpp_refstring {
       const char* __imp_;
        bool __uses_refcount() const;
   };
    _LIBCPP_END_NAMESPACE_STD  namespace std  // purposefully not using versioning namespace
{
    class _LIBCPP_EXCEPTION_ABI logic_error     : public exception {
  private:     _VSTD::__libcpp_refstring __imp_;
  public:     explicit logic_error(const string&);
      explicit logic_error(const char*);
       logic_error(const logic_error&) _NOEXCEPT;
      logic_error& operator=(const logic_error&) _NOEXCEPT;
       virtual ~logic_error() _NOEXCEPT;
       virtual const char* what() const _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI runtime_error     : public exception {
  private:     _VSTD::__libcpp_refstring __imp_;
  public:     explicit runtime_error(const string&);
      explicit runtime_error(const char*);
       runtime_error(const runtime_error&) _NOEXCEPT;
      runtime_error& operator=(const runtime_error&) _NOEXCEPT;
       virtual ~runtime_error() _NOEXCEPT;
       virtual const char* what() const _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI domain_error     : public logic_error {
  public:     _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}
      _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}
       virtual ~domain_error() _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI invalid_argument     : public logic_error {
  public:     _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}
      _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}
       virtual ~invalid_argument() _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI length_error     : public logic_error {
  public:     _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}
      _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}
       virtual ~length_error() _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI out_of_range     : public logic_error {
  public:     _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}
      _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}
       virtual ~out_of_range() _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI range_error     : public runtime_error {
  public:     _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}
      _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}
       virtual ~range_error() _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI overflow_error     : public runtime_error {
  public:     _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}
      _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}
       virtual ~overflow_error() _NOEXCEPT;
  };
    class _LIBCPP_EXCEPTION_ABI underflow_error     : public runtime_error {
  public:     _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}
      _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}
       virtual ~underflow_error() _NOEXCEPT;
  };
    }
    // std
 _LIBCPP_BEGIN_NAMESPACE_STD  // in the dylib
_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_logic_error(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw logic_error(__msg);
     
#else
    ((void)__msg);
   	  _VSTD::abort();
     
    ((void)__msg);
   	  _VSTD::abort();
     
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_invalid_argument(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw invalid_argument(__msg);
     
#else
    ((void)__msg);
   	  _VSTD::abort();
     
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_length_error(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw length_error(__msg);
     
#else
    ((void)__msg);
   	  _VSTD::abort();
     
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_out_of_range(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw out_of_range(__msg);
     
#else
    ((void)__msg);
   	  _VSTD::abort();
     
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_range_error(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw range_error(__msg);
     
#else
    ((void)__msg);
   	  _VSTD::abort();
     
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_overflow_error(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw overflow_error(__msg);
#endif
}
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_STDEXCEPT
  
#pragma clang module end /*std.stdexcept*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cmath>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cmath
// -*- C++ -*-
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CMATH
  
#define _LIBCPP_CMATH
 /*     cmath synopsis  Macros:      HUGE_VAL     HUGE_VALF               // C99
    HUGE_VALL               // C99
    INFINITY                // C99
#endif  // _LIBCPP_MATH_H
  
#pragma clang module end /*std.depr.math_h*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  using ::signbit;
   using ::fpclassify;
   using ::cosh;
   using ::coshf;
    using ::exp;
   using ::expf;
    using ::fabs;
   using ::fabsf;
   using ::floor;
   using ::floorf;
    using ::fmod;
   using ::fmodf;
    using ::frexp;
   using ::frexpf;
   using ::ldexp;
   using ::ldexpf;
    using ::log;
   using ::logf;
 template <class _A1> _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type __libcpp_isnan_or_builtin(_A1 __lcpp_x) _NOEXCEPT {
     
#if __has_builtin(__builtin_isnan)
    return __builtin_isnan(__lcpp_x);
     
#else
    return isnan(__lcpp_x);
     
#endif
}
    template <class _A1> _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type __libcpp_isnan_or_builtin(_A1 __lcpp_x) _NOEXCEPT {
       return isnan(__lcpp_x);
   }
    template <class _A1> _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type __libcpp_isinf_or_builtin(_A1 __lcpp_x) _NOEXCEPT {
     
#if __has_builtin(__builtin_isinf)
    return __builtin_isinf(__lcpp_x);
     
#else
    return isinf(__lcpp_x);
     
#endif
}
    template <class _A1> _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type __libcpp_isinf_or_builtin(_A1 __lcpp_x) _NOEXCEPT {
       return isinf(__lcpp_x);
   }
    template <class _A1> _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR typename enable_if<is_floating_point<_A1>::value, bool>::type __libcpp_isfinite_or_builtin(_A1 __lcpp_x) _NOEXCEPT {
     
#if __has_builtin(__builtin_isfinite)
    return __builtin_isfinite(__lcpp_x);
     
#else
    return isfinite(__lcpp_x);
     
#endif
}
    template <class _A1> _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR typename enable_if<!is_floating_point<_A1>::value, bool>::type __libcpp_isfinite_or_builtin(_A1 __lcpp_x) _NOEXCEPT {
       return isfinite(__lcpp_x);
   }
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CMATH
  
#pragma clang module end /*std.compat.cmath*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <sstream>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.sstream
// -*- C++ -*-
//===--------------------------- sstream ----------------------------------===//
#ifndef _LIBCPP_SSTREAM
  
#define _LIBCPP_SSTREAM
 /*     sstream synopsis  template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> > class basic_stringbuf     : public basic_streambuf<charT, traits> {
   public:     typedef charT                          char_type;
       typedef traits                         traits_type;
       typedef typename traits_type::int_type int_type;
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.ostream
// -*- C++ -*-
//===-------------------------- ostream -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_OSTREAM
  
#define _LIBCPP_OSTREAM
 /*     ostream synopsis  template <class charT, class traits = char_traits<charT> > class basic_ostream     : virtual public basic_ios<charT,traits> {
   public:     // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
       typedef traits                         traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
  
#include <ios>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.ios
// -*- C++ -*-
   
#ifndef _LIBCPP_IOS
  
#define _LIBCPP_IOS
 /*     ios synopsis    
#include <iosfwd>
 namespace std {
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__locale
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP___LOCALE
  
  
#pragma clang module begin std.string
// -*- C++ -*-
//===--------------------------- string -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_STRING
  
#define _LIBCPP_STRING
 /*     string synopsis  namespace std {
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.string_view
// -*- C++ -*-
//===------------------------ string_view ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_STRING_VIEW
  
#define _LIBCPP_STRING_VIEW
 /* string_view synopsis  namespace std {
        // 7.2, Class template basic_string_view
    template<class charT, class traits = char_traits<charT>>         class basic_string_view;
        // 7.9, basic_string_view non-member comparison functions
    template<class charT, class traits>     constexpr bool operator==(basic_string_view<charT, traits> x,                               basic_string_view<charT, traits> y) noexcept;
       template<class charT, class traits>     constexpr bool operator!=(basic_string_view<charT, traits> x,                               basic_string_view<charT, traits> y) noexcept;
       template<class charT, class traits>     constexpr bool operator< (basic_string_view<charT, traits> x,                                  basic_string_view<charT, traits> y) noexcept;
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__string
// -*- C++ -*-
//===-------------------------- __string ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP___STRING
  
#define _LIBCPP___STRING
 /*     string synopsis  namespace std {
    template <class charT> struct char_traits {
       typedef charT     char_type;
       typedef ...       int_type;
       typedef streamoff off_type;
       typedef streampos pos_type;
  
#include <algorithm>  // for search and min
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.algorithm
// -*- C++ -*-
//===-------------------------- algorithm ---------------------------------===//
   
#ifndef _LIBCPP_ALGORITHM
  
#define _LIBCPP_ALGORITHM
 /*     algorithm synopsis    
#include <initializer_list>
 namespace std {
    template <class InputIterator, class Predicate>     bool     all_of(InputIterator first, InputIterator last, Predicate pred);
    }
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstring>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cstring
// -*- C++ -*-
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CSTRING
  
#define _LIBCPP_CSTRING
 /*     cstring synopsis  Macros:      NULL  namespace std {
    Types:      size_t  void* memcpy(void* restrict s1, const void* restrict s2, size_t n);
   void* memmove(void* s1, const void* s2, size_t n);
#include <string.h>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.depr.string_h
// -*- C++ -*-
//===--------------------------- string.h ---------------------------------===//
//
#ifndef _LIBCPP_STRING_H
  
#define _LIBCPP_STRING_H
 /*     string.h synopsis  Macros:      NULL  Types:      size_t  void* memcpy(void* restrict s1, const void* restrict s2, size_t n);
   void* memmove(void* s1, const void* s2, size_t n);
   char* strcpy (char* restrict s1, const char* restrict s2);
   char* strncpy(char* restrict s1, const char* restrict s2, size_t n);
   char* strcat (char* restrict s1, const char* restrict s2);
    */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
   
#endif  // _LIBCPP_STRING_H
  
#pragma clang module end /*std.depr.string_h*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  using ::size_t;
   using ::memcpy;
   using ::memmove;
   using ::strcpy;
   using ::strncpy;
   using ::strcat;
   using ::strncat;
   using ::memcmp;
   using ::strcmp;
using ::memset;
   using ::strerror;
   using ::strlen;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CSTRING
  
#pragma clang module end /*std.compat.cstring*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <utility> // needed to provide swap_ranges.
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.utility
// -*- C++ -*-
   
#ifndef _LIBCPP_UTILITY
  
#define _LIBCPP_UTILITY
 /*     utility synopsis  namespace std {
    template <class T>     void     swap(T& a, T& b);
    namespace rel_ops {
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__tuple
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP___TUPLE
  
  
#pragma clang module begin std.compat.cstddef
// -*- C++ -*-
//===--------------------------- cstddef ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CSTDDEF
  
#define _LIBCPP_CSTDDEF
 /*     cstddef synopsis  Macros:      offsetof(type,member-designator)     NULL  namespace std {
#include <__config>
  
#endif /* expanded by -frewrite-includes */
   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array     : public false_type {
  };
   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[]>     : public true_type {
  };
   template <class _Tp, size_t _Np> struct _LIBCPP_TEMPLATE_VIS is_array<_Tp[_Np]>     : public true_type {
 template <class _Tp> struct __libcpp_is_pointer       : public false_type {
  };
   template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {
  };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_pointer     : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {
  };
      
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
     
#endif
 // is_same
 template <class _Tp, class _Up> struct _LIBCPP_TEMPLATE_VIS is_same           : public false_type {
  };
   template <class _Tp>            struct _LIBCPP_TEMPLATE_VIS is_same<_Tp, _Tp> : public true_type {
  };
      
   template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {
  };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_member_pointer     : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {
  };
      
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_member_pointer_v     = is_member_pointer<_Tp>::value;
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#endif
  _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size;
      
#if !defined(_LIBCPP_CXX03_LANG)
template <class _Tp, class...> using __enable_if_tuple_size_imp = _Tp;
    template <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<__enable_if_tuple_size_imp<     const _Tp,     typename enable_if<!is_volatile<_Tp>::value>::type,     integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>     : public integral_constant<size_t, tuple_size<_Tp>::value> {
  };
    template <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<__enable_if_tuple_size_imp<     volatile _Tp,     typename enable_if<!is_const<_Tp>::value>::type,     integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>     : public integral_constant<size_t, tuple_size<_Tp>::value> {
  };
    template <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<__enable_if_tuple_size_imp<     const volatile _Tp,     integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>     : public integral_constant<size_t, tuple_size<_Tp>::value> {
  };
      
#else
template <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<const _Tp> : public tuple_size<_Tp> {
  };
   template <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<volatile _Tp> : public tuple_size<_Tp> {
  };
   template <class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<const volatile _Tp> : public tuple_size<_Tp> {
  };
     
#endif
 template <size_t _Ip, class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_element;
    template <size_t _Ip, class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, const _Tp> {
   public:     typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
   };
    template <size_t _Ip, class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, volatile _Tp> {
   public:     typedef typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
   };
    template <size_t _Ip, class _Tp> class _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, const volatile _Tp> {
   public:     typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
   };
    template <class _Tp> struct __tuple_like : false_type {
  };
    template <class _Tp> struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {
  };
   template <class _Tp> struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {
  };
   template <class _Tp> struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {
  };
    // tuple specializations
   
#ifndef _LIBCPP_CXX03_LANG
 template <size_t...> struct __tuple_indices {
  };
    template <class _IdxType, _IdxType... _Values> struct __integer_sequence {
     template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>   using __convert = _ToIndexSeq<_ToIndexType, _Values...>;
      template <size_t _Sp>   using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
   };
      
#if !__has_builtin(__make_integer_seq) || defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)
namespace __detail {
    template<typename _Tp, size_t ..._Extra> struct __repeat;
   template<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<__integer_sequence<_Tp, _Np...>, _Extra...> {
     typedef __integer_sequence<_Tp,                            _Np...,                            sizeof...(_Np) + _Np...,                            2 * sizeof...(_Np) + _Np...,                            3 * sizeof...(_Np) + _Np...,                            4 * sizeof...(_Np) + _Np...,                            5 * sizeof...(_Np) + _Np...,                            6 * sizeof...(_Np) + _Np...,                            7 * sizeof...(_Np) + _Np...,                            _Extra...> type;
   // namespace detail
   
#endif  // !__has_builtin(__make_integer_seq) || defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)
   
#if __has_builtin(__make_integer_seq)
template <size_t _Ep, size_t _Sp> using __make_indices_imp =     typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template     __to_tuple_indices<_Sp>;
     
#else
template <size_t _Ep, size_t _Sp> using __make_indices_imp =     typename __detail::__make<_Ep - _Sp>::type::template __to_tuple_indices<_Sp>;
      
#endif
 template <size_t _Ep, size_t _Sp = 0> struct __make_tuple_indices {
       static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
       typedef __make_indices_imp<_Ep, _Sp> type;
   };
     template <class ..._Tp> class _LIBCPP_TEMPLATE_VIS tuple;
    template <size_t _Ip, class ..._Tp> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const typename tuple_element<_Ip, tuple<_Tp...> >::type&& get(const tuple<_Tp...>&&) _NOEXCEPT;
      
#endif // !defined(_LIBCPP_CXX03_LANG)
 // pair specializations
 template <class _T1, class _T2> struct __tuple_like<pair<_T1, _T2> > : true_type {
  };
    template <size_t _Ip, class _T1, class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 typename tuple_element<_Ip, pair<_T1, _T2> >::type& get(pair<_T1, _T2>&) _NOEXCEPT;
    template <size_t _Ip, class _T1, class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const typename tuple_element<_Ip, pair<_T1, _T2> >::type& get(const pair<_T1, _T2>&) _NOEXCEPT;
      
#ifndef _LIBCPP_CXX03_LANG
template <size_t _Ip, class _T1, class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 typename tuple_element<_Ip, pair<_T1, _T2> >::type&& get(pair<_T1, _T2>&&) _NOEXCEPT;
    template <size_t _Ip, class _T1, class _T2> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const typename tuple_element<_Ip, pair<_T1, _T2> >::type&& get(const pair<_T1, _T2>&&) _NOEXCEPT;
     
#endif
 // array specializations
 template <class _Tp, size_t _Size> struct _LIBCPP_TEMPLATE_VIS array;
    template <class _Tp, size_t _Size> struct __tuple_like<array<_Tp, _Size> > : true_type {
  };
    template <size_t _Ip, class _Tp, size_t _Size> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp& get(array<_Tp, _Size>&) _NOEXCEPT;
    template <size_t _Ip, class _Tp, size_t _Size> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Tp& get(const array<_Tp, _Size>&) _NOEXCEPT;
      
#ifndef _LIBCPP_CXX03_LANG
template <size_t _Ip, class _Tp, size_t _Size> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp&& get(array<_Tp, _Size>&&) _NOEXCEPT;
    template <size_t _Ip, class _Tp, size_t _Size> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Tp&& get(const array<_Tp, _Size>&&) _NOEXCEPT;
     
#endif
   
#ifndef _LIBCPP_CXX03_LANG
 // __tuple_types
 template <class ..._Tp> struct __tuple_types {
  };
      
#if !__has_builtin(__type_pack_element)
 namespace __indexer_detail {
    template <size_t _Idx, class _Tp> struct __indexed {
   using type = _Tp;
   };
    template <class _Types, class _Indexes> struct __indexer;
    template <class ..._Types, size_t ..._Idx> struct __indexer<__tuple_types<_Types...>, __tuple_indices<_Idx...>>     : __indexed<_Idx, _Types>... {
     
#endif
 template <size_t _Ip, class ..._Types> class _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, __tuple_types<_Types...>> {
   public:     static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
       typedef __type_pack_element<_Ip, _Types...> type;
   };
     template <class ..._Tp> class _LIBCPP_TEMPLATE_VIS tuple_size<__tuple_types<_Tp...> >     : public integral_constant<size_t, sizeof...(_Tp)> {
   };
    template <class... _Tp> struct __tuple_like<__tuple_types<_Tp...> > : true_type {
  };
    template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile> struct __apply_cv_mf;
   template <> struct __apply_cv_mf<false, false, false> {
     template <class _Tp> using __apply = _Tp;
   };
   template <> struct __apply_cv_mf<false, true, false> {
     template <class _Tp> using __apply = const _Tp;
   };
   template <> struct __apply_cv_mf<false, false, true> {
     template <class _Tp> using __apply = volatile _Tp;
   };
   template <> struct __apply_cv_mf<false, true, true> {
     template <class _Tp> using __apply = const volatile _Tp;
   };
   template <> struct __apply_cv_mf<true, false, false> {
     template <class _Tp> using __apply = _Tp&;
   };
   template <> struct __apply_cv_mf<true, true, false> {
     template <class _Tp> using __apply = const _Tp&;
   };
   template <> struct __apply_cv_mf<true, false, true> {
     template <class _Tp> using __apply = volatile _Tp&;
   };
   template <> struct __apply_cv_mf<true, true, true> {
     template <class _Tp> using __apply = const volatile _Tp&;
   };
   template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type> using __apply_cv_t = __apply_cv_mf<     is_lvalue_reference<_Tp>::value,     is_const<_RawTp>::value,     is_volatile<_RawTp>::value>;
    // __make_tuple_types
 // __make_tuple_types<_Tuple<_Types...>, _Ep, _Sp>::type is a
// __tuple_types<_Types...> using only those _Types in the range [_Sp, _Ep).
// _Sp defaults to 0 and _Ep defaults to tuple_size<_Tuple>.  If _Tuple is a
// lvalue_reference type, then __tuple_types<_Types&...> is the result.
 template <class _TupleTypes, class _TupleIndices> struct __make_tuple_types_flat;
    template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx> struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {
     // Specialization for pair, tuple, and __tuple_types
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>   using __apply_quals = __tuple_types<       typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...     >;
   };
    template <class _Vt, size_t _Np, size_t ..._Idx> struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
     template <size_t>   using __value_type = _Vt;
     template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>   using __apply_quals = __tuple_types<       typename _ApplyFn::template __apply<__value_type<_Idx>>...     >;
   };
    template <class _Tp, size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,           size_t _Sp = 0,           bool _SameSize = (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)> struct __make_tuple_types {
       static_assert(_Sp <= _Ep, "__make_tuple_types input error");
       using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
       using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
   };
    template <bool ..._Preds> struct __all_dummy;
    template <bool ..._Pred> using __all = is_same<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;
    struct __tuple_sfinae_base {
     template <template <class, class...> class _Trait,             class ..._LArgs, class ..._RArgs>   static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)     -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{
  true}
  ...>;
     template <template <class...> class>   static auto __do_test(...) -> false_type;
      template <class _FromArgs, class _ToArgs>   using __constructible = decltype(__do_test<is_constructible>(_ToArgs{
  }
  , _FromArgs{
  }
  ));
     template <class _FromArgs, class _ToArgs>   using __convertible = decltype(__do_test<is_convertible>(_FromArgs{
  }
  , _ToArgs{
  }
  ));
     template <class _FromArgs, class _ToArgs>   using __assignable = decltype(__do_test<is_assignable>(_ToArgs{
  }
  , _FromArgs{
  }
  ));
   };
    // __tuple_convertible
 template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,                                 bool = __tuple_like<_Up>::value> struct __tuple_convertible     : public false_type {
  };
    template <class _Tp, class _Up> struct __tuple_convertible<_Tp, _Up, true, true>     : public __tuple_sfinae_base::__convertible<       typename __make_tuple_types<_Tp>::type     , typename __make_tuple_types<_Up>::type     > {
  };
    // __tuple_constructible
 template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,                                 bool = __tuple_like<_Up>::value> struct __tuple_constructible     : public false_type {
  };
    template <class _Tp, class _Up> struct __tuple_constructible<_Tp, _Up, true, true>     : public __tuple_sfinae_base::__constructible<       typename __make_tuple_types<_Tp>::type     , typename __make_tuple_types<_Up>::type     > {
  };
    // __tuple_assignable
 template <class _Tp, class _Up, bool = __tuple_like<typename remove_reference<_Tp>::type>::value,                                 bool = __tuple_like<_Up>::value> struct __tuple_assignable     : public false_type {
  };
    template <class _Tp, class _Up> struct __tuple_assignable<_Tp, _Up, true, true>     : public __tuple_sfinae_base::__assignable<       typename __make_tuple_types<_Tp>::type     , typename __make_tuple_types<_Up&>::type     > {
  };
     template <size_t _Ip, class ..._Tp> class _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, tuple<_Tp...> > {
   public:     typedef typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
   };
      
#if _LIBCPP_STD_VER > 11
template <size_t _Ip, class ..._Tp> using tuple_element_t = typename tuple_element <_Ip, _Tp...>::type;
     
#endif
 template <bool _IsTuple, class _SizeTrait, size_t _Expected> struct __tuple_like_with_size_imp : false_type {
  };
    template <class _SizeTrait, size_t _Expected> struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>     : integral_constant<bool, _SizeTrait::value == _Expected> {
  };
    template <class _Tuple, size_t _ExpectedSize,           class _RawTuple = typename __uncvref<_Tuple>::type> using __tuple_like_with_size = __tuple_like_with_size_imp<                                    __tuple_like<_RawTuple>::value,                                    tuple_size<_RawTuple>, _ExpectedSize                               >;
    struct _LIBCPP_TYPE_VIS __check_tuple_constructor_fail {
       template <class ...>     static constexpr bool __enable_default() {
   return false;
   }
       template <class ...>     static constexpr bool __enable_explicit() {
   return false;
   }
       template <class ...>     static constexpr bool __enable_implicit() {
   return false;
   }
       template <class ...>     static constexpr bool __enable_assign() {
   return false;
   }
   };
     
#endif // !defined(_LIBCPP_CXX03_LANG)
   
#if _LIBCPP_STD_VER > 14
 template <bool _CanCopy, bool _CanMove> struct __sfinae_ctor_base {
  };
   template <> struct __sfinae_ctor_base<false, false> {
     __sfinae_ctor_base() = default;
     __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
     __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
   };
    template <bool _CanCopy, bool _CanMove> struct __sfinae_assign_base {
  };
   template <> struct __sfinae_assign_base<false, false> {
     __sfinae_assign_base() = default;
     __sfinae_assign_base(__sfinae_assign_base const&) = default;
     __sfinae_assign_base(__sfinae_assign_base &&) = default;
     __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
   };
     
#endif // _LIBCPP_STD_VER > 14
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP___TUPLE
  
#pragma clang module end /*std.__tuple*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TYPE_TRAITS
  
#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {
        // helper class:
    template <class T, T v> struct integral_constant;
           // C++17
      template<class B> struct negation;
                                   // C++17
      template<class B>          constexpr bool negation_v = negation<B>::value;
                    // C++17
 }
    */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
 // __uncvref
 template <class _Tp> struct __uncvref  {
       typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
   };
    template <class _Tp> struct __unconstref {
       typedef typename remove_const<typename remove_reference<_Tp>::type>::type type;
   
#if _LIBCPP_DEBUG_LEVEL >= 1 || defined(_LIBCPP_BUILDING_LIBRARY)
class _LIBCPP_EXCEPTION_ABI __libcpp_debug_exception : public exception {
   public:   __libcpp_debug_exception() _NOEXCEPT;
     explicit __libcpp_debug_exception(__libcpp_debug_info const& __i);
     __libcpp_debug_exception(__libcpp_debug_exception const&);
     ~__libcpp_debug_exception() _NOEXCEPT;
       __i_node** end_;
       __i_node** cap_;
      
#ifndef _LIBCPP_CXX03_LANG
    __c_node(const __c_node&) = delete;
       __c_node& operator=(const __c_node&) = delete;
     
#else
   public:   
#endif
    ~__libcpp_db();
        class __db_c_iterator;
       class __db_c_const_iterator;
       class __db_i_iterator;
       class __db_i_const_iterator;
#endif // _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  namespace rel_ops {
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const _Tp& __x, const _Tp& __y) {
       return !(__x == __y);
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool operator> (const _Tp& __x, const _Tp& __y) {
       return __y < __x;
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool operator<=(const _Tp& __x, const _Tp& __y) {
       return !(__y < __x);
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool operator>=(const _Tp& __x, const _Tp& __y) {
       return !(__x < __y);
   }
    }
    // rel_ops
 // swap_ranges
  template <class _ForwardIterator1, class _ForwardIterator2> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
       for(;
   __first1 != __last1;
   ++__first1, (void) ++__first2)         swap(*__first1, *__first2);
       return __first2;
   }
    // forward declared in <type_traits>
template<class _Tp, size_t _Np> inline _LIBCPP_INLINE_VISIBILITY typename enable_if<     __is_swappable<_Tp>::value >::type swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value) {
       _VSTD::swap_ranges(__a, __a + _Np, __b);
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11   
#ifndef _LIBCPP_CXX03_LANG
typename conditional <     !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,     const _Tp&,     _Tp&& >::type   
#else  // _LIBCPP_CXX03_LANG
const _Tp&   
#endif
move_if_noexcept(_Tp& __x) _NOEXCEPT {
       return _VSTD::move(__x);
   }
      
#if _LIBCPP_STD_VER > 14
template <class _Tp> constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept {
   return __t;
   }
   template <class _Tp>                        void as_const(const _Tp&&) = delete;
     
#endif
 struct _LIBCPP_TEMPLATE_VIS piecewise_construct_t {
   };
     
#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_UTILITY)
extern const piecewise_construct_t piecewise_construct;
  // = piecewise_construct_t();
  
#else
constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
     
#endif
   
#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)
struct __non_trivially_copyable_base {
     _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY   __non_trivially_copyable_base() _NOEXCEPT {
  }
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY   __non_trivially_copyable_base(__non_trivially_copyable_base const&) _NOEXCEPT {
  }
   };
     
#endif
 template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair   
#if defined(_LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR)
: private __non_trivially_copyable_base   
#endif
{
       typedef _T1 first_type;
       typedef _T2 second_type;
        _T1 first;
       _T2 second;
      
#if !defined(_LIBCPP_CXX03_LANG)
    pair(pair const&) = default;
       pair(pair&&) = default;
     
#else
  // Use the implicitly declared copy constructor in C++03
  
#endif
   
#ifdef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     pair() : first(), second() {
           second = __p.second;
           return *this;
       }
     
#else
    template <bool _Val>     using _EnableB = typename enable_if<_Val, bool>::type;
        struct _CheckArgs {
         template <class _U1, class _U2>       static constexpr bool __enable_default() {
             return is_default_constructible<_U1>::value               && is_default_constructible<_U2>::value;
         }
          template <class _U1, class _U2>       static constexpr bool __enable_explicit() {
             return is_constructible<first_type, _U1>::value               && is_constructible<second_type, _U2>::value               && (!is_convertible<_U1, first_type>::value                   || !is_convertible<_U2, second_type>::value);
         }
          template <class _U1, class _U2>       static constexpr bool __enable_implicit() {
             return is_constructible<first_type, _U1>::value               && is_constructible<second_type, _U2>::value               && is_convertible<_U1, first_type>::value               && is_convertible<_U2, second_type>::value;
         }
       };
        template <bool _MaybeEnable>     using _CheckArgsDep = typename conditional<       _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;
        struct _CheckTupleLikeConstructor {
           template <class _Tuple>         static constexpr bool __enable_implicit() {
               return __tuple_convertible<_Tuple, pair>::value;
           }
            template <class _Tuple>         static constexpr bool __enable_explicit() {
               return __tuple_constructible<_Tuple, pair>::value                && !__tuple_convertible<_Tuple, pair>::value;
           }
            template <class _Tuple>         static constexpr bool __enable_assign() {
               return __tuple_assignable<_Tuple, pair>::value;
           }
       };
        template <class _Tuple>     using _CheckTLC = typename conditional<         __tuple_like_with_size<_Tuple, 2>::value             && !is_same<typename decay<_Tuple>::type, pair>::value,         _CheckTupleLikeConstructor,         __check_tuple_constructor_fail     >::type;
        template<bool _Dummy = true, _EnableB<             _CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()     > = false>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     pair() : first(), second() {
  }
        template <bool _Dummy = true, _EnableB<              _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()     > = false>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     explicit pair(_T1 const& __t1, _T2 const& __t2)         : first(__t1), second(__t2) {
  }
        template<bool _Dummy = true, _EnableB<             _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()     > = false>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     pair(_T1 const& __t1, _T2 const& __t2)         : first(__t1), second(__t2) {
  }
        template<class _U1, class _U2, _EnableB<              _CheckArgs::template __enable_explicit<_U1, _U2>()     > = false>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     explicit pair(_U1&& __u1, _U2&& __u2)         : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {
  }
        template<class _U1, class _U2, _EnableB<             _CheckArgs::template __enable_implicit<_U1, _U2>()     > = false>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     pair(_U1&& __u1, _U2&& __u2)         : first(_VSTD::forward<_U1>(__u1)), second(_VSTD::forward<_U2>(__u2)) {
  }
        template<class _U1, class _U2, _EnableB<             _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()     > = false>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     explicit pair(pair<_U1, _U2> const& __p)         : first(__p.first), second(__p.second) {
  }
        template<class _U1, class _U2, _EnableB<             _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()     > = false>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     pair(pair<_U1, _U2> const& __p)         : first(__p.first), second(__p.second) {
  }
        template<class _U1, class _U2, _EnableB<             _CheckArgs::template __enable_explicit<_U1, _U2>()     > = false>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     explicit pair(pair<_U1, _U2>&&__p)         : first(_VSTD::forward<_U1>(__p.first)), second(_VSTD::forward<_U2>(__p.second)) {
  }
        _LIBCPP_INLINE_VISIBILITY     pair& operator=(typename conditional<                         is_copy_assignable<first_type>::value &&                         is_copy_assignable<second_type>::value,                     pair, __nat>::type const& __p)         _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&                    is_nothrow_copy_assignable<second_type>::value)     {
           first = __p.first;
           second = __p.second;
           return *this;
       }
        _LIBCPP_INLINE_VISIBILITY     pair& operator=(typename conditional<                         is_move_assignable<first_type>::value &&                         is_move_assignable<second_type>::value,                     pair, __nat>::type&& __p)         _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&                    is_nothrow_move_assignable<second_type>::value)     {
           first = _VSTD::forward<first_type>(__p.first);
           second = _VSTD::forward<second_type>(__p.second);
           return *this;
       }
        template <class _Tuple, _EnableB<             _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()      > = false>     _LIBCPP_INLINE_VISIBILITY     pair& operator=(_Tuple&& __p) {
           first = _VSTD::get<0>(_VSTD::forward<_Tuple>(__p));
           second = _VSTD::get<1>(_VSTD::forward<_Tuple>(__p));
           return *this;
       }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     void     swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&                                __is_nothrow_swappable<second_type>::value)     {
           using _VSTD::swap;
           swap(first,  __p.first);
           swap(second, __p.second);
       }
   private:    
#ifndef _LIBCPP_CXX03_LANG
    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>         _LIBCPP_INLINE_VISIBILITY         pair(piecewise_construct_t,              tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,              __tuple_indices<_I1...>, __tuple_indices<_I2...>);
     
#endif
};
    template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y) {
       return __x.first == __y.first && __x.second == __y.second;
   }
    template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y) {
       return !(__x == __y);
   }
    template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y) {
       return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
   }
    template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y) {
       return __y < __x;
       __x.swap(__y);
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp> struct __make_pair_return_impl {
       typedef _Tp type;
   };
    template <class _Tp> struct __make_pair_return_impl<reference_wrapper<_Tp>> {
       typedef _Tp& type;
   };
    template <class _Tp> struct __make_pair_return {
       typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;
   };
    template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type> make_pair(_T1&& __t1, _T2&& __t2) {
       return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>                (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));
   }
      
#else  // _LIBCPP_CXX03_LANG
 template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY pair<_T1,_T2> make_pair(_T1 __x, _T2 __y) {
       return pair<_T1, _T2>(__x, __y);
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _T1, class _T2>   class _LIBCPP_TEMPLATE_VIS tuple_size<pair<_T1, _T2> >     : public integral_constant<size_t, 2> {
  };
    template <size_t _Ip, class _T1, class _T2> class _LIBCPP_TEMPLATE_VIS tuple_element<_Ip, pair<_T1, _T2> > {
       static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
   };
    template <class _T1, class _T2> class _LIBCPP_TEMPLATE_VIS tuple_element<0, pair<_T1, _T2> > {
   public:     typedef _T1 type;
   };
    template <class _T1, class _T2> class _LIBCPP_TEMPLATE_VIS tuple_element<1, pair<_T1, _T2> > {
   public:     typedef _T2 type;
   };
    template <size_t _Ip> struct __get_pair;
    template <> struct __get_pair<0> {
       template <class _T1, class _T2>     static     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     _T1&     get(pair<_T1, _T2>& __p) _NOEXCEPT {
  return __p.first;
  }
        template <class _T1, class _T2>     static     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     const _T1&     get(const pair<_T1, _T2>& __p) _NOEXCEPT {
  return __p.first;
  }
      
#ifndef _LIBCPP_CXX03_LANG
    template <class _T1, class _T2>     static     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     _T1&&     get(pair<_T1, _T2>&& __p) _NOEXCEPT {
  return _VSTD::forward<_T1>(__p.first);
  }
        template <class _T1, class _T2>     static     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     const _T1&&     get(const pair<_T1, _T2>&& __p) _NOEXCEPT {
  return _VSTD::forward<const _T1>(__p.first);
  }
     
#endif  // _LIBCPP_CXX03_LANG
};
    template <> struct __get_pair<1> {
       template <class _T1, class _T2>     static     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     _T2&     get(pair<_T1, _T2>& __p) _NOEXCEPT {
  return __p.second;
  }
        template <class _T1, class _T2>     static     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     const _T2&     get(const pair<_T1, _T2>& __p) _NOEXCEPT {
  return __p.second;
  }
      
#ifndef _LIBCPP_CXX03_LANG
    template <class _T1, class _T2>     static     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     _T2&&     get(pair<_T1, _T2>&& __p) _NOEXCEPT {
  return _VSTD::forward<_T2>(__p.second);
  }
        template <class _T1, class _T2>     static     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     const _T2&&     get(const pair<_T1, _T2>&& __p) _NOEXCEPT {
  return _VSTD::forward<const _T2>(__p.second);
  }
     
#endif  // _LIBCPP_CXX03_LANG
};
    template <size_t _Ip, class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 typename tuple_element<_Ip, pair<_T1, _T2> >::type& get(pair<_T1, _T2>& __p) _NOEXCEPT {
       return __get_pair<_Ip>::get(__p);
   }
    template <size_t _Ip, class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const typename tuple_element<_Ip, pair<_T1, _T2> >::type& get(const pair<_T1, _T2>& __p) _NOEXCEPT {
       return __get_pair<_Ip>::get(__p);
   }
      
#ifndef _LIBCPP_CXX03_LANG
template <size_t _Ip, class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 typename tuple_element<_Ip, pair<_T1, _T2> >::type&& get(pair<_T1, _T2>&& __p) _NOEXCEPT {
       return __get_pair<_Ip>::get(_VSTD::move(__p));
   }
    template <size_t _Ip, class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const typename tuple_element<_Ip, pair<_T1, _T2> >::type&& get(const pair<_T1, _T2>&& __p) _NOEXCEPT {
   }
    template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY constexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT {
       return __get_pair<1>::get(_VSTD::move(__p));
   }
    template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY constexpr _T1 const && get(pair<_T2, _T1> const&& __p) _NOEXCEPT {
       return __get_pair<1>::get(_VSTD::move(__p));
   }
      
#endif
   
#if _LIBCPP_STD_VER > 11
 template<class _Tp, _Tp... _Ip> struct _LIBCPP_TEMPLATE_VIS integer_sequence {
       typedef _Tp value_type;
       static_assert( is_integral<_Tp>::value,                   "std::integer_sequence can only be instantiated with an integral type" );
       static     _LIBCPP_INLINE_VISIBILITY     constexpr     size_t     size() noexcept {
   return sizeof...(_Ip);
   }
   };
    template<size_t... _Ip>     using index_sequence = integer_sequence<size_t, _Ip...>;
      
#if __has_builtin(__make_integer_seq) && !defined(_LIBCPP_TESTING_FALLBACK_MAKE_INTEGER_SEQUENCE)
 template <class _Tp, _Tp _Ep> using __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;
      
#else
 template<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =   typename __detail::__make<_Np>::type::template __convert<integer_sequence, _Tp>;
    template <class _Tp, _Tp _Ep> struct __make_integer_sequence_checked {
       static_assert(is_integral<_Tp>::value,                   "std::make_integer_sequence can only be instantiated with an integral type" );
       static_assert(0 <= _Ep, "std::make_integer_sequence must have a non-negative sequence length");
       // Workaround GCC bug by preventing bad installations when 0 <= _Ep
    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68929
    typedef __make_integer_sequence_unchecked<_Tp, 0 <= _Ep ? _Ep : 0> type;
   };
    template <class _Tp, _Tp _Ep> using __make_integer_sequence = typename __make_integer_sequence_checked<_Tp, _Ep>::type;
      
#endif
 template<class _Tp, _Tp _Np>     using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;
    template<size_t _Np>     using make_index_sequence = make_integer_sequence<size_t, _Np>;
    template<class... _Tp>     using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;
      
#endif  // _LIBCPP_STD_VER > 11
   
#if _LIBCPP_STD_VER > 11
template<class _T1, class _T2 = _T1> inline _LIBCPP_INLINE_VISIBILITY _T1 exchange(_T1& __obj, _T2 && __new_value) {
       _T1 __old_value = _VSTD::move(__obj);
       __obj = _VSTD::forward<_T2>(__new_value);
       return __old_value;
   }
     
#endif  // _LIBCPP_STD_VER > 11
   
#if _LIBCPP_STD_VER > 14
 struct _LIBCPP_TYPE_VIS in_place_t {
       explicit in_place_t() = default;
   };
     
#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES
inline   
#endif
constexpr in_place_t in_place{
  };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS in_place_type_t {
       explicit in_place_type_t() = default;
   };
   template <class _Tp>   
#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES
inline   
#endif
constexpr in_place_type_t<_Tp> in_place_type{
  };
    template <size_t _Idx> struct _LIBCPP_TYPE_VIS in_place_index_t {
       explicit in_place_index_t() = default;
   };
   template <size_t _Idx>   
#ifndef _LIBCPP_HAS_NO_INLINE_VARIABLES
inline   
#endif
constexpr in_place_index_t<_Idx> in_place_index{
  };
    template <class _Tp> struct __is_inplace_type_imp : false_type {
  };
   template <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {
  };
    template <class _Tp> using __is_inplace_type = __is_inplace_type_imp<__uncvref_t<_Tp>>;
    template <class _Tp> struct __is_inplace_index_imp : false_type {
  };
   template <size_t _Idx> struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {
  };
    template <class _Tp> using __is_inplace_index = __is_inplace_index_imp<__uncvref_t<_Tp>>;
      
#endif // _LIBCPP_STD_VER > 14
 template <class _Arg, class _Result> struct _LIBCPP_TEMPLATE_VIS unary_function {
       typedef _Arg    argument_type;
       typedef _Result result_type;
   };
    template <class _Size> inline _LIBCPP_INLINE_VISIBILITY _Size __loadword(const void* __p) {
       _Size __r;
       std::memcpy(&__r, __p, sizeof(__r));
       return __r;
   }
    // We use murmur2 when size_t is 32 bits, and cityhash64 when size_t
// is 64 bits.  This is because cityhash64 uses 64bit x 64bit
// multiplication, which can be very slow on 32-bit systems.
template <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__> struct __murmur2_or_cityhash;
    template <class _Size> struct __murmur2_or_cityhash<_Size, 32> {
       inline _Size operator()(const void* __key, _Size __len)          _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK;
   };
    // murmur2
template <class _Size> _Size __murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len) {
       const _Size __m = 0x5bd1e995;
       const _Size __r = 24;
       _Size __h = __len;
       const unsigned char* __data = static_cast<const unsigned char*>(__key);
       for (;
   __len >= 4;
   __data += 4, __len -= 4)     {
           _Size __k = __loadword<_Size>(__data);
           __k *= __m;
           __k ^= __k >> __r;
           __k *= __m;
           __h *= __m;
           __h ^= __k;
       }
       switch (__len)     {
       case 3:         __h ^= __data[2] << 16;
       case 2:         __h ^= __data[1] << 8;
       case 1:         __h ^= __data[0];
           __h *= __m;
       }
       __h ^= __h >> 13;
       __h *= __m;
       __h ^= __h >> 15;
       return __h;
   }
    template <class _Size> struct __murmur2_or_cityhash<_Size, 64> {
       inline _Size operator()(const void* __key, _Size __len)  _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK;
     private:   // Some primes between 2^63 and 2^64.
  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
     static const _Size __k1 = 0xb492b66fbe98f273ULL;
     static const _Size __k2 = 0x9ae16a3b2f90404fULL;
     static const _Size __k3 = 0xc949d7c7509e6557ULL;
      static _Size __rotate(_Size __val, int __shift) {
       return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
     }
      static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
       return (__val >> __shift) | (__val << (64 - __shift));
     }
      static _Size __shift_mix(_Size __val) {
       return __val ^ (__val >> 47);
     }
      static _Size __hash_len_16(_Size __u, _Size __v)      _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK   {
       const _Size __mul = 0x9ddfea08eb382d69ULL;
       _Size __a = (__u ^ __v) * __mul;
       __a ^= (__a >> 47);
       _Size __b = (__v ^ __a) * __mul;
       __b ^= (__b >> 47);
       __b *= __mul;
       return __b;
     }
      static _Size __hash_len_0_to_16(const char* __s, _Size __len)      _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK   {
       if (__len > 8) {
         const _Size __a = __loadword<_Size>(__s);
         const _Size __b = __loadword<_Size>(__s + __len - 8);
         return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
       }
       if (__len >= 4) {
         const uint32_t __a = __loadword<uint32_t>(__s);
         const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
         return __hash_len_16(__len + (__a << 3), __b);
       }
       if (__len > 0) {
         const unsigned char __a = __s[0];
         const unsigned char __b = __s[__len >> 1];
         const unsigned char __c = __s[__len - 1];
         const uint32_t __y = static_cast<uint32_t>(__a) +                            (static_cast<uint32_t>(__b) << 8);
         const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
         return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
       }
       return __k2;
     }
      static _Size __hash_len_17_to_32(const char *__s, _Size __len)      _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK   {
       const _Size __a = __loadword<_Size>(__s) * __k1;
       const _Size __b = __loadword<_Size>(__s + 8);
       const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
       const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
       return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,                          __a + __rotate(__b ^ __k3, 20) - __c + __len);
     }
      // Return a 16-byte hash for 48 bytes.  Quick and dirty.
  // Callers do best to use "random-looking" values for a and b.
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(       _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)         _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK   {
       __a += __w;
       __b = __rotate(__b + __a + __z, 21);
       const _Size __c = __a;
       __a += __x;
       __a += __y;
       __b += __rotate(__a, 44);
       return pair<_Size, _Size>(__a + __z, __b + __c);
     }
      // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(       const char* __s, _Size __a, _Size __b)     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK   {
       return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),                                          __loadword<_Size>(__s + 8),                                          __loadword<_Size>(__s + 16),                                          __loadword<_Size>(__s + 24),                                          __a,                                          __b);
     }
      // Return an 8-byte hash for 33 to 64 bytes.
  static _Size __hash_len_33_to_64(const char *__s, size_t __len)     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK   {
       _Size __z = __loadword<_Size>(__s + 24);
       _Size __a = __loadword<_Size>(__s) +                 (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
       _Size __b = __rotate(__a + __z, 52);
       _Size __c = __rotate(__a, 37);
       __a += __loadword<_Size>(__s + 8);
       __c += __rotate(__a, 7);
       __a += __loadword<_Size>(__s + 16);
       _Size __vf = __a + __z;
       _Size __vs = __b + __rotate(__a, 31) + __c;
       __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
       __z += __loadword<_Size>(__s + __len - 8);
       __b = __rotate(__a + __z, 52);
       __c = __rotate(__a, 37);
       __a += __loadword<_Size>(__s + __len - 24);
       __c += __rotate(__a, 7);
       __a += __loadword<_Size>(__s + __len - 16);
       _Size __wf = __a + __z;
       _Size __ws = __b + __rotate(__a, 31) + __c;
       _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
       return __shift_mix(__r * __k0 + __vs) * __k2;
     }
   };
    // cityhash64
template <class _Size> _Size __murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len) {
     const char* __s = static_cast<const char*>(__key);
     if (__len <= 32) {
       if (__len <= 16) {
         return __hash_len_0_to_16(__s, __len);
       }
   else {
         return __hash_len_17_to_32(__s, __len);
       }
     }
   else if (__len <= 64) {
       return __hash_len_33_to_64(__s, __len);
     }
      // For strings over 64 bytes we hash the end first, and then as we
  // loop we keep 56 bytes of state: v, w, x, y, and z.
  _Size __x = __loadword<_Size>(__s + __len - 40);
     _Size __y = __loadword<_Size>(__s + __len - 16) +               __loadword<_Size>(__s + __len - 56);
     _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,                           __loadword<_Size>(__s + __len - 24));
     pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
     pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
     __x = __x * __k1 + __loadword<_Size>(__s);
      // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.
  __len = (__len - 1) & ~static_cast<_Size>(63);
     do {
       __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
       __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
       __x ^= __w.second;
       __y += __v.first + __loadword<_Size>(__s + 40);
       __z = __rotate(__z + __w.first, 33) * __k1;
       __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
       __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,                                         __y + __loadword<_Size>(__s + 16));
       std::swap(__z, __x);
       __s += 64;
       __len -= 64;
     }
   while (__len != 0);
     return __hash_len_16(       __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,       __hash_len_16(__v.second, __w.second) + __x);
   }
    template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)> struct __scalar_hash;
    template <class _Tp> struct __scalar_hash<_Tp, 0>     : public unary_function<_Tp, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(_Tp __v) const _NOEXCEPT     {
           union         {
               _Tp    __t;
               size_t __a;
           }
   __u;
           __u.__a = 0;
           __u.__t = __v;
           return __u.__a;
       }
   };
    template <class _Tp> struct __scalar_hash<_Tp, 1>     : public unary_function<_Tp, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(_Tp __v) const _NOEXCEPT     {
           union         {
               _Tp    __t;
               size_t __a;
           }
   __u;
           __u.__t = __v;
           return __u.__a;
       }
   };
    template <class _Tp> struct __scalar_hash<_Tp, 2>     : public unary_function<_Tp, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(_Tp __v) const _NOEXCEPT     {
           union         {
               _Tp __t;
               struct             {
                  size_t __a;
                  size_t __b;
                  size_t __c;
                  size_t __d;
              }
   __s;
           }
   __u;
           __u.__t = __v;
           return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
       }
   };
    struct _PairT {
     size_t first;
     size_t second;
   };
    _LIBCPP_INLINE_VISIBILITY inline size_t __hash_combine(size_t __lhs, size_t __rhs) _NOEXCEPT {
       typedef __scalar_hash<_PairT> _HashT;
       const _PairT __p = {
  __lhs, __rhs};
       return _HashT()(__p);
   }
    template<class _Tp> struct _LIBCPP_TEMPLATE_VIS hash<_Tp*>     : public unary_function<_Tp*, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(_Tp* __v) const _NOEXCEPT     {
           union         {
               _Tp* __t;
               size_t __a;
           }
   __u;
  }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<char>     : public unary_function<char, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(char __v) const _NOEXCEPT {
  return static_cast<size_t>(__v);
  }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<signed char>     : public unary_function<signed char, size_t> {
   };
      
#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
 template <> struct _LIBCPP_TEMPLATE_VIS hash<char16_t>     : public unary_function<char16_t, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(char16_t __v) const _NOEXCEPT {
  return static_cast<size_t>(__v);
  }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<char32_t>     : public unary_function<char32_t, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(char32_t __v) const _NOEXCEPT {
  return static_cast<size_t>(__v);
  }
   };
      
#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
 template <> struct _LIBCPP_TEMPLATE_VIS hash<wchar_t>     : public unary_function<wchar_t, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(wchar_t __v) const _NOEXCEPT {
  return static_cast<size_t>(__v);
  }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<short>     : public unary_function<short, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(short __v) const _NOEXCEPT {
  return static_cast<size_t>(__v);
  }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<long>     : public unary_function<long, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(long __v) const _NOEXCEPT {
  return static_cast<size_t>(__v);
  }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<unsigned long>     : public unary_function<unsigned long, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(unsigned long __v) const _NOEXCEPT {
  return static_cast<size_t>(__v);
  }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<long long>     : public __scalar_hash<long long> {
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<unsigned long long>     : public __scalar_hash<unsigned long long> {
   };
      
#ifndef _LIBCPP_HAS_NO_INT128
 template <> struct _LIBCPP_TEMPLATE_VIS hash<__int128_t>     : public __scalar_hash<__int128_t> {
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<__uint128_t>     : public __scalar_hash<__uint128_t> {
   };
      
#endif
 template <> struct _LIBCPP_TEMPLATE_VIS hash<float>     : public __scalar_hash<float> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(float __v) const _NOEXCEPT     {
           // -0.0 and 0.0 should return same hash
       if (__v == 0)            return 0;
           return __scalar_hash<float>::operator()(__v);
       }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<long double>     : public __scalar_hash<long double> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(long double __v) const _NOEXCEPT     {
           // -0.0 and 0.0 should return same hash
        if (__v == 0)             return 0;
     
#if defined(__i386__)
        // Zero out padding bits
        union         {
           __u.__t = __v;
           return __u.__s.__a ^ __u.__s.__b;
     
#else
        return __scalar_hash<long double>::operator()(__v);
     
#endif
    }
   };
      
#if _LIBCPP_STD_VER > 11
 template <class _Tp, bool = is_enum<_Tp>::value> struct _LIBCPP_TEMPLATE_VIS __enum_hash     : public unary_function<_Tp, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(_Tp __v) const _NOEXCEPT     {
           typedef typename underlying_type<_Tp>::type type;
           return hash<type>{
  }
  (static_cast<type>(__v));
       }
   };
   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __enum_hash<_Tp, false> {
       __enum_hash() = delete;
       __enum_hash(__enum_hash const&) = delete;
       __enum_hash& operator=(__enum_hash const&) = delete;
     _LIBCPP_INLINE_VISIBILITY   size_t operator()(nullptr_t) const _NOEXCEPT {
       return 662607004ull;
     }
   };
     
#endif
   
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Hash> using __check_hash_requirements = integral_constant<bool,     is_copy_constructible<_Hash>::value &&     is_move_constructible<_Hash>::value &&     __invokable_r<size_t, _Hash, _Key const&>::value >;
    template <class _Key, class _Hash = std::hash<_Key> > using __has_enabled_hash = integral_constant<bool,     __check_hash_requirements<_Key, _Hash>::value &&     is_default_constructible<_Hash>::value >;
      
#if _LIBCPP_STD_VER > 14
template <class _Type, class> using __enable_hash_helper_imp = _Type;
    template <class _Type, class ..._Keys> using __enable_hash_helper = __enable_hash_helper_imp<_Type,   typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type >;
     
#else
template <class _Type, class ...> using __enable_hash_helper = _Type;
     
#endif
   
#endif // !_LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_UTILITY
  
#pragma clang module end /*std.utility*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <memory>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.memory
// -*- C++ -*-
//===-------------------------- memory ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_MEMORY
  
#define _LIBCPP_MEMORY
 /*     memory synopsis  namespace std {
    struct allocator_arg_t {
   };
   constexpr allocator_arg_t allocator_arg = allocator_arg_t();
    template <class T, class Alloc> struct uses_allocator;
    template <class Ptr> struct pointer_traits {
       typedef Ptr pointer;
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.typeinfo
// -*- C++ -*-
//===-------------------------- typeinfo ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef __LIBCPP_TYPEINFO
  
#define __LIBCPP_TYPEINFO
 /*      typeinfo synopsis  namespace std {
    class type_info {
   public:     virtual ~type_info();
        bool operator==(const type_info& rhs) const noexcept;
       bool operator!=(const type_info& rhs) const noexcept;
        bool before(const type_info& rhs) const noexcept;
       size_t hash_code() const noexcept;
       const char* name() const noexcept;
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.exception
// -*- C++ -*-
//===-------------------------- exception ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXCEPTION
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#endif /* expanded by -frewrite-includes */
   
#if defined(_LIBCPP_ABI_MICROSOFT)
  
#if 0 /* expanded by -frewrite-includes */
  
#include <vcruntime_exception.h>
  
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 namespace std  // purposefully not using versioning namespace
{
   _LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_UNCAUGHT_EXCEPTIONS int uncaught_exceptions() _NOEXCEPT;
    class _LIBCPP_TYPE_VIS exception_ptr;
    _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;
   _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);
      
#ifndef _LIBCPP_ABI_MICROSOFT
 class _LIBCPP_TYPE_VIS exception_ptr {
       void* __ptr_;
           throw __nested<_Up>(_VSTD::forward<_Tp>(__t));
       }
   };
    template <class _Tp, class _Up> struct __throw_with_nested<_Tp, _Up, false> {
       _LIBCPP_NORETURN static inline _LIBCPP_ALWAYS_INLINE void   
#ifndef _LIBCPP_CXX03_LANG
    __do_throw(_Tp&& __t)   
#else
    __do_throw (_Tp& __t)   
#endif  // _LIBCPP_CXX03_LANG
    {
           throw _VSTD::forward<_Tp>(__t);
       }
   };
     
#endif
#endif  // _LIBCPP_EXCEPTION
  
#pragma clang module end /*std.exception*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cstddef
// -*- C++ -*-
//===--------------------------- cstddef ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CSTDDEF
  
#define _LIBCPP_CSTDDEF
  using::intptr_t;
   using::uintptr_t;
    using::intmax_t;
   using::uintmax_t;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CSTDINT
  
#pragma clang module end /*std.compat.cstdint*/
  
#ifdef _LIBCPP_NO_EXCEPTIONS
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdlib>
  
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if defined(_LIBCPP_ABI_MICROSOFT)
  
#define _LIBCPP_HAS_NONUNIQUE_TYPEINFO
  
#else
  
#define _LIBCPP_HAS_UNIQUE_TYPEINFO
  
#endif
 namespace std  // purposefully not using versioning namespace
{
      
#if !defined(_LIBCPP_ABI_MICROSOFT)
class _LIBCPP_EXCEPTION_ABI type_info {
       type_info& operator=(const type_info&);
       type_info(const type_info&);
#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)
    // A const char* with the non-unique RTTI bit possibly set.
    uintptr_t __type_name;
        _LIBCPP_INLINE_VISIBILITY     explicit type_info(const char* __n)       : __type_name(reinterpret_cast<uintptr_t>(__n)) {
  }
     
#else
    const char *__type_name;
        _LIBCPP_INLINE_VISIBILITY     explicit type_info(const char* __n) : __type_name(__n) {
  }
     
#endif
 public:     _LIBCPP_AVAILABILITY_TYPEINFO_VTABLE     virtual ~type_info();
      
#if defined(_LIBCPP_HAS_NONUNIQUE_TYPEINFO)
    _LIBCPP_INLINE_VISIBILITY     const char* name() const _NOEXCEPT     {
          if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))         return false;
         return __compare_nonunique_names(__arg) == 0;
       }
     
#else
    _LIBCPP_INLINE_VISIBILITY     const char* name() const _NOEXCEPT     {
   return __type_name;
   }
        _LIBCPP_INLINE_VISIBILITY     bool before(const type_info& __arg) const _NOEXCEPT     {
   return __type_name < __arg.__type_name;
   }
        _LIBCPP_INLINE_VISIBILITY     size_t hash_code() const _NOEXCEPT     {
   return reinterpret_cast<size_t>(__type_name);
   }
        _LIBCPP_INLINE_VISIBILITY     bool operator==(const type_info& __arg) const _NOEXCEPT     {
   return __type_name == __arg.__type_name;
   }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     bool operator!=(const type_info& __arg) const _NOEXCEPT     {
   return !operator==(__arg);
   }
   };
    class _LIBCPP_EXCEPTION_ABI bad_cast     : public exception {
   public:     bad_cast() _NOEXCEPT;
       virtual ~bad_cast() _NOEXCEPT;
       virtual const char* what() const _NOEXCEPT;
   };
    class _LIBCPP_EXCEPTION_ABI bad_typeid     : public exception {
   public:     bad_typeid() _NOEXCEPT;
       virtual ~bad_typeid() _NOEXCEPT;
       virtual const char* what() const _NOEXCEPT;
   };
      
#endif // !_LIBCPP_ABI_MICROSOFT
 }
    // std
 _LIBCPP_BEGIN_NAMESPACE_STD _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_bad_cast() {
}
   _LIBCPP_END_NAMESPACE_STD    
#endif  // __LIBCPP_TYPEINFO
  
#pragma clang module end /*std.typeinfo*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cstddef
// -*- C++ -*-
//===--------------------------- cstddef ----------------------------------===//
   
#ifndef _LIBCPP_CSTDDEF
  
#define _LIBCPP_CSTDDEF
 /*     cstddef synopsis  Macros:      offsetof(type,member-designator)     NULL  namespace std {
    Types:      ptrdiff_t     size_t     max_align_t     nullptr_t     byte // C++17
 }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__nullptr>
  
#endif /* expanded by -frewrite-includes */
 _LIBCPP_BEGIN_NAMESPACE_STD  using ::ptrdiff_t;
   using::uintptr_t;
    using::intmax_t;
   using::uintmax_t;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CSTDINT
  
#pragma clang module end /*std.compat.cstdint*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <new>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.new
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_NEW
  
#define _LIBCPP_NEW
 /*     new synopsis  namespace std {
    class bad_alloc     : public exception {
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <exception>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.exception
// -*- C++ -*-
//===-------------------------- exception ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXCEPTION
  
#define _LIBCPP_EXCEPTION
 /*     exception synopsis  namespace std {
    template <class T> [[noreturn]] void throw_with_nested(T&& t);
   template <class E> void rethrow_if_nested(const E& e);
    }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
    || defined(_LIBCPP_BUILDING_LIBRARY)
typedef void (*unexpected_handler)();
   _LIBCPP_FUNC_VIS unexpected_handler set_unexpected(unexpected_handler) _NOEXCEPT;
   _LIBCPP_FUNC_VIS unexpected_handler get_unexpected() _NOEXCEPT;
   _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void unexpected();
     
#endif
 typedef void (*terminate_handler)();
   _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);
      
#ifndef _LIBCPP_ABI_MICROSOFT
 class _LIBCPP_TYPE_VIS exception_ptr {
       void* __ptr_;
   public:     _LIBCPP_INLINE_VISIBILITY exception_ptr() _NOEXCEPT : __ptr_() {
  }
       _LIBCPP_INLINE_VISIBILITY exception_ptr(nullptr_t) _NOEXCEPT : __ptr_() {
   }
    }
      
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>  // rest of byte
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#endif  // _LIBCPP_CSTDDEF
  
#pragma clang module end /*std.compat.cstddef*/
  
#ifdef _LIBCPP_NO_EXCEPTIONS
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdlib>
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if defined(_LIBCPP_ABI_MICROSOFT)
  
#if 0 /* expanded by -frewrite-includes */
  
#include <new.h>
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if !(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER >= 14 || \
    (defined(__cpp_sized_deallocation) && __cpp_sized_deallocation >= 201309))
  
# define _LIBCPP_HAS_NO_SIZED_DEALLOCATION
  
#endif
   
#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) && \
    (!(defined(_LIBCPP_BUILDING_NEW) || _LIBCPP_STD_VER > 14 || \
    (defined(__cpp_aligned_new) && __cpp_aligned_new >= 201606)))
  
# define _LIBCPP_HAS_NO_ALIGNED_ALLOCATION
  
#endif
 namespace std  // purposefully not using versioning namespace
{
      
#if !defined(_LIBCPP_ABI_MICROSOFT)
struct _LIBCPP_TYPE_VIS nothrow_t {
  };
   extern _LIBCPP_FUNC_VIS const nothrow_t nothrow;
    class _LIBCPP_EXCEPTION_ABI bad_alloc     : public exception {
   public:     bad_alloc() _NOEXCEPT;
       virtual ~bad_alloc() _NOEXCEPT;
       virtual const char* what() const _NOEXCEPT;
   };
    class _LIBCPP_EXCEPTION_ABI bad_array_new_length     : public bad_alloc {
   public:     bad_array_new_length() _NOEXCEPT;
       virtual ~bad_array_new_length() _NOEXCEPT;
       virtual const char* what() const _NOEXCEPT;
   };
    typedef void (*new_handler)();
   _LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;
   _LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;
      
#endif // !_LIBCPP_ABI_MICROSOFT
 _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_bad_alloc();
    // not in C++ spec
   
#if defined(_LIBCPP_BUILDING_LIBRARY) || (_LIBCPP_STD_VER > 11)
 class _LIBCPP_EXCEPTION_ABI _LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH     bad_array_length : public bad_alloc {
   public:     bad_array_length() _NOEXCEPT;
       virtual ~bad_array_length() _NOEXCEPT;
       virtual const char* what() const _NOEXCEPT;
   };
      
#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED
   
#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)
   
#if !defined(_LIBCPP_HAS_NO_ALIGNED_ALLOCATION) || _LIBCPP_STD_VER > 14
  
#ifndef _LIBCPP_CXX03_LANG
enum class _LIBCPP_ENUM_VIS align_val_t : size_t {
   };
     
#else
enum align_val_t {
   __zero = 0, __max = (size_t)-1 };
     
#endif
  
#endif
 }
    // std
   
#if defined(_LIBCPP_CXX03_LANG)
  
#define _THROW_BAD_ALLOC throw(std::bad_alloc)
  
#else
  
#define _THROW_BAD_ALLOC
  
#endif
   
#if !defined(_LIBCPP_ABI_MICROSOFT)
 _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz) _THROW_BAD_ALLOC;
   _LIBCPP_OVERRIDABLE_FUNC_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;
   _LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p) _NOEXCEPT;
   _LIBCPP_OVERRIDABLE_FUNC_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;
     
#ifndef _LIBCPP_HAS_NO_SIZED_DEALLOCATION
_LIBCPP_OVERRIDABLE_FUNC_VIS _LIBCPP_AVAILABILITY_SIZED_NEW_DELETE void  operator delete(void* __p, std::size_t __sz) _NOEXCEPT;
  
#endif
 inline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {
  return __p;
  }
   inline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {
  return __p;
  }
   inline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {
  }
   inline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {
  }
      
#endif // !_LIBCPP_ABI_MICROSOFT
 _LIBCPP_BEGIN_NAMESPACE_STD  inline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {
}
    inline _LIBCPP_INLINE_VISIBILITY void __libcpp_deallocate(void *__ptr) {
     
#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE
  ::operator delete(__ptr);
     
#else
  __builtin_operator_delete(__ptr);
     
#endif
}
      
#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED
_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE   
#ifndef _LIBCPP_NO_EXCEPTIONS
_LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH   
#endif
void __throw_bad_array_length() {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw bad_array_length();
     
#else
	_VSTD::abort();
     
#endif
}
     
#endif
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_NEW
  
#pragma clang module end /*std.new*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <utility>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.utility
// -*- C++ -*-
//===-------------------------- utility -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ITERATOR
  
#define _LIBCPP_ITERATOR
 /*     iterator synopsis  namespace std {
    template<class Iterator> struct iterator_traits {
       typedef typename Iterator::difference_type difference_type;
       typedef typename Iterator::value_type value_type;
       typedef typename Iterator::pointer pointer;
       typedef typename Iterator::reference reference;
       typedef typename Iterator::iterator_category iterator_category;
   };
     // Include other forward declarations here
template <class _Tp, class _Alloc = allocator<_Tp> > class _LIBCPP_TEMPLATE_VIS vector;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_IOSFWD
  
#pragma clang module end /*std.iosfwd*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__functional_base>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__functional_base
// -*- C++ -*-
   
#ifndef _LIBCPP_FUNCTIONAL_BASE
  
#define _LIBCPP_FUNCTIONAL_BASE
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TYPE_TRAITS
  
#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {
        // helper class:
    template <class T, T v> struct integral_constant;
       typedef integral_constant<bool, true>  true_type;
     // C++11
    typedef integral_constant<bool, false> false_type;
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdint>
  
#endif /* expanded by -frewrite-includes */
     
#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_UTILITY)
extern const piecewise_construct_t piecewise_construct;
  // = piecewise_construct_t();
  
#else
constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
        template <class _Tuple, _EnableB<             _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()      > = false>     _LIBCPP_INLINE_VISIBILITY     pair& operator=(_Tuple&& __p) {
           first = _VSTD::get<0>(_VSTD::forward<_Tuple>(__p));
           second = _VSTD::get<1>(_VSTD::forward<_Tuple>(__p));
           return *this;
       }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     void     swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&                                __is_nothrow_swappable<second_type>::value)     {
#endif  // _LIBCPP_UTILITY
  
#pragma clang module end /*std.utility*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Arg1, class _Arg2, class _Result> struct _LIBCPP_TEMPLATE_VIS binary_function {
       typedef _Arg1   first_argument_type;
       typedef _Arg2   second_argument_type;
       typedef _Result result_type;
   };
    template <class _Tp> struct __has_result_type {
   private:     struct __two { char __lx;  char __lxx; };
       template <class _Up> static __two __test(...);
       template <class _Up> static char __test(typename _Up::result_type* = 0);
   public:     static const bool value = sizeof(__test<_Tp>(0)) == 1;
   };
      
#if _LIBCPP_STD_VER > 11
template <class _Tp = void>   
#else
template <class _Tp>   
#endif
struct _LIBCPP_TEMPLATE_VIS less : binary_function<_Tp, _Tp, bool> {
       _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY      bool operator()(const _Tp& __x, const _Tp& __y) const         { return __x < __y; }
   };
      
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS less<void> {
       template <class _T1, class _T2>      _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))         {  return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u);  }
       typedef void is_transparent;
   };
     
#endif
 // __weak_result_type
 template <class _Tp> struct __derives_from_unary_function {
   private:     struct __two { char __lx;  char __lxx; };
       static __two __test(...);
       template <class _Ap, class _Rp>         static unary_function<_Ap, _Rp>         __test(const volatile unary_function<_Ap, _Rp>*);
   public:     static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
       typedef decltype(__test((_Tp*)0)) type;
   };
    template <class _Tp> struct __derives_from_binary_function {
   private:     struct __two { char __lx;  char __lxx; };
       static __two __test(...);
       template <class _A1, class _A2, class _Rp>         static binary_function<_A1, _A2, _Rp>         __test(const volatile binary_function<_A1, _A2, _Rp>*);
   public:     static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
       typedef decltype(__test((_Tp*)0)) type;
   };
    template <class _Tp, bool = __derives_from_unary_function<_Tp>::value> struct __maybe_derive_from_unary_function  // bool is true
    : public __derives_from_unary_function<_Tp>::type {
   };
    template <class _Tp> struct __maybe_derive_from_unary_function<_Tp, false> {
   };
    template <class _Tp, bool = __derives_from_binary_function<_Tp>::value> struct __maybe_derive_from_binary_function  // bool is true
    : public __derives_from_binary_function<_Tp>::type {
   };
    template <class _Tp> struct __maybe_derive_from_binary_function<_Tp, false> {
   };
    template <class _Tp, bool = __has_result_type<_Tp>::value> struct __weak_result_type_imp // bool is true
    : public __maybe_derive_from_unary_function<_Tp>,       public __maybe_derive_from_binary_function<_Tp> {
       typedef typename _Tp::result_type result_type;
   };
    template <class _Tp> struct __weak_result_type_imp<_Tp, false>     : public __maybe_derive_from_unary_function<_Tp>,       public __maybe_derive_from_binary_function<_Tp> {
   };
    template <class _Tp> struct __weak_result_type     : public __weak_result_type_imp<_Tp> {
   };
    // 0 argument case
 template <class _Rp> struct __weak_result_type<_Rp ()> {
   };
    template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1) const>     : public binary_function<const _Cp*, _A1, _Rp> {
   };
    template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>     : public binary_function<volatile _Cp*, _A1, _Rp> {
   };
    template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>     : public binary_function<const volatile _Cp*, _A1, _Rp> {
   };
       
#ifndef _LIBCPP_CXX03_LANG
// 3 or more arguments
 template <class _Rp, class _A1, class _A2, class _A3, class ..._A4> struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)> {
       typedef _Rp result_type;
   };
    template <class _Rp, class _A1, class _A2, class _A3, class ..._A4> struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)> {
       typedef _Rp result_type;
   };
    template <class _Rp, class _A1, class _A2, class _A3, class ..._A4> struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)> {
       typedef _Rp result_type;
   };
    template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3> struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)> {
       typedef _Rp result_type;
   };
    template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3> struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const> {
       typedef _Rp result_type;
   };
    template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3> struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile> {
       typedef _Rp result_type;
   };
    template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3> struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile> {
       typedef _Rp result_type;
   };
    template <class _Tp, class ..._Args> struct __invoke_return {
       typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;
   };
      
#else // defined(_LIBCPP_CXX03_LANG)
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__functional_base_03>
  
#endif /* expanded by -frewrite-includes */
   
#endif  // !defined(_LIBCPP_CXX03_LANG)
  template <class _Ret> struct __invoke_void_return_wrapper {
     
#ifndef _LIBCPP_CXX03_LANG
    template <class ..._Args>     static _Ret __call(_Args&&... __args) {          return __invoke(_VSTD::forward<_Args>(__args)...);      }
     
#else
    template <class _Fn>     static _Ret __call(_Fn __f) {          return __invoke(__f);      }
        template <class _Fn, class _A0>     static _Ret __call(_Fn __f, _A0& __a0) {          return __invoke(__f, __a0);      }
        template <class _Fn, class _A0, class _A1>     static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1) {          return __invoke(__f, __a0, __a1);      }
        template <class _Fn, class _A0, class _A1, class _A2>     static _Ret __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2){          return __invoke(__f, __a0, __a1, __a2);      }
     
#endif
};
    template <> struct __invoke_void_return_wrapper<void> {
     
#ifndef _LIBCPP_CXX03_LANG
    template <class ..._Args>     static void __call(_Args&&... __args) {          __invoke(_VSTD::forward<_Args>(__args)...);      }
     
#else
    template <class _Fn>     static void __call(_Fn __f) {          __invoke(__f);      }
        template <class _Fn, class _A0>     static void __call(_Fn __f, _A0& __a0) {          __invoke(__f, __a0);      }
        template <class _Fn, class _A0, class _A1>     static void __call(_Fn __f, _A0& __a0, _A1& __a1) {          __invoke(__f, __a0, __a1);      }
        template <class _Fn, class _A0, class _A1, class _A2>     static void __call(_Fn __f, _A0& __a0, _A1& __a1, _A2& __a2) {          __invoke(__f, __a0, __a1, __a2);      }
     
#endif
};
    template <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper     : public __weak_result_type<_Tp> {
   public:     // types
    typedef _Tp type;
   private:     type* __f_;
    public:     // construct/copy/destroy
    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT         : __f_(_VSTD::addressof(__f)) { }
     
       _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT { return *__f_; }
      
#ifndef _LIBCPP_CXX03_LANG
    // invoke
    template <class... _ArgTypes>     _LIBCPP_INLINE_VISIBILITY     typename __invoke_of<type&, _ArgTypes...>::type     operator() (_ArgTypes&&... __args) const {          return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);      }
     
#else
     _LIBCPP_INLINE_VISIBILITY     typename __invoke_return<type>::type     operator() () const {          return __invoke(get());      }
#endif // _LIBCPP_CXX03_LANG
};
     template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY reference_wrapper<_Tp> ref(_Tp& __t) _NOEXCEPT {
       return reference_wrapper<_Tp>(__t);
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY reference_wrapper<_Tp> ref(reference_wrapper<_Tp> __t) _NOEXCEPT {
       return ref(__t.get());
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY reference_wrapper<const _Tp> cref(const _Tp& __t) _NOEXCEPT {
       return reference_wrapper<const _Tp>(__t);
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY reference_wrapper<const _Tp> cref(reference_wrapper<_Tp> __t) _NOEXCEPT {
       return cref(__t.get());
   }
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp> void ref(const _Tp&&) = delete;
   template <class _Tp> void cref(const _Tp&&) = delete;
     
#endif
   
#if _LIBCPP_STD_VER > 11
template <class _Tp, class, class = void> struct __is_transparent : false_type {
  };
    template <class _Tp, class _Up> struct __is_transparent<_Tp, _Up,                           typename __void_t<typename _Tp::is_transparent>::type>    : true_type {
  };
     
#endif
 // allocator_arg_t
 struct _LIBCPP_TEMPLATE_VIS allocator_arg_t {
   };
      
#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_MEMORY)
extern const allocator_arg_t allocator_arg;
     
#else
constexpr allocator_arg_t allocator_arg = allocator_arg_t();
     
#endif
 // uses_allocator
 template <class _Tp> struct __has_allocator_type {
   private:     struct __two { char __lx;  char __lxx; };
       template <class _Up> static __two __test(...);
       template <class _Up> static char __test(typename _Up::allocator_type* = 0);
   public:     static const bool value = sizeof(__test<_Tp>(0)) == 1;
   };
    template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value> struct __uses_allocator     : public integral_constant<bool,         is_convertible<_Alloc, typename _Tp::allocator_type>::value> {
   };
    template <class _Tp, class _Alloc> struct __uses_allocator<_Tp, _Alloc, false>     : public false_type {
   };
    template <class _Tp, class _Alloc> struct _LIBCPP_TEMPLATE_VIS uses_allocator     : public __uses_allocator<_Tp, _Alloc> {
   };
      
#if _LIBCPP_STD_VER > 14
template <class _Tp, class _Alloc> constexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;
     
#endif
   
#ifndef _LIBCPP_CXX03_LANG
 // allocator construction
 template <class _Tp, class _Alloc, class ..._Args> struct __uses_alloc_ctor_imp {
       typedef typename __uncvref<_Alloc>::type _RawAlloc;
       static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
       static const bool __ic =         is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
       static const int value = __ua ? 2 - __ic : 0;
   };
    template <class _Tp, class _Alloc, class ..._Args> struct __uses_alloc_ctor     : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>     {
  };
    template <class _Tp, class _Allocator, class... _Args> inline _LIBCPP_INLINE_VISIBILITY void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args ) {
       new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);
   }
    // FIXME: This should have a version which takes a non-const alloc.
template <class _Tp, class _Allocator, class... _Args> inline _LIBCPP_INLINE_VISIBILITY void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args ) {
       new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);
   }
    // FIXME: This should have a version which takes a non-const alloc.
template <class _Tp, class _Allocator, class... _Args> inline _LIBCPP_INLINE_VISIBILITY void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args ) {
       new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);
   }
    // FIXME: Theis should have a version which takes a non-const alloc.
template <class _Tp, class _Allocator, class... _Args> inline _LIBCPP_INLINE_VISIBILITY void __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args) {
        __user_alloc_construct_impl(               __uses_alloc_ctor<_Tp, _Allocator>(),               __storage, __a, _VSTD::forward<_Args>(__args)...         );
   }
     
#endif  // _LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_FUNCTIONAL_BASE
  
#pragma clang module end /*std.__functional_base*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
#ifndef _LIBCPP_TYPE_TRAITS
  
#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {
        // helper class:
    template <class T, T v> struct integral_constant;
       typedef integral_constant<bool, true>  true_type;
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;
   template <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;
   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_trivially_copyable_v     = is_trivially_copyable<_Tp>::value;
     
#endif
 // is_trivial;
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivial   
#if __has_feature(is_trivial) || _GNUC_VER >= 407
      
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>  // rest of byte
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#endif  // _LIBCPP_CSTDDEF
  
#pragma clang module end /*std.compat.cstddef*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <initializer_list>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.initializer_list
// -*- C++ -*-
//===----------------------- initializer_list -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_INITIALIZER_LIST
  
#define _LIBCPP_INITIALIZER_LIST
 /*     initializer_list synopsis  namespace std {   template<class E> class initializer_list {  public:     typedef E        value_type;      typedef const E& reference;      typedef const E& const_reference;      typedef size_t   size_type;       typedef const E* iterator;      typedef const E* const_iterator;       initializer_list() noexcept;  // constexpr in C++14
     size_t   size()  const noexcept;  // constexpr in C++14
    const E* begin() const noexcept;  // constexpr in C++14
    const E* end()   const noexcept;  // constexpr in C++14
};   template<class E> const E* begin(initializer_list<E> il) noexcept;  // constexpr in C++14
template<class E> const E* end(initializer_list<E> il) noexcept;  // constexpr in C++14
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 namespace std  // purposefully not versioned
{     
#ifndef _LIBCPP_CXX03_LANG
 template<class _Ep> class _LIBCPP_TEMPLATE_VIS initializer_list {      const _Ep* __begin_;      size_t    __size_;       _LIBCPP_ALWAYS_INLINE     _LIBCPP_CONSTEXPR_AFTER_CXX11     initializer_list(const _Ep* __b, size_t __s) _NOEXCEPT         : __begin_(__b),           __size_(__s)         { }  public:     typedef _Ep        value_type;      typedef const _Ep& reference;      typedef const _Ep& const_reference;      typedef size_t    size_type;       typedef const _Ep* iterator;      typedef const _Ep* const_iterator;       _LIBCPP_ALWAYS_INLINE     _LIBCPP_CONSTEXPR_AFTER_CXX11     initializer_list() _NOEXCEPT : __begin_(nullptr), __size_(0) { }       _LIBCPP_ALWAYS_INLINE     _LIBCPP_CONSTEXPR_AFTER_CXX11     size_t    size()  const _NOEXCEPT { return __size_; }           _LIBCPP_ALWAYS_INLINE     _LIBCPP_CONSTEXPR_AFTER_CXX11     const _Ep* begin() const _NOEXCEPT { return __begin_; }       _LIBCPP_ALWAYS_INLINE     _LIBCPP_CONSTEXPR_AFTER_CXX11     const _Ep* end()   const _NOEXCEPT { return __begin_ + __size_; }  };   template<class _Ep> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Ep* begin(initializer_list<_Ep> __il) _NOEXCEPT {      return __il.begin();  }   template<class _Ep> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Ep* end(initializer_list<_Ep> __il) _NOEXCEPT {      return __il.end();  }     
#endif  // !defined(_LIBCPP_CXX03_LANG)
 }
    // std
   
#endif  // _LIBCPP_INITIALIZER_LIST
  
#pragma clang module end /*std.initializer_list*/
  
#ifdef __APPLE__
  
#if 0 /* expanded by -frewrite-includes */
  
#include <Availability.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
#pragma clang module begin std.__debug
// -*- C++ -*-
//===--------------------------- __debug ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_DEBUG_H
  
#define _LIBCPP_DEBUG_H
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
  
#endif
   
#ifndef _LIBCPP_ASSERT
  
#   define _LIBCPP_ASSERT(x, m) ((void)0)
  
#endif
  
#ifndef _LIBCPP_DEBUG_ASSERT
  
#   define _LIBCPP_DEBUG_ASSERT(x, m) ((void)0)
  
#endif
  
#ifndef _LIBCPP_DEBUG_MODE
  
#define _LIBCPP_DEBUG_MODE(...) ((void)0)
  
#endif
   
#if _LIBCPP_DEBUG_LEVEL < 1
class _LIBCPP_EXCEPTION_ABI __libcpp_debug_exception;
     
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  struct _LIBCPP_TEMPLATE_VIS __libcpp_debug_info {    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR   __libcpp_debug_info()       : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) { }    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR   __libcpp_debug_info(const char* __f, int __l, const char* __p, const char* __m)     : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) { }    const char* __file_;    int __line_;    const char* __pred_;    const char* __msg_;  };
    /// __libcpp_debug_function_type - The type of the assertion failure handler.
typedef void(*__libcpp_debug_function_type)(__libcpp_debug_info const&);
    /// __libcpp_debug_function - The handler function called when a _LIBCPP_ASSERT
///    fails.
extern _LIBCPP_EXTERN_VIS __libcpp_debug_function_type __libcpp_debug_function;
_LIBCPP_FUNC_VIS bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
    // Setup the throwing debug handler during dynamic initialization.
  
#if _LIBCPP_DEBUG_LEVEL >= 1 && defined(_LIBCPP_DEBUG_USE_EXCEPTIONS)
  
# if defined(_LIBCPP_NO_EXCEPTIONS)
  
#   error _LIBCPP_DEBUG_USE_EXCEPTIONS cannot be used when exceptions are disabled.
    __c_node(const __c_node&) = delete;      __c_node& operator=(const __c_node&) = delete;    
#else
private:     __c_node(const __c_node&);      __c_node& operator=(const __c_node&);  public:   
#endif
    _LIBCPP_INLINE_VISIBILITY     __c_node(void* __c, __c_node* __next)         : __c_(__c), __next_(__next), beg_(nullptr), end_(nullptr), cap_(nullptr) { }      virtual ~__c_node();       virtual bool __dereferenceable(const void*) const = 0;      virtual bool __decrementable(const void*) const = 0;      virtual bool __addable(const void*, ptrdiff_t) const = 0;      virtual bool __subscriptable(const void*, ptrdiff_t) const = 0;       void __add(__i_node* __i);      _LIBCPP_HIDDEN void __remove(__i_node* __i);  };
    template <class _Cont> struct _C_node     : public __c_node {      _C_node(void* __c, __c_node* __n)         : __c_node(__c, __n) { }       virtual bool __dereferenceable(const void*) const;      virtual bool __decrementable(const void*) const;      virtual bool __addable(const void*, ptrdiff_t) const;      virtual bool __subscriptable(const void*, ptrdiff_t) const;  };
    template <class _Cont> inline bool _C_node<_Cont>::__dereferenceable(const void* __i) const {      typedef typename _Cont::const_iterator iterator;      const iterator* __j = static_cast<const iterator*>(__i);      _Cont* _Cp = static_cast<_Cont*>(__c_);      return _Cp->__dereferenceable(__j);  }
    template <class _Cont> inline bool _C_node<_Cont>::__decrementable(const void* __i) const {      typedef typename _Cont::const_iterator iterator;      const iterator* __j = static_cast<const iterator*>(__i);      _Cont* _Cp = static_cast<_Cont*>(__c_);      return _Cp->__decrementable(__j);  }
    ~__libcpp_db();       class __db_c_iterator;      class __db_c_const_iterator;      class __db_i_iterator;      class __db_i_const_iterator;       __db_c_const_iterator __c_end() const;      __db_i_const_iterator __i_end() const;       template <class _Cont>     _LIBCPP_INLINE_VISIBILITY     void __insert_c(_Cont* __c)     {          __c_node* __n = __insert_c(static_cast<void*>(__c));          ::new(__n) _C_node<_Cont>(__n->__c_, __n->__next_);      }       void __insert_i(void* __i);      __c_node* __insert_c(void* __c);      void __erase_c(void* __c);       void __insert_ic(void* __i, const void* __c);      void __iterator_copy(void* __i, const void* __i0);      void __erase_i(void* __i);       void* __find_c_from_i(void* __i) const;      void __invalidate_all(void* __c);      __c_node* __find_c_and_lock(void* __c) const;      __c_node* __find_c(void* __c) const;      void unlock() const;       void swap(void* __c1, void* __c2);        bool __dereferenceable(const void* __i) const;      bool __decrementable(const void* __i) const;      bool __addable(const void* __i, ptrdiff_t __n) const;      bool __subscriptable(const void* __i, ptrdiff_t __n) const;      bool __less_than_comparable(const void* __i, const void* __j) const;  private:     _LIBCPP_HIDDEN     __i_node* __insert_iterator(void* __i);      _LIBCPP_HIDDEN     __i_node* __find_iterator(const void* __i) const;       friend _LIBCPP_FUNC_VIS __libcpp_db* __get_db();  };
    _LIBCPP_FUNC_VIS __libcpp_db* __get_db();
   _LIBCPP_FUNC_VIS const __libcpp_db* __get_const_db();
       
#endif // _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  struct _LIBCPP_TEMPLATE_VIS input_iterator_tag { };
   struct _LIBCPP_TEMPLATE_VIS output_iterator_tag { };
   struct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag { };
   struct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag { };
   struct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag { };
    template <class _Tp> struct __has_iterator_category {  private:     struct __two { char __lx;  char __lxx; };      template <class _Up> static __two __test(...);      template <class _Up> static char __test(typename _Up::iterator_category* = 0);  public:     static const bool value = sizeof(__test<_Tp>(0)) == 1;  };
    template <class _Iter, bool> struct __iterator_traits_impl { };
    template <class _Iter> struct __iterator_traits_impl<_Iter, true> {      typedef typename _Iter::difference_type   difference_type;      typedef typename _Iter::value_type        value_type;      typedef typename _Iter::pointer           pointer;      typedef typename _Iter::reference         reference;      typedef typename _Iter::iterator_category iterator_category;  };
    template <class _Iter, bool> struct __iterator_traits { };
    template <class _Iter> struct __iterator_traits<_Iter, true>     :  __iterator_traits_impl       <         _Iter,         is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||         is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value       > { };
    // iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category
//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a
//    conforming extension which allows some programs to compile and behave as
//    the client expects instead of failing at compile time.
 template <class _Iter> struct _LIBCPP_TEMPLATE_VIS iterator_traits     : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> { };
    template<class _Tp> struct _LIBCPP_TEMPLATE_VIS iterator_traits<_Tp*> {      typedef ptrdiff_t difference_type;      typedef typename remove_const<_Tp>::type value_type;      typedef _Tp* pointer;      typedef _Tp& reference;      typedef random_access_iterator_tag iterator_category;  };
    template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value> struct __has_iterator_category_convertible_to     : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value> { };
    template <class _Tp, class _Up> struct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type { };
    template <class _Tp> struct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> { };
    template <class _Tp> struct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> { };
    template <class _Tp> struct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> { };
    template <class _Tp> struct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> { };
    template <class _Tp> struct __is_exactly_input_iterator     : public integral_constant<bool,           __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&          !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> { };
    template<class _Category, class _Tp, class _Distance = ptrdiff_t,          class _Pointer = _Tp*, class _Reference = _Tp&> struct _LIBCPP_TEMPLATE_VIS iterator {      typedef _Tp        value_type;      typedef _Distance  difference_type;      typedef _Pointer   pointer;      typedef _Reference reference;      typedef _Category  iterator_category;  };
    template <class _InputIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 void __advance(_InputIter& __i,              typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag) {      for (;  __n > 0;  --__n)         ++__i;  }
    template <class _BiDirIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 void __advance(_BiDirIter& __i,              typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag) {      if (__n >= 0)         for (;  __n > 0;  --__n)             ++__i;      else         for (;  __n < 0;  ++__n)             --__i;  }
    template <class _RandIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 void __advance(_RandIter& __i,              typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag) {     __i += __n;  }
    template <class _InputIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 void advance(_InputIter& __i,              typename iterator_traits<_InputIter>::difference_type __n) {      __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());  }
    template <class _InputIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 typename iterator_traits<_InputIter>::difference_type __distance(_InputIter __first, _InputIter __last, input_iterator_tag) {      typename iterator_traits<_InputIter>::difference_type __r(0);      for (;  __first != __last;  ++__first)         ++__r;      return __r;  }
    template <class _RandIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 typename iterator_traits<_RandIter>::difference_type __distance(_RandIter __first, _RandIter __last, random_access_iterator_tag) {      return __last - __first;  }
    template <class _InputIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 typename iterator_traits<_InputIter>::difference_type distance(_InputIter __first, _InputIter __last) {      return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());  }
    template <class _InputIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 typename enable_if <     __is_input_iterator<_InputIter>::value,      _InputIter >::type next(_InputIter __x,      typename iterator_traits<_InputIter>::difference_type __n = 1) {      _VSTD::advance(__x, __n);      return __x;  }
    template <class _BidirectionalIter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 typename enable_if <     __is_bidirectional_iterator<_BidirectionalIter>::value,      _BidirectionalIter >::type prev(_BidirectionalIter __x,      typename iterator_traits<_BidirectionalIter>::difference_type __n = 1) {      _VSTD::advance(__x, -__n);      return __x;  }
     template <class _Tp, class = void> struct __is_stashing_iterator : false_type { };
    template <class _Tp> struct __is_stashing_iterator<_Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>   : true_type { };
    template <class _Iter> class _LIBCPP_TEMPLATE_VIS reverse_iterator     : public iterator<typename iterator_traits<_Iter>::iterator_category,                       typename iterator_traits<_Iter>::value_type,                       typename iterator_traits<_Iter>::difference_type,                       typename iterator_traits<_Iter>::pointer,                       typename iterator_traits<_Iter>::reference> {  private:     /*mutable*/ _Iter __t;   // no longer used as of LWG #2360, not removed due to ABI break
     static_assert(!__is_stashing_iterator<_Iter>::value,       "The specified iterator type cannot be used with reverse_iterator; "       "Using stashing iterators with reverse_iterator causes undefined behavior");   protected:     _Iter current;  public:     typedef _Iter                                            iterator_type;      typedef typename iterator_traits<_Iter>::difference_type difference_type;      typedef typename iterator_traits<_Iter>::reference       reference;      typedef typename iterator_traits<_Iter>::pointer         pointer;       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator() : __t(), current() { }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) { }      template <class _Up>         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14         reverse_iterator(const reverse_iterator<_Up>& __u) : __t(__u.base()), current(__u.base()) { }      template <class _Up>         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14         reverse_iterator& operator=(const reverse_iterator<_Up>& __u)             {  __t = current = __u.base();  return *this;  }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     _Iter base() const { return current; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reference operator*() const { _Iter __tmp = current;  return *--__tmp; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     pointer  operator->() const { return _VSTD::addressof(operator*()); }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator& operator++() { --current;  return *this; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator  operator++(int) { reverse_iterator __tmp(*this);  --current;  return __tmp; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator& operator--() { ++current;  return *this; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator  operator--(int) { reverse_iterator __tmp(*this);  ++current;  return __tmp; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator  operator+ (difference_type __n) const { return reverse_iterator(current - __n); }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator& operator+=(difference_type __n) { current -= __n;  return *this; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator  operator- (difference_type __n) const { return reverse_iterator(current + __n); }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reverse_iterator& operator-=(difference_type __n) { current += __n;  return *this; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reference         operator[](difference_type __n) const { return *(*this + __n); }  };
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 bool operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {      return __x.base() == __y.base();  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 bool operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {      return __x.base() > __y.base();  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 bool operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {      return __x.base() != __y.base();  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 bool operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {      return __x.base() < __y.base();  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 bool operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {      return __x.base() <= __y.base();  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 bool operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {      return __x.base() >= __y.base();  }
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 auto operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) -> decltype(__y.base() - __x.base()) {      return __y.base() - __x.base();  }
     
#else
template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY typename reverse_iterator<_Iter1>::difference_type operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {      return __y.base() - __x.base();  }
     
#endif
 template <class _Iter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 reverse_iterator<_Iter> operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x) {      return reverse_iterator<_Iter>(__x.base() - __n);  }
      
#if _LIBCPP_STD_VER > 11
template <class _Iter> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 reverse_iterator<_Iter> make_reverse_iterator(_Iter __i) {      return reverse_iterator<_Iter>(__i);  }
     
#endif
 template <class _Container> class _LIBCPP_TEMPLATE_VIS back_insert_iterator     : public iterator<output_iterator_tag,                       void,                       void,                       void,                       void> {  protected:     _Container* container;  public:     typedef _Container container_type;       _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) { }      _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)         { container->push_back(__value_);  return *this; }    
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)         { container->push_back(_VSTD::move(__value_));  return *this; }    
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     { return *this; }      _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    { return *this; }      _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) { return *this; }  };
    template <class _Container> inline _LIBCPP_INLINE_VISIBILITY back_insert_iterator<_Container> back_inserter(_Container& __x) {      return back_insert_iterator<_Container>(__x);  }
    template <class _Container> class _LIBCPP_TEMPLATE_VIS front_insert_iterator     : public iterator<output_iterator_tag,                       void,                       void,                       void,                       void> {  protected:     _Container* container;  public:     typedef _Container container_type;       _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) { }      _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)         { container->push_front(__value_);  return *this; }    
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)         { container->push_front(_VSTD::move(__value_));  return *this; }    
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     { return *this; }      _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    { return *this; }      _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) { return *this; }  };
    template <class _Container> inline _LIBCPP_INLINE_VISIBILITY front_insert_iterator<_Container> front_inserter(_Container& __x) {      return front_insert_iterator<_Container>(__x);  }
    template <class _Container> class _LIBCPP_TEMPLATE_VIS insert_iterator     : public iterator<output_iterator_tag,                       void,                       void,                       void,                       void> {  protected:     _Container* container;      typename _Container::iterator iter;  public:     typedef _Container container_type;       _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)         : container(_VSTD::addressof(__x)), iter(__i) { }      _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)         { iter = container->insert(iter, __value_);  ++iter;  return *this; }    
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)         { iter = container->insert(iter, _VSTD::move(__value_));  ++iter;  return *this; }    
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        { return *this; }      _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       { return *this; }      _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    { return *this; }  };
    template <class _Container> inline _LIBCPP_INLINE_VISIBILITY insert_iterator<_Container> inserter(_Container& __x, typename _Container::iterator __i) {      return insert_iterator<_Container>(__x, __i);  }
    template <class _Tp, class _CharT = char,           class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t> class _LIBCPP_TEMPLATE_VIS istream_iterator     : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&> {  public:     typedef _CharT char_type;      typedef _Traits traits_type;      typedef basic_istream<_CharT,_Traits> istream_type;  private:     istream_type* __in_stream_;      _Tp __value_;  public:     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istream_iterator() : __in_stream_(0), __value_() { }      _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(_VSTD::addressof(__s))         {              if (!(*__in_stream_ >> __value_))                 __in_stream_ = 0;          }       _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const { return __value_; }      _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const { return _VSTD::addressof((operator*())); }      _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()         {              if (!(*__in_stream_ >> __value_))                 __in_stream_ = 0;              return *this;          }      _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)         { istream_iterator __t(*this);  ++(*this);  return __t; }       friend _LIBCPP_INLINE_VISIBILITY     bool operator==(const istream_iterator& __x, const istream_iterator& __y)         { return __x.__in_stream_ == __y.__in_stream_; }       friend _LIBCPP_INLINE_VISIBILITY     bool operator!=(const istream_iterator& __x, const istream_iterator& __y)         { return !(__x == __y); }  };
    template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> > class _LIBCPP_TEMPLATE_VIS ostream_iterator     : public iterator<output_iterator_tag, void, void, void, void> {  public:     typedef _CharT char_type;      typedef _Traits traits_type;      typedef basic_ostream<_CharT,_Traits> ostream_type;  private:     ostream_type* __out_stream_;      const char_type* __delim_;  public:     _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s) _NOEXCEPT         : __out_stream_(_VSTD::addressof(__s)), __delim_(0) { }      _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter) _NOEXCEPT         : __out_stream_(_VSTD::addressof(__s)), __delim_(__delimiter) { }      _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)         {              *__out_stream_ << __value_;              if (__delim_)                 *__out_stream_ << __delim_;              return *this;          }       _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     { return *this; }      _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    { return *this; }      _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) { return *this; }  };
    template<class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS istreambuf_iterator     : public iterator<input_iterator_tag, _CharT,                       typename _Traits::off_type, _CharT*,                       _CharT> {  public:     typedef _CharT                          char_type;      typedef _Traits                         traits_type;      typedef typename _Traits::int_type      int_type;      typedef basic_streambuf<_CharT,_Traits> streambuf_type;      typedef basic_istream<_CharT,_Traits>   istream_type;  private:     mutable streambuf_type* __sbuf_;       class __proxy     {          char_type __keep_;          streambuf_type* __sbuf_;          _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)             : __keep_(__c), __sbuf_(__s) { }          friend class istreambuf_iterator;      public:         _LIBCPP_INLINE_VISIBILITY char_type operator*() const { return __keep_; }      };       _LIBCPP_INLINE_VISIBILITY     bool __test_for_eof() const     {          if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))             __sbuf_ = 0;          return __sbuf_ == 0;      }  public:     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) { }      _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT         : __sbuf_(__s.rdbuf()) { }      _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT         : __sbuf_(__s) { }      _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT         : __sbuf_(__p.__sbuf_) { }       _LIBCPP_INLINE_VISIBILITY char_type  operator*() const         { return static_cast<char_type>(__sbuf_->sgetc()); }      _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()         {              __sbuf_->sbumpc();              return *this;          }      _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)         {              return __proxy(__sbuf_->sbumpc(), __sbuf_);          }       _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const         { return __test_for_eof() == __b.__test_for_eof(); }  };
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,                 const istreambuf_iterator<_CharT,_Traits>& __b)                 { return __a.equal(__b); }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,                 const istreambuf_iterator<_CharT,_Traits>& __b)                 { return !__a.equal(__b); }
    template <class _Iter> class _LIBCPP_TEMPLATE_VIS move_iterator {  private:     _Iter __i;  public:     typedef _Iter                                            iterator_type;      typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;      typedef typename iterator_traits<iterator_type>::value_type value_type;      typedef typename iterator_traits<iterator_type>::difference_type difference_type;      typedef iterator_type pointer;    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename iterator_traits<iterator_type>::reference __reference;      typedef typename conditional<             is_reference<__reference>::value,             typename remove_reference<__reference>::type&&,             __reference         >::type reference;    
#else
    typedef typename iterator_traits<iterator_type>::reference reference;    
#endif
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator() : __i() { }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     explicit move_iterator(_Iter __x) : __i(__x) { }      template <class _Up>       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14       move_iterator(const move_iterator<_Up>& __u) : __i(__u.base()) { }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 _Iter base() const { return __i; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14      reference operator*() const {  return static_cast<reference>(*__i);  }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     pointer  operator->() const {  return __i; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator& operator++() { ++__i;  return *this; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator  operator++(int) { move_iterator __tmp(*this);  ++__i;  return __tmp; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator& operator--() { --__i;  return *this; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator  operator--(int) { move_iterator __tmp(*this);  --__i;  return __tmp; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator  operator+ (difference_type __n) const { return move_iterator(__i + __n); }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator& operator+=(difference_type __n) { __i += __n;  return *this; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator  operator- (difference_type __n) const { return move_iterator(__i - __n); }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     move_iterator& operator-=(difference_type __n) { __i -= __n;  return *this; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reference operator[](difference_type __n) const {  return static_cast<reference>(__i[__n]);  }  };
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 bool operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y) {      return __x.base() == __y.base();  }
 template <class _Iter> class __wrap_iter;
    template <class _Iter1, class _Iter2> _LIBCPP_INLINE_VISIBILITY bool operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
    template <class _Iter1, class _Iter2> _LIBCPP_INLINE_VISIBILITY bool operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
    template <class _Iter1, class _Iter2> _LIBCPP_INLINE_VISIBILITY bool operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
    template <class _Iter1, class _Iter2> _LIBCPP_INLINE_VISIBILITY bool operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
    template <class _Iter1, class _Iter2> _LIBCPP_INLINE_VISIBILITY bool operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
    template <class _Iter1, class _Iter2> _LIBCPP_INLINE_VISIBILITY bool operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;
 template <class _Iter> _LIBCPP_INLINE_VISIBILITY __wrap_iter<_Iter> operator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT_DEBUG;
    template <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);
   template <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);
   template <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);
   template <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);
      
#if _LIBCPP_DEBUG_LEVEL < 2
 template <class _Tp> _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_trivially_copy_assignable<_Tp>::value,     _Tp* >::type __unwrap_iter(__wrap_iter<_Tp*>);
      
#else
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_trivially_copy_assignable<_Tp>::value,     __wrap_iter<_Tp*> >::type __unwrap_iter(__wrap_iter<_Tp*> __i);
      
#endif
 template <class _Iter> class __wrap_iter {  public:     typedef _Iter                                                      iterator_type;      typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;      typedef typename iterator_traits<iterator_type>::value_type        value_type;      typedef typename iterator_traits<iterator_type>::difference_type   difference_type;      typedef typename iterator_traits<iterator_type>::pointer           pointer;      typedef typename iterator_traits<iterator_type>::reference         reference;  private:     iterator_type __i;  public:     _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT_DEBUG   
#if _LIBCPP_STD_VER > 11
                : __i{ }    
#endif
    {    
#if _LIBCPP_DEBUG_LEVEL >= 2
        __get_db()->__insert_i(this);    
#endif
    }      template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,         typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT_DEBUG         : __i(__u.base())     {    
#if _LIBCPP_DEBUG_LEVEL >= 2
        __get_db()->__iterator_copy(this, &__u);    
#endif
    }    
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     __wrap_iter(const __wrap_iter& __x)         : __i(__x.base())     {          __get_db()->__iterator_copy(this, &__x);      }      _LIBCPP_INLINE_VISIBILITY     __wrap_iter& operator=(const __wrap_iter& __x)     {          if (this != &__x)         {              __get_db()->__iterator_copy(this, &__x);              __i = __x.__i;          }          return *this;      }      _LIBCPP_INLINE_VISIBILITY     ~__wrap_iter()     {          __get_db()->__erase_i(this);      }    
#endif
    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT_DEBUG     {    
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),                        "Attempted to dereference a non-dereferenceable iterator");    
#endif
        return *__i;      }      _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT_DEBUG     {    
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),                        "Attempted to dereference a non-dereferenceable iterator");    
#endif
        return (pointer)_VSTD::addressof(*__i);      }      _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT_DEBUG     {    
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),                        "Attempted to increment non-incrementable iterator");    
#endif
        ++__i;          return *this;      }      _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT_DEBUG         { __wrap_iter __tmp(*this);  ++(*this);  return __tmp; }      _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT_DEBUG     {    
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),                        "Attempted to decrement non-decrementable iterator");    
#endif
        --__i;          return *this;      }      _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT_DEBUG         { __wrap_iter __tmp(*this);  --(*this);  return __tmp; }      _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT_DEBUG         { __wrap_iter __w(*this);  __w += __n;  return __w; }      _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT_DEBUG     {    
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),                    "Attempted to add/subtract iterator outside of valid range");    
#endif
        __i += __n;          return *this;      }      _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT_DEBUG         { return *this + (-__n); }      _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT_DEBUG         { *this += -__n;  return *this; }      _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT_DEBUG     {    
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),                    "Attempted to subscript iterator outside of valid range");    
#endif
        return __i[__n];      }       _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT_DEBUG { return __i; }   private:   
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)     {          __get_db()->__insert_ic(this, __p);      }    
#else
    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT_DEBUG : __i(__x) { }    
#endif
     template <class _Up> friend class __wrap_iter;      template <class _CharT, class _Traits, class _Alloc> friend class basic_string;      template <class _Tp, class _Alloc> friend class _LIBCPP_TEMPLATE_VIS vector;       template <class _Iter1, class _Iter2>     friend     bool     operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;       template <class _Iter1, class _Iter2>     friend     bool     operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;       template <class _Iter1, class _Iter2>     friend     bool     operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;       template <class _Iter1, class _Iter2>     friend     bool     operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;       template <class _Iter1, class _Iter2>     friend     bool     operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;       template <class _Iter1, class _Iter2>     friend     bool     operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT_DEBUG;     
#ifndef _LIBCPP_CXX03_LANG
    template <class _Iter1, class _Iter2>     friend     auto     operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG     -> decltype(__x.base() - __y.base());    
  template <class _Tp>   inline _LIBCPP_INLINE_VISIBILITY   typename enable_if   <       is_trivially_copy_assignable<_Tp>::value,       __wrap_iter<_Tp*>   >::type   __unwrap_iter(__wrap_iter<_Tp*> __i);    
#endif
};
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG {      return __x.base() == __y.base();  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY bool operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG {    
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),                    "Attempted to compare incomparable iterators");    
#endif
    return __x.base() < __y.base();  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG {      return !(__x == __y);  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG {      return __y < __x;  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG {      return !(__x < __y);  }
    template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG {      return !(__y < __x);  }
    template <class _Iter1> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG {      return !(__x == __y);  }
    template <class _Iter1> inline _LIBCPP_INLINE_VISIBILITY bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG {      return __y < __x;  }
    template <class _Iter1> inline _LIBCPP_INLINE_VISIBILITY bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG {      return !(__x < __y);  }
    template <class _Iter1> inline _LIBCPP_INLINE_VISIBILITY bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG {      return !(__y < __x);  }
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY auto operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG -> decltype(__x.base() - __y.base()) {    
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),                    "Attempted to subtract incompatible iterators");    
#endif
    return __x.base() - __y.base();  }
     
#else
template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG {    
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),                    "Attempted to subtract incompatible iterators");    
#endif
    return __x.base() - __y.base();  }
     
#endif
 template <class _Iter> inline _LIBCPP_INLINE_VISIBILITY __wrap_iter<_Iter> operator+(typename __wrap_iter<_Iter>::difference_type __n,           __wrap_iter<_Iter> __x) _NOEXCEPT_DEBUG {      __x += __n;      return __x;  }
    template <class _Iter> struct __libcpp_is_trivial_iterator     : public _LIBCPP_BOOL_CONSTANT(is_pointer<_Iter>::value) { };
        template <class _Iter> struct __libcpp_is_trivial_iterator<move_iterator<_Iter> >     : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) { };
    template <class _Iter> struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter> >     : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) { };
    template <class _Iter> struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >     : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value) { };
     template <class _Tp, size_t _Np> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp* begin(_Tp (&__array)[_Np]) {      return __array;  }
    template <class _Tp, size_t _Np> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp* end(_Tp (&__array)[_Np]) {      return __array + _Np;  }
      
#if !defined(_LIBCPP_CXX03_LANG)
 template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 auto begin(_Cp& __c) -> decltype(__c.begin()) {      return __c.begin();  }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 auto begin(const _Cp& __c) -> decltype(__c.begin()) {      return __c.begin();  }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 auto end(_Cp& __c) -> decltype(__c.end()) {      return __c.end();  }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 auto end(const _Cp& __c) -> decltype(__c.end()) {      return __c.end();  }
      
#if _LIBCPP_STD_VER > 11
 template <class _Tp, size_t _Np> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np]) {      return reverse_iterator<_Tp*>(__array + _Np);  }
    template <class _Tp, size_t _Np> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np]) {      return reverse_iterator<_Tp*>(__array);  }
    template <class _Ep> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il) {      return reverse_iterator<const _Ep*>(__il.end());  }
    template <class _Ep> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il) {      return reverse_iterator<const _Ep*>(__il.begin());  }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 auto cbegin(const _Cp& __c) -> decltype(_VSTD::begin(__c)) {      return _VSTD::begin(__c);  }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 auto cend(const _Cp& __c) -> decltype(_VSTD::end(__c)) {      return _VSTD::end(__c);  }
#endif
    
#else  // defined(_LIBCPP_CXX03_LANG)
 template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY typename _Cp::iterator begin(_Cp& __c) {      return __c.begin();  }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY typename _Cp::const_iterator begin(const _Cp& __c) {      return __c.begin();  }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY typename _Cp::iterator end(_Cp& __c) {      return __c.end();  }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY typename _Cp::const_iterator end(const _Cp& __c) {      return __c.end();  }
      
    template <class _Ep> constexpr bool empty(initializer_list<_Ep> __il) noexcept {  return __il.size() == 0;  }
    template <class _Cont> constexpr auto data(_Cont& __c) -> decltype(__c.data()) {  return __c.data();  }
    template <class _Cont> constexpr auto data(const _Cont& __c) -> decltype(__c.data()) {  return __c.data();  }
    template <class _Tp, size_t _Sz> constexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept {  return __array;  }
    template <class _Ep> constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept {  return __il.begin();  }
     
#endif
  _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_ITERATOR
  
#pragma clang module end /*std.iterator*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__functional_base>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__functional_base
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_FUNCTIONAL_BASE
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
#endif
struct _LIBCPP_TEMPLATE_VIS less : binary_function<_Tp, _Tp, bool> {      _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY      bool operator()(const _Tp& __x, const _Tp& __y) const         { return __x < __y; }  };
      
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS less<void> {      template <class _T1, class _T2>      _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u))         {  return        _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u);  }      typedef void is_transparent;  };
     
#endif
#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
typedef fpos<mbstate_t>    u16streampos;  typedef fpos<mbstate_t>    u32streampos;    
#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
   
#if defined(_NEWLIB_VERSION)
// On newlib, off_t is 'long int'
typedef long int streamoff;          // for char_traits in <string>
  
#else
typedef long long streamoff;         // for char_traits in <string>
  
#endif
 template <class _CharT,             // for <stdexcept>
          class _Traits = char_traits<_CharT>,           class _Allocator = allocator<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_string;  typedef basic_string<char, char_traits<char>, allocator<char> > string;  typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;    // Include other forward declarations here
template <class _Tp, class _Alloc = allocator<_Tp> > class _LIBCPP_TEMPLATE_VIS vector;   _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_IOSFWD
  
#pragma clang module end /*std.iosfwd*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <tuple>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.tuple
// -*- C++ -*-
//===--------------------------- tuple ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TUPLE
  
#define _LIBCPP_TUPLE
 /*     tuple synopsis  namespace std {   template <class... T> class tuple {  public:     constexpr tuple();      explicit tuple(const T&...);   // constexpr in C++14
    template <class... U>         explicit tuple(U&&...);   // constexpr in C++14
    tuple(const tuple&) = default;      tuple(tuple&&) = default;      template <class... U>         tuple(const tuple<U...>&);   // constexpr in C++14
    template <class... U>         tuple(tuple<U...>&&);   // constexpr in C++14
    template <class U1, class U2>         tuple(const pair<U1, U2>&);  // iff sizeof...(T) == 2 // constexpr in C++14
    template <class U1, class U2>         tuple(pair<U1, U2>&&);  // iff sizeof...(T) == 2  // constexpr in C++14
     // allocator-extended constructors
#endif // !_LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_UTILITY
  
#pragma clang module end /*std.utility*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD    
#ifndef _LIBCPP_CXX03_LANG
  // __tuple_leaf
 template <size_t _Ip, class _Hp,           bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value          > class __tuple_leaf;
    template <size_t _Ip, class _Hp, bool _Ep> inline _LIBCPP_INLINE_VISIBILITY void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)     _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value) {      swap(__x.get(), __y.get());  }
    template <size_t _Ip, class _Hp, bool> class __tuple_leaf {      _Hp __value_;       template <class _Tp>     static constexpr bool __can_bind_reference() {          using _RawTp = typename remove_reference<_Tp>::type;          using _RawHp = typename remove_reference<_Hp>::type;          using _CheckLValueArg = integral_constant<bool,             is_lvalue_reference<_Tp>::value         ||  is_same<_RawTp, reference_wrapper<_RawHp>>::value         ||  is_same<_RawTp, reference_wrapper<typename remove_const<_RawHp>::type>>::value         >;          return  !is_reference<_Hp>::value             || (is_lvalue_reference<_Hp>::value && _CheckLValueArg::value)             || (is_rvalue_reference<_Hp>::value && !is_lvalue_reference<_Tp>::value);      }       __tuple_leaf& operator=(const __tuple_leaf&);  public:     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()              _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : __value_()        { static_assert(!is_reference<_Hp>::value,               "Attempted to default construct a reference element in a tuple"); }       template <class _Alloc>         _LIBCPP_INLINE_VISIBILITY         __tuple_leaf(integral_constant<int, 0>, const _Alloc&)             : __value_()         { static_assert(!is_reference<_Hp>::value,               "Attempted to default construct a reference element in a tuple"); }       template <class _Alloc>         _LIBCPP_INLINE_VISIBILITY         __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)             : __value_(allocator_arg_t(), __a)         { static_assert(!is_reference<_Hp>::value,               "Attempted to default construct a reference element in a tuple"); }       template <class _Alloc>         _LIBCPP_INLINE_VISIBILITY         __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)             : __value_(__a)         { static_assert(!is_reference<_Hp>::value,               "Attempted to default construct a reference element in a tuple"); }       template <class _Tp,               class = typename enable_if<                   __lazy_and<                       __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>                     , is_constructible<_Hp, _Tp>                     >::value                 >::type             >         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11         explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))             : __value_(_VSTD::forward<_Tp>(__t))         { static_assert(__can_bind_reference<_Tp>(),        "Attempted to construct a reference element in a tuple with an rvalue"); }       template <class _Tp, class _Alloc>         _LIBCPP_INLINE_VISIBILITY         explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)             : __value_(_VSTD::forward<_Tp>(__t))         { static_assert(__can_bind_reference<_Tp>(),        "Attempted to construct a reference element in a tuple with an rvalue"); }       template <class _Tp, class _Alloc>         _LIBCPP_INLINE_VISIBILITY         explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)             : __value_(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))         { static_assert(!is_reference<_Hp>::value,             "Attempted to uses-allocator construct a reference element in a tuple"); }       template <class _Tp, class _Alloc>         _LIBCPP_INLINE_VISIBILITY         explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)             : __value_(_VSTD::forward<_Tp>(__t), __a)         { static_assert(!is_reference<_Hp>::value,            "Attempted to uses-allocator construct a reference element in a tuple"); }       __tuple_leaf(const __tuple_leaf& __t) = default;      __tuple_leaf(__tuple_leaf&& __t) = default;       template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         __tuple_leaf&         operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))         {              __value_ = _VSTD::forward<_Tp>(__t);              return *this;          }       _LIBCPP_INLINE_VISIBILITY     int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)     {          _VSTD::swap(*this, __t);          return 0;      }       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT { return __value_; }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT { return __value_; }  };
    template <size_t _Ip, class _Hp> class __tuple_leaf<_Ip, _Hp, true>     : private _Hp {       __tuple_leaf& operator=(const __tuple_leaf&);  public:     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR __tuple_leaf()              _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) { }       template <class _Alloc>         _LIBCPP_INLINE_VISIBILITY         __tuple_leaf(integral_constant<int, 0>, const _Alloc&) { }       template <class _Alloc>         _LIBCPP_INLINE_VISIBILITY         __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)             : _Hp(allocator_arg_t(), __a) { }       template <class _Alloc>         _LIBCPP_INLINE_VISIBILITY         __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)             : _Hp(__a) { }       template <class _Tp,               class = typename enable_if<                   __lazy_and<                         __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>                       , is_constructible<_Hp, _Tp>                     >::value                 >::type             >         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11         explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))             : _Hp(_VSTD::forward<_Tp>(__t)) { }       template <class _Tp, class _Alloc>         _LIBCPP_INLINE_VISIBILITY         explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)             : _Hp(_VSTD::forward<_Tp>(__t)) { }       template <class _Tp, class _Alloc>         _LIBCPP_INLINE_VISIBILITY         explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)             : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) { }       template <class _Tp, class _Alloc>         _LIBCPP_INLINE_VISIBILITY         explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)             : _Hp(_VSTD::forward<_Tp>(__t), __a) { }       __tuple_leaf(__tuple_leaf const &) = default;      __tuple_leaf(__tuple_leaf &&) = default;       template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         __tuple_leaf&         operator=(_Tp&& __t) _NOEXCEPT_((is_nothrow_assignable<_Hp&, _Tp>::value))         {              _Hp::operator=(_VSTD::forward<_Tp>(__t));              return *this;          }       _LIBCPP_INLINE_VISIBILITY     int     swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)     {          _VSTD::swap(*this, __t);          return 0;      }       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11       _Hp& get()       _NOEXCEPT { return static_cast<_Hp&>(*this); }      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Hp& get() const _NOEXCEPT { return static_cast<const _Hp&>(*this); }  };
    template <class ..._Tp> _LIBCPP_INLINE_VISIBILITY void __swallow(_Tp&&...) _NOEXCEPT { }
    template <class ..._Tp> struct __lazy_all : __all<_Tp::value...> { };
    template <class _Tp> struct __all_default_constructible;
    template <class ..._Tp> struct __all_default_constructible<__tuple_types<_Tp...>>     : __all<is_default_constructible<_Tp>::value...> {  };
    // __tuple_impl
 template<class _Indx, class ..._Tp> struct __tuple_impl;
    template<size_t ..._Indx, class ..._Tp> struct _LIBCPP_DECLSPEC_EMPTY_BASES __tuple_impl<__tuple_indices<_Indx...>, _Tp...>     : public __tuple_leaf<_Indx, _Tp>... {      _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR __tuple_impl()         _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) { }       template <size_t ..._Uf, class ..._Tf,               size_t ..._Ul, class ..._Tl, class ..._Up>         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11         explicit         __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,                      __tuple_indices<_Ul...>, __tuple_types<_Tl...>,                      _Up&&... __u)                      _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&                                  __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :             __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,             __tuple_leaf<_Ul, _Tl>()...             { }       template <class _Alloc, size_t ..._Uf, class ..._Tf,               size_t ..._Ul, class ..._Tl, class ..._Up>         _LIBCPP_INLINE_VISIBILITY         explicit         __tuple_impl(allocator_arg_t, const _Alloc& __a,                      __tuple_indices<_Uf...>, __tuple_types<_Tf...>,                      __tuple_indices<_Ul...>, __tuple_types<_Tl...>,                      _Up&&... __u) :             __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,             _VSTD::forward<_Up>(__u))...,             __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...             { }       template <class _Tuple,               class = typename enable_if                       <                          __tuple_constructible<_Tuple, tuple<_Tp...> >::value                       >::type              >         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11         __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,                                        typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))             : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,                                        typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...             { }       template <class _Alloc, class _Tuple,               class = typename enable_if                       <                          __tuple_constructible<_Tuple, tuple<_Tp...> >::value                       >::type              >         _LIBCPP_INLINE_VISIBILITY         __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)             : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,                                        typename __make_tuple_types<_Tuple>::type>::type>(), __a,                                        _VSTD::forward<typename tuple_element<_Indx,                                        typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...             { }       template <class _Tuple>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             __tuple_assignable<_Tuple, tuple<_Tp...> >::value,             __tuple_impl&         >::type         operator=(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_assignable<_Tp&, typename tuple_element<_Indx,                                        typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))         {              __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<typename tuple_element<_Indx,                                        typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...);              return *this;          }       __tuple_impl(const __tuple_impl&) = default;      __tuple_impl(__tuple_impl&&) = default;       _LIBCPP_INLINE_VISIBILITY     __tuple_impl&     operator=(const __tuple_impl& __t) _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))     {          __swallow(__tuple_leaf<_Indx, _Tp>::operator=(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t).get())...);          return *this;      }       _LIBCPP_INLINE_VISIBILITY     __tuple_impl&     operator=(__tuple_impl&& __t) _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))     {          __swallow(__tuple_leaf<_Indx, _Tp>::operator=(_VSTD::forward<_Tp>(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t).get()))...);          return *this;      }       _LIBCPP_INLINE_VISIBILITY     void swap(__tuple_impl& __t)         _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)     {          __swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);      }  };
      template <class ..._Tp> class _LIBCPP_TEMPLATE_VIS tuple {      typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;       _BaseT __base_;     
#if defined(_LIBCPP_ENABLE_TUPLE_IMPLICIT_REDUCED_ARITY_EXTENSION)
    static constexpr bool _EnableImplicitReducedArityExtension = true;    
#else
    static constexpr bool _EnableImplicitReducedArityExtension = false;    
#endif
     template <class ..._Args>     struct _PackExpandsToThisTuple : false_type { };       template <class _Arg>     struct _PackExpandsToThisTuple<_Arg>         : is_same<typename __uncvref<_Arg>::type, tuple> { };       template <bool _MaybeEnable, class _Dummy = void>     struct _CheckArgsConstructor : __check_tuple_constructor_fail { };       template <class _Dummy>     struct _CheckArgsConstructor<true, _Dummy>     {          template <class ..._Args>         static constexpr bool __enable_default() {              return __all<is_default_constructible<_Args>::value...>::value;          }           template <class ..._Args>         static constexpr bool __enable_explicit() {              return                 __tuple_constructible<                     tuple<_Args...>,                     typename __make_tuple_types<tuple,                              sizeof...(_Args) < sizeof...(_Tp) ?                                  sizeof...(_Args) :                                  sizeof...(_Tp)>::type                 >::value &&                 !__tuple_convertible<                     tuple<_Args...>,                     typename __make_tuple_types<tuple,                              sizeof...(_Args) < sizeof...(_Tp) ?                                  sizeof...(_Args) :                                  sizeof...(_Tp)>::type                 >::value &&                 __all_default_constructible<                     typename __make_tuple_types<tuple, sizeof...(_Tp),                              sizeof...(_Args) < sizeof...(_Tp) ?                                  sizeof...(_Args) :                                  sizeof...(_Tp)>::type                 >::value;          }           template <class ..._Args>         static constexpr bool __enable_implicit() {              return                 __tuple_convertible<                     tuple<_Args...>,                     typename __make_tuple_types<tuple,                              sizeof...(_Args) < sizeof...(_Tp) ?                                  sizeof...(_Args) :                                  sizeof...(_Tp)>::type                 >::value &&                 __all_default_constructible<                     typename __make_tuple_types<tuple, sizeof...(_Tp),                              sizeof...(_Args) < sizeof...(_Tp) ?                                  sizeof...(_Args) :                                  sizeof...(_Tp)>::type                 >::value;          }      };       template <bool _MaybeEnable,               bool = sizeof...(_Tp) == 1,               class _Dummy = void>     struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail { };       template <class _Dummy>     struct _CheckTupleLikeConstructor<true, false, _Dummy>     {          template <class _Tuple>         static constexpr bool __enable_implicit() {              return __tuple_convertible<_Tuple, tuple>::value;          }           template <class _Tuple>         static constexpr bool __enable_explicit() {              return __tuple_constructible<_Tuple, tuple>::value                && !__tuple_convertible<_Tuple, tuple>::value;          }      };       template <class _Dummy>     struct _CheckTupleLikeConstructor<true, true, _Dummy>     {          // This trait is used to disable the tuple-like constructor when
        // the UTypes... constructor should be selected instead.
        // See LWG issue #2549.
        template <class _Tuple>         using _PreferTupleLikeConstructor = __lazy_or<             // Don't attempt the two checks below if the tuple we are given
            // has the same type as this tuple.
            is_same<typename __uncvref<_Tuple>::type, tuple>,             __lazy_and<                 __lazy_not<is_constructible<_Tp..., _Tuple>>,                 __lazy_not<is_convertible<_Tuple, _Tp...>>             >         >;           template <class _Tuple>         static constexpr bool __enable_implicit() {              return __lazy_and<                 __tuple_convertible<_Tuple, tuple>,                 _PreferTupleLikeConstructor<_Tuple>             >::value;          }           template <class _Tuple>         static constexpr bool __enable_explicit() {              return __lazy_and<                 __tuple_constructible<_Tuple, tuple>,                 _PreferTupleLikeConstructor<_Tuple>,                 __lazy_not<__tuple_convertible<_Tuple, tuple>>             >::value;          }      };       template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11         typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;      template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11         const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;      template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11         typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;      template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_AFTER_CXX11         const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;  public:      template <bool _Dummy = true, class = typename enable_if<         _CheckArgsConstructor<_Dummy>::template __enable_default<_Tp...>()     >::type>     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR tuple()         _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) { }       tuple(tuple const&) = default;      tuple(tuple&&) = default;       template <class _AllocArgT, class _Alloc, bool _Dummy = true, class = typename enable_if<         __lazy_and<             is_same<allocator_arg_t, _AllocArgT>,             __lazy_all<__dependent_type<is_default_constructible<_Tp>, _Dummy>...>        >::value     >::type>     _LIBCPP_INLINE_VISIBILITY     tuple(_AllocArgT, _Alloc const& __a)       : __base_(allocator_arg_t(), __a,                     __tuple_indices<>(), __tuple_types<>(),                     typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),                     __tuple_types<_Tp...>()) { }       template <bool _Dummy = true,               typename enable_if                       <                          _CheckArgsConstructor<                             _Dummy                          >::template __enable_implicit<_Tp const&...>(),                          bool                       >::type = false         >     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))         : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),                 typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),                 typename __make_tuple_indices<0>::type(),                 typename __make_tuple_types<tuple, 0>::type(),                 __t...                ) { }       template <bool _Dummy = true,               typename enable_if                       <                          _CheckArgsConstructor<                             _Dummy                          >::template __enable_explicit<_Tp const&...>(),                          bool                       >::type = false         >     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     explicit tuple(const _Tp& ... __t) _NOEXCEPT_((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))         : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),                 typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),                 typename __make_tuple_indices<0>::type(),                 typename __make_tuple_types<tuple, 0>::type(),                 __t...                ) { }       template <class _Alloc, bool _Dummy = true,               typename enable_if                       <                          _CheckArgsConstructor<                             _Dummy                          >::template __enable_implicit<_Tp const&...>(),                          bool                       >::type = false         >       _LIBCPP_INLINE_VISIBILITY       tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)         : __base_(allocator_arg_t(), __a,                 typename __make_tuple_indices<sizeof...(_Tp)>::type(),                 typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),                 typename __make_tuple_indices<0>::type(),                 typename __make_tuple_types<tuple, 0>::type(),                 __t...                ) { }       template <class _Alloc, bool _Dummy = true,               typename enable_if                       <                          _CheckArgsConstructor<                             _Dummy                          >::template __enable_explicit<_Tp const&...>(),                          bool                       >::type = false         >       _LIBCPP_INLINE_VISIBILITY       explicit       tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)         : __base_(allocator_arg_t(), __a,                 typename __make_tuple_indices<sizeof...(_Tp)>::type(),                 typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),                 typename __make_tuple_indices<0>::type(),                 typename __make_tuple_types<tuple, 0>::type(),                 __t...                ) { }       template <class ..._Up,               bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,               typename enable_if                       <                          _CheckArgsConstructor<                              sizeof...(_Up) == sizeof...(_Tp)                              && !_PackIsTuple                          >::template __enable_implicit<_Up...>() ||                         _CheckArgsConstructor<                             _EnableImplicitReducedArityExtension                             && sizeof...(_Up) < sizeof...(_Tp)                             && !_PackIsTuple                          >::template __enable_implicit<_Up...>(),                          bool                       >::type = false              >         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11         tuple(_Up&&... __u)             _NOEXCEPT_((                 is_nothrow_constructible<_BaseT,                     typename __make_tuple_indices<sizeof...(_Up)>::type,                     typename __make_tuple_types<tuple, sizeof...(_Up)>::type,                     typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,                     typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,                     _Up...                 >::value             ))             : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),                     typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),                     typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),                     typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),                     _VSTD::forward<_Up>(__u)...) { }       template <class ..._Up,               typename enable_if                       <                          _CheckArgsConstructor<                              sizeof...(_Up) <= sizeof...(_Tp)                              && !_PackExpandsToThisTuple<_Up...>::value                          >::template __enable_explicit<_Up...>() ||                          _CheckArgsConstructor<                             !_EnableImplicitReducedArityExtension                             && sizeof...(_Up) < sizeof...(_Tp)                             && !_PackExpandsToThisTuple<_Up...>::value                          >::template __enable_implicit<_Up...>(),                          bool                       >::type = false              >         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11         explicit         tuple(_Up&&... __u)             _NOEXCEPT_((                 is_nothrow_constructible<_BaseT,                     typename __make_tuple_indices<sizeof...(_Up)>::type,                     typename __make_tuple_types<tuple, sizeof...(_Up)>::type,                     typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,                     typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type,                     _Up...                 >::value             ))             : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),                     typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),                     typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),                     typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),                     _VSTD::forward<_Up>(__u)...) { }       template <class _Alloc, class ..._Up,               typename enable_if                       <                          _CheckArgsConstructor<                              sizeof...(_Up) == sizeof...(_Tp) &&                              !_PackExpandsToThisTuple<_Up...>::value                          >::template __enable_implicit<_Up...>(),                          bool                       >::type = false              >         _LIBCPP_INLINE_VISIBILITY         tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)             : __base_(allocator_arg_t(), __a,                     typename __make_tuple_indices<sizeof...(_Up)>::type(),                     typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),                     typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),                     typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),                     _VSTD::forward<_Up>(__u)...) { }       template <class _Alloc, class ..._Up,               typename enable_if                       <                          _CheckArgsConstructor<                              sizeof...(_Up) == sizeof...(_Tp) &&                              !_PackExpandsToThisTuple<_Up...>::value                          >::template __enable_explicit<_Up...>(),                          bool                       >::type = false              >         _LIBCPP_INLINE_VISIBILITY         explicit         tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)             : __base_(allocator_arg_t(), __a,                     typename __make_tuple_indices<sizeof...(_Up)>::type(),                     typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),                     typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),                     typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),                     _VSTD::forward<_Up>(__u)...) { }       template <class _Tuple,               typename enable_if                       <                          _CheckTupleLikeConstructor<                              __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value                              && !_PackExpandsToThisTuple<_Tuple>::value                          >::template __enable_implicit<_Tuple>(),                          bool                       >::type = false              >         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11         tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<_BaseT, _Tuple>::value))             : __base_(_VSTD::forward<_Tuple>(__t)) { }       template <class _Tuple,               typename enable_if                       <                          _CheckTupleLikeConstructor<                              __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value                              && !_PackExpandsToThisTuple<_Tuple>::value                          >::template __enable_explicit<_Tuple>(),                          bool                       >::type = false              >         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11         explicit         tuple(_Tuple&& __t) _NOEXCEPT_((is_nothrow_constructible<_BaseT, _Tuple>::value))             : __base_(_VSTD::forward<_Tuple>(__t)) { }       template <class _Alloc, class _Tuple,               typename enable_if                       <                          _CheckTupleLikeConstructor<                              __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value                          >::template __enable_implicit<_Tuple>(),                          bool                       >::type = false              >         _LIBCPP_INLINE_VISIBILITY         tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)             : __base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) { }       template <class _Alloc, class _Tuple,               typename enable_if                       <                          _CheckTupleLikeConstructor<                              __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value                          >::template __enable_explicit<_Tuple>(),                          bool                       >::type = false              >         _LIBCPP_INLINE_VISIBILITY         explicit         tuple(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)             : __base_(allocator_arg_t(), __a, _VSTD::forward<_Tuple>(__t)) { }       using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;      using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;       _LIBCPP_INLINE_VISIBILITY     tuple& operator=(typename conditional<_CanCopyAssign::value, tuple, __nat>::type const& __t)         _NOEXCEPT_((__all<is_nothrow_copy_assignable<_Tp>::value...>::value))     {          __base_.operator=(__t.__base_);          return *this;      }       _LIBCPP_INLINE_VISIBILITY     tuple& operator=(typename conditional<_CanMoveAssign::value, tuple, __nat>::type&& __t)         _NOEXCEPT_((__all<is_nothrow_move_assignable<_Tp>::value...>::value))     {          __base_.operator=(static_cast<_BaseT&&>(__t.__base_));          return *this;      }       template <class _Tuple,               class = typename enable_if                       <                          __tuple_assignable<_Tuple, tuple>::value                       >::type              >         _LIBCPP_INLINE_VISIBILITY         tuple&         operator=(_Tuple&& __t) _NOEXCEPT_((is_nothrow_assignable<_BaseT&, _Tuple>::value))         {              __base_.operator=(_VSTD::forward<_Tuple>(__t));              return *this;          }       _LIBCPP_INLINE_VISIBILITY     void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)         { __base_.swap(__t.__base_); }  };
    template <> class _LIBCPP_TEMPLATE_VIS tuple<> {  public:     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR tuple() _NOEXCEPT { }      template <class _Alloc>     _LIBCPP_INLINE_VISIBILITY         tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT { }      template <class _Alloc>     _LIBCPP_INLINE_VISIBILITY         tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT { }      template <class _Up>     _LIBCPP_INLINE_VISIBILITY         tuple(array<_Up, 0>) _NOEXCEPT { }      template <class _Alloc, class _Up>     _LIBCPP_INLINE_VISIBILITY         tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT { }      _LIBCPP_INLINE_VISIBILITY     void swap(tuple&) _NOEXCEPT { }  };
      
#ifdef __cpp_deduction_guides
// NOTE: These are not yet standardized, but are required to simulate the
// implicit deduction guide that should be generated had libc++ declared the
// tuple-like constructors "correctly"
template <class _Alloc, class ..._Args> tuple(allocator_arg_t, const _Alloc&, tuple<_Args...> const&) -> tuple<_Args...>;
   template <class _Alloc, class ..._Args> tuple(allocator_arg_t, const _Alloc&, tuple<_Args...>&&) -> tuple<_Args...>;
     
#endif
 template <class ..._Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     __all<__is_swappable<_Tp>::value...>::value,     void >::type swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)                  _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)     { __t.swap(__u); }
    // get
    template <class... _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 tuple<_Tp&&...> forward_as_tuple(_Tp&&... __t) _NOEXCEPT {      return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);  }
    template <size_t _Ip> struct __tuple_equal {      template <class _Tp, class _Up>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _Tp& __x, const _Up& __y)     {          return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);      }  };
    template <> struct __tuple_equal<0> {      template <class _Tp, class _Up>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _Tp&, const _Up&)     {          return true;      }  };
    template <class ..._Tp, class ..._Up> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {      return __tuple_equal<sizeof...(_Tp)>()(__x, __y);  }
    template <class ..._Tp, class ..._Up> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {      return !(__x == __y);  }
    template <size_t _Ip> struct __tuple_less {      template <class _Tp, class _Up>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _Tp& __x, const _Up& __y)     {          const size_t __idx = tuple_size<_Tp>::value - _Ip;          if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))             return true;          if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))             return false;          return __tuple_less<_Ip-1>()(__x, __y);      }  };
    template <> struct __tuple_less<0> {      template <class _Tp, class _Up>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _Tp&, const _Up&)     {          return false;      }  };
    template <class ..._Tp, class ..._Up> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {      return __tuple_less<sizeof...(_Tp)>()(__x, __y);  }
#if _LIBCPP_STD_VER > 14
template <class _Tp> constexpr size_t tuple_size_v = tuple_size<_Tp>::value;
      
#define _LIBCPP_NOEXCEPT_RETURN(...) noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }
 template <class _Fn, class _Tuple, size_t ..._Id> inline _LIBCPP_INLINE_VISIBILITY constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,                                             __tuple_indices<_Id...>) _LIBCPP_NOEXCEPT_RETURN(     _VSTD::__invoke_constexpr(         _VSTD::forward<_Fn>(__f),         _VSTD::get<_Id>(_VSTD::forward<_Tuple>(__t))...) )  template <class _Fn, class _Tuple> inline _LIBCPP_INLINE_VISIBILITY constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t) _LIBCPP_NOEXCEPT_RETURN(     _VSTD::__apply_tuple_impl(         _VSTD::forward<_Fn>(__f), _VSTD::forward<_Tuple>(__t),         typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{ }
  ) )  template <class _Tp, class _Tuple, size_t... _Idx> inline _LIBCPP_INLINE_VISIBILITY constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>) _LIBCPP_NOEXCEPT_RETURN(     _Tp(_VSTD::get<_Idx>(_VSTD::forward<_Tuple>(__t))...) )  template <class _Tp, class _Tuple> inline _LIBCPP_INLINE_VISIBILITY constexpr _Tp make_from_tuple(_Tuple&& __t) _LIBCPP_NOEXCEPT_RETURN(     _VSTD::__make_from_tuple_impl<_Tp>(_VSTD::forward<_Tuple>(__t),         typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{ }
  ) )    
#undef _LIBCPP_NOEXCEPT_RETURN
   
#endif // _LIBCPP_STD_VER > 14
   
#endif // !defined(_LIBCPP_CXX03_LANG)
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_TUPLE
  
#pragma clang module end /*std.tuple*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <stdexcept>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.stdexcept
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_STDEXCEPT
  
#define _LIBCPP_STDEXCEPT
 /*     stdexcept synopsis  namespace std {   class logic_error;      class domain_error;      class invalid_argument;      class length_error;      class out_of_range;  class runtime_error;      class range_error;      class overflow_error;      class underflow_error;   for each class xxx_error:  class xxx_error : public exception // at least indirectly
{  public:     explicit xxx_error(const string& what_arg);      explicit xxx_error(const char*   what_arg);       virtual const char* what() const noexcept // returns what_arg
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <exception>
  
#endif /* expanded by -frewrite-includes */
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw range_error(__msg);    
#else
    ((void)__msg);  	  _VSTD::abort();    
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_overflow_error(const char*__msg) {    
#ifndef _LIBCPP_NO_EXCEPTIONS
#else
    ((void)__msg);      _VSTD::abort();    
#endif
}
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_STDEXCEPT
  
#pragma clang module end /*std.stdexcept*/
#pragma clang module begin std.compat.cstring
// -*- C++ -*-
//===--------------------------- cstring ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CSTRING
  
#define _LIBCPP_CSTRING
 /*     cstring synopsis  Macros:      NULL  namespace std {   Types:      size_t  void* memcpy(void* restrict s1, const void* restrict s2, size_t n);  void* memmove(void* s1, const void* s2, size_t n);  char* strcpy (char* restrict s1, const char* restrict s2);  char* strncpy(char* restrict s1, const char* restrict s2, size_t n);  char* strcat (char* restrict s1, const char* restrict s2);  char* strncat(char* restrict s1, const char* restrict s2, size_t n);  int memcmp(const void* s1, const void* s2, size_t n);  int strcmp (const char* s1, const char* s2);  int strncmp(const char* s1, const char* s2, size_t n);  int strcoll(const char* s1, const char* s2);  size_t strxfrm(char* restrict s1, const char* restrict s2, size_t n);  const void* memchr(const void* s, int c, size_t n);        void* memchr(      void* s, int c, size_t n);  const char* strchr(const char* s, int c);        char* strchr(      char* s, int c);  size_t strcspn(const char* s1, const char* s2);  const char* strpbrk(const char* s1, const char* s2);        char* strpbrk(      char* s1, const char* s2);  const char* strrchr(const char* s, int c);        char* strrchr(      char* s, int c);  size_t strspn(const char* s1, const char* s2);  const char* strstr(const char* s1, const char* s2);        char* strstr(      char* s1, const char* s2);  char* strtok(char* restrict s1, const char* restrict s2);  void* memset(void* s, int c, size_t n);  char* strerror(int errnum);  size_t strlen(const char* s);   }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
   using ::strpbrk;
   using ::strrchr;
   using ::strspn;
   using ::strstr;
     
#ifndef _LIBCPP_HAS_NO_THREAD_UNSAFE_C_FUNCTIONS
using ::strtok;
     
#endif
using ::memset;
   using ::strerror;
   using ::strlen;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CSTRING
  
#pragma clang module end /*std.compat.cstring*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cassert>
  
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard: 7.2 Diagnostics	<assert.h>  */
   
#ifdef	_ASSERT_H
   
# undef	_ASSERT_H
  
# undef	assert
  
# undef __ASSERT_VOID_CAST
   
# ifdef	__USE_GNU
  
#  undef assert_perror
  
# endif
   
#endif /* assert.h	*/
   
#if defined __cplusplus && __GNUC_PREREQ (2,95)
  
# define __ASSERT_VOID_CAST static_cast<void>
  
#else
  
# define __ASSERT_VOID_CAST (void)
  
#endif
 /* void assert (int expression);
       If NDEBUG is defined, do nothing.    If not, and EXPRESSION is zero, print an error message and abort.  */
   
#ifdef	NDEBUG
   
# define assert(expr)		(__ASSERT_VOID_CAST (0))
 /* void assert_perror (int errnum);
       If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an    error message with the error text for ERRNUM and abort.    (This is a GNU extension.) */
   
# ifdef	__USE_GNU
  
#  define assert_perror(errnum)	(__ASSERT_VOID_CAST (0))
  
# endif
   
#else /* Not NDEBUG.  */
 __BEGIN_DECLS  /* This prints an "Assertion failed" message and aborts.  */
extern void __assert_fail (const char *__assertion, const char *__file, 			   unsigned int __line, const char *__function)      __THROW __attribute__ ((__noreturn__));
    /* Likewise, but prints the error text for ERRNUM.  */
extern void __assert_perror_fail (int __errnum, const char *__file, 				  unsigned int __line, const char *__function)      __THROW __attribute__ ((__noreturn__));
     /* The following is not at all used here but needed for standard    compliance.  */
extern void __assert (const char *__assertion, const char *__file, int __line)      __THROW __attribute__ ((__noreturn__));
     __END_DECLS    
# define assert(expr)							\
  ((expr)								\
   ? __ASSERT_VOID_CAST (0)						\
   : __assert_fail (__STRING(expr), __FILE__, __LINE__, __ASSERT_FUNCTION))
   
# ifdef	__USE_GNU
  
#  define assert_perror(errnum)						\
  (!(errnum)								\
   ? __ASSERT_VOID_CAST (0)						\
   : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))
  
# endif
 /* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
#  include <atomic>
#endif /* expanded by -frewrite-includes */
#pragma clang module begin std.atomic
// -*- C++ -*-
//===--------------------------- atomic -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_ATOMIC
#define _LIBCPP_ATOMIC

/*
    atomic synopsis

namespace std
{

// feature test macro
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifdef _LIBCPP_HAS_NO_THREADS
  
#error <atomic> is not supported on this single threaded system
  
#endif
  
#if !defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
  
#endif
   
#define _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m) \
  _LIBCPP_DIAGNOSE_WARNING(__m == memory_order_consume || \
                           __m == memory_order_acquire || \
                           __m == memory_order_acq_rel,   \
                        "memory order argument to atomic operation is invalid")
   
#define _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m) \
  _LIBCPP_DIAGNOSE_WARNING(__m == memory_order_release || \
                           __m == memory_order_acq_rel,   \
                        "memory order argument to atomic operation is invalid")
   
#define _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__m, __f) \
  _LIBCPP_DIAGNOSE_WARNING(__f == memory_order_release || \
                           __f == memory_order_acq_rel,   \
                        "memory order argument to atomic operation is invalid")
 _LIBCPP_BEGIN_NAMESPACE_STD  typedef enum memory_order {      memory_order_relaxed, memory_order_consume, memory_order_acquire,     memory_order_release, memory_order_acq_rel, memory_order_seq_cst }  memory_order;     
#if defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
namespace __gcc_atomic {  template <typename _Tp> struct __gcc_atomic_t {     
#if _GNUC_VER >= 501
    static_assert(is_trivially_copyable<_Tp>::value,       "std::atomic<Tp> requires that 'Tp' be a trivially copyable type");    
#endif
  
#endif
 // general atomic<T>
 template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value> struct __atomic_base  // false
{      mutable _Atomic(_Tp) __a_;     
#if defined(__cpp_lib_atomic_is_always_lock_free)
  static _LIBCPP_CONSTEXPR bool is_always_lock_free = __atomic_always_lock_free(sizeof(__a_), 0);    
#endif
     _LIBCPP_INLINE_VISIBILITY     bool is_lock_free() const volatile _NOEXCEPT     {    
#if defined(_LIBCPP_HAS_C_ATOMIC_IMP)
    return __c11_atomic_is_lock_free(sizeof(_Tp));    
#else
    return __atomic_is_lock_free(sizeof(_Tp), 0);    
#endif
    }      _LIBCPP_INLINE_VISIBILITY     bool is_lock_free() const _NOEXCEPT         { return static_cast<__atomic_base const volatile*>(this)->is_lock_free(); }      _LIBCPP_INLINE_VISIBILITY     void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT       _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)         { __c11_atomic_store(&__a_, __d, __m); }      _LIBCPP_INLINE_VISIBILITY     void store(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT       _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m)         { __c11_atomic_store(&__a_, __d, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp load(memory_order __m = memory_order_seq_cst) const volatile _NOEXCEPT       _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)         { return __c11_atomic_load(&__a_, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp load(memory_order __m = memory_order_seq_cst) const _NOEXCEPT       _LIBCPP_CHECK_LOAD_MEMORY_ORDER(__m)         { return __c11_atomic_load(&__a_, __m); }      _LIBCPP_INLINE_VISIBILITY     operator _Tp() const volatile _NOEXCEPT { return load(); }      _LIBCPP_INLINE_VISIBILITY     operator _Tp() const _NOEXCEPT          { return load(); }      _LIBCPP_INLINE_VISIBILITY     _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_exchange(&__a_, __d, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_exchange(&__a_, __d, __m); }      _LIBCPP_INLINE_VISIBILITY     bool compare_exchange_weak(_Tp& __e, _Tp __d,                                memory_order __s, memory_order __f) volatile _NOEXCEPT       _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)         { return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f); }      _LIBCPP_INLINE_VISIBILITY     bool compare_exchange_weak(_Tp& __e, _Tp __d,                                memory_order __s, memory_order __f) _NOEXCEPT       _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)         { return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f); }      _LIBCPP_INLINE_VISIBILITY     bool compare_exchange_strong(_Tp& __e, _Tp __d,                                  memory_order __s, memory_order __f) volatile _NOEXCEPT       _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)         { return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f); }      _LIBCPP_INLINE_VISIBILITY     bool compare_exchange_strong(_Tp& __e, _Tp __d,                                  memory_order __s, memory_order __f) _NOEXCEPT       _LIBCPP_CHECK_EXCHANGE_MEMORY_ORDER(__s, __f)         { return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f); }      _LIBCPP_INLINE_VISIBILITY     bool compare_exchange_weak(_Tp& __e, _Tp __d,                               memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m); }      _LIBCPP_INLINE_VISIBILITY     bool compare_exchange_weak(_Tp& __e, _Tp __d,                                memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m); }      _LIBCPP_INLINE_VISIBILITY     bool compare_exchange_strong(_Tp& __e, _Tp __d,                               memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m); }      _LIBCPP_INLINE_VISIBILITY     bool compare_exchange_strong(_Tp& __e, _Tp __d,                                  memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m); }       _LIBCPP_INLINE_VISIBILITY   
#ifndef _LIBCPP_CXX03_LANG
    __atomic_base() _NOEXCEPT = default;    
#else
    __atomic_base() _NOEXCEPT : __a_() { }    
#endif // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __a_(__d) { }    
#ifndef _LIBCPP_CXX03_LANG
    __atomic_base(const __atomic_base&) = delete;      __atomic_base& operator=(const __atomic_base&) = delete;      __atomic_base& operator=(const __atomic_base&) volatile = delete;    
#else
private:     __atomic_base(const __atomic_base&);      __atomic_base& operator=(const __atomic_base&);      __atomic_base& operator=(const __atomic_base&) volatile;    
#endif
};     
#if defined(__cpp_lib_atomic_is_always_lock_free)
template <class _Tp, bool __b> _LIBCPP_CONSTEXPR bool __atomic_base<_Tp, __b>::is_always_lock_free;    
#endif
 // atomic<Integral>
 template <class _Tp> struct __atomic_base<_Tp, true>     : public __atomic_base<_Tp, false> {      typedef __atomic_base<_Tp, false> __base;      _LIBCPP_INLINE_VISIBILITY     __atomic_base() _NOEXCEPT _LIBCPP_DEFAULT     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR __atomic_base(_Tp __d) _NOEXCEPT : __base(__d) { }       _LIBCPP_INLINE_VISIBILITY     _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_fetch_add(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_fetch_add(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_fetch_sub(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_fetch_sub(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_fetch_and(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_fetch_and(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_fetch_or(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_fetch_or(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_fetch_xor(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_fetch_xor(&this->__a_, __op, __m); }       _LIBCPP_INLINE_VISIBILITY     _Tp operator++(int) volatile _NOEXCEPT      { return fetch_add(_Tp(1)); }      _LIBCPP_INLINE_VISIBILITY     _Tp operator++(int) _NOEXCEPT               { return fetch_add(_Tp(1)); }      _LIBCPP_INLINE_VISIBILITY     _Tp operator--(int) volatile _NOEXCEPT      { return fetch_sub(_Tp(1)); }      _LIBCPP_INLINE_VISIBILITY     _Tp operator--(int) _NOEXCEPT               { return fetch_sub(_Tp(1)); }      _LIBCPP_INLINE_VISIBILITY     _Tp operator++() volatile _NOEXCEPT         { return fetch_add(_Tp(1)) + _Tp(1); }      _LIBCPP_INLINE_VISIBILITY     _Tp operator++() _NOEXCEPT                  { return fetch_add(_Tp(1)) + _Tp(1); }      _LIBCPP_INLINE_VISIBILITY     _Tp operator--() volatile _NOEXCEPT         { return fetch_sub(_Tp(1)) - _Tp(1); }      _LIBCPP_INLINE_VISIBILITY     _Tp operator--() _NOEXCEPT                  { return fetch_sub(_Tp(1)) - _Tp(1); }      _LIBCPP_INLINE_VISIBILITY     _Tp operator+=(_Tp __op) volatile _NOEXCEPT { return fetch_add(__op) + __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator+=(_Tp __op) _NOEXCEPT          { return fetch_add(__op) + __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator-=(_Tp __op) volatile _NOEXCEPT { return fetch_sub(__op) - __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator-=(_Tp __op) _NOEXCEPT          { return fetch_sub(__op) - __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator&=(_Tp __op) volatile _NOEXCEPT { return fetch_and(__op) & __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator&=(_Tp __op) _NOEXCEPT          { return fetch_and(__op) & __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator|=(_Tp __op) volatile _NOEXCEPT { return fetch_or(__op) | __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator|=(_Tp __op) _NOEXCEPT          { return fetch_or(__op) | __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator^=(_Tp __op) volatile _NOEXCEPT { return fetch_xor(__op) ^ __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator^=(_Tp __op) _NOEXCEPT          { return fetch_xor(__op) ^ __op; }  };   // atomic<T>
 template <class _Tp> struct atomic     : public __atomic_base<_Tp> {      typedef __atomic_base<_Tp> __base;      _LIBCPP_INLINE_VISIBILITY     atomic() _NOEXCEPT _LIBCPP_DEFAULT     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR atomic(_Tp __d) _NOEXCEPT : __base(__d) { }       _LIBCPP_INLINE_VISIBILITY     _Tp operator=(_Tp __d) volatile _NOEXCEPT         { __base::store(__d);  return __d; }      _LIBCPP_INLINE_VISIBILITY     _Tp operator=(_Tp __d) _NOEXCEPT         { __base::store(__d);  return __d; }  };   // atomic<T*>
 template <class _Tp> struct atomic<_Tp*>     : public __atomic_base<_Tp*> {      typedef __atomic_base<_Tp*> __base;      _LIBCPP_INLINE_VISIBILITY     atomic() _NOEXCEPT _LIBCPP_DEFAULT     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR atomic(_Tp* __d) _NOEXCEPT : __base(__d) { }       _LIBCPP_INLINE_VISIBILITY     _Tp* operator=(_Tp* __d) volatile _NOEXCEPT         { __base::store(__d);  return __d; }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator=(_Tp* __d) _NOEXCEPT         { __base::store(__d);  return __d; }       _LIBCPP_INLINE_VISIBILITY     _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)                                                                         volatile _NOEXCEPT         { return __c11_atomic_fetch_add(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_fetch_add(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst)                                                                         volatile _NOEXCEPT         { return __c11_atomic_fetch_sub(&this->__a_, __op, __m); }      _LIBCPP_INLINE_VISIBILITY     _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_fetch_sub(&this->__a_, __op, __m); }       _LIBCPP_INLINE_VISIBILITY     _Tp* operator++(int) volatile _NOEXCEPT            { return fetch_add(1); }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator++(int) _NOEXCEPT                     { return fetch_add(1); }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator--(int) volatile _NOEXCEPT            { return fetch_sub(1); }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator--(int) _NOEXCEPT                     { return fetch_sub(1); }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator++() volatile _NOEXCEPT               { return fetch_add(1) + 1; }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator++() _NOEXCEPT                        { return fetch_add(1) + 1; }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator--() volatile _NOEXCEPT               { return fetch_sub(1) - 1; }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator--() _NOEXCEPT                        { return fetch_sub(1) - 1; }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator+=(ptrdiff_t __op) volatile _NOEXCEPT { return fetch_add(__op) + __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator+=(ptrdiff_t __op) _NOEXCEPT          { return fetch_add(__op) + __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator-=(ptrdiff_t __op) volatile _NOEXCEPT { return fetch_sub(__op) - __op; }      _LIBCPP_INLINE_VISIBILITY     _Tp* operator-=(ptrdiff_t __op) _NOEXCEPT          { return fetch_sub(__op) - __op; }  };   // atomic_is_lock_free
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool atomic_is_lock_free(const volatile atomic<_Tp>* __o) _NOEXCEPT {      return __o->is_lock_free();  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool atomic_is_lock_free(const atomic<_Tp>* __o) _NOEXCEPT {      return __o->is_lock_free();  }   // atomic_init
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void atomic_init(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT {      __c11_atomic_init(&__o->__a_, __d);  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void atomic_init(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT {      __c11_atomic_init(&__o->__a_, __d);  }   // atomic_store
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void atomic_store(volatile atomic<_Tp>* __o, _Tp __d) _NOEXCEPT {      __o->store(__d);  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void atomic_store(atomic<_Tp>* __o, _Tp __d) _NOEXCEPT {      __o->store(__d);  }   // atomic_store_explicit
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void atomic_store_explicit(volatile atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT   _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m) {      __o->store(__d, __m);  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void atomic_store_explicit(atomic<_Tp>* __o, _Tp __d, memory_order __m) _NOEXCEPT   _LIBCPP_CHECK_STORE_MEMORY_ORDER(__m) {      __o->store(__d, __m);  }   // atomic_load
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_integral<_Tp>::value && !is_same<_Tp, bool>::value,     _Tp >::type atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT {      return __o->fetch_or(__op, __m);  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_integral<_Tp>::value && !is_same<_Tp, bool>::value,     _Tp >::type atomic_fetch_or_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT {      return __o->fetch_or(__op, __m);  }   // atomic_fetch_xor
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_integral<_Tp>::value && !is_same<_Tp, bool>::value,     _Tp >::type atomic_fetch_xor(volatile atomic<_Tp>* __o, _Tp __op) _NOEXCEPT {      return __o->fetch_xor(__op);  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_integral<_Tp>::value && !is_same<_Tp, bool>::value,     _Tp >::type atomic_fetch_xor(atomic<_Tp>* __o, _Tp __op) _NOEXCEPT {      return __o->fetch_xor(__op);  }   // atomic_fetch_xor_explicit
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_integral<_Tp>::value && !is_same<_Tp, bool>::value,     _Tp >::type atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT {      return __o->fetch_xor(__op, __m);  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_integral<_Tp>::value && !is_same<_Tp, bool>::value,     _Tp >::type atomic_fetch_xor_explicit(atomic<_Tp>* __o, _Tp __op, memory_order __m) _NOEXCEPT {      return __o->fetch_xor(__op, __m);  }   // flag type and operations
 typedef struct atomic_flag {      _Atomic(bool) __a_;       _LIBCPP_INLINE_VISIBILITY     bool test_and_set(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { return __c11_atomic_exchange(&__a_, true, __m); }      _LIBCPP_INLINE_VISIBILITY     bool test_and_set(memory_order __m = memory_order_seq_cst) _NOEXCEPT         { return __c11_atomic_exchange(&__a_, true, __m); }      _LIBCPP_INLINE_VISIBILITY     void clear(memory_order __m = memory_order_seq_cst) volatile _NOEXCEPT         { __c11_atomic_store(&__a_, false, __m); }      _LIBCPP_INLINE_VISIBILITY     void clear(memory_order __m = memory_order_seq_cst) _NOEXCEPT         { __c11_atomic_store(&__a_, false, __m); }       _LIBCPP_INLINE_VISIBILITY   
#ifndef _LIBCPP_CXX03_LANG
    atomic_flag() _NOEXCEPT = default;    
#else
    atomic_flag() _NOEXCEPT : __a_() { }    
#endif // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     atomic_flag(bool __b) _NOEXCEPT : __a_(__b) { }  // EXTENSION
   
#ifndef _LIBCPP_CXX03_LANG
    atomic_flag(const atomic_flag&) = delete;      atomic_flag& operator=(const atomic_flag&) = delete;      atomic_flag& operator=(const atomic_flag&) volatile = delete;    
#else
private:     atomic_flag(const atomic_flag&);      atomic_flag& operator=(const atomic_flag&);      atomic_flag& operator=(const atomic_flag&) volatile;    
#endif
}  atomic_flag;   inline _LIBCPP_INLINE_VISIBILITY bool atomic_flag_test_and_set(volatile atomic_flag* __o) _NOEXCEPT {      return __o->test_and_set();  }   inline _LIBCPP_INLINE_VISIBILITY bool atomic_flag_test_and_set(atomic_flag* __o) _NOEXCEPT {      return __o->test_and_set();  }   inline _LIBCPP_INLINE_VISIBILITY bool atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT {      return __o->test_and_set(__m);  }   inline _LIBCPP_INLINE_VISIBILITY bool atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT {      return __o->test_and_set(__m);  }   inline _LIBCPP_INLINE_VISIBILITY void atomic_flag_clear(volatile atomic_flag* __o) _NOEXCEPT {      __o->clear();  }   inline _LIBCPP_INLINE_VISIBILITY void atomic_flag_clear(atomic_flag* __o) _NOEXCEPT {      __o->clear();  }   inline _LIBCPP_INLINE_VISIBILITY void atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) _NOEXCEPT {      __o->clear(__m);  }   inline _LIBCPP_INLINE_VISIBILITY void atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) _NOEXCEPT {      __o->clear(__m);  }   // fences
 inline _LIBCPP_INLINE_VISIBILITY void atomic_thread_fence(memory_order __m) _NOEXCEPT {      __c11_atomic_thread_fence(__m);  }   inline _LIBCPP_INLINE_VISIBILITY void atomic_signal_fence(memory_order __m) _NOEXCEPT {      __c11_atomic_signal_fence(__m);  }   // Atomics for standard typedef types
 typedef atomic<bool>               atomic_bool;  typedef atomic<char>               atomic_char;  typedef atomic<signed char>        atomic_schar;  typedef atomic<unsigned char>      atomic_uchar;  typedef atomic<short>              atomic_short;  typedef atomic<unsigned short>     atomic_ushort;  typedef atomic<int>                atomic_int;  typedef atomic<unsigned int>       atomic_uint;  typedef atomic<long>               atomic_long;  typedef atomic<unsigned long>      atomic_ulong;  typedef atomic<long long>          atomic_llong;  typedef atomic<unsigned long long> atomic_ullong;  typedef atomic<char16_t>           atomic_char16_t;  typedef atomic<char32_t>           atomic_char32_t;  typedef atomic<wchar_t>            atomic_wchar_t;   typedef atomic<int_least8_t>   atomic_int_least8_t;  typedef atomic<uint_least8_t>  atomic_uint_least8_t;  typedef atomic<int_least16_t>  atomic_int_least16_t;  typedef atomic<uint_least16_t> atomic_uint_least16_t;  typedef atomic<int_least32_t>  atomic_int_least32_t;  typedef atomic<uint_least32_t> atomic_uint_least32_t;  typedef atomic<int_least64_t>  atomic_int_least64_t;  typedef atomic<uint_least64_t> atomic_uint_least64_t;   typedef atomic<int_fast8_t>   atomic_int_fast8_t;  typedef atomic<uint_fast8_t>  atomic_uint_fast8_t;  typedef atomic<int_fast16_t>  atomic_int_fast16_t;  typedef atomic<uint_fast16_t> atomic_uint_fast16_t;  typedef atomic<int_fast32_t>  atomic_int_fast32_t;  typedef atomic<uint_fast32_t> atomic_uint_fast32_t;  typedef atomic<int_fast64_t>  atomic_int_fast64_t;  typedef atomic<uint_fast64_t> atomic_uint_fast64_t;   typedef atomic< int8_t>  atomic_int8_t;  typedef atomic<uint8_t>  atomic_uint8_t;  typedef atomic< int16_t> atomic_int16_t;  typedef atomic<uint16_t> atomic_uint16_t;  typedef atomic< int32_t> atomic_int32_t;  typedef atomic<uint32_t> atomic_uint32_t;  typedef atomic< int64_t> atomic_int64_t;  typedef atomic<uint64_t> atomic_uint64_t;   typedef atomic<intptr_t>  atomic_intptr_t;  typedef atomic<uintptr_t> atomic_uintptr_t;  typedef atomic<size_t>    atomic_size_t;  typedef atomic<ptrdiff_t> atomic_ptrdiff_t;  typedef atomic<intmax_t>  atomic_intmax_t;  typedef atomic<uintmax_t> atomic_uintmax_t;     
#define ATOMIC_FLAG_INIT {false}
  
#define ATOMIC_VAR_INIT(__v) {__v}
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_ATOMIC
  
#pragma clang module end /*std.atomic*/
  
#endif
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template <class _ValueType> inline _LIBCPP_ALWAYS_INLINE _ValueType __libcpp_relaxed_load(_ValueType const* __value) {    
#if !defined(_LIBCPP_HAS_NO_THREADS) && \
    defined(__ATOMIC_RELAXED) &&        \
    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)
    return __atomic_load_n(__value, __ATOMIC_RELAXED);    
#else
    return *__value;    
#endif
}   template <class _ValueType> inline _LIBCPP_ALWAYS_INLINE _ValueType __libcpp_acquire_load(_ValueType const* __value) {    
#if !defined(_LIBCPP_HAS_NO_THREADS) && \
    defined(__ATOMIC_ACQUIRE) &&        \
    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)
    return __atomic_load_n(__value, __ATOMIC_ACQUIRE);    
#else
    return *__value;    
#endif
}   // addressof moved to <type_traits>
 template <class _Tp> class allocator;   template <> class _LIBCPP_TEMPLATE_VIS allocator<void> {  public:     typedef void*             pointer;      typedef const void*       const_pointer;      typedef void              value_type;       template <class _Up> struct rebind { typedef allocator<_Up> other; };  };   template <> class _LIBCPP_TEMPLATE_VIS allocator<const void> {  public:     typedef const void*       pointer;      typedef const void*       const_pointer;      typedef const void        value_type;       template <class _Up> struct rebind { typedef allocator<_Up> other; };  };   // pointer_traits
 template <class _Tp, class = void> struct __has_element_type : false_type { };   template <class _Tp> struct __has_element_type<_Tp,               typename __void_t<typename _Tp::element_type>::type> : true_type { };   template <class _Ptr, bool = __has_element_type<_Ptr>::value> struct __pointer_traits_element_type;   template <class _Ptr> struct __pointer_traits_element_type<_Ptr, true> {      typedef typename _Ptr::element_type type;  };     
#ifndef _LIBCPP_HAS_NO_VARIADICS
 template <template <class, class...> class _Sp, class _Tp, class ..._Args> struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true> {      typedef typename _Sp<_Tp, _Args...>::element_type type;  };   template <template <class, class...> class _Sp, class _Tp, class ..._Args> struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false> {      typedef _Tp type;  };     
#else  // _LIBCPP_HAS_NO_VARIADICS
 template <template <class> class _Sp, class _Tp> struct __pointer_traits_element_type<_Sp<_Tp>, true> {      typedef typename _Sp<_Tp>::element_type type;  };   template <template <class> class _Sp, class _Tp> struct __pointer_traits_element_type<_Sp<_Tp>, false> {      typedef _Tp type;  };   template <template <class, class> class _Sp, class _Tp, class _A0> struct __pointer_traits_element_type<_Sp<_Tp, _A0>, true> {      typedef typename _Sp<_Tp, _A0>::element_type type;  };   template <template <class, class> class _Sp, class _Tp, class _A0> struct __pointer_traits_element_type<_Sp<_Tp, _A0>, false> {      typedef _Tp type;  };   template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1> struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true> {      typedef typename _Sp<_Tp, _A0, _A1>::element_type type;  };   template <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1> struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false> {      typedef _Tp type;  };   template <template <class, class, class, class> class _Sp, class _Tp, class _A0,                                                            class _A1, class _A2> struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true> {      typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;  };   template <template <class, class, class, class> class _Sp, class _Tp, class _A0,                                                            class _A1, class _A2> struct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false> {      typedef _Tp type;  };     
#endif  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Tp, class = void> struct __has_difference_type : false_type { };   template <class _Tp> struct __has_difference_type<_Tp,             typename __void_t<typename _Tp::difference_type>::type> : true_type { };   template <class _Ptr, bool = __has_difference_type<_Ptr>::value> struct __pointer_traits_difference_type {      typedef ptrdiff_t type;  };   template <class _Ptr> struct __pointer_traits_difference_type<_Ptr, true> {      typedef typename _Ptr::difference_type type;  };   template <class _Tp, class _Up> struct __has_rebind {  private:     struct __two { char __lx;  char __lxx; };      template <class _Xp> static __two __test(...);      template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);  public:     static const bool value = sizeof(__test<_Tp>(0)) == 1;  };   template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __pointer_traits_rebind {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Tp::template rebind<_Up> type;    
#else
    typedef typename _Tp::template rebind<_Up>::other type;    
#endif
};     
#ifndef _LIBCPP_HAS_NO_VARIADICS
 template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true> {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;    
#else
    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;    
#endif
};   template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false> {      typedef _Sp<_Up, _Args...> type;  };     
#else  // _LIBCPP_HAS_NO_VARIADICS
 template <template <class> class _Sp, class _Tp, class _Up> struct __pointer_traits_rebind<_Sp<_Tp>, _Up, true> {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Sp<_Tp>::template rebind<_Up> type;    
#else
    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;    
#endif
};   template <template <class> class _Sp, class _Tp, class _Up> struct __pointer_traits_rebind<_Sp<_Tp>, _Up, false> {      typedef _Sp<_Up> type;  };   template <template <class, class> class _Sp, class _Tp, class _A0, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true> {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;    
#else
    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;    
#endif
};   template <template <class, class> class _Sp, class _Tp, class _A0, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false> {      typedef _Sp<_Up, _A0> type;  };   template <template <class, class, class> class _Sp, class _Tp, class _A0,                                          class _A1, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true> {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;    
#else
    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;    
#endif
};   template <template <class, class, class> class _Sp, class _Tp, class _A0,                                          class _A1, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false> {      typedef _Sp<_Up, _A0, _A1> type;  };   template <template <class, class, class, class> class _Sp, class _Tp, class _A0,                                                 class _A1, class _A2, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true> {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;    
#else
    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;    
#endif
};   template <template <class, class, class, class> class _Sp, class _Tp, class _A0,                                                 class _A1, class _A2, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false> {      typedef _Sp<_Up, _A0, _A1, _A2> type;  };     
#endif  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Ptr> struct _LIBCPP_TEMPLATE_VIS pointer_traits {      typedef _Ptr                                                     pointer;      typedef typename __pointer_traits_element_type<pointer>::type    element_type;      typedef typename __pointer_traits_difference_type<pointer>::type difference_type;     
#ifndef _LIBCPP_CXX03_LANG
    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;    
#else
    template <class _Up> struct rebind         { typedef typename __pointer_traits_rebind<pointer, _Up>::type other; };    
#endif  // _LIBCPP_CXX03_LANG
 private:     struct __nat { };  public:     _LIBCPP_INLINE_VISIBILITY     static pointer pointer_to(typename conditional<is_void<element_type>::value,                                            __nat, element_type>::type& __r)         { return pointer::pointer_to(__r); }  };   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS pointer_traits<_Tp*> {      typedef _Tp*      pointer;      typedef _Tp       element_type;      typedef ptrdiff_t difference_type;     
#ifndef _LIBCPP_CXX03_LANG
    template <class _Up> using rebind = _Up*;    
#else
    template <class _Up> struct rebind { typedef _Up* other; };    
#endif
 private:     struct __nat { };  public:     _LIBCPP_INLINE_VISIBILITY     static pointer pointer_to(typename conditional<is_void<element_type>::value,                                       __nat, element_type>::type& __r) _NOEXCEPT         { return _VSTD::addressof(__r); }  };   template <class _From, class _To> struct __rebind_pointer {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename pointer_traits<_From>::template rebind<_To>        type;    
#else
    typedef typename pointer_traits<_From>::template rebind<_To>::other type;    
#endif
};   // allocator_traits
 template <class _Tp, class = void> struct __has_pointer_type : false_type { };   template <class _Tp> struct __has_pointer_type<_Tp,           typename __void_t<typename _Tp::pointer>::type> : true_type { };   namespace __pointer_type_imp {   template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value> struct __pointer_type {      typedef typename _Dp::pointer type;  };   template <class _Tp, class _Dp> struct __pointer_type<_Tp, _Dp, false> {      typedef _Tp* type;  };   }   // __pointer_type_imp
 template <class _Tp, class _Dp> struct __pointer_type {      typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;  };   template <class _Tp, class = void> struct __has_const_pointer : false_type { };   template <class _Tp> struct __has_const_pointer<_Tp,             typename __void_t<typename _Tp::const_pointer>::type> : true_type { };   template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value> struct __const_pointer {      typedef typename _Alloc::const_pointer type;  };   template <class _Tp, class _Ptr, class _Alloc> struct __const_pointer<_Tp, _Ptr, _Alloc, false> {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;    
#else
    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;    
#endif
};   template <class _Tp, class = void> struct __has_void_pointer : false_type { };   template <class _Tp> struct __has_void_pointer<_Tp,                typename __void_t<typename _Tp::void_pointer>::type> : true_type { };   template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value> struct __void_pointer {      typedef typename _Alloc::void_pointer type;  };   template <class _Ptr, class _Alloc> struct __void_pointer<_Ptr, _Alloc, false> {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename pointer_traits<_Ptr>::template rebind<void> type;    
#else
    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;    
#endif
};   template <class _Tp, class = void> struct __has_const_void_pointer : false_type { };   template <class _Tp> struct __has_const_void_pointer<_Tp,             typename __void_t<typename _Tp::const_void_pointer>::type> : true_type { };   template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value> struct __const_void_pointer {      typedef typename _Alloc::const_void_pointer type;  };   template <class _Ptr, class _Alloc> struct __const_void_pointer<_Ptr, _Alloc, false> {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;    
#else
    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;    
#endif
};   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _Tp* __to_raw_pointer(_Tp* __p) _NOEXCEPT {      return __p;  }   template <class _Pointer> inline _LIBCPP_INLINE_VISIBILITY typename pointer_traits<_Pointer>::element_type* __to_raw_pointer(_Pointer __p) _NOEXCEPT {      return _VSTD::__to_raw_pointer(__p.operator->());  }   template <class _Tp, class = void> struct __has_size_type : false_type { };   template <class _Tp> struct __has_size_type<_Tp,                typename __void_t<typename _Tp::size_type>::type> : true_type { };   template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value> struct __size_type {      typedef typename make_unsigned<_DiffType>::type type;  };   template <class _Alloc, class _DiffType> struct __size_type<_Alloc, _DiffType, true> {      typedef typename _Alloc::size_type type;  };   template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type { };   template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp,     typename __void_t<typename _Tp::propagate_on_container_copy_assignment>::type>         : true_type { };   template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value> struct __propagate_on_container_copy_assignment {      typedef false_type type;  };   template <class _Alloc> struct __propagate_on_container_copy_assignment<_Alloc, true> {      typedef typename _Alloc::propagate_on_container_copy_assignment type;  };   template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type { };   template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp,            typename __void_t<typename _Tp::propagate_on_container_move_assignment>::type>                : true_type { };   template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value> struct __propagate_on_container_move_assignment {      typedef false_type type;  };   template <class _Alloc> struct __propagate_on_container_move_assignment<_Alloc, true> {      typedef typename _Alloc::propagate_on_container_move_assignment type;  };   template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type { };   template <class _Tp> struct __has_propagate_on_container_swap<_Tp,            typename __void_t<typename _Tp::propagate_on_container_swap>::type>                : true_type { };   template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value> struct __propagate_on_container_swap {      typedef false_type type;  };   template <class _Alloc> struct __propagate_on_container_swap<_Alloc, true> {      typedef typename _Alloc::propagate_on_container_swap type;  };   template <class _Tp, class = void> struct __has_is_always_equal : false_type { };   template <class _Tp> struct __has_is_always_equal<_Tp,            typename __void_t<typename _Tp::is_always_equal>::type>                : true_type { };   template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value> struct __is_always_equal {      typedef typename _VSTD::is_empty<_Alloc>::type type;  };   template <class _Alloc> struct __is_always_equal<_Alloc, true> {      typedef typename _Alloc::is_always_equal type;  };   template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __has_rebind_other {  private:     struct __two { char __lx;  char __lxx; };      template <class _Xp> static __two __test(...);      template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);  public:     static const bool value = sizeof(__test<_Tp>(0)) == 1;  };   template <class _Tp, class _Up> struct __has_rebind_other<_Tp, _Up, false> {      static const bool value = false;  };   template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value> struct __allocator_traits_rebind {      typedef typename _Tp::template rebind<_Up>::other type;  };     
#ifndef _LIBCPP_HAS_NO_VARIADICS
 template <class _Alloc, class _SizeType, class _ConstVoidPtr> struct __has_allocate_hint     : true_type {  };     
#endif  // _LIBCPP_CXX03_LANG
   
#if !defined(_LIBCPP_CXX03_LANG)
 template <class _Alloc, class _Tp, class ..._Args> decltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),                                            _VSTD::declval<_Args>()...),                                            true_type()) __has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);   template <class _Alloc, class _Pointer, class ..._Args> false_type __has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);   template <class _Alloc, class _Pointer, class ..._Args> struct __has_construct     : integral_constant<bool,         is_same<             decltype(__has_construct_test(declval<_Alloc>(),                                           declval<_Pointer>(),                                           declval<_Args>()...)),             true_type>::value> {  };   template <class _Alloc, class _Pointer> auto __has_destroy_test(_Alloc&& __a, _Pointer&& __p)     -> decltype(__a.destroy(__p), true_type());   template <class _Alloc, class _Pointer> auto __has_destroy_test(const _Alloc& __a, _Pointer&& __p)     -> false_type;   template <class _Alloc, class _Pointer> struct __has_destroy     : integral_constant<bool,         is_same<             decltype(__has_destroy_test(declval<_Alloc>(),                                         declval<_Pointer>())),             true_type>::value> {  };   template <class _Alloc> auto __has_max_size_test(_Alloc&& __a)     -> decltype(__a.max_size(), true_type());   template <class _Alloc> auto __has_max_size_test(const volatile _Alloc& __a)     -> false_type;   template <class _Alloc> struct __has_max_size     : integral_constant<bool,         is_same<             decltype(__has_max_size_test(declval<_Alloc&>())),             true_type>::value> {  };   template <class _Alloc> auto __has_select_on_container_copy_construction_test(_Alloc&& __a)     -> decltype(__a.select_on_container_copy_construction(), true_type());   template <class _Alloc> auto __has_select_on_container_copy_construction_test(const volatile _Alloc& __a)     -> false_type;   template <class _Alloc> struct __has_select_on_container_copy_construction     : integral_constant<bool,         is_same<             decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),             true_type>::value> {  };     
#else  // _LIBCPP_CXX03_LANG
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
 template <class _Alloc, class _Pointer, class ..._Args> struct __has_construct     : false_type {  };     
#else  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Alloc, class _Pointer, class _Args> struct __has_construct     : false_type {  };     
#endif  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Alloc, class _Pointer> struct __has_destroy     : false_type {  };   template <class _Alloc> struct __has_max_size     : true_type {  };   template <class _Alloc> struct __has_select_on_container_copy_construction     : false_type {  };     
#endif  // _LIBCPP_CXX03_LANG
 template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value> struct __alloc_traits_difference_type {      typedef typename pointer_traits<_Ptr>::difference_type type;  };   template <class _Alloc, class _Ptr> struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {      typedef typename _Alloc::difference_type type;  };   template <class _Alloc> struct _LIBCPP_TEMPLATE_VIS allocator_traits {      typedef _Alloc                              allocator_type;      typedef typename allocator_type::value_type value_type;       typedef typename __pointer_type<value_type, allocator_type>::type pointer;      typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;      typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;      typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;       typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;      typedef typename __size_type<allocator_type, difference_type>::type size_type;       typedef typename __propagate_on_container_copy_assignment<allocator_type>::type                      propagate_on_container_copy_assignment;      typedef typename __propagate_on_container_move_assignment<allocator_type>::type                      propagate_on_container_move_assignment;      typedef typename __propagate_on_container_swap<allocator_type>::type                      propagate_on_container_swap;      typedef typename __is_always_equal<allocator_type>::type                      is_always_equal;     
#ifndef _LIBCPP_CXX03_LANG
    template <class _Tp> using rebind_alloc =                   typename __allocator_traits_rebind<allocator_type, _Tp>::type;      template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;    
#else  // _LIBCPP_CXX03_LANG
    template <class _Tp> struct rebind_alloc         { typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other; };      template <class _Tp> struct rebind_traits         { typedef allocator_traits<typename rebind_alloc<_Tp>::other> other; };    
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     static pointer allocate(allocator_type& __a, size_type __n)         { return __a.allocate(__n); }      _LIBCPP_INLINE_VISIBILITY     static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)         { return __allocate(__a, __n, __hint,             __has_allocate_hint<allocator_type, size_type, const_void_pointer>()); }       _LIBCPP_INLINE_VISIBILITY     static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT         { __a.deallocate(__p, __n); }     
#ifndef _LIBCPP_HAS_NO_VARIADICS
    template <class _Tp, class... _Args>         _LIBCPP_INLINE_VISIBILITY         static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)             { __construct(__has_construct<allocator_type, _Tp*, _Args...>(),                          __a, __p, _VSTD::forward<_Args>(__args)...); }    
#else  // _LIBCPP_HAS_NO_VARIADICS
    template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         static void construct(allocator_type&, _Tp* __p)             {                  ::new ((void*)__p) _Tp();              }      template <class _Tp, class _A0>         _LIBCPP_INLINE_VISIBILITY         static void construct(allocator_type&, _Tp* __p, const _A0& __a0)             {                  ::new ((void*)__p) _Tp(__a0);              }      template <class _Tp, class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         static void construct(allocator_type&, _Tp* __p, const _A0& __a0,                               const _A1& __a1)             {                  ::new ((void*)__p) _Tp(__a0, __a1);              }      template <class _Tp, class _A0, class _A1, class _A2>         _LIBCPP_INLINE_VISIBILITY         static void construct(allocator_type&, _Tp* __p, const _A0& __a0,                               const _A1& __a1, const _A2& __a2)             {                  ::new ((void*)__p) _Tp(__a0, __a1, __a2);              }    
#endif  // _LIBCPP_HAS_NO_VARIADICS
     template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         static void destroy(allocator_type& __a, _Tp* __p)             { __destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p); }       _LIBCPP_INLINE_VISIBILITY     static size_type max_size(const allocator_type& __a) _NOEXCEPT         { return __max_size(__has_max_size<const allocator_type>(), __a); }       _LIBCPP_INLINE_VISIBILITY     static allocator_type         select_on_container_copy_construction(const allocator_type& __a)             { return __select_on_container_copy_construction(                 __has_select_on_container_copy_construction<const allocator_type>(),                 __a); }       template <class _Ptr>         _LIBCPP_INLINE_VISIBILITY         static         void         __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)         {              for (;  __begin1 != __end1;  ++__begin1, ++__begin2)                 construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));          }       template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             (is_same<allocator_type, allocator<_Tp> >::value                 || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&              is_trivially_move_constructible<_Tp>::value,             void         >::type         __construct_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)         {              ptrdiff_t _Np = __end1 - __begin1;              if (_Np > 0)             {                  _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));                  __begin2 += _Np;              }          }       template <class _Iter, class _Ptr>         _LIBCPP_INLINE_VISIBILITY         static         void         __construct_range_forward(allocator_type& __a, _Iter __begin1, _Iter __end1, _Ptr& __begin2)         {              for (;  __begin1 != __end1;  ++__begin1, (void) ++__begin2)                 construct(__a, _VSTD::__to_raw_pointer(__begin2), *__begin1);          }       template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             (is_same<allocator_type, allocator<_Tp> >::value                 || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&              is_trivially_move_constructible<_Tp>::value,             void         >::type         __construct_range_forward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)         {              typedef typename remove_const<_Tp>::type _Vp;              ptrdiff_t _Np = __end1 - __begin1;              if (_Np > 0)             {                  _VSTD::memcpy(const_cast<_Vp*>(__begin2), __begin1, _Np * sizeof(_Tp));                  __begin2 += _Np;              }          }       template <class _Ptr>         _LIBCPP_INLINE_VISIBILITY         static         void         __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)         {              while (__end1 != __begin1)             {                  construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));                  --__end2;              }          }       template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             (is_same<allocator_type, allocator<_Tp> >::value                 || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&              is_trivially_move_constructible<_Tp>::value,             void         >::type         __construct_backward(allocator_type&, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)         {              ptrdiff_t _Np = __end1 - __begin1;              __end2 -= _Np;              if (_Np > 0)                 _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));          }   private:      _LIBCPP_INLINE_VISIBILITY     static pointer __allocate(allocator_type& __a, size_type __n,         const_void_pointer __hint, true_type)         { return __a.allocate(__n, __hint); }      _LIBCPP_INLINE_VISIBILITY     static pointer __allocate(allocator_type& __a, size_type __n,         const_void_pointer, false_type)         { return __a.allocate(__n); }     
#ifndef _LIBCPP_HAS_NO_VARIADICS
    template <class _Tp, class... _Args>         _LIBCPP_INLINE_VISIBILITY         static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)             { __a.construct(__p, _VSTD::forward<_Args>(__args)...); }      template <class _Tp, class... _Args>         _LIBCPP_INLINE_VISIBILITY         static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)             {                  ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);              }    
#endif  // _LIBCPP_HAS_NO_VARIADICS
     template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         static void __destroy(true_type, allocator_type& __a, _Tp* __p)             { __a.destroy(__p); }      template <class _Tp>         _LIBCPP_INLINE_VISIBILITY         static void __destroy(false_type, allocator_type&, _Tp* __p)             {                  __p->~_Tp();              }       _LIBCPP_INLINE_VISIBILITY     static size_type __max_size(true_type, const allocator_type& __a)             { return __a.max_size(); }      _LIBCPP_INLINE_VISIBILITY     static size_type __max_size(false_type, const allocator_type&)             { return numeric_limits<size_type>::max() / sizeof(value_type); }       _LIBCPP_INLINE_VISIBILITY     static allocator_type         __select_on_container_copy_construction(true_type, const allocator_type& __a)             { return __a.select_on_container_copy_construction(); }      _LIBCPP_INLINE_VISIBILITY     static allocator_type         __select_on_container_copy_construction(false_type, const allocator_type& __a)             { return __a; }  };   template <class _Traits, class _Tp> struct __rebind_alloc_helper {    
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Traits::template rebind_alloc<_Tp>        type;    
#else
    typedef typename _Traits::template rebind_alloc<_Tp>::other type;    
#endif
};   // allocator
 template <class _Tp> class _LIBCPP_TEMPLATE_VIS allocator {  public:     typedef size_t            size_type;      typedef ptrdiff_t         difference_type;      typedef _Tp*              pointer;      typedef const _Tp*        const_pointer;      typedef _Tp&              reference;      typedef const _Tp&        const_reference;      typedef _Tp               value_type;       typedef true_type propagate_on_container_move_assignment;      typedef true_type is_always_equal;       template <class _Up> struct rebind { typedef allocator<_Up> other; };       _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT { }      template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT { }      _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT         { return _VSTD::addressof(__x); }      _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT         { return _VSTD::addressof(__x); }      _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)         {          if (__n > max_size())             __throw_length_error("allocator<T>::allocate(size_t n)"                                  " 'n' exceeds maximum supported size");          return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));          }      _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT         { _VSTD::__libcpp_deallocate((void*)__p); }      _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT         { return size_type(~0) / sizeof(_Tp); }    
#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
    template <class _Up, class... _Args>         _LIBCPP_INLINE_VISIBILITY         void         construct(_Up* __p, _Args&&... __args)         {              ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);          }    
#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
        _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p)         {              ::new((void*)__p) _Tp();          }    
# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
     template <class _A0>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, _A0& __a0)         {              ::new((void*)__p) _Tp(__a0);          }      template <class _A0>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, const _A0& __a0)         {              ::new((void*)__p) _Tp(__a0);          }    
# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
    template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, _A0& __a0, _A1& __a1)         {              ::new((void*)__p) _Tp(__a0, __a1);          }      template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, const _A0& __a0, _A1& __a1)         {              ::new((void*)__p) _Tp(__a0, __a1);          }      template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, _A0& __a0, const _A1& __a1)         {              ::new((void*)__p) _Tp(__a0, __a1);          }      template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, const _A0& __a0, const _A1& __a1)         {              ::new((void*)__p) _Tp(__a0, __a1);          }    
#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) { __p->~_Tp(); }  };   template <class _Tp> class _LIBCPP_TEMPLATE_VIS allocator<const _Tp> {  public:     typedef size_t            size_type;      typedef ptrdiff_t         difference_type;      typedef const _Tp*        pointer;      typedef const _Tp*        const_pointer;      typedef const _Tp&        reference;      typedef const _Tp&        const_reference;      typedef const _Tp         value_type;       typedef true_type propagate_on_container_move_assignment;      typedef true_type is_always_equal;       template <class _Up> struct rebind { typedef allocator<_Up> other; };       _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT { }      template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT { }      _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT         { return _VSTD::addressof(__x); }      _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)     {          if (__n > max_size())             __throw_length_error("allocator<const T>::allocate(size_t n)"                                  " 'n' exceeds maximum supported size");          return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));      }      _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT         { _VSTD::__libcpp_deallocate((void*) const_cast<_Tp *>(__p)); }      _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT         { return size_type(~0) / sizeof(_Tp); }    
#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
    template <class _Up, class... _Args>         _LIBCPP_INLINE_VISIBILITY         void         construct(_Up* __p, _Args&&... __args)         {              ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);          }    
#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
        _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p)         {              ::new((void*) const_cast<_Tp *>(__p)) _Tp();          }    
# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
     template <class _A0>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, _A0& __a0)         {              ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);          }      template <class _A0>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, const _A0& __a0)         {              ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0);          }    
# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)
    template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, _A0& __a0, _A1& __a1)         {              ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);          }      template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, const _A0& __a0, _A1& __a1)         {              ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);          }      template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, _A0& __a0, const _A1& __a1)         {              ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);          }      template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         void         construct(pointer __p, const _A0& __a0, const _A1& __a1)         {              ::new((void*) const_cast<_Tp *>(__p)) _Tp(__a0, __a1);          }    
#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) { __p->~_Tp(); }  };   template <class _Tp, class _Up> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT { return true; }   template <class _Tp, class _Up> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT { return false; }   template <class _OutputIterator, class _Tp> class _LIBCPP_TEMPLATE_VIS raw_storage_iterator     : public iterator<output_iterator_tag,                       _Tp,                                         // purposefully not C++03
                      ptrdiff_t,                                   // purposefully not C++03
                      _Tp*,                                        // purposefully not C++03
                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03
{  private:     _OutputIterator __x_;  public:     _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) { }      _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() { return *this; }      _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)         { ::new(&*__x_) _Tp(__element);  return *this; }    
};   template <class _Tp> pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __n) _NOEXCEPT {      pair<_Tp*, ptrdiff_t> __r(0, 0);      const ptrdiff_t __m = (~ptrdiff_t(0) ^                            ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))                            / sizeof(_Tp);      if (__n > __m)         __n = __m;      while (__n > 0)     {          __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));          if (__r.first)         {              __r.second = __n;              break;          }          __n /= 2;      }      return __r;  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void return_temporary_buffer(_Tp* __p) _NOEXCEPT { ::operator delete(__p); }     
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
template <class _Tp> struct auto_ptr_ref {      _Tp* __ptr_;  };   template<class _Tp> class _LIBCPP_TEMPLATE_VIS auto_ptr {  private:     _Tp* __ptr_;  public:     typedef _Tp element_type;       _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) { }      _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) { }      template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()         : __ptr_(__p.release()) { }      _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()         { reset(__p.release());  return *this; }      template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()         { reset(__p.release());  return *this; }      _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()         { reset(__p.__ptr_);  return *this; }      _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() { delete __ptr_; }       _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()         { return *__ptr_; }      _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() { return __ptr_; }      _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() { return __ptr_; }      _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()     {          _Tp* __t = __ptr_;          __ptr_ = 0;          return __t;      }      _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()     {          if (__ptr_ != __p)             delete __ptr_;          __ptr_ = __p;      }       _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) { }      template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()         { auto_ptr_ref<_Up> __t;  __t.__ptr_ = release();  return __t; }      template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()         { return auto_ptr<_Up>(release()); }  };   template <> class _LIBCPP_TEMPLATE_VIS auto_ptr<void> {  public:     typedef void element_type;  };    
#endif
 template <class _Tp, int _Idx,           bool _CanBeEmptyBase =               is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value> struct __compressed_pair_elem {    typedef _Tp _ParamT;    typedef _Tp& reference;    typedef const _Tp& const_reference;     
#ifndef _LIBCPP_CXX03_LANG
  constexpr __compressed_pair_elem() : __value_() { }     template <class _Up, class = typename enable_if<       !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value   >::type>   constexpr explicit   __compressed_pair_elem(_Up&& __u)       : __value_(_VSTD::forward<_Up>(__u)){ };     template <class... _Args, size_t... _Indexes>   _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14   __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,                          __tuple_indices<_Indexes...>)       : __value_(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) { }    
#else
  __compressed_pair_elem() : __value_() { }    __compressed_pair_elem(_ParamT __p) : __value_(std::forward<_ParamT>(__p)) { }    
#endif
   reference __get() _NOEXCEPT {  return __value_;  }    const_reference __get() const _NOEXCEPT {  return __value_;  }   private:   _Tp __value_;  };   template <class _Tp, int _Idx> struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {    typedef _Tp _ParamT;    typedef _Tp& reference;    typedef const _Tp& const_reference;    typedef _Tp __value_type;     
#ifndef _LIBCPP_CXX03_LANG
  constexpr __compressed_pair_elem() = default;     template <class _Up, class = typename enable_if<         !is_same<__compressed_pair_elem, typename decay<_Up>::type>::value   >::type>   constexpr explicit   __compressed_pair_elem(_Up&& __u)       : __value_type(_VSTD::forward<_Up>(__u)){ };     template <class... _Args, size_t... _Indexes>   _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14   __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,                          __tuple_indices<_Indexes...>)       : __value_type(_VSTD::forward<_Args>(_VSTD::get<_Indexes>(__args))...) { }    
#else
  __compressed_pair_elem() : __value_type() { }    __compressed_pair_elem(_ParamT __p)       : __value_type(std::forward<_ParamT>(__p)) { }    
#endif
   reference __get() _NOEXCEPT {  return *this;  }    const_reference __get() const _NOEXCEPT {  return *this;  }  };   // Tag used to construct the second element of the compressed pair.
struct __second_tag { };   template <class _T1, class _T2> class __compressed_pair : private __compressed_pair_elem<_T1, 0>,                           private __compressed_pair_elem<_T2, 1> {    typedef __compressed_pair_elem<_T1, 0> _Base1;    typedef __compressed_pair_elem<_T2, 1> _Base2;     // NOTE: This static assert should never fire because __compressed_pair
  // is *almost never* used in a scenario where it's possible for T1 == T2.
  // (The exception is std::function where it is possible that the function
  //  object and the allocator have the same type).
  static_assert((!is_same<_T1, _T2>::value),     "__compressed_pair cannot be instantated when T1 and T2 are the same type; "     "The current implementation is NOT ABI-compatible with the previous "     "implementation for this configuration");   public:   
#ifndef _LIBCPP_CXX03_LANG
  template <bool _Dummy = true,       class = typename enable_if<           __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&           __dependent_type<is_default_constructible<_T2>, _Dummy>::value       >::type   >   _LIBCPP_INLINE_VISIBILITY   constexpr __compressed_pair() { }     template <class _Tp, typename enable_if<!is_same<typename decay<_Tp>::type,                                                    __compressed_pair>::value,                                           bool>::type = true>   _LIBCPP_INLINE_VISIBILITY constexpr explicit   __compressed_pair(_Tp&& __t)       : _Base1(std::forward<_Tp>(__t)), _Base2() { }     template <class _Tp>   _LIBCPP_INLINE_VISIBILITY constexpr   __compressed_pair(__second_tag, _Tp&& __t)       : _Base1(), _Base2(std::forward<_Tp>(__t)) { }     template <class _U1, class _U2>   _LIBCPP_INLINE_VISIBILITY constexpr   __compressed_pair(_U1&& __t1, _U2&& __t2)       : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) { }     template <class... _Args1, class... _Args2>   _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14   __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,                     tuple<_Args2...> __second_args)       : _Base1(__pc, _VSTD::move(__first_args),                typename __make_tuple_indices<sizeof...(_Args1)>::type()),         _Base2(__pc, _VSTD::move(__second_args),                typename __make_tuple_indices<sizeof...(_Args2)>::type()) { }     
#else
  _LIBCPP_INLINE_VISIBILITY   __compressed_pair() { }     _LIBCPP_INLINE_VISIBILITY explicit   __compressed_pair(_T1 __t1) : _Base1(_VSTD::forward<_T1>(__t1)) { }     _LIBCPP_INLINE_VISIBILITY   __compressed_pair(__second_tag, _T2 __t2)       : _Base1(), _Base2(_VSTD::forward<_T2>(__t2)) { }     _LIBCPP_INLINE_VISIBILITY   __compressed_pair(_T1 __t1, _T2 __t2)       : _Base1(_VSTD::forward<_T1>(__t1)), _Base2(_VSTD::forward<_T2>(__t2)) { }    
#endif
   _LIBCPP_INLINE_VISIBILITY   typename _Base1::reference first() _NOEXCEPT {      return static_cast<_Base1&>(*this).__get();    }     _LIBCPP_INLINE_VISIBILITY   typename _Base1::const_reference first() const _NOEXCEPT {      return static_cast<_Base1 const&>(*this).__get();    }     _LIBCPP_INLINE_VISIBILITY   typename _Base2::reference second() _NOEXCEPT {      return static_cast<_Base2&>(*this).__get();    }     _LIBCPP_INLINE_VISIBILITY   typename _Base2::const_reference second() const _NOEXCEPT {      return static_cast<_Base2 const&>(*this).__get();    }     _LIBCPP_INLINE_VISIBILITY   void swap(__compressed_pair& __x)     _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&                __is_nothrow_swappable<_T2>::value)   {      using std::swap;      swap(first(), __x.first());      swap(second(), __x.second());    }  };   template <class _T1, class _T2> inline _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)     _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&                __is_nothrow_swappable<_T2>::value) {    __x.swap(__y);  }   // default_delete
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS default_delete {      static_assert(!is_function<_Tp>::value,                   "default_delete cannot be instantiated for function types");    
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;    
#else
  _LIBCPP_INLINE_VISIBILITY default_delete() { }    
#endif
  template <class _Up>   _LIBCPP_INLINE_VISIBILITY   default_delete(const default_delete<_Up>&,                  typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* =                      0) _NOEXCEPT { }     _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __ptr) const _NOEXCEPT {      static_assert(sizeof(_Tp) > 0,                   "default_delete can not delete incomplete type");      static_assert(!is_void<_Tp>::value,                   "default_delete can not delete incomplete type");      delete __ptr;    }  };   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS default_delete<_Tp[]> {  private:   template <class _Up>   struct _EnableIfConvertible       : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> { };   public:   
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_INLINE_VISIBILITY constexpr default_delete() noexcept = default;    
#else
  _LIBCPP_INLINE_VISIBILITY default_delete() { }    
#endif
   template <class _Up>   _LIBCPP_INLINE_VISIBILITY   default_delete(const default_delete<_Up[]>&,                  typename _EnableIfConvertible<_Up>::type* = 0) _NOEXCEPT { }     template <class _Up>   _LIBCPP_INLINE_VISIBILITY   typename _EnableIfConvertible<_Up>::type   operator()(_Up* __ptr) const _NOEXCEPT {      static_assert(sizeof(_Tp) > 0,                   "default_delete can not delete incomplete type");      static_assert(!is_void<_Tp>::value,                   "default_delete can not delete void type");      delete[] __ptr;    }  };       
#ifndef _LIBCPP_CXX03_LANG
template <class _Deleter> struct __unique_ptr_deleter_sfinae {    static_assert(!is_reference<_Deleter>::value, "incorrect specialization");    typedef const _Deleter& __lval_ref_type;    typedef _Deleter&& __good_rval_ref_type;    typedef true_type __enable_rval_overload;  };   template <class _Deleter> struct __unique_ptr_deleter_sfinae<_Deleter const&> {    typedef const _Deleter& __lval_ref_type;    typedef const _Deleter&& __bad_rval_ref_type;    typedef false_type __enable_rval_overload;  };   template <class _Deleter> struct __unique_ptr_deleter_sfinae<_Deleter&> {    typedef _Deleter& __lval_ref_type;    typedef _Deleter&& __bad_rval_ref_type;    typedef false_type __enable_rval_overload;  };    
#endif // !defined(_LIBCPP_CXX03_LANG)
 template <class _Tp, class _Dp = default_delete<_Tp> > class _LIBCPP_TEMPLATE_VIS unique_ptr {  public:   typedef _Tp element_type;    typedef _Dp deleter_type;    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;     static_assert(!is_rvalue_reference<deleter_type>::value,                 "the specified deleter type cannot be an rvalue reference");   private:   __compressed_pair<pointer, deleter_type> __ptr_;     struct __nat {  int __for_bool_;  };     
#ifndef _LIBCPP_CXX03_LANG
  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;     template <bool _Dummy>   using _LValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;     template <bool _Dummy>   using _GoodRValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;     template <bool _Dummy>   using _BadRValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;     template <bool _Dummy, class _Deleter = typename __dependent_type<                              __identity<deleter_type>, _Dummy>::type>   using _EnableIfDeleterDefaultConstructible =       typename enable_if<is_default_constructible<_Deleter>::value &&                          !is_pointer<_Deleter>::value>::type;     template <class _ArgType>   using _EnableIfDeleterConstructible =       typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;     template <class _UPtr, class _Up>   using _EnableIfMoveConvertible = typename enable_if<       is_convertible<typename _UPtr::pointer, pointer>::value &&       !is_array<_Up>::value   >::type;     template <class _UDel>   using _EnableIfDeleterConvertible = typename enable_if<       (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||       (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)     >::type;     template <class _UDel>   using _EnableIfDeleterAssignable = typename enable_if<       is_assignable<_Dp&, _UDel&&>::value     >::type;   public:   template <bool _Dummy = true,             class = _EnableIfDeleterDefaultConstructible<_Dummy>>   _LIBCPP_INLINE_VISIBILITY   constexpr unique_ptr() noexcept : __ptr_(pointer()) { }     template <bool _Dummy = true,             class = _EnableIfDeleterDefaultConstructible<_Dummy>>   _LIBCPP_INLINE_VISIBILITY   constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) { }     template <bool _Dummy = true,             class = _EnableIfDeleterDefaultConstructible<_Dummy>>   _LIBCPP_INLINE_VISIBILITY   explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) { }     template <bool _Dummy = true,             class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept       : __ptr_(__p, __d) { }     template <bool _Dummy = true,             class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept       : __ptr_(__p, _VSTD::move(__d)) {      static_assert(!is_reference<deleter_type>::value,                   "rvalue deleter bound to reference");    }     template <bool _Dummy = true,             class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;     _LIBCPP_INLINE_VISIBILITY   unique_ptr(unique_ptr&& __u) noexcept       : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {    }     template <class _Up, class _Ep,       class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,       class = _EnableIfDeleterConvertible<_Ep>   >   _LIBCPP_INLINE_VISIBILITY   unique_ptr(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT       : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) { }     
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  template <class _Up>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(auto_ptr<_Up>&& __p,              typename enable_if<is_convertible<_Up*, _Tp*>::value &&                                     is_same<_Dp, default_delete<_Tp>>::value,                                 __nat>::type = __nat()) _NOEXCEPT       : __ptr_(__p.release()) { }    
#endif
   _LIBCPP_INLINE_VISIBILITY   unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT {      reset(__u.release());      __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());      return *this;    }     template <class _Up, class _Ep,       class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,       class = _EnableIfDeleterAssignable<_Ep>   >   _LIBCPP_INLINE_VISIBILITY   unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT {      reset(__u.release());      __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());      return *this;    }     
#else  // _LIBCPP_CXX03_LANG
private:   unique_ptr(unique_ptr&);    template <class _Up, class _Ep> unique_ptr(unique_ptr<_Up, _Ep>&);     unique_ptr& operator=(unique_ptr&);    template <class _Up, class _Ep> unique_ptr& operator=(unique_ptr<_Up, _Ep>&);   public:   _LIBCPP_INLINE_VISIBILITY   unique_ptr() : __ptr_(pointer())   {      static_assert(!is_pointer<deleter_type>::value,                   "unique_ptr constructed with null function pointer deleter");      static_assert(is_default_constructible<deleter_type>::value,                   "unique_ptr::deleter_type is not default constructible");    }    _LIBCPP_INLINE_VISIBILITY   unique_ptr(nullptr_t) : __ptr_(pointer())   {      static_assert(!is_pointer<deleter_type>::value,                   "unique_ptr constructed with null function pointer deleter");    }    _LIBCPP_INLINE_VISIBILITY   explicit unique_ptr(pointer __p)       : __ptr_(_VSTD::move(__p)) {      static_assert(!is_pointer<deleter_type>::value,                   "unique_ptr constructed with null function pointer deleter");    }     _LIBCPP_INLINE_VISIBILITY   operator __rv<unique_ptr>() {      return __rv<unique_ptr>(*this);    }     _LIBCPP_INLINE_VISIBILITY   unique_ptr(__rv<unique_ptr> __u)       : __ptr_(__u->release(),                _VSTD::forward<deleter_type>(__u->get_deleter())) { }     template <class _Up, class _Ep>   _LIBCPP_INLINE_VISIBILITY   typename enable_if<       !is_array<_Up>::value &&           is_convertible<typename unique_ptr<_Up, _Ep>::pointer,                          pointer>::value &&           is_assignable<deleter_type&, _Ep&>::value,       unique_ptr&>::type   operator=(unique_ptr<_Up, _Ep> __u) {      reset(__u.release());      __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());      return *this;    }     _LIBCPP_INLINE_VISIBILITY   unique_ptr(pointer __p, deleter_type __d)       : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) { }    
#endif // _LIBCPP_CXX03_LANG
   
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  template <class _Up>   _LIBCPP_INLINE_VISIBILITY       typename enable_if<is_convertible<_Up*, _Tp*>::value &&                              is_same<_Dp, default_delete<_Tp> >::value,                          unique_ptr&>::type       operator=(auto_ptr<_Up> __p) {      reset(__p.release());      return *this;    }    
#endif
   _LIBCPP_INLINE_VISIBILITY   ~unique_ptr() {  reset();  }     _LIBCPP_INLINE_VISIBILITY   unique_ptr& operator=(nullptr_t) _NOEXCEPT {      reset();      return *this;    }     _LIBCPP_INLINE_VISIBILITY   typename add_lvalue_reference<_Tp>::type   operator*() const {      return *__ptr_.first();    }    _LIBCPP_INLINE_VISIBILITY   pointer operator->() const _NOEXCEPT {      return __ptr_.first();    }    _LIBCPP_INLINE_VISIBILITY   pointer get() const _NOEXCEPT {      return __ptr_.first();    }    _LIBCPP_INLINE_VISIBILITY   deleter_type& get_deleter() _NOEXCEPT {      return __ptr_.second();    }    _LIBCPP_INLINE_VISIBILITY   const deleter_type& get_deleter() const _NOEXCEPT {      return __ptr_.second();    }    _LIBCPP_INLINE_VISIBILITY   _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {      return __ptr_.first() != nullptr;    }     _LIBCPP_INLINE_VISIBILITY   pointer release() _NOEXCEPT {      pointer __t = __ptr_.first();      __ptr_.first() = pointer();      return __t;    }     _LIBCPP_INLINE_VISIBILITY   void reset(pointer __p = pointer()) _NOEXCEPT {      pointer __tmp = __ptr_.first();      __ptr_.first() = __p;      if (__tmp)       __ptr_.second()(__tmp);    }     _LIBCPP_INLINE_VISIBILITY   void swap(unique_ptr& __u) _NOEXCEPT {      __ptr_.swap(__u.__ptr_);    }  };    template <class _Tp, class _Dp> class _LIBCPP_TEMPLATE_VIS unique_ptr<_Tp[], _Dp> {  public:   typedef _Tp element_type;    typedef _Dp deleter_type;    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;   private:   __compressed_pair<pointer, deleter_type> __ptr_;     template <class _From>   struct _CheckArrayPointerConversion : is_same<_From, pointer> { };     template <class _FromElem>   struct _CheckArrayPointerConversion<_FromElem*>       : integral_constant<bool,           is_same<_FromElem*, pointer>::value ||             (is_same<pointer, element_type*>::value &&              is_convertible<_FromElem(*)[], element_type(*)[]>::value)       >   { };     
#ifndef _LIBCPP_CXX03_LANG
  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;     template <bool _Dummy>   using _LValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;     template <bool _Dummy>   using _GoodRValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;     template <bool _Dummy>   using _BadRValRefType =       typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;     template <bool _Dummy, class _Deleter = typename __dependent_type<                              __identity<deleter_type>, _Dummy>::type>   using _EnableIfDeleterDefaultConstructible =       typename enable_if<is_default_constructible<_Deleter>::value &&                          !is_pointer<_Deleter>::value>::type;     template <class _ArgType>   using _EnableIfDeleterConstructible =       typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;     template <class _Pp>   using _EnableIfPointerConvertible = typename enable_if<       _CheckArrayPointerConversion<_Pp>::value   >::type;     template <class _UPtr, class _Up,         class _ElemT = typename _UPtr::element_type>   using _EnableIfMoveConvertible = typename enable_if<       is_array<_Up>::value &&       is_same<pointer, element_type*>::value &&       is_same<typename _UPtr::pointer, _ElemT*>::value &&       is_convertible<_ElemT(*)[], element_type(*)[]>::value     >::type;     template <class _UDel>   using _EnableIfDeleterConvertible = typename enable_if<       (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||       (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)     >::type;     template <class _UDel>   using _EnableIfDeleterAssignable = typename enable_if<       is_assignable<_Dp&, _UDel&&>::value     >::type;   public:   template <bool _Dummy = true,             class = _EnableIfDeleterDefaultConstructible<_Dummy>>   _LIBCPP_INLINE_VISIBILITY   constexpr unique_ptr() noexcept : __ptr_(pointer()) { }     template <bool _Dummy = true,             class = _EnableIfDeleterDefaultConstructible<_Dummy>>   _LIBCPP_INLINE_VISIBILITY   constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) { }     template <class _Pp, bool _Dummy = true,             class = _EnableIfDeleterDefaultConstructible<_Dummy>,             class = _EnableIfPointerConvertible<_Pp>>   _LIBCPP_INLINE_VISIBILITY   explicit unique_ptr(_Pp __p) noexcept       : __ptr_(__p) { }     template <class _Pp, bool _Dummy = true,             class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,             class = _EnableIfPointerConvertible<_Pp>>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept       : __ptr_(__p, __d) { }     template <bool _Dummy = true,             class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept       : __ptr_(nullptr, __d) { }     template <class _Pp, bool _Dummy = true,             class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,             class = _EnableIfPointerConvertible<_Pp>>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept       : __ptr_(__p, _VSTD::move(__d)) {      static_assert(!is_reference<deleter_type>::value,                   "rvalue deleter bound to reference");    }     template <bool _Dummy = true,             class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept       : __ptr_(nullptr, _VSTD::move(__d)) {      static_assert(!is_reference<deleter_type>::value,                   "rvalue deleter bound to reference");    }     template <class _Pp, bool _Dummy = true,             class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,             class = _EnableIfPointerConvertible<_Pp>>   _LIBCPP_INLINE_VISIBILITY   unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;     _LIBCPP_INLINE_VISIBILITY   unique_ptr(unique_ptr&& __u) noexcept       : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {    }     _LIBCPP_INLINE_VISIBILITY   unique_ptr& operator=(unique_ptr&& __u) noexcept {      reset(__u.release());      __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());      return *this;    }     template <class _Up, class _Ep,       class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,       class = _EnableIfDeleterConvertible<_Ep>   >   _LIBCPP_INLINE_VISIBILITY   unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept       : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {    }     template <class _Up, class _Ep,       class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,       class = _EnableIfDeleterAssignable<_Ep>   >   _LIBCPP_INLINE_VISIBILITY   unique_ptr&   operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {      reset(__u.release());      __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());      return *this;    }     
#else // _LIBCPP_CXX03_LANG
private:   template <class _Up> explicit unique_ptr(_Up);     unique_ptr(unique_ptr&);    template <class _Up> unique_ptr(unique_ptr<_Up>&);     unique_ptr& operator=(unique_ptr&);    template <class _Up> unique_ptr& operator=(unique_ptr<_Up>&);     template <class _Up>   unique_ptr(_Up __u,              typename conditional<                  is_reference<deleter_type>::value, deleter_type,                  typename add_lvalue_reference<const deleter_type>::type>::type,              typename enable_if<is_convertible<_Up, pointer>::value,                                 __nat>::type = __nat());  public:   _LIBCPP_INLINE_VISIBILITY   unique_ptr() : __ptr_(pointer()) {      static_assert(!is_pointer<deleter_type>::value,                   "unique_ptr constructed with null function pointer deleter");    }    _LIBCPP_INLINE_VISIBILITY   unique_ptr(nullptr_t) : __ptr_(pointer()) {      static_assert(!is_pointer<deleter_type>::value,                   "unique_ptr constructed with null function pointer deleter");    }     _LIBCPP_INLINE_VISIBILITY   explicit unique_ptr(pointer __p) : __ptr_(__p) {      static_assert(!is_pointer<deleter_type>::value,                   "unique_ptr constructed with null function pointer deleter");    }     _LIBCPP_INLINE_VISIBILITY   unique_ptr(pointer __p, deleter_type __d)       : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) { }     _LIBCPP_INLINE_VISIBILITY   unique_ptr(nullptr_t, deleter_type __d)       : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) { }     _LIBCPP_INLINE_VISIBILITY   operator __rv<unique_ptr>() {      return __rv<unique_ptr>(*this);    }     _LIBCPP_INLINE_VISIBILITY   unique_ptr(__rv<unique_ptr> __u)       : __ptr_(__u->release(),                _VSTD::forward<deleter_type>(__u->get_deleter())) { }     _LIBCPP_INLINE_VISIBILITY   unique_ptr& operator=(__rv<unique_ptr> __u) {      reset(__u->release());      __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());      return *this;    }     
#endif // _LIBCPP_CXX03_LANG
 public:   _LIBCPP_INLINE_VISIBILITY   ~unique_ptr() {  reset();  }     _LIBCPP_INLINE_VISIBILITY   unique_ptr& operator=(nullptr_t) _NOEXCEPT {      reset();      return *this;    }     _LIBCPP_INLINE_VISIBILITY   typename add_lvalue_reference<_Tp>::type   operator[](size_t __i) const {      return __ptr_.first()[__i];    }    _LIBCPP_INLINE_VISIBILITY   pointer get() const _NOEXCEPT {      return __ptr_.first();    }     _LIBCPP_INLINE_VISIBILITY   deleter_type& get_deleter() _NOEXCEPT {      return __ptr_.second();    }     _LIBCPP_INLINE_VISIBILITY   const deleter_type& get_deleter() const _NOEXCEPT {      return __ptr_.second();    }    _LIBCPP_INLINE_VISIBILITY   _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {      return __ptr_.first() != nullptr;    }     _LIBCPP_INLINE_VISIBILITY   pointer release() _NOEXCEPT {      pointer __t = __ptr_.first();      __ptr_.first() = pointer();      return __t;    }     template <class _Pp>   _LIBCPP_INLINE_VISIBILITY   typename enable_if<       _CheckArrayPointerConversion<_Pp>::value   >::type   reset(_Pp __p) _NOEXCEPT {      pointer __tmp = __ptr_.first();      __ptr_.first() = __p;      if (__tmp)       __ptr_.second()(__tmp);    }     _LIBCPP_INLINE_VISIBILITY   void reset(nullptr_t = nullptr) _NOEXCEPT {      pointer __tmp = __ptr_.first();      __ptr_.first() = nullptr;      if (__tmp)       __ptr_.second()(__tmp);    }     _LIBCPP_INLINE_VISIBILITY   void swap(unique_ptr& __u) _NOEXCEPT {      __ptr_.swap(__u.__ptr_);    }   };   template <class _Tp, class _Dp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if<     __is_swappable<_Dp>::value,     void >::type swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT { __x.swap(__y); }   template <class _T1, class _D1, class _T2, class _D2> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) { return __x.get() == __y.get(); }   template <class _T1, class _D1, class _T2, class _D2> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) { return !(__x == __y); }   template <class _T1, class _D1, class _T2, class _D2> inline _LIBCPP_INLINE_VISIBILITY bool operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {      typedef typename unique_ptr<_T1, _D1>::pointer _P1;      typedef typename unique_ptr<_T2, _D2>::pointer _P2;      typedef typename common_type<_P1, _P2>::type _Vp;      return less<_Vp>()(__x.get(), __y.get());  }   template <class _T1, class _D1, class _T2, class _D2> inline _LIBCPP_INLINE_VISIBILITY bool operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) { return __y < __x; }   template <class _T1, class _D1, class _T2, class _D2> inline _LIBCPP_INLINE_VISIBILITY bool operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) { return !(__y < __x); }   template <class _T1, class _D1, class _T2, class _D2> inline _LIBCPP_INLINE_VISIBILITY bool operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) { return !(__x < __y); }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT {      return !__x;  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT {      return !__x;  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT {      return static_cast<bool>(__x);  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT {      return static_cast<bool>(__x);  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t) {      typedef typename unique_ptr<_T1, _D1>::pointer _P1;      return less<_P1>()(__x.get(), nullptr);  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x) {      typedef typename unique_ptr<_T1, _D1>::pointer _P1;      return less<_P1>()(nullptr, __x.get());  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t) {      return nullptr < __x;  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x) {      return __x < nullptr;  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {      return !(nullptr < __x);  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {      return !(__x < nullptr);  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {      return !(__x < nullptr);  }   template <class _T1, class _D1> inline _LIBCPP_INLINE_VISIBILITY bool operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {      return !(nullptr < __x);  }     
#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp, class _Dp> inline _LIBCPP_INLINE_VISIBILITY unique_ptr<_Tp, _Dp> move(unique_ptr<_Tp, _Dp>& __t) {      return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));  }     
#endif
   
#if _LIBCPP_STD_VER > 11
 template<class _Tp> struct __unique_if {      typedef unique_ptr<_Tp> __unique_single;  };   template<class _Tp> struct __unique_if<_Tp[]> {      typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;  };   template<class _Tp, size_t _Np> struct __unique_if<_Tp[_Np]> {      typedef void __unique_array_known_bound;  };   template<class _Tp, class... _Args> inline _LIBCPP_INLINE_VISIBILITY typename __unique_if<_Tp>::__unique_single make_unique(_Args&&... __args) {      return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));  }   template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename __unique_if<_Tp>::__unique_array_unknown_bound make_unique(size_t __n) {      typedef typename remove_extent<_Tp>::type _Up;      return unique_ptr<_Tp>(new _Up[__n]());  }   template<class _Tp, class... _Args>     typename __unique_if<_Tp>::__unique_array_known_bound     make_unique(_Args&&...) = delete;     
#endif  // _LIBCPP_STD_VER > 11
 template <class _Tp, class _Dp>   
#ifdef _LIBCPP_CXX03_LANG
struct _LIBCPP_TEMPLATE_VIS hash<unique_ptr<_Tp, _Dp> >   
#else
struct _LIBCPP_TEMPLATE_VIS hash<__enable_hash_helper<     unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer>>   
#endif
{      typedef unique_ptr<_Tp, _Dp> argument_type;      typedef size_t               result_type;      _LIBCPP_INLINE_VISIBILITY     result_type operator()(const argument_type& __ptr) const     {          typedef typename argument_type::pointer pointer;          return hash<pointer>()(__ptr.get());      }  };   struct __destruct_n {  private:     size_t __size_;       template <class _Tp>     _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT         { for (size_t __i = 0;  __i < __size_;  ++__i, ++__p) __p->~_Tp(); }       template <class _Tp>     _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT         { }       _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT         { ++__size_; }      _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT         { }       _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT         { __size_ = __s; }      _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT         { }  public:     _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT         : __size_(__s) { }       template <class _Tp>     _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT         { __incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>()); }       template <class _Tp>     _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT         { __set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>()); }       template <class _Tp>     _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT         { __process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>()); }  };   template <class _Alloc> class __allocator_destructor {      typedef allocator_traits<_Alloc> __alloc_traits;  public:     typedef typename __alloc_traits::pointer pointer;      typedef typename __alloc_traits::size_type size_type;  private:     _Alloc& __alloc_;      size_type __s_;  public:     _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)              _NOEXCEPT         : __alloc_(__a), __s_(__s) { }      _LIBCPP_INLINE_VISIBILITY     void operator()(pointer __p) _NOEXCEPT         { __alloc_traits::deallocate(__alloc_, __p, __s_); }  };   template <class _InputIterator, class _ForwardIterator> _ForwardIterator uninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r) {      typedef typename iterator_traits<_ForwardIterator>::value_type value_type;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    _ForwardIterator __s = __r;      try     {    
#endif
        for (;  __f != __l;  ++__f, (void) ++__r)             ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }      catch (...)     {          for (;  __s != __r;  ++__s)             __s->~value_type();          throw;      }    
#endif
    return __r;  }   template <class _InputIterator, class _Size, class _ForwardIterator> _ForwardIterator uninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r) {      typedef typename iterator_traits<_ForwardIterator>::value_type value_type;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    _ForwardIterator __s = __r;      try     {    
#endif
        for (;  __n > 0;  ++__f, (void) ++__r, (void) --__n)             ::new (static_cast<void*>(_VSTD::addressof(*__r))) value_type(*__f);    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }      catch (...)     {          for (;  __s != __f;  ++__s)             __s->~value_type();          throw;      }    
#endif
}   template <class _ForwardIterator, class _Size, class _Tp> _ForwardIterator uninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x) {      typedef typename iterator_traits<_ForwardIterator>::value_type value_type;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    _ForwardIterator __s = __f;      try     {    
#endif
        for (;  __n > 0;  ++__f, (void) --__n)             ::new (static_cast<void*>(_VSTD::addressof(*__f))) value_type(__x);    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }      catch (...)     {          for (;  __s != __f;  ++__s)             __s->~value_type();          throw;      }    
#endif
    return __f;  }     
#if _LIBCPP_STD_VER > 14
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void destroy_at(_Tp* __loc) {      _LIBCPP_ASSERT(__loc, "null pointer given to destroy_at");      __loc->~_Tp();  }   template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY void destroy(_ForwardIterator __first, _ForwardIterator __last) {      for (;  __first != __last;  ++__first)         _VSTD::destroy_at(_VSTD::addressof(*__first));  }   template <class _ForwardIterator, class _Size> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {      for (;  __n > 0;  (void)++__first, --__n)         _VSTD::destroy_at(_VSTD::addressof(*__first));      return __first;  }   template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY void uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {      using _Vt = typename iterator_traits<_ForwardIterator>::value_type;      auto __idx = __first;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    try {    
#endif
    for (;  __idx != __last;  ++__idx)         ::new((void*)_VSTD::addressof(*__idx)) _Vt;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }  catch (...) {          _VSTD::destroy(__first, __idx);          throw;      }    
#endif
}   template <class _ForwardIterator, class _Size> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {      using _Vt = typename iterator_traits<_ForwardIterator>::value_type;      auto __idx = __first;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    try {    
#endif
    for (;  __n > 0;  (void)++__idx, --__n)         ::new((void*)_VSTD::addressof(*__idx)) _Vt;      return __idx;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }  catch (...) {          _VSTD::destroy(__first, __idx);          throw;      }    
#endif
}    template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY void uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {      using _Vt = typename iterator_traits<_ForwardIterator>::value_type;      auto __idx = __first;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    try {    
#endif
    for (;  __idx != __last;  ++__idx)         ::new((void*)_VSTD::addressof(*__idx)) _Vt();    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }  catch (...) {          _VSTD::destroy(__first, __idx);          throw;      }    
#endif
}   template <class _ForwardIterator, class _Size> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {      using _Vt = typename iterator_traits<_ForwardIterator>::value_type;      auto __idx = __first;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    try {    
#endif
    for (;  __n > 0;  (void)++__idx, --__n)         ::new((void*)_VSTD::addressof(*__idx)) _Vt();      return __idx;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }  catch (...) {          _VSTD::destroy(__first, __idx);          throw;      }    
#endif
}    template <class _InputIt, class _ForwardIt> inline _LIBCPP_INLINE_VISIBILITY _ForwardIt uninitialized_move(_InputIt __first, _InputIt __last, _ForwardIt __first_res) {      using _Vt = typename iterator_traits<_ForwardIt>::value_type;      auto __idx = __first_res;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    try {    
#endif
    for (;  __first != __last;  (void)++__idx, ++__first)         ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));      return __idx;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }  catch (...) {          _VSTD::destroy(__first_res, __idx);          throw;      }    
#endif
}   template <class _InputIt, class _Size, class _ForwardIt> inline _LIBCPP_INLINE_VISIBILITY pair<_InputIt, _ForwardIt> uninitialized_move_n(_InputIt __first, _Size __n, _ForwardIt __first_res) {      using _Vt = typename iterator_traits<_ForwardIt>::value_type;      auto __idx = __first_res;    
#ifndef _LIBCPP_NO_EXCEPTIONS
    try {    
#endif
    for (;  __n > 0;  ++__idx, (void)++__first, --__n)         ::new((void*)_VSTD::addressof(*__idx)) _Vt(std::move(*__first));      return { __first, __idx};    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }  catch (...) {          _VSTD::destroy(__first_res, __idx);          throw;      }    
#endif
}      
#endif
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _Tp __libcpp_atomic_refcount_increment(_Tp& __t) _NOEXCEPT {    
#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)
    return __atomic_add_fetch(&__t, 1, __ATOMIC_RELAXED);    
#else
    return __t += 1;    
#endif
}   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _Tp __libcpp_atomic_refcount_decrement(_Tp& __t) _NOEXCEPT {    
#if defined(_LIBCPP_HAS_BUILTIN_ATOMIC_SUPPORT) && !defined(_LIBCPP_HAS_NO_THREADS)
    return __atomic_add_fetch(&__t, -1, __ATOMIC_ACQ_REL);    
#else
    return __t -= 1;    
#endif
}   class _LIBCPP_EXCEPTION_ABI bad_weak_ptr     : public std::exception {  public:     virtual ~bad_weak_ptr() _NOEXCEPT;      virtual const char* what() const  _NOEXCEPT;  };   _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_bad_weak_ptr() {    
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw bad_weak_ptr();    
#else
    _VSTD::abort();    
#endif
}   template<class _Tp> class _LIBCPP_TEMPLATE_VIS weak_ptr;   class _LIBCPP_TYPE_VIS __shared_count {      __shared_count(const __shared_count&);      __shared_count& operator=(const __shared_count&);   protected:     long __shared_owners_;      virtual ~__shared_count();  private:     virtual void __on_zero_shared() _NOEXCEPT = 0;   public:     _LIBCPP_INLINE_VISIBILITY     explicit __shared_count(long __refs = 0) _NOEXCEPT         : __shared_owners_(__refs) { }     
#if defined(_LIBCPP_BUILDING_MEMORY) && \
    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)
    void __add_shared() _NOEXCEPT;      bool __release_shared() _NOEXCEPT;    
#else
    _LIBCPP_INLINE_VISIBILITY     void __add_shared() _NOEXCEPT {        __libcpp_atomic_refcount_increment(__shared_owners_);      }      _LIBCPP_INLINE_VISIBILITY     bool __release_shared() _NOEXCEPT {        if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {          __on_zero_shared();          return true;        }        return false;      }    
#endif
    _LIBCPP_INLINE_VISIBILITY     long use_count() const _NOEXCEPT {          return __libcpp_relaxed_load(&__shared_owners_) + 1;      }  };   class _LIBCPP_TYPE_VIS __shared_weak_count     : private __shared_count {      long __shared_weak_owners_;   public:     _LIBCPP_INLINE_VISIBILITY     explicit __shared_weak_count(long __refs = 0) _NOEXCEPT         : __shared_count(__refs),           __shared_weak_owners_(__refs) { }  protected:     virtual ~__shared_weak_count();   public:   
#if defined(_LIBCPP_BUILDING_MEMORY) && \
    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)
    void __add_shared() _NOEXCEPT;      void __add_weak() _NOEXCEPT;      void __release_shared() _NOEXCEPT;    
#else
    _LIBCPP_INLINE_VISIBILITY     void __add_shared() _NOEXCEPT {        __shared_count::__add_shared();      }      _LIBCPP_INLINE_VISIBILITY     void __add_weak() _NOEXCEPT {        __libcpp_atomic_refcount_increment(__shared_weak_owners_);      }      _LIBCPP_INLINE_VISIBILITY     void __release_shared() _NOEXCEPT {        if (__shared_count::__release_shared())         __release_weak();      }    
#endif
    void __release_weak() _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     long use_count() const _NOEXCEPT { return __shared_count::use_count(); }      __shared_weak_count* lock() _NOEXCEPT;       // Define the function out only if we build static libc++ without RTTI.
    // Otherwise we may break clients who need to compile their projects with
    // -fno-rtti and yet link against a libc++.dylib compiled
    // without -fno-rtti.
  
#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)
    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;    
#endif
private:     virtual void __on_zero_shared_weak() _NOEXCEPT = 0;  };   template <class _Tp, class _Dp, class _Alloc> class __shared_ptr_pointer     : public __shared_weak_count {      __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;  public:     _LIBCPP_INLINE_VISIBILITY     __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)         :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) { }     
#ifndef _LIBCPP_NO_RTTI
    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;    
#endif
 private:     virtual void __on_zero_shared() _NOEXCEPT;      virtual void __on_zero_shared_weak() _NOEXCEPT;  };     
#ifndef _LIBCPP_NO_RTTI
 template <class _Tp, class _Dp, class _Alloc> const void* __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT {      return __t == typeid(_Dp) ? _VSTD::addressof(__data_.first().second()) : nullptr;  }     
#endif  // _LIBCPP_NO_RTTI
 template <class _Tp, class _Dp, class _Alloc> void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT {      __data_.first().second()(__data_.first().first());      __data_.first().second().~_Dp();  }   template <class _Tp, class _Dp, class _Alloc> void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT {      typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;      typedef allocator_traits<_Al> _ATraits;      typedef pointer_traits<typename _ATraits::pointer> _PTraits;       _Al __a(__data_.second());      __data_.second().~_Alloc();      __a.deallocate(_PTraits::pointer_to(*this), 1);  }   template <class _Tp, class _Alloc> class __shared_ptr_emplace     : public __shared_weak_count {      __compressed_pair<_Alloc, _Tp> __data_;  public:   
#ifndef _LIBCPP_HAS_NO_VARIADICS
     _LIBCPP_INLINE_VISIBILITY     __shared_ptr_emplace(_Alloc __a)         :  __data_(_VSTD::move(__a)) { }       template <class ..._Args>         _LIBCPP_INLINE_VISIBILITY         __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)             :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),                    _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) { }     
#else  // _LIBCPP_HAS_NO_VARIADICS
     _LIBCPP_INLINE_VISIBILITY     __shared_ptr_emplace(_Alloc __a)         :  __data_(__a) { }       template <class _A0>         _LIBCPP_INLINE_VISIBILITY         __shared_ptr_emplace(_Alloc __a, _A0& __a0)             :  __data_(__a, _Tp(__a0)) { }       template <class _A0, class _A1>         _LIBCPP_INLINE_VISIBILITY         __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)             :  __data_(__a, _Tp(__a0, __a1)) { }       template <class _A0, class _A1, class _A2>         _LIBCPP_INLINE_VISIBILITY         __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)             :  __data_(__a, _Tp(__a0, __a1, __a2)) { }     
#endif  // _LIBCPP_HAS_NO_VARIADICS
 private:     virtual void __on_zero_shared() _NOEXCEPT;      virtual void __on_zero_shared_weak() _NOEXCEPT;  public:     _LIBCPP_INLINE_VISIBILITY     _Tp* get() _NOEXCEPT { return &__data_.second(); }  };   template <class _Tp, class _Alloc> void __shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT {      __data_.second().~_Tp();  }   template <class _Tp, class _Alloc> void __shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT {      typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type _Al;      typedef allocator_traits<_Al> _ATraits;      typedef pointer_traits<typename _ATraits::pointer> _PTraits;      _Al __a(__data_.first());      __data_.first().~_Alloc();      __a.deallocate(_PTraits::pointer_to(*this), 1);  }   struct __shared_ptr_dummy_rebind_allocator_type;  template <> class _LIBCPP_TEMPLATE_VIS allocator<__shared_ptr_dummy_rebind_allocator_type> {  public:     template <class _Other>     struct rebind     {          typedef allocator<_Other> other;      };  };   template<class _Tp> class _LIBCPP_TEMPLATE_VIS enable_shared_from_this;   template<class _Tp> class _LIBCPP_TEMPLATE_VIS shared_ptr {  public:     typedef _Tp element_type;     
#if _LIBCPP_STD_VER > 14
    typedef weak_ptr<_Tp> weak_type;    
#endif
private:     element_type*      __ptr_;      __shared_weak_count* __cntrl_;       struct __nat { int __for_bool_; };  public:     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;      template<class _Yp>         explicit shared_ptr(_Yp* __p,                             typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());      template<class _Yp, class _Dp>         shared_ptr(_Yp* __p, _Dp __d,                    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());      template<class _Yp, class _Dp, class _Alloc>         shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,                    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());      template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);      template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);      template<class _Yp> _LIBCPP_INLINE_VISIBILITY shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     shared_ptr(const shared_ptr& __r) _NOEXCEPT;      template<class _Yp>         _LIBCPP_INLINE_VISIBILITY         shared_ptr(const shared_ptr<_Yp>& __r,                    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())                        _NOEXCEPT;    
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY     shared_ptr(shared_ptr&& __r) _NOEXCEPT;      template<class _Yp> _LIBCPP_INLINE_VISIBILITY  shared_ptr(shared_ptr<_Yp>&& __r,                    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat())                        _NOEXCEPT;    
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,                    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type= __nat());    
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
  
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template<class _Yp>         shared_ptr(auto_ptr<_Yp>&& __r,                    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());    
#else
    template<class _Yp>         shared_ptr(auto_ptr<_Yp> __r,                    typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());    
#endif
  
#endif
  
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template <class _Yp, class _Dp>         shared_ptr(unique_ptr<_Yp, _Dp>&&,                    typename enable_if                    <                        !is_lvalue_reference<_Dp>::value &&                        !is_array<_Yp>::value &&                        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,                        __nat                    >::type = __nat());      template <class _Yp, class _Dp>         shared_ptr(unique_ptr<_Yp, _Dp>&&,                    typename enable_if                    <                        is_lvalue_reference<_Dp>::value &&                        !is_array<_Yp>::value &&                        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,                        __nat                    >::type = __nat());    
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    template <class _Yp, class _Dp>         shared_ptr(unique_ptr<_Yp, _Dp>,                    typename enable_if                    <                        !is_lvalue_reference<_Dp>::value &&                        !is_array<_Yp>::value &&                        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,                        __nat                    >::type = __nat());      template <class _Yp, class _Dp>         shared_ptr(unique_ptr<_Yp, _Dp>,                    typename enable_if                    <                        is_lvalue_reference<_Dp>::value &&                        !is_array<_Yp>::value &&                        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,                        __nat                    >::type = __nat());    
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
     ~shared_ptr();       _LIBCPP_INLINE_VISIBILITY     shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;      template<class _Yp>         typename enable_if         <             is_convertible<_Yp*, element_type*>::value,             shared_ptr&         >::type         _LIBCPP_INLINE_VISIBILITY         operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;    
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY     shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;      template<class _Yp>         typename enable_if         <             is_convertible<_Yp*, element_type*>::value,             shared_ptr<_Tp>&         >::type         _LIBCPP_INLINE_VISIBILITY         operator=(shared_ptr<_Yp>&& __r);    
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
    template<class _Yp>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             !is_array<_Yp>::value &&             is_convertible<_Yp*, element_type*>::value,             shared_ptr         >::type&         operator=(auto_ptr<_Yp>&& __r);    
#endif
  
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
  
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
    template<class _Yp>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             !is_array<_Yp>::value &&             is_convertible<_Yp*, element_type*>::value,             shared_ptr&         >::type         operator=(auto_ptr<_Yp> __r);    
#endif
  
#endif
#ifndef _LIBCPP_NO_RTTI
    template <class _Dp>         _LIBCPP_INLINE_VISIBILITY         _Dp* __get_deleter() const _NOEXCEPT             { return static_cast<_Dp*>(__cntrl_                     ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))                       : nullptr); }    
#endif  // _LIBCPP_NO_RTTI
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
     template<class ..._Args>         static         shared_ptr<_Tp>         make_shared(_Args&& ...__args);       template<class _Alloc, class ..._Args>         static         shared_ptr<_Tp>         allocate_shared(const _Alloc& __a, _Args&& ...__args);     
#else  // _LIBCPP_HAS_NO_VARIADICS
     static shared_ptr<_Tp> make_shared();       template<class _A0>         static shared_ptr<_Tp> make_shared(_A0&);       template<class _A0, class _A1>         static shared_ptr<_Tp> make_shared(_A0&, _A1&);       template<class _A0, class _A1, class _A2>         static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);       template<class _Alloc>         static shared_ptr<_Tp>         allocate_shared(const _Alloc& __a);       template<class _Alloc, class _A0>         static shared_ptr<_Tp>         allocate_shared(const _Alloc& __a, _A0& __a0);       template<class _Alloc, class _A0, class _A1>         static shared_ptr<_Tp>         allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);       template<class _Alloc, class _A0, class _A1, class _A2>         static shared_ptr<_Tp>         allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);     
#endif  // _LIBCPP_HAS_NO_VARIADICS
 private:     template <class _Yp, bool = is_function<_Yp>::value>         struct __shared_ptr_default_allocator         {              typedef allocator<_Yp> type;          };       template <class _Yp>         struct __shared_ptr_default_allocator<_Yp, true>         {              typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;          };       template <class _Yp, class _OrigPtr>         _LIBCPP_INLINE_VISIBILITY         typename enable_if<is_convertible<_OrigPtr*,                                           const enable_shared_from_this<_Yp>*         >::value,             void>::type         __enable_weak_this(const enable_shared_from_this<_Yp>* __e,                            _OrigPtr* __ptr) _NOEXCEPT         {              typedef typename remove_cv<_Yp>::type _RawYp;              if (__e && __e->__weak_this_.expired())             {                  __e->__weak_this_ = shared_ptr<_RawYp>(*this,                     const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));              }          }       _LIBCPP_INLINE_VISIBILITY void __enable_weak_this(...) _NOEXCEPT { }       template <class _Up> friend class _LIBCPP_TEMPLATE_VIS shared_ptr;      template <class _Up> friend class _LIBCPP_TEMPLATE_VIS weak_ptr;  };    template<class _Tp> inline _LIBCPP_CONSTEXPR shared_ptr<_Tp>::shared_ptr() _NOEXCEPT     : __ptr_(0),       __cntrl_(0) {  }   template<class _Tp> inline _LIBCPP_CONSTEXPR shared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT     : __ptr_(0),       __cntrl_(0) {  }   template<class _Tp> template<class _Yp> shared_ptr<_Tp>::shared_ptr(_Yp* __p,                             typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)     : __ptr_(__p) {      unique_ptr<_Yp> __hold(__p);      typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;      typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, _AllocT > _CntrlBlk;      __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());      __hold.release();      __enable_weak_this(__p, __p);  }   template<class _Tp> template<class _Yp, class _Dp> shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,                             typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)     : __ptr_(__p) {    
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {    
#endif  // _LIBCPP_NO_EXCEPTIONS
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;          typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;          __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());          __enable_weak_this(__p, __p);    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }      catch (...)     {          __d(__p);          throw;      }    
#endif  // _LIBCPP_NO_EXCEPTIONS
}   template<class _Tp> template<class _Yp, class _Dp, class _Alloc> shared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,                             typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)     : __ptr_(__p) {    
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {    
#endif  // _LIBCPP_NO_EXCEPTIONS
        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;          typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;          typedef __allocator_destructor<_A2> _D2;          _A2 __a2(__a);          unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));          ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))             _CntrlBlk(__p, __d, __a);          __cntrl_ = _VSTD::addressof(*__hold2.release());          __enable_weak_this(__p, __p);    
#ifndef _LIBCPP_NO_EXCEPTIONS
    }      catch (...)     {          __d(__p);          throw;      }    
#endif  // _LIBCPP_NO_EXCEPTIONS
}   template<class _Tp> template<class _Yp> inline shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT     : __ptr_(__p),       __cntrl_(__r.__cntrl_) {      if (__cntrl_)         __cntrl_->__add_shared();  }   template<class _Tp> inline shared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT     : __ptr_(__r.__ptr_),       __cntrl_(__r.__cntrl_) {      if (__cntrl_)         __cntrl_->__add_shared();  }   template<class _Tp> template<class _Yp> inline shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,                             typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)          _NOEXCEPT     : __ptr_(__r.__ptr_),       __cntrl_(__r.__cntrl_) {      if (__cntrl_)         __cntrl_->__add_shared();  }     
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template<class _Tp> inline shared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT     : __ptr_(__r.__ptr_),       __cntrl_(__r.__cntrl_) {      __r.__ptr_ = 0;      __r.__cntrl_ = 0;  }   template<class _Tp> template<class _Yp> inline shared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,                             typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)          _NOEXCEPT     : __ptr_(__r.__ptr_),       __cntrl_(__r.__cntrl_) {      __r.__ptr_ = 0;      __r.__cntrl_ = 0;  }     
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
   
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
template<class _Tp> template<class _Yp>   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,   
#else
shared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,   
#endif
                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)     : __ptr_(__r.get()) {      typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;      __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());      __enable_weak_this(__r.get(), __r.get());      __r.release();  }    
#endif
 template<class _Tp> template <class _Yp, class _Dp>   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,   
#else
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,   
#endif
                            typename enable_if                             <                                 !is_lvalue_reference<_Dp>::value &&                                 !is_array<_Yp>::value &&                                 is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,                                 __nat                             >::type)     : __ptr_(__r.get()) {    
#if _LIBCPP_STD_VER > 11
    if (__ptr_ == nullptr)         __cntrl_ = nullptr;      else   
#endif
    {          typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;          typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT > _CntrlBlk;          __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());          __enable_weak_this(__r.get(), __r.get());      }      __r.release();  }   template<class _Tp> template <class _Yp, class _Dp>   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,   
#else
shared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,   
#endif
                            typename enable_if                             <                                 is_lvalue_reference<_Dp>::value &&                                 !is_array<_Yp>::value &&                                 is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,                                 __nat                             >::type)     : __ptr_(__r.get()) {    
#if _LIBCPP_STD_VER > 11
    if (__ptr_ == nullptr)         __cntrl_ = nullptr;      else   
#endif
    {          typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;          typedef __shared_ptr_pointer<_Yp*,                                      reference_wrapper<typename remove_reference<_Dp>::type>,                                      _AllocT > _CntrlBlk;          __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());          __enable_weak_this(__r.get(), __r.get());      }      __r.release();  }     
#ifndef _LIBCPP_HAS_NO_VARIADICS
 template<class _Tp> template<class ..._Args> shared_ptr<_Tp> shared_ptr<_Tp>::make_shared(_Args&& ...__args) {      typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;      typedef allocator<_CntrlBlk> _A2;      typedef __allocator_destructor<_A2> _D2;      _A2 __a2;      unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));      ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = __hold2.release();      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }   template<class _Tp> template<class _Alloc, class ..._Args> shared_ptr<_Tp> shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args) {      typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;      typedef __allocator_destructor<_A2> _D2;      _A2 __a2(__a);      unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));      ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))         _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = _VSTD::addressof(*__hold2.release());      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }     
#else  // _LIBCPP_HAS_NO_VARIADICS
 template<class _Tp> shared_ptr<_Tp> shared_ptr<_Tp>::make_shared() {      typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;      typedef allocator<_CntrlBlk> _Alloc2;      typedef __allocator_destructor<_Alloc2> _D2;      _Alloc2 __alloc2;      unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));      ::new(__hold2.get()) _CntrlBlk(__alloc2);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = __hold2.release();      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }   template<class _Tp> template<class _A0> shared_ptr<_Tp> shared_ptr<_Tp>::make_shared(_A0& __a0) {      typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;      typedef allocator<_CntrlBlk> _Alloc2;      typedef __allocator_destructor<_Alloc2> _D2;      _Alloc2 __alloc2;      unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));      ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = __hold2.release();      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }   template<class _Tp> template<class _A0, class _A1> shared_ptr<_Tp> shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1) {      typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;      typedef allocator<_CntrlBlk> _Alloc2;      typedef __allocator_destructor<_Alloc2> _D2;      _Alloc2 __alloc2;      unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));      ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = __hold2.release();      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }   template<class _Tp> template<class _A0, class _A1, class _A2> shared_ptr<_Tp> shared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2) {      typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;      typedef allocator<_CntrlBlk> _Alloc2;      typedef __allocator_destructor<_Alloc2> _D2;      _Alloc2 __alloc2;      unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));      ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = __hold2.release();      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }   template<class _Tp> template<class _Alloc> shared_ptr<_Tp> shared_ptr<_Tp>::allocate_shared(const _Alloc& __a) {      typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;      typedef __allocator_destructor<_Alloc2> _D2;      _Alloc2 __alloc2(__a);      unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));      ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))         _CntrlBlk(__a);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = _VSTD::addressof(*__hold2.release());      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }   template<class _Tp> template<class _Alloc, class _A0> shared_ptr<_Tp> shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0) {      typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;      typedef __allocator_destructor<_Alloc2> _D2;      _Alloc2 __alloc2(__a);      unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));      ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))         _CntrlBlk(__a, __a0);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = _VSTD::addressof(*__hold2.release());      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }   template<class _Tp> template<class _Alloc, class _A0, class _A1> shared_ptr<_Tp> shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1) {      typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;      typedef __allocator_destructor<_Alloc2> _D2;      _Alloc2 __alloc2(__a);      unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));      ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))         _CntrlBlk(__a, __a0, __a1);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = _VSTD::addressof(*__hold2.release());      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }   template<class _Tp> template<class _Alloc, class _A0, class _A1, class _A2> shared_ptr<_Tp> shared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2) {      typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _Alloc2;      typedef __allocator_destructor<_Alloc2> _D2;      _Alloc2 __alloc2(__a);      unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));      ::new(static_cast<void*>(_VSTD::addressof(*__hold2.get())))         _CntrlBlk(__a, __a0, __a1, __a2);      shared_ptr<_Tp> __r;      __r.__ptr_ = __hold2.get()->get();      __r.__cntrl_ = _VSTD::addressof(*__hold2.release());      __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);      return __r;  }     
#endif  // _LIBCPP_HAS_NO_VARIADICS
 template<class _Tp> shared_ptr<_Tp>::~shared_ptr() {      if (__cntrl_)         __cntrl_->__release_shared();  }   template<class _Tp> inline shared_ptr<_Tp>& shared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT {      shared_ptr(__r).swap(*this);      return *this;  }   template<class _Tp> template<class _Yp> inline typename enable_if <     is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,     shared_ptr<_Tp>& >::type shared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT {      shared_ptr(__r).swap(*this);      return *this;  }     
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template<class _Tp> inline shared_ptr<_Tp>& shared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT {      shared_ptr(_VSTD::move(__r)).swap(*this);      return *this;  }   template<class _Tp> template<class _Yp> inline typename enable_if <     is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value,     shared_ptr<_Tp>& >::type shared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r) {      shared_ptr(_VSTD::move(__r)).swap(*this);      return *this;  }     
 class _LIBCPP_TYPE_VIS __sp_mut {      void* __lx;  public:     void lock() _NOEXCEPT;      void unlock() _NOEXCEPT;   private:     _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;      __sp_mut(const __sp_mut&);      __sp_mut& operator=(const __sp_mut&);       friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);  };   _LIBCPP_FUNC_VIS _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR __sp_mut& __get_sp_mut(const void*);   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool atomic_is_lock_free(const shared_ptr<_Tp>*) {      return false;  }   template <class _Tp> _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp>* __p) {      __sp_mut& __m = __get_sp_mut(__p);      __m.lock();      shared_ptr<_Tp> __q = *__p;      __m.unlock();      return __q;  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR shared_ptr<_Tp> atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order) {      return atomic_load(__p);  }   template <class _Tp> _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR void atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r) {      __sp_mut& __m = __get_sp_mut(__p);      __m.lock();      __p->swap(__r);      __m.unlock();  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR void atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order) {      atomic_store(__p, __r);  }   template <class _Tp> _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR shared_ptr<_Tp> atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r) {      __sp_mut& __m = __get_sp_mut(__p);      __m.lock();      __p->swap(__r);      __m.unlock();      return __r;  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR shared_ptr<_Tp> atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order) {      return atomic_exchange(__p, __r);  }   template <class _Tp> _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR bool atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w) {      shared_ptr<_Tp> __temp;      __sp_mut& __m = __get_sp_mut(__p);      __m.lock();      if (__p->__owner_equivalent(*__v))     {          _VSTD::swap(__temp, *__p);          *__p = __w;          __m.unlock();          return true;      }      _VSTD::swap(__temp, *__v);      *__v = *__p;      __m.unlock();      return false;  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR bool atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w) {      return atomic_compare_exchange_strong(__p, __v, __w);  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR bool atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,                                         shared_ptr<_Tp> __w, memory_order, memory_order) {      return atomic_compare_exchange_strong(__p, __v, __w);  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_AVAILABILITY_ATOMIC_SHARED_PTR bool atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,                                       shared_ptr<_Tp> __w, memory_order, memory_order) {      return atomic_compare_exchange_weak(__p, __v, __w);  }     
#endif  // !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
 //enum class
  
#if defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE)
  
# ifndef _LIBCPP_CXX03_LANG
enum class pointer_safety : unsigned char {    relaxed,   preferred,   strict };    
# endif
  
#else
struct _LIBCPP_TYPE_VIS pointer_safety {      enum __lx     {          relaxed,         preferred,         strict     };       __lx __v_;       _LIBCPP_INLINE_VISIBILITY     pointer_safety() : __v_() { }       _LIBCPP_INLINE_VISIBILITY     pointer_safety(__lx __v) : __v_(__v) { }      _LIBCPP_INLINE_VISIBILITY     operator int() const { return __v_; }  };    
#endif
   
#if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) && \
    defined(_LIBCPP_BUILDING_MEMORY)
_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;    
#else
// This function is only offered in C++03 under ABI v1.
  
# if !defined(_LIBCPP_ABI_POINTER_SAFETY_ENUM_TYPE) || !defined(_LIBCPP_CXX03_LANG)
inline _LIBCPP_INLINE_VISIBILITY pointer_safety get_pointer_safety() _NOEXCEPT {    return pointer_safety::relaxed;  }    
# endif
  
#endif
  _LIBCPP_FUNC_VIS void declare_reachable(void* __p);  _LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);  _LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);  _LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _Tp* undeclare_reachable(_Tp* __p) {      return static_cast<_Tp*>(__undeclare_reachable(__p));  }   _LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);   // --- Helper for container swap --
template <typename _Alloc> inline _LIBCPP_INLINE_VISIBILITY void __swap_allocator(_Alloc & __a1, _Alloc & __a2)   
#if _LIBCPP_STD_VER >= 14
    _NOEXCEPT   
#else
    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)   
#endif
{      __swap_allocator(__a1, __a2,       integral_constant<bool, _VSTD::allocator_traits<_Alloc>::propagate_on_container_swap::value>());  }   template <typename _Alloc> _LIBCPP_INLINE_VISIBILITY void __swap_allocator(_Alloc & __a1, _Alloc & __a2, true_type)   
#if _LIBCPP_STD_VER >= 14
    _NOEXCEPT   
#else
    _NOEXCEPT_(__is_nothrow_swappable<_Alloc>::value)   
#endif
{      using _VSTD::swap;      swap(__a1, __a2);  }   template <typename _Alloc> inline _LIBCPP_INLINE_VISIBILITY void __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT { }   template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> > struct __noexcept_move_assign_container : public integral_constant<bool,     _Traits::propagate_on_container_move_assignment::value   
#if _LIBCPP_STD_VER > 14
        || _Traits::is_always_equal::value   
#else
        && is_nothrow_move_assignable<_Alloc>::value   
#endif
    > { };      
#ifndef _LIBCPP_HAS_NO_VARIADICS
template <class _Tp, class _Alloc> struct __temp_value {      typedef allocator_traits<_Alloc> _Traits;       typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;      _Alloc &__a;       _Tp *__addr() {  return reinterpret_cast<_Tp *>(addressof(__v));  }      _Tp &   get() {  return *__addr();  }       template<class... _Args>     __temp_value(_Alloc &__alloc, _Args&& ... __args) : __a(__alloc)     {  _Traits::construct(__a, __addr(), _VSTD::forward<_Args>(__args)...);  }       ~__temp_value() {  _Traits::destroy(__a, __addr());  }      };    
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_MEMORY
  
#pragma clang module end /*std.memory*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <iterator>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.iterator
// -*- C++ -*-
//===-------------------------- iterator ----------------------------------===//
#ifndef _LIBCPP_ITERATOR
  
#define _LIBCPP_ITERATOR
 /*     iterator synopsis  namespace std {   template<class Iterator> struct iterator_traits {      typedef typename Iterator::difference_type difference_type;      typedef typename Iterator::value_type value_type;      typedef typename Iterator::pointer pointer;      typedef typename Iterator::reference reference;      typedef typename Iterator::iterator_category iterator_category;  };   template<class T> struct iterator_traits<T*> {      typedef ptrdiff_t difference_type;      typedef T value_type;      typedef T* pointer;      typedef T& reference;      typedef random_access_iterator_tag iterator_category;  };   template<class T> struct iterator_traits<const T*> {      typedef ptrdiff_t difference_type;      typedef T value_type;      typedef const T* pointer;      typedef const T& reference;      typedef random_access_iterator_tag iterator_category;  };   template<class Category, class T, class Distance = ptrdiff_t,          class Pointer = T*, class Reference = T&> struct iterator {      typedef T         value_type;      typedef Distance  difference_type;      typedef Pointer   pointer;      typedef Reference reference;      typedef Category  iterator_category;  };   struct input_iterator_tag  { };  struct output_iterator_tag { };  struct forward_iterator_tag       : public input_iterator_tag         { };  struct bidirectional_iterator_tag : public forward_iterator_tag       { };  struct random_access_iterator_tag : public bidirectional_iterator_tag { };   // 27.4.3, iterator operations
// extension: second argument not conforming to C++03
template <class InputIterator>  // constexpr in C++17
  constexpr void advance(InputIterator& i,              typename iterator_traits<InputIterator>::difference_type n);   template <class InputIterator>  // constexpr in C++17
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  struct _LIBCPP_TEMPLATE_VIS input_iterator_tag { };  struct _LIBCPP_TEMPLATE_VIS output_iterator_tag { };  struct _LIBCPP_TEMPLATE_VIS forward_iterator_tag       : public input_iterator_tag { };  struct _LIBCPP_TEMPLATE_VIS bidirectional_iterator_tag : public forward_iterator_tag { };  struct _LIBCPP_TEMPLATE_VIS random_access_iterator_tag : public bidirectional_iterator_tag { };   template <class _Tp> struct __has_iterator_category {  private:     struct __two { char __lx;  char __lxx; };      template <class _Up> static __two __test(...);      template <class _Up> static char __test(typename _Up::iterator_category* = 0);  public:     static const bool value = sizeof(__test<_Tp>(0)) == 1;  };   template <class _Iter, bool> struct __iterator_traits_impl { };   template <class _Iter> struct __iterator_traits_impl<_Iter, true> {      typedef typename _Iter::difference_type   difference_type;      typedef typename _Iter::value_type        value_type;      typedef typename _Iter::pointer           pointer;      typedef typename _Iter::reference         reference;      typedef typename _Iter::iterator_category iterator_category;  };   template <class _Iter, bool> struct __iterator_traits { };   template <class _Iter> struct __iterator_traits<_Iter, true>     :  __iterator_traits_impl       <         _Iter,         is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||         is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value       > { };   // iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category
//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a
//    conforming extension which allows some programs to compile and behave as
//    the client expects instead of failing at compile time.
///    function.
_LIBCPP_FUNC_VIS bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);   // Setup the throwing debug handler during dynamic initialization.
  
#if _LIBCPP_DEBUG_LEVEL >= 1 && defined(_LIBCPP_DEBUG_USE_EXCEPTIONS)
  
# if defined(_LIBCPP_NO_EXCEPTIONS)
  
#   error _LIBCPP_DEBUG_USE_EXCEPTIONS cannot be used when exceptions are disabled.
#endif
    _LIBCPP_INLINE_VISIBILITY     __i_node(void* __i, __i_node* __next, __c_node* __c)         : __i_(__i), __next_(__next), __c_(__c) { }      ~__i_node();  };   struct _LIBCPP_TYPE_VIS __c_node {      void* __c_;      __c_node* __next_;      __i_node** beg_;      __i_node** end_;      __i_node** cap_;     
#ifndef _LIBCPP_CXX03_LANG
    __c_node(const __c_node&) = delete;      __c_node& operator=(const __c_node&) = delete;    
#else
private:     __c_node(const __c_node&);      __c_node& operator=(const __c_node&);  public:   
#endif
    _LIBCPP_INLINE_VISIBILITY     __c_node(void* __c, __c_node* __next)         : __c_(__c), __next_(__next), beg_(nullptr), end_(nullptr), cap_(nullptr) { }      virtual ~__c_node();       virtual bool __dereferenceable(const void*) const = 0;      virtual bool __decrementable(const void*) const = 0;      virtual bool __addable(const void*, ptrdiff_t) const = 0;      virtual bool __subscriptable(const void*, ptrdiff_t) const = 0;       void __add(__i_node* __i);      _LIBCPP_HIDDEN void __remove(__i_node* __i);  };   template <class _Cont> struct _C_node     : public __c_node {      _C_node(void* __c, __c_node* __n)         : __c_node(__c, __n) { }       virtual bool __dereferenceable(const void*) const;      virtual bool __decrementable(const void*) const;      virtual bool __addable(const void*, ptrdiff_t) const;      virtual bool __subscriptable(const void*, ptrdiff_t) const;  };   template <class _Cont> inline bool _C_node<_Cont>::__dereferenceable(const void* __i) const {      typedef typename _Cont::const_iterator iterator;      const iterator* __j = static_cast<const iterator*>(__i);      _Cont* _Cp = static_cast<_Cont*>(__c_);      return _Cp->__dereferenceable(__j);  }   template <class _Cont> inline bool _C_node<_Cont>::__decrementable(const void* __i) const {      typedef typename _Cont::const_iterator iterator;      const iterator* __j = static_cast<const iterator*>(__i);      _Cont* _Cp = static_cast<_Cont*>(__c_);      return _Cp->__decrementable(__j);  }   template <class _Cont> inline bool _C_node<_Cont>::__addable(const void* __i, ptrdiff_t __n) const {      typedef typename _Cont::const_iterator iterator;      const iterator* __j = static_cast<const iterator*>(__i);      _Cont* _Cp = static_cast<_Cont*>(__c_);      return _Cp->__addable(__j, __n);  }   template <class _Cont> inline bool _C_node<_Cont>::__subscriptable(const void* __i, ptrdiff_t __n) const {      typedef typename _Cont::const_iterator iterator;      const iterator* __j = static_cast<const iterator*>(__i);      _Cont* _Cp = static_cast<_Cont*>(__c_);      return _Cp->__subscriptable(__j, __n);  }   class _LIBCPP_TYPE_VIS __libcpp_db {      __c_node** __cbeg_;      __c_node** __cend_;      size_t   __csz_;      __i_node** __ibeg_;      __i_node** __iend_;      size_t   __isz_;       __libcpp_db();  public:   
#ifndef _LIBCPP_CXX03_LANG
    __libcpp_db(const __libcpp_db&) = delete;      __libcpp_db& operator=(const __libcpp_db&) = delete;    
#else
private:     __libcpp_db(const __libcpp_db&);      __libcpp_db& operator=(const __libcpp_db&);  public:   
#endif
    ~__libcpp_db();       class __db_c_iterator;      class __db_c_const_iterator;      class __db_i_iterator;      class __db_i_const_iterator;       __db_c_const_iterator __c_end() const;      __db_i_const_iterator __i_end() const;       template <class _Cont>     _LIBCPP_INLINE_VISIBILITY     void __insert_c(_Cont* __c)     {          __c_node* __n = __insert_c(static_cast<void*>(__c));          ::new(__n) _C_node<_Cont>(__n->__c_, __n->__next_);      }       void __insert_i(void* __i);      __c_node* __insert_c(void* __c);      void __erase_c(void* __c);       void __insert_ic(void* __i, const void* __c);      void __iterator_copy(void* __i, const void* __i0);      void __erase_i(void* __i);       void* __find_c_from_i(void* __i) const;      void __invalidate_all(void* __c);      __c_node* __find_c_and_lock(void* __c) const;      __c_node* __find_c(void* __c) const;      void unlock() const;       void swap(void* __c1, void* __c2);        bool __dereferenceable(const void* __i) const;      bool __decrementable(const void* __i) const;      bool __addable(const void* __i, ptrdiff_t __n) const;      bool __subscriptable(const void* __i, ptrdiff_t __n) const;      bool __less_than_comparable(const void* __i, const void* __j) const;  private:     _LIBCPP_HIDDEN     __i_node* __insert_iterator(void* __i);      _LIBCPP_HIDDEN     __i_node* __find_iterator(const void* __i) const;       friend _LIBCPP_FUNC_VIS __libcpp_db* __get_db();  };   _LIBCPP_FUNC_VIS __libcpp_db* __get_db();  _LIBCPP_FUNC_VIS const __libcpp_db* __get_const_db();      
#endif // _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  // I'd like to replace these with _VSTD::equal_to<void>, but can't because:
//   * That only works with C++14 and later, and
//   * We haven't included <functional> here.
template <class _T1, class _T2 = _T1> struct __equal_to {      _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const { return __x == __y; }      _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const { return __x == __y; }      _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const { return __x == __y; }      _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const { return __x == __y; }  };   template <class _T1> struct __equal_to<_T1, _T1> {      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T1& __x, const _T1& __y) const { return __x == __y; }  };   template <class _T1> struct __equal_to<const _T1, _T1> {      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T1& __x, const _T1& __y) const { return __x == __y; }  };   template <class _T1> struct __equal_to<_T1, const _T1> {      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T1& __x, const _T1& __y) const { return __x == __y; }  };   template <class _T1, class _T2 = _T1> struct __less {      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T1& __x, const _T1& __y) const { return __x < __y; }       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T1& __x, const _T2& __y) const { return __x < __y; }       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T2& __x, const _T1& __y) const { return __x < __y; }       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T2& __x, const _T2& __y) const { return __x < __y; }  };   template <class _T1> struct __less<_T1, _T1> {      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T1& __x, const _T1& __y) const { return __x < __y; }  };   template <class _T1> struct __less<const _T1, _T1> {      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T1& __x, const _T1& __y) const { return __x < __y; }  };   template <class _T1> struct __less<_T1, const _T1> {      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     bool operator()(const _T1& __x, const _T1& __y) const { return __x < __y; }  };   template <class _Predicate> class __invert // invert the sense of a comparison
{  private:     _Predicate __p_;  public:     _LIBCPP_INLINE_VISIBILITY __invert() { }       _LIBCPP_INLINE_VISIBILITY     explicit __invert(_Predicate __p) : __p_(__p) { }       template <class _T1>     _LIBCPP_INLINE_VISIBILITY     bool operator()(const _T1& __x) { return !__p_(__x); }       template <class _T1, class _T2>     _LIBCPP_INLINE_VISIBILITY     bool operator()(const _T1& __x, const _T2& __y) { return __p_(__y, __x); }  };     
#ifdef _LIBCPP_DEBUG
 template <class _Compare> struct __debug_less {      _Compare __comp_;      __debug_less(_Compare& __c) : __comp_(__c) { }       template <class _Tp, class _Up>     bool operator()(const _Tp& __x, const _Up& __y)     {          bool __r = __comp_(__x, __y);          if (__r)             __do_compare_assert(0, __y, __x);          return __r;      }       template <class _LHS, class _RHS>     inline _LIBCPP_INLINE_VISIBILITY     decltype((void)_VSTD::declval<_Compare&>()(         _VSTD::declval<_LHS const&>(), _VSTD::declval<_RHS const&>()))     __do_compare_assert(int, _LHS const& __l, _RHS const& __r) {          _LIBCPP_ASSERT(!__comp_(__l, __r),             "Comparator does not induce a strict weak ordering");      }       template <class _LHS, class _RHS>     inline _LIBCPP_INLINE_VISIBILITY     void __do_compare_assert(long, _LHS const&, _RHS const&) { }  };     
#endif  // _LIBCPP_DEBUG
 // Precondition:  __x != 0
inline _LIBCPP_INLINE_VISIBILITY unsigned __ctz(unsigned __x) {    
#ifndef _LIBCPP_COMPILER_MSVC
    return static_cast<unsigned>(__builtin_ctz(__x));    
#else
  static_assert(sizeof(unsigned) == sizeof(unsigned long), "");    static_assert(sizeof(unsigned long) == 4, "");    unsigned long where;    // Search from LSB to MSB for first set bit.
  // Returns zero if no set bit is found.
  if (_BitScanForward(&where, mask))     return where;    return 32;    
#endif
}   inline _LIBCPP_INLINE_VISIBILITY unsigned long __ctz(unsigned long __x) {    
#ifndef _LIBCPP_COMPILER_MSVC
    return static_cast<unsigned long>(__builtin_ctzl(__x));    
#else
    static_assert(sizeof(unsigned long) == sizeof(unsigned), "");      return __ctz(static_cast<unsigned>(__x));    
#endif
}   inline _LIBCPP_INLINE_VISIBILITY unsigned long long __ctz(unsigned long long __x) {    
#ifndef _LIBCPP_COMPILER_MSVC
    return static_cast<unsigned long long>(__builtin_ctzll(__x));    
#else
    unsigned long where;  // Search from LSB to MSB for first set bit.
// Returns zero if no set bit is found.
  
#if defined(_LIBCPP_HAS_BITSCAN64)
    (defined(_M_AMD64) || defined(__x86_64__))   if (_BitScanForward64(&where, mask))     return static_cast<int>(where);    
#else
  // Win32 doesn't have _BitScanForward64 so emulate it with two 32 bit calls.
  // Scan the Low Word.
  if (_BitScanForward(&where, static_cast<unsigned long>(mask)))     return where;    // Scan the High Word.
  if (_BitScanForward(&where, static_cast<unsigned long>(mask >> 32)))     return where + 32;  // Create a bit offset from the LSB.
  
#endif
  static_assert(sizeof(unsigned) == sizeof(unsigned long), "");    static_assert(sizeof(unsigned long) == 4, "");    unsigned long where;    // Search from LSB to MSB for first set bit.
  // Returns zero if no set bit is found.
  if (_BitScanReverse(&where, mask))     return 31 - where;    return 32;  // Undefined Behavior.
  
#endif
}   inline _LIBCPP_INLINE_VISIBILITY unsigned long __clz(unsigned long __x) {    
#ifndef _LIBCPP_COMPILER_MSVC
    return static_cast<unsigned long>(__builtin_clzl (__x));    
#else
    static_assert(sizeof(unsigned) == sizeof(unsigned long), "");      return __clz(static_cast<unsigned>(__x));    
#endif
}   inline _LIBCPP_INLINE_VISIBILITY unsigned long long __clz(unsigned long long __x) {    
#ifndef _LIBCPP_COMPILER_MSVC
    return static_cast<unsigned long long>(__builtin_clzll(__x));    
#else
  unsigned long where;  // BitScanReverse scans from MSB to LSB for first set bit.
// Returns 0 if no set bit is found.
  
#if defined(_LIBCPP_HAS_BITSCAN64)
  if (_BitScanReverse64(&where, mask))     return static_cast<int>(63 - where);    
#else
  // Scan the high 32 bits.
  if (_BitScanReverse(&where, static_cast<unsigned long>(mask >> 32)))     return 63 - (where + 32);  // Create a bit offset from the MSB.
  // Scan the low 32 bits.
  if (_BitScanReverse(&where, static_cast<unsigned long>(mask)))     return 63 - where;    
#endif
  return 64;  // Undefined Behavior.
  
#endif // _LIBCPP_COMPILER_MSVC
}   inline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned __x) {    
#ifndef _LIBCPP_COMPILER_MSVC
#endif
}   // all_of
 template <class _InputIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY bool all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {      for (;  __first != __last;  ++__first)         if (!__pred(*__first))             return false;      return true;  }   // any_of
 template <class _InputIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY bool any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {      for (;  __first != __last;  ++__first)         if (__pred(*__first))             return true;      return false;  }   // none_of
 template <class _InputIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY bool none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {      for (;  __first != __last;  ++__first)         if (__pred(*__first))             return false;      return true;  }   // for_each
 template <class _InputIterator, class _Function> inline _LIBCPP_INLINE_VISIBILITY _Function for_each(_InputIterator __first, _InputIterator __last, _Function __f) {      for (;  __first != __last;  ++__first)         __f(*__first);      return __f;  }     
#if _LIBCPP_STD_VER > 14
// for_each_n
 template <class _InputIterator, class _Size, class _Function> inline _LIBCPP_INLINE_VISIBILITY _InputIterator for_each_n(_InputIterator __first, _Size __orig_n, _Function __f) {      typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;      _IntegralSize __n = __orig_n;      while (__n > 0)     {           __f(*__first);           ++__first;           --__n;      }      return __first;  }    
#endif
 // find
 template <class _InputIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY _InputIterator find(_InputIterator __first, _InputIterator __last, const _Tp& __value_) {      for (;  __first != __last;  ++__first)         if (*__first == __value_)             break;      return __first;  }   // find_if
 template <class _InputIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY _InputIterator find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {      for (;  __first != __last;  ++__first)         if (__pred(*__first))             break;      return __first;  }   // find_if_not
 template<class _InputIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY _InputIterator find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) {      for (;  __first != __last;  ++__first)         if (!__pred(*__first))             break;      return __first;  }   // find_end
 template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2> _ForwardIterator1 __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,            _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,            forward_iterator_tag, forward_iterator_tag) {      // modeled after search algorithm
    _ForwardIterator1 __r = __last1;   // __last1 is the "default" answer
    if (__first2 == __last2)         return __r;      while (true)     {          while (true)         {              if (__first1 == __last1)         // if source exhausted return last correct answer
                return __r;                   //    (or __last1 if never found)
            if (__pred(*__first1, *__first2))                 break;              ++__first1;          }          // *__first1 matches *__first2, now match elements after here
        _ForwardIterator1 __m1 = __first1;          _ForwardIterator2 __m2 = __first2;          while (true)         {              if (++__m2 == __last2)             {                         // Pattern exhaused, record answer and search for another one
                __r = __first1;                 ++__first1;                 break;             }              if (++__m1 == __last1)     // Source exhausted, return last answer
                return __r;              if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first
            {                 ++__first1;                 break;             }   // else there is a match, check next elements
            {                 break;             }   // else there is a match, check next elements
        }      }  }   template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2> _LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1 __find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,            _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,            random_access_iterator_tag, random_access_iterator_tag) {      // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;      if (__len2 == 0)         return __last1;      typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;      if (__len1 < __len2)         return __last1;      const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);   // End of pattern match can't go before here
    _RandomAccessIterator1 __l1 = __last1;      _RandomAccessIterator2 __l2 = __last2;      --__l2;      while (true)     {          while (true)         {              if (__s == __l1)                 return __last1;              if (__pred(*--__l1, *__l2))                 break;          }          _RandomAccessIterator1 __m1 = __l1;          _RandomAccessIterator2 __m2 = __l2;          while (true)         {              if (__m2 == __first2)                 return __m1;                                   // no need to check range on __m1 because __s guarantees we have enough source
            if (!__pred(*--__m1, *--__m2))             {                 break;             }          }      }  }   template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,          _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) {      return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>                          (__first1, __last1, __first2, __last2, __pred,                           typename iterator_traits<_ForwardIterator1>::iterator_category(),                           typename iterator_traits<_ForwardIterator2>::iterator_category());  }   template <class _ForwardIterator1, class _ForwardIterator2> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,          _ForwardIterator2 __first2, _ForwardIterator2 __last2) {      typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;      typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;      return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());  }   // find_first_of
 template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> _LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1 __find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) {      for (;  __first1 != __last1;  ++__first1)         for (_ForwardIterator2 __j = __first2;  __j != __last2;  ++__j)             if (__pred(*__first1, *__j))                 return __first1;      return __last1;  }    template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator1 find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) {      return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);  }   template <class _ForwardIterator1, class _ForwardIterator2> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator1 find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,               _ForwardIterator2 __first2, _ForwardIterator2 __last2) {      typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;      typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;      return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());  }   // adjacent_find
 template <class _ForwardIterator, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {      if (__first != __last)     {          _ForwardIterator __i = __first;          while (++__i != __last)         {              if (__pred(*__first, *__i))                 return __first;              __first = __i;          }      }      return __last;  }   template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator adjacent_find(_ForwardIterator __first, _ForwardIterator __last) {      typedef typename iterator_traits<_ForwardIterator>::value_type __v;      return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());  }   // count
 template <class _InputIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename iterator_traits<_InputIterator>::difference_type count(_InputIterator __first, _InputIterator __last, const _Tp& __value_) {      typename iterator_traits<_InputIterator>::difference_type __r(0);      for (;  __first != __last;  ++__first)         if (*__first == __value_)             ++__r;      return __r;  }   // count_if
 template <class _InputIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY typename iterator_traits<_InputIterator>::difference_type count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {      typename iterator_traits<_InputIterator>::difference_type __r(0);      for (;  __first != __last;  ++__first)         if (__pred(*__first))             ++__r;      return __r;  }   // mismatch
 template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1,          _InputIterator2 __first2, _BinaryPredicate __pred) {      for (;  __first1 != __last1;  ++__first1, (void) ++__first2)         if (!__pred(*__first1, *__first2))             break;      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);  }   template <class _InputIterator1, class _InputIterator2> inline _LIBCPP_INLINE_VISIBILITY pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {      typedef typename iterator_traits<_InputIterator1>::value_type __v1;      typedef typename iterator_traits<_InputIterator2>::value_type __v2;      return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());  }     
#if _LIBCPP_STD_VER > 11
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1,          _InputIterator2 __first2, _InputIterator2 __last2,          _BinaryPredicate __pred) {      for (;  __first1 != __last1 && __first2 != __last2;  ++__first1, (void) ++__first2)         if (!__pred(*__first1, *__first2))             break;      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);  }   template <class _InputIterator1, class _InputIterator2> inline _LIBCPP_INLINE_VISIBILITY pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1,          _InputIterator2 __first2, _InputIterator2 __last2) {      typedef typename iterator_traits<_InputIterator1>::value_type __v1;      typedef typename iterator_traits<_InputIterator2>::value_type __v2;      return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());  }    
#endif
 // equal
 template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY bool equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {      for (;  __first1 != __last1;  ++__first1, (void) ++__first2)         if (!__pred(*__first1, *__first2))             return false;      return true;  }   template <class _InputIterator1, class _InputIterator2> inline _LIBCPP_INLINE_VISIBILITY bool equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {      typedef typename iterator_traits<_InputIterator1>::value_type __v1;      typedef typename iterator_traits<_InputIterator2>::value_type __v2;      return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());  }     
#if _LIBCPP_STD_VER > 11
template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2> inline _LIBCPP_INLINE_VISIBILITY bool __equal(_InputIterator1 __first1, _InputIterator1 __last1,         _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,         input_iterator_tag, input_iterator_tag ) {      for (;  __first1 != __last1 && __first2 != __last2;  ++__first1, (void) ++__first2)         if (!__pred(*__first1, *__first2))             return false;      return __first1 == __last1 && __first2 == __last2;  }   template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2> inline _LIBCPP_INLINE_VISIBILITY bool __equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,       random_access_iterator_tag, random_access_iterator_tag ) {      if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))         return false;      return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,                         typename add_lvalue_reference<_BinaryPredicate>::type>                        (__first1, __last1, __first2, __pred );  }   template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY bool equal(_InputIterator1 __first1, _InputIterator1 __last1,       _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred ) {      return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>        (__first1, __last1, __first2, __last2, __pred,         typename iterator_traits<_InputIterator1>::iterator_category(),         typename iterator_traits<_InputIterator2>::iterator_category());  }   template <class _InputIterator1, class _InputIterator2> inline _LIBCPP_INLINE_VISIBILITY bool equal(_InputIterator1 __first1, _InputIterator1 __last1,       _InputIterator2 __first2, _InputIterator2 __last2) {      typedef typename iterator_traits<_InputIterator1>::value_type __v1;      typedef typename iterator_traits<_InputIterator2>::value_type __v2;      return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),         typename iterator_traits<_InputIterator1>::iterator_category(),         typename iterator_traits<_InputIterator2>::iterator_category());  }    
#endif
 // is_permutation
 template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,                _ForwardIterator2 __first2, _BinaryPredicate __pred) {      // shorten sequences as much as possible by lopping of any equal parts
    for (;  __first1 != __last1;  ++__first1, (void) ++__first2)         if (!__pred(*__first1, *__first2))             goto __not_done;      return true;  __not_done:     // __first1 != __last1 && *__first1 != *__first2
    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;      _D1 __l1 = _VSTD::distance(__first1, __last1);      if (__l1 == _D1(1))         return false;      _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);      // For each element in [f1, l1) see if there are the same number of
    //    equal elements in [f2, l2)
    for (_ForwardIterator1 __i = __first1;  __i != __last1;  ++__i)     {          // Have we already counted the number of *__i in [f1, l1)?
        for (_ForwardIterator1 __j = __first1;  __j != __i;  ++__j)             if (__pred(*__j, *__i))                 goto __next_iter;          {              // Count number of *__i in [f2, l2)
            _D1 __c2 = 0;              for (_ForwardIterator2 __j = __first2;  __j != __last2;  ++__j)                 if (__pred(*__i, *__j))                     ++__c2;              if (__c2 == 0)                 return false;              // Count number of *__i in [__i, l1) (we can start with 1)
            _D1 __c1 = 1;              for (_ForwardIterator1 __j = _VSTD::next(__i);  __j != __last1;  ++__j)                 if (__pred(*__i, *__j))                     ++__c1;              if (__c1 != __c2)                 return false;          }  __next_iter:;      }      return true;  }   template<class _ForwardIterator1, class _ForwardIterator2> inline _LIBCPP_INLINE_VISIBILITY bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,                _ForwardIterator2 __first2) {      typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;      typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;      return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());  }     
#if _LIBCPP_STD_VER > 11
template<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2> bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,                  _ForwardIterator2 __first2, _ForwardIterator2 __last2,                  _BinaryPredicate __pred,                  forward_iterator_tag, forward_iterator_tag ) {      // shorten sequences as much as possible by lopping of any equal parts
    for (;  __first1 != __last1 && __first2 != __last2;  ++__first1, (void) ++__first2)         if (!__pred(*__first1, *__first2))             goto __not_done;      return __first1 == __last1 && __first2 == __last2;  __not_done:     // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2
    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;      _D1 __l1 = _VSTD::distance(__first1, __last1);       typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;      _D2 __l2 = _VSTD::distance(__first2, __last2);      if (__l1 != __l2)         return false;       // For each element in [f1, l1) see if there are the same number of
    //    equal elements in [f2, l2)
    for (_ForwardIterator1 __i = __first1;  __i != __last1;  ++__i)     {          // Have we already counted the number of *__i in [f1, l1)?
        for (_ForwardIterator1 __j = __first1;  __j != __i;  ++__j)             if (__pred(*__j, *__i))                 goto __next_iter;          {              // Count number of *__i in [f2, l2)
            _D1 __c2 = 0;              for (_ForwardIterator2 __j = __first2;  __j != __last2;  ++__j)                 if (__pred(*__i, *__j))                     ++__c2;              if (__c2 == 0)                 return false;              // Count number of *__i in [__i, l1) (we can start with 1)
            _D1 __c1 = 1;              for (_ForwardIterator1 __j = _VSTD::next(__i);  __j != __last1;  ++__j)                 if (__pred(*__i, *__j))                     ++__c1;              if (__c1 != __c2)                 return false;          }  __next_iter:;      }      return true;  }   template<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2> bool __is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,                _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2,                _BinaryPredicate __pred,                random_access_iterator_tag, random_access_iterator_tag ) {      if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))         return false;      return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,                                  typename add_lvalue_reference<_BinaryPredicate>::type>                                 (__first1, __last1, __first2, __pred );  }   template<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,                _ForwardIterator2 __first2, _ForwardIterator2 __last2,                _BinaryPredicate __pred ) {      return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>        (__first1, __last1, __first2, __last2, __pred,         typename iterator_traits<_ForwardIterator1>::iterator_category(),         typename iterator_traits<_ForwardIterator2>::iterator_category());  }   template<class _ForwardIterator1, class _ForwardIterator2> inline _LIBCPP_INLINE_VISIBILITY bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,                _ForwardIterator2 __first2, _ForwardIterator2 __last2) {      typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;      typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;      return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,         __equal_to<__v1, __v2>(),         typename iterator_traits<_ForwardIterator1>::iterator_category(),         typename iterator_traits<_ForwardIterator2>::iterator_category());  }    
#endif
 // search
 template <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2> pair<_ForwardIterator1, _ForwardIterator1> __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,          _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,          forward_iterator_tag, forward_iterator_tag) {      if (__first2 == __last2)         return make_pair(__first1, __first1);   // Everything matches an empty sequence
    while (true)     {          // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks
        while (true)         {              if (__first1 == __last1)  // return __last1 if no element matches *__first2
                return make_pair(__last1, __last1);              if (__pred(*__first1, *__first2))                 break;              ++__first1;          }          // *__first1 matches *__first2, now match elements after here
        _ForwardIterator1 __m1 = __first1;          _ForwardIterator2 __m2 = __first2;          while (true)         {              if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)
                return make_pair(__first1, __m1);              if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found
                return make_pair(__last1, __last1);              if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1
            {                 ++__first1;                 break;             }   // else there is a match, check next elements
        }      }  }   template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2> _LIBCPP_CONSTEXPR_AFTER_CXX11 pair<_RandomAccessIterator1, _RandomAccessIterator1> __search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,          _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,            random_access_iterator_tag, random_access_iterator_tag) {      typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;      typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;      // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern
    const _D2 __len2 = __last2 - __first2;      if (__len2 == 0)         return make_pair(__first1, __first1);      const _D1 __len1 = __last1 - __first1;      if (__len1 < __len2)         return make_pair(__last1, __last1);      const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);   // Start of pattern match can't go beyond here
     while (true)     {          while (true)         {              if (__first1 == __s)                 return make_pair(__last1, __last1);              if (__pred(*__first1, *__first2))                 break;              ++__first1;          }           _RandomAccessIterator1 __m1 = __first1;          _RandomAccessIterator2 __m2 = __first2;           while (true)          {               if (++__m2 == __last2)                  return make_pair(__first1, __first1 + __len2);               ++__m1;           // no need to check range on __m1 because __s guarantees we have enough source
             if (!__pred(*__m1, *__m2))              {                  ++__first1;                  break;              }           }      }  }   template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,        _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred) {      return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>                          (__first1, __last1, __first2, __last2, __pred,                           typename iterator_traits<_ForwardIterator1>::iterator_category(),                           typename iterator_traits<_ForwardIterator2>::iterator_category())             .first;  }   template <class _ForwardIterator1, class _ForwardIterator2> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,        _ForwardIterator2 __first2, _ForwardIterator2 __last2) {      typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;      typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;      return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());  }   // search_n
 template <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp> _ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last,            _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag) {      if (__count <= 0)         return __first;      while (true)     {          // Find first element in sequence that matchs __value_, with a mininum of loop checks
        while (true)         {              if (__first == __last)  // return __last if no element matches __value_
                return __last;              if (__pred(*__first, __value_))                 break;              ++__first;          }          // *__first matches __value_, now match elements after here
        _ForwardIterator __m = __first;          _Size __c(0);          while (true)         {              if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)
                return __first;              if (++__m == __last)  // Otherwise if source exhaused, pattern not found
                return __last;              if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first
            {                 __first = __m;                 ++__first;                 break;             }   // else there is a match, check next elements
        }      }  }   template <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp> _RandomAccessIterator __search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,            _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag) {      if (__count <= 0)         return __first;      _Size __len = static_cast<_Size>(__last - __first);      if (__len < __count)         return __last;      const _RandomAccessIterator __s = __last - (__count - 1);   // Start of pattern match can't go beyond here
    while (true)     {          // Find first element in sequence that matchs __value_, with a mininum of loop checks
        while (true)         {              if (__first >= __s)  // return __last if no element matches __value_
                return __last;              if (__pred(*__first, __value_))                 break;              ++__first;          }          // *__first matches __value_, now match elements after here
        _RandomAccessIterator __m = __first;          _Size __c(0);          while (true)         {              if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)
                return __first;               ++__m;           // no need to check range on __m because __s guarantees we have enough source
            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first
            {                 __first = __m;                 ++__first;                 break;             }   // else there is a match, check next elements
        }      }  }   template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last,          _Size __count, const _Tp& __value_, _BinaryPredicate __pred) {      return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>            (__first, __last, __convert_to_integral(__count), __value_, __pred,            typename iterator_traits<_ForwardIterator>::iterator_category());  }   template <class _ForwardIterator, class _Size, class _Tp> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_) {      typedef typename iterator_traits<_ForwardIterator>::value_type __v;      return _VSTD::search_n(__first, __last, __convert_to_integral(__count),                            __value_, __equal_to<__v, _Tp>());  }   // copy
template <class _Iter> inline _LIBCPP_INLINE_VISIBILITY _Iter __unwrap_iter(_Iter __i) {      return __i;  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_trivially_copy_assignable<_Tp>::value,     _Tp* >::type __unwrap_iter(move_iterator<_Tp*> __i) {      return __i.base();  }     
#if _LIBCPP_DEBUG_LEVEL < 2
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_trivially_copy_assignable<_Tp>::value,     _Tp* >::type __unwrap_iter(__wrap_iter<_Tp*> __i) {      return __i.base();  }     
#else
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_trivially_copy_assignable<_Tp>::value,     __wrap_iter<_Tp*> >::type __unwrap_iter(__wrap_iter<_Tp*> __i) {      return __i;  }     
#endif  // _LIBCPP_DEBUG_LEVEL < 2
 template <class _InputIterator, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator __copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {      for (;  __first != __last;  ++__first, (void) ++__result)         *__result = *__first;      return __result;  }   template <class _Tp, class _Up> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_same<typename remove_const<_Tp>::type, _Up>::value &&     is_trivially_copy_assignable<_Up>::value,     _Up* >::type __copy(_Tp* __first, _Tp* __last, _Up* __result) {      const size_t __n = static_cast<size_t>(__last - __first);      if (__n > 0)         _VSTD::memmove(__result, __first, __n * sizeof(_Up));      return __result + __n;  }   template <class _InputIterator, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {      return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));  }   // copy_backward
 template <class _BidirectionalIterator, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator __copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result) {      while (__first != __last)         *--__result = *--__last;      return __result;  }   template <class _Tp, class _Up> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_same<typename remove_const<_Tp>::type, _Up>::value &&     is_trivially_copy_assignable<_Up>::value,     _Up* >::type __copy_backward(_Tp* __first, _Tp* __last, _Up* __result) {      const size_t __n = static_cast<size_t>(__last - __first);      if (__n > 0)     {          __result -= __n;          _VSTD::memmove(__result, __first, __n * sizeof(_Up));      }      return __result;  }   template <class _BidirectionalIterator1, class _BidirectionalIterator2> inline _LIBCPP_INLINE_VISIBILITY _BidirectionalIterator2 copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,               _BidirectionalIterator2 __result) {      return _VSTD::__copy_backward(__unwrap_iter(__first),                                   __unwrap_iter(__last),                                   __unwrap_iter(__result));  }   // copy_if
 template<class _InputIterator, class _OutputIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator copy_if(_InputIterator __first, _InputIterator __last,         _OutputIterator __result, _Predicate __pred) {      for (;  __first != __last;  ++__first)     {          if (__pred(*__first))         {              *__result = *__first;              ++__result;          }      }      return __result;  }   // copy_n
 template<class _InputIterator, class _Size, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     __is_input_iterator<_InputIterator>::value &&    !__is_random_access_iterator<_InputIterator>::value,     _OutputIterator >::type copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {      typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;      _IntegralSize __n = __orig_n;      if (__n > 0)     {          *__result = *__first;          ++__result;          for (--__n;  __n > 0;  --__n)         {              ++__first;              *__result = *__first;              ++__result;          }      }      return __result;  }   template<class _InputIterator, class _Size, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     __is_random_access_iterator<_InputIterator>::value,     _OutputIterator >::type copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {      typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;      _IntegralSize __n = __orig_n;      return _VSTD::copy(__first, __first + __n, __result);  }   // move
 template <class _InputIterator, class _OutputIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_) {      for (;  __first != __last;  ++__first)     {          if (!(*__first == __value_))         {              *__result = *__first;              ++__result;          }      }      return __result;  }   // remove_copy_if
 template <class _InputIterator, class _OutputIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred) {      for (;  __first != __last;  ++__first)     {          if (!__pred(*__first))         {              *__result = *__first;              ++__result;          }      }      return __result;  }   // unique
 template <class _ForwardIterator, class _BinaryPredicate> _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {      __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>                                  (__first, __last, __pred);      if (__first != __last)     {          // ...  a  a  ?  ...
        //      f     i
        _ForwardIterator __i = __first;          for (++__i;  ++__i != __last; )             if (!__pred(*__first, *__i))                 *++__first = _VSTD::move(*__i);          ++__first;      }      return __first;  }   template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last) {      typedef typename iterator_traits<_ForwardIterator>::value_type __v;      return _VSTD::unique(__first, __last, __equal_to<__v>());  }   // unique_copy
 template <class _BinaryPredicate, class _InputIterator, class _OutputIterator> _OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,               input_iterator_tag, output_iterator_tag) {      if (__first != __last)     {          typename iterator_traits<_InputIterator>::value_type __t(*__first);          *__result = __t;          ++__result;          while (++__first != __last)         {              if (!__pred(__t, *__first))             {                 __t = *__first;                 *__result = __t;                 ++__result;             }          }      }      return __result;  }   template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator> _OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,               forward_iterator_tag, output_iterator_tag) {      if (__first != __last)     {          _ForwardIterator __i = __first;          *__result = *__i;          ++__result;          while (++__first != __last)         {              if (!__pred(*__i, *__first))             {                 *__result = *__first;                 ++__result;                 __i = __first;             }          }      }      return __result;  }   template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator> _ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,               input_iterator_tag, forward_iterator_tag) {      if (__first != __last)     {          *__result = *__first;          while (++__first != __last)             if (!__pred(*__result, *__first))                 *++__result = *__first;          ++__result;      }      return __result;  }   template <class _InputIterator, class _OutputIterator, class _BinaryPredicate> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred) {      return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>                               (__first, __last, __result, __pred,                                typename iterator_traits<_InputIterator>::iterator_category(),                                typename iterator_traits<_OutputIterator>::iterator_category());  }   template <class _InputIterator, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {      typedef typename iterator_traits<_InputIterator>::value_type __v;      return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());  }   // reverse
 template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY void __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag) {      while (__first != __last)     {          if (__first == --__last)             break;          _VSTD::iter_swap(__first, __last);          ++__first;      }  }   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag) {      if (__first != __last)         for (;  __first < --__last;  ++__first)             _VSTD::iter_swap(__first, __last);  }   template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY void reverse(_BidirectionalIterator __first, _BidirectionalIterator __last) {      _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());  }   // reverse_copy
 template <class _BidirectionalIterator, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result) {      for (;  __first != __last;  ++__result)         *__result = *--__last;      return __result;  }   // rotate
 template <class _ForwardIterator> _ForwardIterator __rotate_left(_ForwardIterator __first, _ForwardIterator __last) {      typedef typename iterator_traits<_ForwardIterator>::value_type value_type;      value_type __tmp = _VSTD::move(*__first);      _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);      *__lm1 = _VSTD::move(__tmp);      return __lm1;  }   template <class _BidirectionalIterator> _BidirectionalIterator __rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last) {      typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;      _BidirectionalIterator __lm1 = _VSTD::prev(__last);      value_type __tmp = _VSTD::move(*__lm1);      _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);      *__first = _VSTD::move(__tmp);      return __fp1;  }   template <class _ForwardIterator> _ForwardIterator __rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last) {      _ForwardIterator __i = __middle;      while (true)     {          swap(*__first, *__i);          ++__first;          if (++__i == __last)             break;          if (__first == __middle)             __middle = __i;      }      _ForwardIterator __r = __first;      if (__first != __middle)     {          __i = __middle;          while (true)         {              swap(*__first, *__i);              ++__first;              if (++__i == __last)             {                 if (__first == __middle)                     break;                 __i = __middle;             }              else if (__first == __middle)                 __middle = __i;          }      }      return __r;  }   template<typename _Integral> inline _LIBCPP_INLINE_VISIBILITY _Integral __algo_gcd(_Integral __x, _Integral __y) {      do     {          _Integral __t = __x % __y;          __x = __y;          __y = __t;      }  while (__y);      return __x;  }   template<typename _RandomAccessIterator> _RandomAccessIterator __rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last) {      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;       const difference_type __m1 = __middle - __first;      const difference_type __m2 = __last - __middle;      if (__m1 == __m2)     {          _VSTD::swap_ranges(__first, __middle, __middle);          return __middle;      }      const difference_type __g = _VSTD::__algo_gcd(__m1, __m2);      for (_RandomAccessIterator __p = __first + __g;  __p != __first; )     {          value_type __t(_VSTD::move(*--__p));          _RandomAccessIterator __p1 = __p;          _RandomAccessIterator __p2 = __p1 + __m1;          do         {              *__p1 = _VSTD::move(*__p2);              __p1 = __p2;              const difference_type __d = __last - __p2;              if (__m1 < __d)                 __p2 += __m1;              else                 __p2 = __first + (__m1 - __d);          }  while (__p2 != __p);          *__p1 = _VSTD::move(__t);      }      return __first + __m2;  }   template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator __rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,          _VSTD::forward_iterator_tag) {      typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;      if (_VSTD::is_trivially_move_assignable<value_type>::value)     {          if (_VSTD::next(__first) == __middle)             return _VSTD::__rotate_left(__first, __last);      }      return _VSTD::__rotate_forward(__first, __middle, __last);  }   template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY _BidirectionalIterator __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,          _VSTD::bidirectional_iterator_tag) {      typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;      if (_VSTD::is_trivially_move_assignable<value_type>::value)     {          if (_VSTD::next(__first) == __middle)             return _VSTD::__rotate_left(__first, __last);          if (_VSTD::next(__middle) == __last)             return _VSTD::__rotate_right(__first, __last);      }      return _VSTD::__rotate_forward(__first, __middle, __last);  }   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY _RandomAccessIterator __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,          _VSTD::random_access_iterator_tag) {      typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;      if (_VSTD::is_trivially_move_assignable<value_type>::value)     {          if (_VSTD::next(__first) == __middle)             return _VSTD::__rotate_left(__first, __last);          if (_VSTD::next(__middle) == __last)             return _VSTD::__rotate_right(__first, __last);          return _VSTD::__rotate_gcd(__first, __middle, __last);      }      return _VSTD::__rotate_forward(__first, __middle, __last);  }   template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last) {      if (__first == __middle)         return __last;      if (__middle == __last)         return __first;      return _VSTD::__rotate(__first, __middle, __last,                            typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());  }   // rotate_copy
 template <class _ForwardIterator, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result) {      return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));  }   // min_element
 template <class _ForwardIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {      if (__first != __last)     {          _ForwardIterator __i = __first;          while (++__i != __last)             if (__comp(*__i, *__first))                 __first = __i;      }      return __first;  }   template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator min_element(_ForwardIterator __first, _ForwardIterator __last) {      return _VSTD::min_element(__first, __last,               __less<typename iterator_traits<_ForwardIterator>::value_type>());  }   // min
 template <class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Tp& min(const _Tp& __a, const _Tp& __b, _Compare __comp) {      return __comp(__b, __a) ? __b : __a;  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Tp& min(const _Tp& __a, const _Tp& __b) {      return _VSTD::min(__a, __b, __less<_Tp>());  }     
#ifndef _LIBCPP_CXX03_LANG
 template<class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp min(initializer_list<_Tp> __t, _Compare __comp) {      return *_VSTD::min_element(__t.begin(), __t.end(), __comp);  }   template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp min(initializer_list<_Tp> __t) {      return *_VSTD::min_element(__t.begin(), __t.end(), __less<_Tp>());  }     
#endif  // _LIBCPP_CXX03_LANG
 // max_element
 template <class _ForwardIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {      if (__first != __last)     {          _ForwardIterator __i = __first;          while (++__i != __last)             if (__comp(*__first, *__i))                 __first = __i;      }      return __first;  }    template <class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator max_element(_ForwardIterator __first, _ForwardIterator __last) {      return _VSTD::max_element(__first, __last,               __less<typename iterator_traits<_ForwardIterator>::value_type>());  }   // max
 template <class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Tp& max(const _Tp& __a, const _Tp& __b, _Compare __comp) {      return __comp(__a, __b) ? __b : __a;  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Tp& max(const _Tp& __a, const _Tp& __b) {      return _VSTD::max(__a, __b, __less<_Tp>());  }     
#ifndef _LIBCPP_CXX03_LANG
 template<class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp max(initializer_list<_Tp> __t, _Compare __comp) {      return *_VSTD::max_element(__t.begin(), __t.end(), __comp);  }   template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp max(initializer_list<_Tp> __t) {      return *_VSTD::max_element(__t.begin(), __t.end(), __less<_Tp>());  }     
#endif  // _LIBCPP_CXX03_LANG
   
#if _LIBCPP_STD_VER > 14
#endif  // _LIBCPP_CXX03_LANG
 // random_shuffle
 // __independent_bits_engine
 template <unsigned long long _Xp, size_t _Rp> struct __log2_imp {      static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp                                            : __log2_imp<_Xp, _Rp - 1>::value;  };   template <unsigned long long _Xp> struct __log2_imp<_Xp, 0> {      static const size_t value = 0;  };   template <size_t _Rp> struct __log2_imp<0, _Rp> {      static const size_t value = _Rp + 1;  };   template <class _UIntType, _UIntType _Xp> struct __log2 {      static const size_t value = __log2_imp<_Xp,                                          sizeof(_UIntType) * __CHAR_BIT__ - 1>::value;  };   template<class _Engine, class _UIntType> class __independent_bits_engine {  public:     // types
    typedef _UIntType result_type;   private:     typedef typename _Engine::result_type _Engine_result_type;      typedef typename conditional         <             sizeof(_Engine_result_type) <= sizeof(result_type),                 result_type,                 _Engine_result_type         >::type _Working_result_type;       _Engine& __e_;      size_t __w_;      size_t __w0_;      size_t __n_;      size_t __n0_;      _Working_result_type __y0_;      _Working_result_type __y1_;      _Engine_result_type __mask0_;      _Engine_result_type __mask1_;     
#ifdef _LIBCPP_CXX03_LANG
    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min                                           + _Working_result_type(1);    
#else
    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()                                                       + _Working_result_type(1);    
#endif
    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;      static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;      static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;   public:     // constructors and seeding functions
    __independent_bits_engine(_Engine& __e, size_t __w);       // generating functions
    result_type operator()() { return __eval(integral_constant<bool, _Rp != 0>()); }   private:     result_type __eval(false_type);      result_type __eval(true_type);  };   template<class _Engine, class _UIntType> __independent_bits_engine<_Engine, _UIntType>     ::__independent_bits_engine(_Engine& __e, size_t __w)         : __e_(__e),           __w_(__w) {      __n_ = __w_ / __m + (__w_ % __m != 0);      __w0_ = __w_ / __n_;      if (_Rp == 0)         __y0_ = _Rp;      else if (__w0_ < _WDt)         __y0_ = (_Rp >> __w0_) << __w0_;      else         __y0_ = 0;      if (_Rp - __y0_ > __y0_ / __n_)     {          ++__n_;          __w0_ = __w_ / __n_;          if (__w0_ < _WDt)             __y0_ = (_Rp >> __w0_) << __w0_;          else             __y0_ = 0;      }      __n0_ = __n_ - __w_ % __n_;      if (__w0_ < _WDt - 1)         __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);      else         __y1_ = 0;      __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :                           _Engine_result_type(0);      __mask1_ = __w0_ < _EDt - 1 ?                                _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :                                _Engine_result_type(~0);  }   template<class _Engine, class _UIntType> inline _UIntType __independent_bits_engine<_Engine, _UIntType>::__eval(false_type) {      return static_cast<result_type>(__e_() & __mask0_);  }   template<class _Engine, class _UIntType> _UIntType __independent_bits_engine<_Engine, _UIntType>::__eval(true_type) {      result_type _Sp = 0;      for (size_t __k = 0;  __k < __n0_;  ++__k)     {          _Engine_result_type __u;          do         {              __u = __e_() - _Engine::min();          }  while (__u >= __y0_);          if (__w0_ < _WDt)             _Sp <<= __w0_;          else             _Sp = 0;          _Sp += __u & __mask0_;      }      for (size_t __k = __n0_;  __k < __n_;  ++__k)     {          _Engine_result_type __u;          do         {              __u = __e_() - _Engine::min();          }  while (__u >= __y1_);          if (__w0_ < _WDt - 1)             _Sp <<= __w0_ + 1;          else             _Sp = 0;          _Sp += __u & __mask1_;      }      return _Sp;  }   // uniform_int_distribution
 template<class _IntType = int> class uniform_int_distribution {  public:     // types
    typedef _IntType result_type;       class param_type     {          result_type __a_;          result_type __b_;      public:         typedef uniform_int_distribution distribution_type;           explicit param_type(result_type __a = 0,                             result_type __b = numeric_limits<result_type>::max())             : __a_(__a), __b_(__b) { }           result_type a() const { return __a_; }          result_type b() const { return __b_; }           friend bool operator==(const param_type& __x, const param_type& __y)             { return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_; }          friend bool operator!=(const param_type& __x, const param_type& __y)             { return !(__x == __y); }      };   private:     param_type __p_;   public:     // constructors and reset functions
    explicit uniform_int_distribution(result_type __a = 0,                                       result_type __b = numeric_limits<result_type>::max())         : __p_(param_type(__a, __b)) { }      explicit uniform_int_distribution(const param_type& __p) : __p_(__p) { }      void reset() { }       // generating functions
    template<class _URNG> result_type operator()(_URNG& __g)         { return (*this)(__g, __p_); }      template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);       // property functions
    result_type a() const { return __p_.a(); }      result_type b() const { return __p_.b(); }       param_type param() const { return __p_; }      void param(const param_type& __p) { __p_ = __p; }       result_type min() const { return a(); }      result_type max() const { return b(); }       friend bool operator==(const uniform_int_distribution& __x,                            const uniform_int_distribution& __y)         { return __x.__p_ == __y.__p_; }      friend bool operator!=(const uniform_int_distribution& __x,                            const uniform_int_distribution& __y)             { return !(__x == __y); }  };   template<class _IntType> template<class _URNG> typename uniform_int_distribution<_IntType>::result_type uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p) {      typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),                                             uint32_t, uint64_t>::type _UIntType;      const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);      if (_Rp == 1)         return __p.a();      const size_t _Dt = numeric_limits<_UIntType>::digits;      typedef __independent_bits_engine<_URNG, _UIntType> _Eng;      if (_Rp == 0)         return static_cast<result_type>(_Eng(__g, _Dt)());      size_t __w = _Dt - __clz(_Rp) - 1;      if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)         ++__w;      _Eng __e(__g, __w);      _UIntType __u;      do     {          __u = __e();      }  while (__u >= _Rp);      return static_cast<result_type>(__u + __p.a());  }     
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_RANDOM_SHUFFLE) \
  || defined(_LIBCPP_BUILDING_LIBRARY)
class _LIBCPP_TYPE_VIS __rs_default;   _LIBCPP_FUNC_VIS __rs_default __rs_get();   class _LIBCPP_TYPE_VIS __rs_default {      static unsigned __c_;       __rs_default();  public:     typedef uint_fast32_t result_type;       static const result_type _Min = 0;      static const result_type _Max = 0xFFFFFFFF;       __rs_default(const __rs_default&);      ~__rs_default();       result_type operator()();       static _LIBCPP_CONSTEXPR result_type min() { return _Min; }      static _LIBCPP_CONSTEXPR result_type max() { return _Max; }       friend _LIBCPP_FUNC_VIS __rs_default __rs_get();  };   _LIBCPP_FUNC_VIS __rs_default __rs_get();   template <class _RandomAccessIterator> void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last) {      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      typedef uniform_int_distribution<ptrdiff_t> _Dp;      typedef typename _Dp::param_type _Pp;      difference_type __d = __last - __first;      if (__d > 1)     {          _Dp __uid;          __rs_default __g = __rs_get();          for (--__last, --__d;  __first < __last;  ++__first, --__d)         {              difference_type __i = __uid(__g, _Pp(0, __d));              if (__i != difference_type(0))                 swap(*__first, *(__first + __i));          }      }  }   template <class _RandomAccessIterator, class _RandomNumberGenerator> void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,   
#ifndef _LIBCPP_CXX03_LANG
               _RandomNumberGenerator&& __rand)   
#else
               _RandomNumberGenerator& __rand)   
#endif
{      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      difference_type __d = __last - __first;      if (__d > 1)     {          for (--__last;  __first < __last;  ++__first, --__d)         {              difference_type __i = __rand(__d);              swap(*__first, *(__first + __i));          }      }  }    
#endif
 template <class _PopulationIterator, class _SampleIterator, class _Distance,           class _UniformRandomNumberGenerator> _LIBCPP_INLINE_VISIBILITY _SampleIterator __sample(_PopulationIterator __first,                          _PopulationIterator __last, _SampleIterator __output,                          _Distance __n,                          _UniformRandomNumberGenerator & __g,                          input_iterator_tag) {     _Distance __k = 0;    for (;  __first != __last && __k < __n;  ++__first, (void)++__k)     __output[__k] = *__first;    _Distance __sz = __k;    for (;  __first != __last;  ++__first, (void)++__k) {      _Distance __r = _VSTD::uniform_int_distribution<_Distance>(0, __k)(__g);      if (__r < __sz)       __output[__r] = *__first;    }    return __output + _VSTD::min(__n, __k);  }   template <class _PopulationIterator, class _SampleIterator, class _Distance,           class _UniformRandomNumberGenerator> _LIBCPP_INLINE_VISIBILITY _SampleIterator __sample(_PopulationIterator __first,                          _PopulationIterator __last, _SampleIterator __output,                          _Distance __n,                          _UniformRandomNumberGenerator& __g,                          forward_iterator_tag) {    _Distance __unsampled_sz = _VSTD::distance(__first, __last);    for (__n = _VSTD::min(__n, __unsampled_sz);  __n != 0;  ++__first) {      _Distance __r =         _VSTD::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);      if (__r < __n) {        *__output++ = *__first;        --__n;      }    }    return __output;  }   template <class _PopulationIterator, class _SampleIterator, class _Distance,           class _UniformRandomNumberGenerator> _LIBCPP_INLINE_VISIBILITY _SampleIterator __sample(_PopulationIterator __first,                          _PopulationIterator __last, _SampleIterator __output,                          _Distance __n, _UniformRandomNumberGenerator& __g) {    typedef typename iterator_traits<_PopulationIterator>::iterator_category         _PopCategory;    typedef typename iterator_traits<_PopulationIterator>::difference_type         _Difference;    static_assert(__is_forward_iterator<_PopulationIterator>::value ||                 __is_random_access_iterator<_SampleIterator>::value,                 "SampleIterator must meet the requirements of RandomAccessIterator");    typedef typename common_type<_Distance, _Difference>::type _CommonType;    _LIBCPP_ASSERT(__n >= 0, "N must be a positive number.");    return _VSTD::__sample(       __first, __last, __output, _CommonType(__n),       __g, _PopCategory());  }     
#if _LIBCPP_STD_VER > 14
template <class _PopulationIterator, class _SampleIterator, class _Distance,           class _UniformRandomNumberGenerator> inline _LIBCPP_INLINE_VISIBILITY _SampleIterator sample(_PopulationIterator __first,                        _PopulationIterator __last, _SampleIterator __output,                        _Distance __n, _UniformRandomNumberGenerator&& __g) {      return _VSTD::__sample(__first, __last, __output, __n, __g);  }    
#endif // _LIBCPP_STD_VER > 14
 template<class _RandomAccessIterator, class _UniformRandomNumberGenerator>     void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,   
#ifndef _LIBCPP_CXX03_LANG
                 _UniformRandomNumberGenerator&& __g)   
#else
                 _UniformRandomNumberGenerator& __g)   
#endif
{      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      typedef uniform_int_distribution<ptrdiff_t> _Dp;      typedef typename _Dp::param_type _Pp;      difference_type __d = __last - __first;      if (__d > 1)     {          _Dp __uid;          for (--__last, --__d;  __first < __last;  ++__first, --__d)         {              difference_type __i = __uid(__g, _Pp(0, __d));              if (__i != difference_type(0))                 swap(*__first, *(__first + __i));          }      }  }   template <class _InputIterator, class _Predicate> bool is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred) {      for (;  __first != __last;  ++__first)         if (!__pred(*__first))             break;      if ( __first == __last )         return true;      ++__first;      for (;  __first != __last;  ++__first)         if (__pred(*__first))             return false;      return true;  }   // partition
 template <class _Predicate, class _ForwardIterator> _ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag) {      while (true)     {          if (__first == __last)             return __first;          if (!__pred(*__first))             break;          ++__first;      }      for (_ForwardIterator __p = __first;  ++__p != __last; )     {          if (__pred(*__p))         {              swap(*__first, *__p);              ++__first;          }      }      return __first;  }   template <class _Predicate, class _BidirectionalIterator> _BidirectionalIterator __partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,             bidirectional_iterator_tag) {      while (true)     {          while (true)         {              if (__first == __last)                 return __first;              if (!__pred(*__first))                 break;              ++__first;          }          do         {              if (__first == --__last)                 return __first;          }  while (!__pred(*__last));          swap(*__first, *__last);          ++__first;      }  }   template <class _ForwardIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {      return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());  }   // partition_copy
 template <class _InputIterator, class _OutputIterator1,           class _OutputIterator2, class _Predicate> pair<_OutputIterator1, _OutputIterator2> partition_copy(_InputIterator __first, _InputIterator __last,                _OutputIterator1 __out_true, _OutputIterator2 __out_false,                _Predicate __pred) {      for (;  __first != __last;  ++__first)     {          if (__pred(*__first))         {              *__out_true = *__first;              ++__out_true;          }          else         {              *__out_false = *__first;              ++__out_false;          }      }      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);  }   // partition_point
 template<class _ForwardIterator, class _Predicate> _ForwardIterator partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {      typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;      difference_type __len = _VSTD::distance(__first, __last);      while (__len != 0)     {          difference_type __l2 = __len / 2;          _ForwardIterator __m = __first;          _VSTD::advance(__m, __l2);          if (__pred(*__m))         {              __first = ++__m;              __len -= __l2 + 1;          }          else             __len = __l2;      }      return __first;  }   // stable_partition
 template <class _Predicate, class _ForwardIterator, class _Distance, class _Pair> _ForwardIterator __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,                    _Distance __len, _Pair __p, forward_iterator_tag __fit) {      // *__first is known to be false
    // __len >= 1
    if (__len == 1)         return __first;      if (__len == 2)     {          _ForwardIterator __m = __first;          if (__pred(*++__m))         {              swap(*__first, *__m);              return __m;          }          return __first;      }      if (__len <= __p.second)     {    // The buffer is big enough to use
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;          __destruct_n __d(0);          unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);          // Move the falses into the temporary buffer, and the trues to the front of the line
        // Update __first to always point to the end of the trues
        value_type* __t = __p.first;          ::new(__t) value_type(_VSTD::move(*__first));          __d.__incr((value_type*)0);          ++__t;          _ForwardIterator __i = __first;          while (++__i != __last)         {              if (__pred(*__i))             {                 *__first = _VSTD::move(*__i);                 ++__first;             }              else             {                 ::new(__t) value_type(_VSTD::move(*__i));                 __d.__incr((value_type*)0);                 ++__t;             }          }          // All trues now at start of range, all falses in buffer
        // Move falses back into range, but don't mess up __first which points to first false
        __i = __first;          for (value_type* __t2 = __p.first;  __t2 < __t;  ++__t2, ++__i)             *__i = _VSTD::move(*__t2);          // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer
        return __first;      }      // Else not enough buffer, do in place
    // __len >= 3
    _ForwardIterator __m = __first;      _Distance __len2 = __len / 2;   // __len2 >= 2
    _VSTD::advance(__m, __len2);      // recurse on [__first, __m), *__first know to be false
    // F?????????????????
    // f       m         l
    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;      _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);      // TTTFFFFF??????????
    // f  ff   m         l
    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true
    _ForwardIterator __m1 = __m;      _ForwardIterator __second_false = __last;      _Distance __len_half = __len - __len2;      while (__pred(*__m1))     {          if (++__m1 == __last)             goto __second_half_done;          --__len_half;      }      // TTTFFFFFTTTF??????
    // f  ff   m  m1     l
    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);  __second_half_done:     // TTTFFFFFTTTTTFFFFF
    // f  ff   m    sf   l
    return _VSTD::rotate(__first_false, __m, __second_false);      // TTTTTTTTFFFFFFFFFF
    //         |
}   struct __return_temporary_buffer {      template <class _Tp>     _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const { _VSTD::return_temporary_buffer(__p); }  };   template <class _Predicate, class _ForwardIterator> _ForwardIterator __stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,                    forward_iterator_tag) {      const unsigned __alloc_limit = 3;   // might want to make this a function of trivial assignment
    // Either prove all true and return __first or point to first false
    while (true)     {          if (__first == __last)             return __first;          if (!__pred(*__first))             break;          ++__first;      }      // We now have a reduced range [__first, __last)
    // *__first is known to be false
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;      typedef typename iterator_traits<_ForwardIterator>::value_type value_type;      difference_type __len = _VSTD::distance(__first, __last);      pair<value_type*, ptrdiff_t> __p(0, 0);      unique_ptr<value_type, __return_temporary_buffer> __h;      if (__len >= __alloc_limit)     {          __p = _VSTD::get_temporary_buffer<value_type>(__len);          __h.reset(__p.first);      }      return __stable_partition<typename add_lvalue_reference<_Predicate>::type>                              (__first, __last, __pred, __len, __p, forward_iterator_tag());  }   template <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair> _BidirectionalIterator __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,                    _Distance __len, _Pair __p, bidirectional_iterator_tag __bit) {      // *__first is known to be false
    // *__last is known to be true
    // __len >= 2
    if (__len == 2)     {          swap(*__first, *__last);          return __last;      }      if (__len == 3)     {          _BidirectionalIterator __m = __first;          if (__pred(*++__m))         {              swap(*__first, *__m);              swap(*__m, *__last);              return __last;          }          swap(*__m, *__last);          swap(*__first, *__m);          return __m;      }      if (__len <= __p.second)     {    // The buffer is big enough to use
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;          __destruct_n __d(0);          unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);          // Move the falses into the temporary buffer, and the trues to the front of the line
        // Update __first to always point to the end of the trues
        value_type* __t = __p.first;          ::new(__t) value_type(_VSTD::move(*__first));          __d.__incr((value_type*)0);          ++__t;          _BidirectionalIterator __i = __first;          while (++__i != __last)         {              if (__pred(*__i))             {                 *__first = _VSTD::move(*__i);                 ++__first;             }              else             {                 ::new(__t) value_type(_VSTD::move(*__i));                 __d.__incr((value_type*)0);                 ++__t;             }          }          // move *__last, known to be true
        *__first = _VSTD::move(*__i);          __i = ++__first;          // All trues now at start of range, all falses in buffer
        // Move falses back into range, but don't mess up __first which points to first false
        for (value_type* __t2 = __p.first;  __t2 < __t;  ++__t2, ++__i)             *__i = _VSTD::move(*__t2);          // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer
        return __first;      }      // Else not enough buffer, do in place
    // __len >= 4
    _BidirectionalIterator __m = __first;      _Distance __len2 = __len / 2;   // __len2 >= 2
    _VSTD::advance(__m, __len2);      // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false
    // F????????????????T
    // f       m        l
    _BidirectionalIterator __m1 = __m;      _BidirectionalIterator __first_false = __first;      _Distance __len_half = __len2;      while (!__pred(*--__m1))     {          if (__m1 == __first)             goto __first_half_done;          --__len_half;      }      // F???TFFF?????????T
    // f   m1  m        l
    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;      __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);  __first_half_done:     // TTTFFFFF?????????T
    // f  ff   m        l
    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true
    __m1 = __m;      _BidirectionalIterator __second_false = __last;      ++__second_false;      __len_half = __len - __len2;      while (__pred(*__m1))     {          if (++__m1 == __last)             goto __second_half_done;          --__len_half;      }      // TTTFFFFFTTTF?????T
    // f  ff   m  m1    l
    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);  __second_half_done:     // TTTFFFFFTTTTTFFFFF
    // f  ff   m    sf  l
    return _VSTD::rotate(__first_false, __m, __second_false);      // TTTTTTTTFFFFFFFFFF
    //         |
}   template <class _Predicate, class _BidirectionalIterator> _BidirectionalIterator __stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,                    bidirectional_iterator_tag) {      typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;      typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;      const difference_type __alloc_limit = 4;   // might want to make this a function of trivial assignment
    // Either prove all true and return __first or point to first false
    while (true)     {          if (__first == __last)             return __first;          if (!__pred(*__first))             break;          ++__first;      }      // __first points to first false, everything prior to __first is already set.
    // Either prove [__first, __last) is all false and return __first, or point __last to last true
    do     {          if (__first == --__last)             return __first;      }  while (!__pred(*__last));      // We now have a reduced range [__first, __last]
    // *__first is known to be false
    // *__last is known to be true
    // __len >= 2
    difference_type __len = _VSTD::distance(__first, __last) + 1;      pair<value_type*, ptrdiff_t> __p(0, 0);      unique_ptr<value_type, __return_temporary_buffer> __h;      if (__len >= __alloc_limit)     {          __p = _VSTD::get_temporary_buffer<value_type>(__len);          __h.reset(__p.first);      }      return __stable_partition<typename add_lvalue_reference<_Predicate>::type>                              (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());  }   template <class _ForwardIterator, class _Predicate> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {      return __stable_partition<typename add_lvalue_reference<_Predicate>::type>                              (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());  }   // is_sorted_until
 template <class _ForwardIterator, class _Compare> _ForwardIterator is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {      if (__first != __last)     {          _ForwardIterator __i = __first;          while (++__i != __last)         {              if (__comp(*__i, *__first))                 return __i;              __first = __i;          }      }      return __last;  }   template<class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator is_sorted_until(_ForwardIterator __first, _ForwardIterator __last) {      return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());  }   // is_sorted
 template <class _ForwardIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {      return _VSTD::is_sorted_until(__first, __last, __comp) == __last;  }   template<class _ForwardIterator> inline _LIBCPP_INLINE_VISIBILITY bool is_sorted(_ForwardIterator __first, _ForwardIterator __last) {      return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());  }   // sort
 // stable, 2-3 compares, 0-2 swaps
 template <class _Compare, class _ForwardIterator> unsigned __sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c) {      unsigned __r = 0;      if (!__c(*__y, *__x))          // if x <= y
    {          if (!__c(*__z, *__y))      // if y <= z
            return __r;             // x <= y && y <= z
                                   // x <= y && y > z
        swap(*__y, *__z);           // x <= z && y < z
        __r = 1;          if (__c(*__y, *__x))       // if x > y
        {              swap(*__x, *__y);       // x < y && y <= z
            __r = 2;          }          return __r;                 // x <= y && y < z
    }      if (__c(*__z, *__y))           // x > y, if y > z
    {          swap(*__x, *__z);           // x < y && y < z
        __r = 1;          return __r;      }      swap(*__x, *__y);               // x > y && y <= z
    __r = 1;                        // x < y && x <= z
    if (__c(*__z, *__y))           // if y > z
    {          swap(*__y, *__z);           // x <= y && y < z
        __r = 2;      }      return __r;  }                                   // x <= y && y <= z
 // stable, 3-6 compares, 0-5 swaps
 template <class _Compare, class _ForwardIterator> unsigned __sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,             _ForwardIterator __x4, _Compare __c) {      unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);      if (__c(*__x4, *__x3))     {          swap(*__x3, *__x4);          ++__r;          if (__c(*__x3, *__x2))         {              swap(*__x2, *__x3);              ++__r;              if (__c(*__x2, *__x1))             {                 swap(*__x1, *__x2);                 ++__r;             }          }      }      return __r;  }   // stable, 4-10 compares, 0-9 swaps
 template <class _Compare, class _ForwardIterator> unsigned __sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,             _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c) {      unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);      if (__c(*__x5, *__x4))     {          swap(*__x4, *__x5);          ++__r;          if (__c(*__x4, *__x3))         {              swap(*__x3, *__x4);              ++__r;              if (__c(*__x3, *__x2))             {                 swap(*__x2, *__x3);                 ++__r;                 if (__c(*__x2, *__x1))                 {                     swap(*__x1, *__x2);                     ++__r;                 }             }          }      }      return __r;  }   // Assumes size > 0
template <class _Compare, class _BirdirectionalIterator> void __selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp) {      _BirdirectionalIterator __lm1 = __last;      for (--__lm1;  __first != __lm1;  ++__first)     {          _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,                                                         typename add_lvalue_reference<_Compare>::type>                                                        (__first, __last, __comp);          if (__i != __first)             swap(*__first, *__i);      }  }   template <class _Compare, class _BirdirectionalIterator> void __insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp) {      typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;      if (__first != __last)     {          _BirdirectionalIterator __i = __first;          for (++__i;  __i != __last;  ++__i)         {              _BirdirectionalIterator __j = __i;              value_type __t(_VSTD::move(*__j));              for (_BirdirectionalIterator __k = __i;  __k != __first && __comp(__t,  *--__k);  --__j)                 *__j = _VSTD::move(*__k);              *__j = _VSTD::move(__t);          }      }  }   template <class _Compare, class _RandomAccessIterator> void __insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;      _RandomAccessIterator __j = __first+2;      __sort3<_Compare>(__first, __first+1, __j, __comp);      for (_RandomAccessIterator __i = __j+1;  __i != __last;  ++__i)     {          if (__comp(*__i, *__j))         {              value_type __t(_VSTD::move(*__i));              _RandomAccessIterator __k = __j;              __j = __i;              do             {                 *__j = _VSTD::move(*__k);                 __j = __k;             }  while (__j != __first && __comp(__t, *--__k));              *__j = _VSTD::move(__t);          }          __j = __i;      }  }   template <class _Compare, class _RandomAccessIterator> bool __insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {      switch (__last - __first)     {      case 0:     case 1:         return true;      case 2:         if (__comp(*--__last, *__first))             swap(*__first, *__last);          return true;      case 3:         _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);          return true;      case 4:         _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);          return true;      case 5:         _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);          return true;      }      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;      _RandomAccessIterator __j = __first+2;      __sort3<_Compare>(__first, __first+1, __j, __comp);      const unsigned __limit = 8;      unsigned __count = 0;      for (_RandomAccessIterator __i = __j+1;  __i != __last;  ++__i)     {          if (__comp(*__i, *__j))         {              value_type __t(_VSTD::move(*__i));              _RandomAccessIterator __k = __j;              __j = __i;              do             {                 *__j = _VSTD::move(*__k);                 __j = __k;             }  while (__j != __first && __comp(__t, *--__k));              *__j = _VSTD::move(__t);              if (++__count == __limit)                 return ++__i == __last;          }          __j = __i;      }      return true;  }   template <class _Compare, class _BirdirectionalIterator> void __insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,                       typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp) {      typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;      if (__first1 != __last1)     {          __destruct_n __d(0);          unique_ptr<value_type, __destruct_n&> __h(__first2, __d);          value_type* __last2 = __first2;          ::new(__last2) value_type(_VSTD::move(*__first1));          __d.__incr((value_type*)0);          for (++__last2;  ++__first1 != __last1;  ++__last2)         {              value_type* __j2 = __last2;              value_type* __i2 = __j2;              if (__comp(*__first1, *--__i2))             {                 ::new(__j2) value_type(_VSTD::move(*__i2));                 __d.__incr((value_type*)0);                 for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)                     *__j2 = _VSTD::move(*__i2);                 *__j2 = _VSTD::move(*__first1);             }              else             {                 ::new(__j2) value_type(_VSTD::move(*__first1));                 __d.__incr((value_type*)0);             }          }          __h.release();      }  }   template <class _Compare, class _RandomAccessIterator> void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {      // _Compare is known to be a reference type
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;      const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&                                     is_trivially_copy_assignable<value_type>::value ? 30 : 6;      while (true)     {      __restart:         difference_type __len = __last - __first;          switch (__len)         {          case 0:         case 1:             return;          case 2:             if (__comp(*--__last, *__first))                 swap(*__first, *__last);              return;          case 3:             _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);              return;          case 4:             _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);              return;          case 5:             _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);              return;          }          if (__len <= __limit)         {              _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);              return;          }          // __len > 5
        _RandomAccessIterator __m = __first;          _RandomAccessIterator __lm1 = __last;          --__lm1;          unsigned __n_swaps;          {          difference_type __delta;          if (__len >= 1000)         {             __delta = __len/2;             __m += __delta;             __delta /= 2;             __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);         }          else         {             __delta = __len/2;             __m += __delta;             __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);         }          }          // *__m is median
        // partition [__first, __m) < *__m and *__m <= [__m, __last)
        // (this inhibits tossing elements equivalent to __m around unnecessarily)
        _RandomAccessIterator __i = __first;          _RandomAccessIterator __j = __lm1;          // j points beyond range to be tested, *__m is known to be <= *__lm1
        // The search going up is known to be guarded but the search coming down isn't.
        // Prime the downward search with a guard.
        if (!__comp(*__i, *__m))  // if *__first == *__m
        {              // *__first == *__m, *__first doesn't go in first part
            // manually guard downward moving __j against __i
            while (true)             {                 if (__i == --__j)                 {                     // *__first == *__m, *__m <= all other elements
                    __first = __i;                     goto __restart;                 }                 if (__comp(*__j, *__m))                 {                     swap(*__i, *__j);                     ++__n_swaps;                     break;  // found guard for downward moving __j, now use unguarded partition
                }             }          }          // It is known that *__i < *__m
        ++__i;          // j points beyond range to be tested, *__m is known to be <= *__lm1
        // if not yet partitioned...
        if (__i < __j)         {              // known that *(__i - 1) < *__m
            // known that __i <= __m
            while (true)             {                 // __m still guards upward moving __i
                while (__comp(*__i, *__m))                     ++__i;                 // It is now known that a guard exists for downward moving __j
                while (!__comp(*--__j, *__m))                     ;                 if (__i > __j)                     break;                 swap(*__i, *__j);                 ++__n_swaps;                 // It is known that __m != __j
                // If __m just moved, follow it
                if (__m == __i)                     __m = __j;                 ++__i;             }          }          // [__first, __i) < *__m and *__m <= [__i, __last)
        if (__i != __m && __comp(*__m, *__i))         {              swap(*__i, *__m);              ++__n_swaps;          }          // [__first, __i) < *__i and *__i <= [__i+1, __last)
        // If we were given a perfect partition, see if insertion sort is quick...
        if (__n_swaps == 0)         {              bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);              if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))             {                 if (__fs)                     return;                 __last = __i;                 continue;             }              else             {                 if (__fs)                 {                     __first = ++__i;                     continue;                 }             }          }          // sort smaller range with recursive call and larger with tail recursion elimination
        if (__i - __first < __last - __i)         {              _VSTD::__sort<_Compare>(__first, __i, __comp);              // _VSTD::__sort<_Compare>(__i+1, __last, __comp);
            __first = ++__i;          }          else         {              _VSTD::__sort<_Compare>(__i+1, __last, __comp);              // _VSTD::__sort<_Compare>(__first, __i, __comp);
            __last = __i;          }      }  }   // This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare
template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      __sort<_Comp_ref>(__first, __last, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      __sort<_Comp_ref>(__first, __last, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {      _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void sort(_Tp** __first, _Tp** __last) {      _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());  }   template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY void sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last) {      _VSTD::sort(__first.base(), __last.base());  }   template <class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void sort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp) {      typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);  }   _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))  _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&)) _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))  _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))  // lower_bound
 template <class _Compare, class _ForwardIterator, class _Tp> _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {      typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;      difference_type __len = _VSTD::distance(__first, __last);      while (__len != 0)     {          difference_type __l2 = __len / 2;          _ForwardIterator __m = __first;          _VSTD::advance(__m, __l2);          if (__comp(*__m, __value_))         {              __first = ++__m;              __len -= __l2 + 1;          }          else             __len = __l2;      }      return __first;  }   template <class _ForwardIterator, class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _ForwardIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_) {      return _VSTD::lower_bound(__first, __last, __value_,                              __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());  }   // upper_bound
 template <class _Compare, class _ForwardIterator, class _Tp> _ForwardIterator __upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {      typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;      difference_type __len = _VSTD::distance(__first, __last);      while (__len != 0)     {          difference_type __l2 = __len / 2;          _ForwardIterator __m = __first;          _VSTD::advance(__m, __l2);          if (__comp(__value_, *__m))             __len = __l2;          else         {              __first = ++__m;              __len -= __l2 + 1;          }      }      return __first;  }   template <class _ForwardIterator, class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _ForwardIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY _ForwardIterator upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_) {      return _VSTD::upper_bound(__first, __last, __value_,                              __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());  }   // equal_range
 template <class _Compare, class _ForwardIterator, class _Tp> pair<_ForwardIterator, _ForwardIterator> __equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {      typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;      difference_type __len = _VSTD::distance(__first, __last);      while (__len != 0)     {          difference_type __l2 = __len / 2;          _ForwardIterator __m = __first;          _VSTD::advance(__m, __l2);          if (__comp(*__m, __value_))         {              __first = ++__m;              __len -= __l2 + 1;          }          else if (__comp(__value_, *__m))         {              __last = __m;              __len = __l2;          }          else         {              _ForwardIterator __mp1 = __m;              return pair<_ForwardIterator, _ForwardIterator>                    (                       __lower_bound<_Compare>(__first, __m, __value_, __comp),                       __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)                    );          }      }      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);  }   template <class _ForwardIterator, class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __equal_range<_Comp_ref>(__first, __last, __value_, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _ForwardIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY pair<_ForwardIterator, _ForwardIterator> equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_) {      return _VSTD::equal_range(__first, __last, __value_,                              __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());  }   // binary_search
 template <class _Compare, class _ForwardIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool __binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {      __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);      return __first != __last && !__comp(__value_, *__first);  }   template <class _ForwardIterator, class _Tp, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __binary_search<_Comp_ref>(__first, __last, __value_, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _ForwardIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_) {      return _VSTD::binary_search(__first, __last, __value_,                              __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());  }   // merge
 template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __merge(_InputIterator1 __first1, _InputIterator1 __last1,         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {      for (;  __first1 != __last1;  ++__result)     {          if (__first2 == __last2)             return _VSTD::copy(__first1, __last1, __result);          if (__comp(*__first2, *__first1))         {              *__result = *__first2;              ++__first2;          }          else         {              *__result = *__first1;              ++__first1;          }      }      return _VSTD::copy(__first2, __last2, __result);  }   template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1,       _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator merge(_InputIterator1 __first1, _InputIterator1 __last1,       _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) {      typedef typename iterator_traits<_InputIterator1>::value_type __v1;      typedef typename iterator_traits<_InputIterator2>::value_type __v2;      return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());  }   // inplace_merge
 template <class _Compare, class _InputIterator1, class _InputIterator2,           class _OutputIterator> void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,                           _InputIterator2 __first2, _InputIterator2 __last2,                           _OutputIterator __result, _Compare __comp) {      for (;  __first1 != __last1;  ++__result)     {          if (__first2 == __last2)         {              _VSTD::move(__first1, __last1, __result);              return;          }           if (__comp(*__first2, *__first1))         {              *__result = _VSTD::move(*__first2);              ++__first2;          }          else         {              *__result = _VSTD::move(*__first1);              ++__first1;          }      }      // __first2 through __last2 are already in the right spot.
}   template <class _Compare, class _BidirectionalIterator> void __buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,                 _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,                                  typename iterator_traits<_BidirectionalIterator>::difference_type __len2,                 typename iterator_traits<_BidirectionalIterator>::value_type* __buff) {      typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;      __destruct_n __d(0);      unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);      if (__len1 <= __len2)     {          value_type* __p = __buff;          for (_BidirectionalIterator __i = __first;  __i != __middle;  __d.__incr((value_type*)0), (void) ++__i, ++__p)             ::new(__p) value_type(_VSTD::move(*__i));          __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);      }      else     {          value_type* __p = __buff;          for (_BidirectionalIterator __i = __middle;  __i != __last;  __d.__incr((value_type*)0), (void) ++__i, ++__p)             ::new(__p) value_type(_VSTD::move(*__i));          typedef reverse_iterator<_BidirectionalIterator> _RBi;          typedef reverse_iterator<value_type*> _Rv;          __half_inplace_merge(_Rv(__p), _Rv(__buff),                              _RBi(__middle), _RBi(__first),                              _RBi(__last), __invert<_Compare>(__comp));      }  }   template <class _Compare, class _BidirectionalIterator> void __inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,                 _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,                                  typename iterator_traits<_BidirectionalIterator>::difference_type __len2,                 typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size) {      typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;      while (true)     {          // if __middle == __last, we're done
        //         [__m1, __middle) <= [__m2, __last)
        //     and __m1 or __m2 is in the middle of its range
        _BidirectionalIterator __m1;   // "median" of [__first, __middle)
        _BidirectionalIterator __m2;   // "median" of [__middle, __last)
        difference_type __len11;       // distance(__first, __m1)
        difference_type __len21;       // distance(__middle, __m2)
        // binary search smaller range
        if (__len1 < __len2)         {    // __len >= 1, __len2 >= 2
            __len21 = __len2 / 2;              __m2 = __middle;              _VSTD::advance(__m2, __len21);              __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);              __len11 = _VSTD::distance(__first, __m1);          }          else         {              if (__len1 == 1)             {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1
                // It is known *__first > *__middle
                swap(*__first, *__middle);                 return;             }              // __len1 >= 2, __len2 >= 1
            __len11 = __len1 / 2;              __m1 = __first;              _VSTD::advance(__m1, __len11);              __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);              __len21 = _VSTD::distance(__middle, __m2);          }          difference_type __len12 = __len1 - __len11;   // distance(__m1, __middle)
        difference_type __len22 = __len2 - __len21;   // distance(__m2, __last)
        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)
        // swap middle two partitions
        __middle = _VSTD::rotate(__m1, __middle, __m2);          // __len12 and __len21 now have swapped meanings
        // merge smaller range with recurisve call and larger with tail recursion elimination
        if (__len11 + __len21 < __len12 + __len22)         {              __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);  //          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
            __first = __middle;              __middle = __m2;              __len1 = __len12;              __len2 = __len22;          }          else         {              __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);  //          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
            __last = __middle;              __middle = __m1;              __len1 = __len11;              __len2 = __len21;          }      }  }   template <class _BidirectionalIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,               _Compare __comp) {      typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;      typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;      difference_type __len1 = _VSTD::distance(__first, __middle);      difference_type __len2 = _VSTD::distance(__middle, __last);      difference_type __buf_size = _VSTD::min(__len1, __len2);      pair<value_type*, ptrdiff_t> __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);      unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);     
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,                                             __buf.first, __buf.second);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,                                             __buf.first, __buf.second);    
#endif  // _LIBCPP_DEBUG
}   template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY void inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last) {      _VSTD::inplace_merge(__first, __middle, __last,                         __less<typename iterator_traits<_BidirectionalIterator>::value_type>());  }   // stable_sort
 template <class _Compare, class _InputIterator1, class _InputIterator2> void __merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,         _InputIterator2 __first2, _InputIterator2 __last2,         typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp) {      typedef typename iterator_traits<_InputIterator1>::value_type value_type;      __destruct_n __d(0);      unique_ptr<value_type, __destruct_n&> __h(__result, __d);      for (;  true;  ++__result)     {          if (__first1 == __last1)         {              for (;  __first2 != __last2;  ++__first2, ++__result, __d.__incr((value_type*)0))                 ::new (__result) value_type(_VSTD::move(*__first2));              __h.release();              return;          }          if (__first2 == __last2)         {              for (;  __first1 != __last1;  ++__first1, ++__result, __d.__incr((value_type*)0))                 ::new (__result) value_type(_VSTD::move(*__first1));              __h.release();              return;          }          if (__comp(*__first2, *__first1))         {              ::new (__result) value_type(_VSTD::move(*__first2));              __d.__incr((value_type*)0);              ++__first2;          }          else         {              ::new (__result) value_type(_VSTD::move(*__first1));              __d.__incr((value_type*)0);              ++__first1;          }      }  }   template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> void __merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,         _InputIterator2 __first2, _InputIterator2 __last2,         _OutputIterator __result, _Compare __comp) {      for (;  __first1 != __last1;  ++__result)     {          if (__first2 == __last2)         {              for (;  __first1 != __last1;  ++__first1, ++__result)                 *__result = _VSTD::move(*__first1);              return;          }          if (__comp(*__first2, *__first1))         {              *__result = _VSTD::move(*__first2);              ++__first2;          }          else         {              *__result = _VSTD::move(*__first1);              ++__first1;          }      }      for (;  __first2 != __last2;  ++__first2, ++__result)         *__result = _VSTD::move(*__first2);  }   template <class _Compare, class _RandomAccessIterator> void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,               typename iterator_traits<_RandomAccessIterator>::difference_type __len,               typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);   template <class _Compare, class _RandomAccessIterator> void __stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,                    typename iterator_traits<_RandomAccessIterator>::difference_type __len,                    typename iterator_traits<_RandomAccessIterator>::value_type* __first2) {      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;      switch (__len)     {      case 0:         return;      case 1:         ::new(__first2) value_type(_VSTD::move(*__first1));          return;      case 2:        __destruct_n __d(0);          unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);           if (__comp(*--__last1, *__first1))         {              ::new(__first2) value_type(_VSTD::move(*__last1));              __d.__incr((value_type*)0);              ++__first2;              ::new(__first2) value_type(_VSTD::move(*__first1));          }          else         {              ::new(__first2) value_type(_VSTD::move(*__first1));              __d.__incr((value_type*)0);              ++__first2;              ::new(__first2) value_type(_VSTD::move(*__last1));          }          __h2.release();          return;      }      if (__len <= 8)     {          __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);          return;      }      typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;      _RandomAccessIterator __m = __first1 + __l2;      __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);      __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);      __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);  }   template <class _Tp> struct __stable_sort_switch {      static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;  };   template <class _Compare, class _RandomAccessIterator> void __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,               typename iterator_traits<_RandomAccessIterator>::difference_type __len,               typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size) {      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      switch (__len)     {      case 0:     case 1:         return;      case 2:         if (__comp(*--__last, *__first))             swap(*__first, *__last);          return;      }      if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))     {          __insertion_sort<_Compare>(__first, __last, __comp);          return;      }      typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;      _RandomAccessIterator __m = __first + __l2;      if (__len <= __buff_size)     {          __destruct_n __d(0);          unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);          __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);          __d.__set(__l2, (value_type*)0);          __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);          __d.__set(__len, (value_type*)0);          __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);  //         __merge<_Compare>(move_iterator<value_type*>(__buff),
//                           move_iterator<value_type*>(__buff + __l2),
//                           move_iterator<_RandomAccessIterator>(__buff + __l2),
//                           move_iterator<_RandomAccessIterator>(__buff + __len),
//                           __first, __comp);
        return;      }      __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);      __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);      __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);  }   template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      difference_type __len = __last - __first;      pair<value_type*, ptrdiff_t> __buf(0, 0);      unique_ptr<value_type, __return_temporary_buffer> __h;      if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))     {          __buf = _VSTD::get_temporary_buffer<value_type>(__len);          __h.reset(__buf.first);      }    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);    
#endif  // _LIBCPP_DEBUG
}   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {      _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // is_heap_until
 template <class _RandomAccessIterator, class _Compare> _RandomAccessIterator is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {      typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;      difference_type __len = __last - __first;      difference_type __p = 0;      difference_type __c = 1;      _RandomAccessIterator __pp = __first;      while (__c < __len)     {          _RandomAccessIterator __cp = __first + __c;          if (__comp(*__pp, *__cp))             return __cp;          ++__c;          ++__cp;          if (__c == __len)             return __last;          if (__comp(*__pp, *__cp))             return __cp;          ++__p;          ++__pp;          __c = 2 * __p + 1;      }      return __last;  }   template<class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY _RandomAccessIterator is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last) {      return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // is_heap
 template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {      return _VSTD::is_heap_until(__first, __last, __comp) == __last;  }   template<class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY bool is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {      return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // push_heap
 template <class _Compare, class _RandomAccessIterator> void __sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,           typename iterator_traits<_RandomAccessIterator>::difference_type __len) {      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;      if (__len > 1)     {          __len = (__len - 2) / 2;          _RandomAccessIterator __ptr = __first + __len;          if (__comp(*__ptr, *--__last))         {              value_type __t(_VSTD::move(*__last));              do             {                 *__last = _VSTD::move(*__ptr);                 __last = __ptr;                 if (__len == 0)                     break;                 __len = (__len - 1) / 2;                 __ptr = __first + __len;             }  while (__comp(*__ptr, __t));              *__last = _VSTD::move(__t);          }      }  }   template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);    
#endif  // _LIBCPP_DEBUG
}   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {      _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // pop_heap
 template <class _Compare, class _RandomAccessIterator> void __sift_down(_RandomAccessIterator __first, _RandomAccessIterator /*__last*/,             _Compare __comp,             typename iterator_traits<_RandomAccessIterator>::difference_type __len,             _RandomAccessIterator __start) {      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;      // left-child of __start is at 2 * __start + 1
    // right-child of __start is at 2 * __start + 2
    difference_type __child = __start - __first;       if (__len < 2 || (__len - 2) / 2 < __child)         return;       __child = 2 * __child + 1;      _RandomAccessIterator __child_i = __first + __child;       if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {          // right-child exists and is greater than left-child
        ++__child_i;          ++__child;      }       // check if we are in heap-order
    if (__comp(*__child_i, *__start))         // we are, __start is larger than it's largest child
        return;       value_type __top(_VSTD::move(*__start));      do     {          // we are not in heap-order, swap the parent with it's largest child
        *__start = _VSTD::move(*__child_i);          __start = __child_i;           if ((__len - 2) / 2 < __child)             break;           // recompute the child based off of the updated parent
        __child = 2 * __child + 1;          __child_i = __first + __child;           if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {              // right-child exists and is greater than left-child
            ++__child_i;              ++__child;          }           // check if we are in heap-order
    }  while (!__comp(*__child_i, __top));      *__start = _VSTD::move(__top);  }   template <class _Compare, class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,            typename iterator_traits<_RandomAccessIterator>::difference_type __len) {      if (__len > 1)     {          swap(*__first, *--__last);          __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);      }  }   template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);    
#endif  // _LIBCPP_DEBUG
}   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {      _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // make_heap
 template <class _Compare, class _RandomAccessIterator> void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      difference_type __n = __last - __first;      if (__n > 1)     {          // start from the first parent, there is no need to consider children
        for (difference_type __start = (__n - 2) / 2;  __start >= 0;  --__start)         {              __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);          }      }  }   template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      __make_heap<_Comp_ref>(__first, __last, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      __make_heap<_Comp_ref>(__first, __last, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {      _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // sort_heap
 template <class _Compare, class _RandomAccessIterator> void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {      typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      for (difference_type __n = __last - __first;  __n > 1;  --__last, --__n)         __pop_heap<_Compare>(__first, __last, __comp, __n);  }   template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      __sort_heap<_Comp_ref>(__first, __last, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      __sort_heap<_Comp_ref>(__first, __last, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {      _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // partial_sort
 template <class _Compare, class _RandomAccessIterator> void __partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,              _Compare __comp) {      __make_heap<_Compare>(__first, __middle, __comp);      typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;      for (_RandomAccessIterator __i = __middle;  __i != __last;  ++__i)     {          if (__comp(*__i, *__first))         {              swap(*__i, *__first);              __sift_down<_Compare>(__first, __middle, __comp, __len, __first);          }      }      __sort_heap<_Compare>(__first, __middle, __comp);  }   template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,              _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      __partial_sort<_Comp_ref>(__first, __middle, __last, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last) {      _VSTD::partial_sort(__first, __middle, __last,                        __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // partial_sort_copy
 template <class _Compare, class _InputIterator, class _RandomAccessIterator> _RandomAccessIterator __partial_sort_copy(_InputIterator __first, _InputIterator __last,                     _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp) {      _RandomAccessIterator __r = __result_first;      if (__r != __result_last)     {          for (;  __first != __last && __r != __result_last;  (void) ++__first, ++__r)             *__r = *__first;          __make_heap<_Compare>(__result_first, __r, __comp);          typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;          for (;  __first != __last;  ++__first)             if (__comp(*__first, *__result_first))             {                  *__result_first = *__first;                  __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);              }          __sort_heap<_Compare>(__result_first, __r, __comp);      }      return __r;  }   template <class _InputIterator, class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last,                   _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _InputIterator, class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY _RandomAccessIterator partial_sort_copy(_InputIterator __first, _InputIterator __last,                   _RandomAccessIterator __result_first, _RandomAccessIterator __result_last) {      return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,                                    __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // nth_element
 template <class _Compare, class _RandomAccessIterator> void __nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp) {      // _Compare is known to be a reference type
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;      const difference_type __limit = 7;      while (true)     {      __restart:         if (__nth == __last)             return;          difference_type __len = __last - __first;          switch (__len)         {          case 0:         case 1:             return;          case 2:             if (__comp(*--__last, *__first))                 swap(*__first, *__last);              return;          case 3:             {             _RandomAccessIterator __m = __first;             _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);             return;             }          }          if (__len <= __limit)         {              __selection_sort<_Compare>(__first, __last, __comp);              return;          }          // __len > __limit >= 3
        _RandomAccessIterator __m = __first + __len/2;          _RandomAccessIterator __lm1 = __last;          unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);          // *__m is median
        // partition [__first, __m) < *__m and *__m <= [__m, __last)
        // (this inhibits tossing elements equivalent to __m around unnecessarily)
        _RandomAccessIterator __i = __first;          _RandomAccessIterator __j = __lm1;          // j points beyond range to be tested, *__lm1 is known to be <= *__m
        // The search going up is known to be guarded but the search coming down isn't.
        // Prime the downward search with a guard.
        if (!__comp(*__i, *__m))  // if *__first == *__m
        if (__nth < __i)         {              // __nth_element<_Compare>(__first, __nth, __i, __comp);
            __last = __i;          }          else         {              // __nth_element<_Compare>(__i+1, __nth, __last, __comp);
            __first = ++__i;          }      }  }   template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      __nth_element<_Comp_ref>(__first, __nth, __last, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      __nth_element<_Comp_ref>(__first, __nth, __last, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _RandomAccessIterator> inline _LIBCPP_INLINE_VISIBILITY void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last) {      _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());  }   // includes
 template <class _Compare, class _InputIterator1, class _InputIterator2> bool __includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,            _Compare __comp) {      for (;  __first2 != __last2;  ++__first1)     {          if (__first1 == __last1 || __comp(*__first2, *__first1))             return false;          if (!__comp(*__first1, *__first2))             ++__first2;      }      return true;  }   template <class _InputIterator1, class _InputIterator2, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,          _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _InputIterator1, class _InputIterator2> inline _LIBCPP_INLINE_VISIBILITY bool includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {      return _VSTD::includes(__first1, __last1, __first2, __last2,                           __less<typename iterator_traits<_InputIterator1>::value_type,                                  typename iterator_traits<_InputIterator2>::value_type>());  }   // set_union
 template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_union(_InputIterator1 __first1, _InputIterator1 __last1,             _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {      for (;  __first1 != __last1;  ++__result)     {          if (__first2 == __last2)             return _VSTD::copy(__first1, __last1, __result);          if (__comp(*__first2, *__first1))         {              *__result = *__first2;              ++__first2;          }          else         {              *__result = *__first1;              if (!__comp(*__first1, *__first2))                 ++__first2;              ++__first1;          }      }      return _VSTD::copy(__first2, __last2, __result);  }   template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1,           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1,           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) {      return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,                           __less<typename iterator_traits<_InputIterator1>::value_type,                                  typename iterator_traits<_InputIterator2>::value_type>());  }   // set_intersection
 template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,                    _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {      while (__first1 != __last1 && __first2 != __last2)     {          if (__comp(*__first1, *__first2))             ++__first1;          else         {              if (!__comp(*__first2, *__first1))             {                 *__result = *__first1;                 ++__result;                 ++__first1;             }              ++__first2;          }      }      return __result;  }   template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,                  _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,                  _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) {      return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,                                   __less<typename iterator_traits<_InputIterator1>::value_type,                                          typename iterator_traits<_InputIterator2>::value_type>());  }   // set_difference
 template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,                  _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {      while (__first1 != __last1)     {          if (__first2 == __last2)             return _VSTD::copy(__first1, __last1, __result);          if (__comp(*__first1, *__first2))         {              *__result = *__first1;              ++__result;              ++__first1;          }          else         {              if (!__comp(*__first2, *__first1))                 ++__first1;              ++__first2;          }      }      return __result;  }   template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1,                _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_difference(_InputIterator1 __first1, _InputIterator1 __last1,                _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) {      return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,                                 __less<typename iterator_traits<_InputIterator1>::value_type,                                        typename iterator_traits<_InputIterator2>::value_type>());  }   // set_symmetric_difference
 template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,                            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {      while (__first1 != __last1)     {          if (__first2 == __last2)             return _VSTD::copy(__first1, __last1, __result);          if (__comp(*__first1, *__first2))         {              *__result = *__first1;              ++__result;              ++__first1;          }          else         {              if (__comp(*__first2, *__first1))             {                 *__result = *__first2;                 ++__result;             }              else                 ++__first1;              ++__first2;          }      }      return _VSTD::copy(__first2, __last2, __result);  }   template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,                          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,                          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) {      return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,                                           __less<typename iterator_traits<_InputIterator1>::value_type,                                                  typename iterator_traits<_InputIterator2>::value_type>());  }   // lexicographical_compare
 template <class _Compare, class _InputIterator1, class _InputIterator2> bool __lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,                           _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) {      for (;  __first2 != __last2;  ++__first1, (void) ++__first2)     {          if (__first1 == __last1 || __comp(*__first1, *__first2))             return true;          if (__comp(*__first2, *__first1))             return false;      }      return false;  }   template <class _InputIterator1, class _InputIterator2, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,                         _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _InputIterator1, class _InputIterator2> inline _LIBCPP_INLINE_VISIBILITY bool lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,                         _InputIterator2 __first2, _InputIterator2 __last2) {      return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,                                          __less<typename iterator_traits<_InputIterator1>::value_type,                                                 typename iterator_traits<_InputIterator2>::value_type>());  }   // next_permutation
 template <class _Compare, class _BidirectionalIterator> bool __next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {      _BidirectionalIterator __i = __last;      if (__first == __last || __first == --__i)         return false;      while (true)     {          _BidirectionalIterator __ip1 = __i;          if (__comp(*--__i, *__ip1))         {              _BidirectionalIterator __j = __last;              while (!__comp(*__i, *--__j))                 ;              swap(*__i, *__j);              _VSTD::reverse(__ip1, __last);              return true;          }          if (__i == __first)         {              _VSTD::reverse(__first, __last);              return false;          }      }  }   template <class _BidirectionalIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __next_permutation<_Comp_ref>(__first, __last, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __next_permutation<_Comp_ref>(__first, __last, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY bool next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) {      return _VSTD::next_permutation(__first, __last,                                   __less<typename iterator_traits<_BidirectionalIterator>::value_type>());  }   // prev_permutation
 template <class _Compare, class _BidirectionalIterator> bool __prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {      _BidirectionalIterator __i = __last;      if (__first == __last || __first == --__i)         return false;      while (true)     {          _BidirectionalIterator __ip1 = __i;          if (__comp(*__ip1, *--__i))         {              _BidirectionalIterator __j = __last;              while (!__comp(*--__j, *__i))                 ;              swap(*__i, *__j);              _VSTD::reverse(__ip1, __last);              return true;          }          if (__i == __first)         {              _VSTD::reverse(__first, __last);              return false;          }      }  }   template <class _BidirectionalIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {    
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;      __debug_less<_Compare> __c(__comp);      return __prev_permutation<_Comp_ref>(__first, __last, __c);    
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;      return __prev_permutation<_Comp_ref>(__first, __last, __comp);    
#endif  // _LIBCPP_DEBUG
}   template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) {      return _VSTD::prev_permutation(__first, __last,                                   __less<typename iterator_traits<_BidirectionalIterator>::value_type>());  }   _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_ALGORITHM
  
#pragma clang module end /*std.algorithm*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdio>     // For EOF.
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cstdio
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CSTDIO
  
#define _LIBCPP_CSTDIO
 /*     cstdio synopsis  Macros:      BUFSIZ     EOF     FILENAME_MAX     FOPEN_MAX     L_tmpnam     NULL     SEEK_CUR     SEEK_END     SEEK_SET     TMP_MAX     _IOFBF     _IOLBF     _IONBF     stderr     stdin     stdout  namespace std {   Types:  FILE fpos_t size_t  int remove(const char* filename);  int rename(const char* old, const char* new);  FILE* tmpfile(void);  char* tmpnam(char* s);  int fclose(FILE* stream);  int fflush(FILE* stream);  FILE* fopen(const char* restrict filename, const char* restrict mode);  FILE* freopen(const char* restrict filename, const char * restrict mode,               FILE * restrict stream);  void setbuf(FILE* restrict stream, char* restrict buf);  int setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);  int fprintf(FILE* restrict stream, const char* restrict format, ...);  int fscanf(FILE* restrict stream, const char * restrict format, ...);  int printf(const char* restrict format, ...);  int scanf(const char* restrict format, ...);  int snprintf(char* restrict s, size_t n, const char* restrict format, ...);     // C99
int sprintf(char* restrict s, const char* restrict format, ...);  int sscanf(const char* restrict s, const char* restrict format, ...);  int vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);  int vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);   // C99
int vprintf(const char* restrict format, va_list arg);  int vscanf(const char* restrict format, va_list arg);                           // C99
int vsnprintf(char* restrict s, size_t n, const char* restrict format,         // C99
              va_list arg);  int vsprintf(char* restrict s, const char* restrict format, va_list arg);  int vsscanf(const char* restrict s, const char* restrict format, va_list arg);  // C99
int fgetc(FILE* stream);  char* fgets(char* restrict s, int n, FILE* restrict stream);  int fputc(int c, FILE* stream);  int fputs(const char* restrict s, FILE* restrict stream);  int getc(FILE* stream);  int getchar(void);  char* gets(char* s);   // removed in C++14
int putc(int c, FILE* stream);  int putchar(int c);  int puts(const char* s);  int ungetc(int c, FILE* stream);  size_t fread(void* restrict ptr, size_t size, size_t nmemb,              FILE* restrict stream);  size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb,               FILE* restrict stream);  int fgetpos(FILE* restrict stream, fpos_t* restrict pos);  int fseek(FILE* stream, long offset, int whence);  int fsetpos(FILE*stream, const fpos_t* pos);  long ftell(FILE* stream);  void rewind(FILE* stream);  void clearerr(FILE* stream);  int feof(FILE* stream);  int ferror(FILE* stream);  void perror(const char* s);   }   // std
*/   
#if 0 /* expanded by -frewrite-includes */
  
   
#elif !defined(_LIBCPP_STDIO_H)
  
#define _LIBCPP_STDIO_H
 /*     stdio.h synopsis  Macros:      BUFSIZ     EOF     FILENAME_MAX     FOPEN_MAX     L_tmpnam     NULL     SEEK_CUR     SEEK_END     SEEK_SET     TMP_MAX     _IOFBF     _IOLBF     _IONBF     stderr     stdin     stdout  Types:  FILE fpos_t size_t  int remove(const char* filename);  int rename(const char* old, const char* new);  FILE* tmpfile(void);  char* tmpnam(char* s);  int fclose(FILE* stream);  int fflush(FILE* stream);  FILE* fopen(const char* restrict filename, const char* restrict mode);  FILE* freopen(const char* restrict filename, const char * restrict mode,               FILE * restrict stream);  void setbuf(FILE* restrict stream, char* restrict buf);  int setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);  int fprintf(FILE* restrict stream, const char* restrict format, ...);  int fscanf(FILE* restrict stream, const char * restrict format, ...);  int printf(const char* restrict format, ...);  int scanf(const char* restrict format, ...);  int snprintf(char* restrict s, size_t n, const char* restrict format, ...);     // C99
int sprintf(char* restrict s, const char* restrict format, ...);  int sscanf(const char* restrict s, const char* restrict format, ...);  int vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);  int vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);   // C99
int vprintf(const char* restrict format, va_list arg);  int vscanf(const char* restrict format, va_list arg);                           // C99
int vsnprintf(char* restrict s, size_t n, const char* restrict format,         // C99
  
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <stdio.h>
  
#endif /* expanded by -frewrite-includes */
/* Define ISO C stdio on top of C++ iostreams.    Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;  you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;  either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;  without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;  if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard: 7.19 Input/output	<stdio.h>  */   
#ifndef _STDIO_H
   
#if !defined __need_FILE && !defined __need___FILE
 __BEGIN_DECLS    
# define __need_size_t
  
# define __need_NULL
  
#if 0 /* expanded by -frewrite-includes */
  
# include <stddef.h>
  
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===--------------------------- stddef.h ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <stddef.h>
  
#endif /* expanded by -frewrite-includes */
/*===---- stddef.h - Basic type definitions --------------------------------===  *  * Copyright (c) 2008 Eli Friedman  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN  * THE SOFTWARE.  *  *===-----------------------------------------------------------------------===  */   
#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)
   
#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)
  
#undef __need_ptrdiff_t
  
#endif /* defined(__need_ptrdiff_t) */
   
#if defined(__need_size_t)
  
#if !defined(_SIZE_T) || __has_feature(modules)
/* Always define size_t when modules are available. */  
#if !__has_feature(modules)
   
#endif  /* defined(__need_STDDEF_H_misc) */
 /* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use __WINT_TYPE__ directly;  accommodate both by requiring __need_wint_t */  
#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */  
#if !defined(_WINT_T) || __has_feature(modules)
#endif
  
#undef __need_wint_t
  
#endif /* __need_wint_t */
   
#endif
   
#elif !defined(_LIBCPP_STDDEF_H)
  
#define _LIBCPP_STDDEF_H
 /*     stddef.h synopsis  Macros:      offsetof(type,member-designator)     NULL  Types:      ptrdiff_t     size_t     max_align_t     nullptr_t  */   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
  
#endif /* expanded by -frewrite-includes */
using std::nullptr_t;  }   // Re-use the compiler's <stddef.h> max_align_t where possible.
  
#if !defined(__CLANG_MAX_ALIGN_T_DEFINED) && !defined(_GCC_MAX_ALIGN_T) && \
    !defined(__DEFINED_max_align_t)
typedef long double max_align_t;    
#endif
   
#endif
   
#endif  // _LIBCPP_STDDEF_H
  
#define __need_mbstate_t
  
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
#include <wchar.h>
  
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===--------------------------- wchar.h ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#if defined(__need_wint_t) || defined(__need_mbstate_t)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <wchar.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1995-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;  you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;  either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;  without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;  if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *      ISO C99 Standard: 7.24  *	Extended multibyte and wide character utilities	<wchar.h>  */   
#ifndef _WCHAR_H
   
#if !defined __need_mbstate_t && !defined __need_wint_t
  
# define _WCHAR_H 1
  
#if 0 /* expanded by -frewrite-includes */
  
# include <features.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifdef _WCHAR_H
/* Get FILE definition.  */  
# define __need___FILE
  
# if defined __USE_UNIX98 || defined __USE_XOPEN2K
  
#  define __need_FILE
  
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n, 				 __FILE *__restrict __stream);
  /* This function does the same as `fputws' but does not lock the stream.     This function is not part of POSIX and therefore no official    cancellation point.  But due to similarity with an POSIX interface    or due to the implementation it is a cancellation point and    therefore not marked with __THROW.  */extern int fputws_unlocked (const wchar_t *__restrict __ws, 			    __FILE *__restrict __stream);  
#endif
  __BEGIN_NAMESPACE_C99 /* Format TP into S according to FORMAT.    Write no more than MAXSIZE wide characters and return the number    of wide characters written, or 0 if it would exceed MAXSIZE.  */extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize, 			const wchar_t *__restrict __format, 			const struct tm *__restrict __tp) __THROW; __END_NAMESPACE_C99   
# ifdef __USE_GNU
 
#if 0 /* expanded by -frewrite-includes */
 
# include <wctype.h>

#endif /* expanded by -frewrite-includes */

#endif
 /* Define some macros helping to catch buffer overflows.  */

#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function

#if 0 /* expanded by -frewrite-includes */

# include <bits/wchar2.h>

#endif /* expanded by -frewrite-includes */

#endif
 
#ifdef __LDBL_COMPAT

#if 0 /* expanded by -frewrite-includes */

# include <bits/wchar-ldbl.h>

#endif /* expanded by -frewrite-includes */

#endif
 __END_DECLS  
#endif	/* _WCHAR_H defined */
 
#endif /* wchar.h  */
 /* Undefine all __need_* constants in case we are included to get those    constants but the whole file was already read.  */

#undef __need_mbstate_t

#undef __need_wint_t
 
#elif !defined(_LIBCPP_WCHAR_H)

#define _LIBCPP_WCHAR_H
 /*     wchar.h synopsis  Macros:      NULL     WCHAR_MAX     WCHAR_MIN     WEOF  Types:      mbstate_t     size_t     tm     wint_t  int fwprintf(FILE* restrict stream, const wchar_t* restrict format, ...);
 int fwscanf(FILE* restrict stream, const wchar_t* restrict format, ...);
 int swprintf(wchar_t* restrict s, size_t n, const wchar_t* restrict format, ...);
 int swscanf(const wchar_t* restrict s, const wchar_t* restrict format, ...);
 int vfwprintf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
 int vfwscanf(FILE* restrict stream, const wchar_t* restrict format, va_list arg);
  // C99
#include <__config>

#endif /* expanded by -frewrite-includes */
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 
#ifdef __cplusplus

 inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_PREFERRED_OVERLOAD       wchar_t* wmemchr(      wchar_t* __s, wchar_t __c, size_t __n) {
return __libcpp_wmemchr(__s, __c, __n);
}
 }
 
#endif
 
 
#endif  // _LIBCPP_WCHAR_H
typedef struct {
   __off_t __pos;
   __mbstate_t __state;
 }
 _G_fpos_t;
 typedef struct {
   __off64_t __pos;
   __mbstate_t __state;
 }
 _G_fpos64_t;
 
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T

#if 0 /* expanded by -frewrite-includes */

# include <gconv.h>

#endif /* expanded by -frewrite-includes */
typedef union {
   struct __gconv_info __cd;
   struct   {
     struct __gconv_info __cd;
     struct __gconv_step_data __data;
   }
 __combined;
 }
 _G_iconv_t;
 
#endif
  /* These library features are always available in the GNU C library.  */

#define _G_va_list __gnuc_va_list
 
#define _G_HAVE_MMAP 1

#define _G_HAVE_MREMAP 1
 
#define _G_IO_IO_FILE_VERSION 0x20001
 /* This is defined by <bits/stat.h> if `st_blksize' exists.  */
#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)
  
#define _G_BUFSIZ 8192
  
#endif	/* _G_config.h */
/* ALL of these should be defined in _G_config.h */
 
#define _IO_off_t __off_t
 
#define _IO_off64_t __off64_t
 
#define _IO_pid_t __pid_t
 
#define _IO_uid_t __uid_t
#define _IO_va_list _G_va_list
 
#define _IO_wint_t wint_t
 /* This define avoids name pollution if we're using GNU stdarg.h */

#define __need___va_list

#if 0 /* expanded by -frewrite-includes */
#if 0 /* expanded by -frewrite-includes */

# include <sys/cdefs.h>

#endif /* expanded by -frewrite-includes */

#endif /*!__P*/
 
#define _IO_UNIFIED_JUMPTABLES 1
 
#ifndef EOF

# define EOF (-1)

#endif

  
#define _IO_DONT_CLOSE 0100000
  
#define _IO_BOOLALPHA 0200000
  struct _IO_jump_t;   struct _IO_FILE;   /* Handle lock.  */  
#ifdef _IO_MTSAFE_IO
  
# if defined __GLIBC__ && __GLIBC__ >= 2
/*  
# include <comthread.h>*/
  
# endif
  
#else
typedef void _IO_lock_t;    
#endif
  /* A streammarker remembers a position in a buffer. */ struct _IO_marker {    struct _IO_marker *_next;    struct _IO_FILE *_sbuf;    /* If _pos >= 0  it points to _buf->Gbase()+_pos. FIXME comment */  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */  int _pos;    
#if 0
    void set_streampos(streampos sp) {  _spos = sp;  }      void set_offset(int offset) {  _pos = offset;  _spos = (streampos)(-2);  }    public:     streammarker(streambuf *sb);      ~streammarker();      int saving() {  return  _spos == -2;  }      int delta(streammarker&);      int delta();    
#endif
};   /* This is the structure from the libstdc++ codecvt class.  */enum __codecvt_result {    __codecvt_ok,   __codecvt_partial,   __codecvt_error,   __codecvt_noconv };     
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
/* The order of the elements in the following struct must match the order    of the virtual functions in the libstdc++ codecvt class.  */struct _IO_codecvt {    void (*__codecvt_destr) (struct _IO_codecvt *);    enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *, 					     __mbstate_t *, 					     const wchar_t *, 					     const wchar_t *, 					     const wchar_t **, char *, 					     char *, char **);    enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *, 						 __mbstate_t *, char *, 						 char *, char **);    enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *, 					    __mbstate_t *, 					    const char *, const char *, 					    const char **, wchar_t *, 					    wchar_t *, wchar_t **);    int (*__codecvt_do_encoding) (struct _IO_codecvt *);    int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);    int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *, 			      const char *, const char *, _IO_size_t);    int (*__codecvt_do_max_length) (struct _IO_codecvt *);     _IO_iconv_t __cd_in;    _IO_iconv_t __cd_out;  };   /* Extra data for wide character streams.  */struct _IO_wide_data {    wchar_t *_IO_read_ptr; 	/* Current read pointer */  wchar_t *_IO_read_end; 	/* End of get area. */  wchar_t *_IO_read_base; 	/* Start of putback+get area. */  wchar_t *_IO_write_base; 	/* Start of put area. */  wchar_t *_IO_write_ptr; 	/* Current put pointer. */  wchar_t *_IO_write_end; 	/* End of put area. */  wchar_t *_IO_buf_base; 	/* Start of reserve area. */  wchar_t *_IO_buf_end; 		/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base; 	/* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base; 	/* Pointer to first valid character of 				   backup area */  wchar_t *_IO_save_end; 	/* Pointer to end of non-current get area. */   __mbstate_t _IO_state;    __mbstate_t _IO_last_state;    struct _IO_codecvt _codecvt;     wchar_t _shortbuf[1];     const struct _IO_jump_t *_wide_vtable;  };    
#endif
 struct _IO_FILE {    int _flags; 		/* High-order word is _IO_MAGIC;  rest is flags. */  
#define _IO_file_flags _flags
   /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr; 	/* Current read pointer */  char* _IO_read_end; 	/* End of get area. */  char* _IO_read_base; 	/* Start of putback+get area. */  char* _IO_write_base; 	/* Start of put area. */  char* _IO_write_ptr; 	/* Current put pointer. */  char* _IO_write_end; 	/* End of put area. */  char* _IO_buf_base; 	/* Start of reserve area. */  char* _IO_buf_end; 	/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base;  /* Pointer to start of non-current get area. */  char *_IO_backup_base;   /* Pointer to first valid character of backup area */  char *_IO_save_end;  /* Pointer to end of non-current get area. */   struct _IO_marker *_markers;     struct _IO_FILE *_chain;     int _fileno;    
#if 0
  int _blksize;    
#else
  int _flags2;    
#endif
  _IO_off_t _old_offset;  /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};

struct _IO_FILE_complete
{
  struct _IO_FILE _file;
#endif
#if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001
  _IO_off64_t _offset;
# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
  /* Wide character stream stuff.  */
  void *__pad3;
  void *__pad4;
  size_t __pad5;
# endif
  int _mode;
  /* Make sure we don't get into trouble again.  */  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];    
#endif
};     
#ifndef __cplusplus
typedef struct _IO_FILE _IO_FILE;    
#endif
 struct _IO_FILE_plus;   extern struct _IO_FILE_plus _IO_2_1_stdin_;  extern struct _IO_FILE_plus _IO_2_1_stdout_;  extern struct _IO_FILE_plus _IO_2_1_stderr_;    
#ifndef _LIBC
  
#define _IO_stdin ((_IO_FILE*)(&_IO_2_1_stdin_))
#endif
  /* Functions to do I/O and file management for a stream.  */ /* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.    Return number of bytes read.  */typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);   /* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes    unless there is an error.  Return number of bytes written.  If    there is an error, return 0 and do not write anything.  If the file    has been opened for append (__mode.__append set), then set the file    pointer to the end of the file and then do the write;  if not, just    write at the current file pointer.  */typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf, 				 size_t __n);   /* Move COOKIE's file position to *POS bytes from the
   beginning of the file (if W is SEEK_SET),
   the current position (if W is SEEK_CUR),
   or the end of the file (if W is SEEK_END).
   Set *POS to the new file position.
   Returns zero if successful, nonzero if not.  */
typedef int __io_seek_fn (void *__cookie, _IO_off64_t *__pos, int __w);

/* Close COOKIE.  */
typedef int __io_close_fn (void *__cookie);


#ifdef _GNU_SOURCE
/* User-visible names for the above.  */
typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;

/* The structure with the cookie function pointers.  */
typedef struct
{
  __io_read_fn *read;		/* Read bytes.  */
  __io_write_fn *write;		/* Write bytes.  */
  __io_seek_fn *seek;		/* Seek/tell file position.  */
  __io_close_fn *close;		/* Close file.  */
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;
extern "C" {
#endif

extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
# define _IO_BE(expr, res) (expr)
#endif

#define _IO_getc_unlocked(_fp) \
       (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) \
	? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)
#define _IO_peekc_unlocked(_fp) \

extern _IO_off64_t _IO_seekoff (_IO_FILE *, _IO_off64_t, int, int);
extern _IO_off64_t _IO_seekpos (_IO_FILE *, _IO_off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __THROW;

#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T
extern _IO_wint_t _IO_getwc (_IO_FILE *__fp);
extern _IO_wint_t _IO_putwc (wchar_t __wc, _IO_FILE *__fp);
extern int _IO_fwide (_IO_FILE *__fp, int __mode) __THROW;
# if __GNUC__ >= 2
/* While compiling glibc we have to handle compatibility with very old
   versions.  */
#  if defined _LIBC && defined SHARED
#if 0 /* expanded by -frewrite-includes */
#   include <shlib-compat.h>
#endif /* expanded by -frewrite-includes */
#   if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
#    define _IO_fwide_maybe_incompatible \
  (__builtin_expect (&_IO_stdin_used == NULL, 0))
extern const int _IO_stdin_used;
weak_extern (_IO_stdin_used);
#   endif
#  endif
# include <bits/libio-ldbl.h>
#endif /* expanded by -frewrite-includes */
#endif

#ifdef __cplusplus
}
#endif

#endif /* _IO_STDIO_H */

#if defined __USE_XOPEN || defined __USE_XOPEN2K8
# ifdef __GNUC__
#  ifndef _VA_LIST_DEFINED
typedef _G_va_list va_list;
#   define _VA_LIST_DEFINED
#  endif
# else
#if 0 /* expanded by -frewrite-includes */
#  include <stdarg.h>
#endif /* expanded by -frewrite-includes */
# endif
#endif

#ifdef __USE_XOPEN2K8
# ifndef __off_t_defined
# ifndef __USE_FILE_OFFSET64
typedef __off_t off_t;
# else
typedef __off64_t off_t;
# endif
# define __off_t_defined
typedef __ssize_t ssize_t;
# define __ssize_t_defined
# endif
#endif

/* The type of the second argument to `fgetpos' and `fsetpos'.  */
__BEGIN_NAMESPACE_STD
#ifndef __USE_FILE_OFFSET64
typedef _G_fpos_t fpos_t;
#else
typedef _G_fpos64_t fpos_t;
#endif
__END_NAMESPACE_STD
#ifdef __USE_LARGEFILE64
typedef _G_fpos64_t fpos64_t;
#endif

/* The possibilities for the third argument to `setvbuf'.  */  
#define _IOFBF 0		/* Fully buffered.  */
  
#define _IOLBF 1		/* Line buffered.  */
  
#define _IONBF 2		/* No buffering.  */
 __BEGIN_NAMESPACE_STD /* Remove file FILENAME.  */extern int remove (const char *__filename) __THROW;  /* Rename file OLD to NEW.  */extern int rename (const char *__old, const char *__new) __THROW;  __END_NAMESPACE_STD    
#ifdef __USE_ATFILE
/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */extern int renameat (int __oldfd, const char *__old, int __newfd, 		     const char *__new) __THROW;    
#endif
 __BEGIN_NAMESPACE_STD /* Create a temporary file and open it read/write.     This function is a possible cancellation point and therefore not    marked with __THROW.  */  
#ifndef __USE_FILE_OFFSET64
extern FILE *tmpfile (void) __wur;    
#else
  
# ifdef __REDIRECT
extern FILE *__REDIRECT (tmpfile, (void), tmpfile64) __wur;    
# else
  
#  define tmpfile tmpfile64
  
# endif
  
#endif
   
#ifdef __USE_LARGEFILE64
extern FILE *tmpfile64 (void) __wur;    
#endif
 /* Generate a temporary filename.  */extern char *tmpnam (char *__s) __THROW __wur;  __END_NAMESPACE_STD    
#ifdef __USE_MISC
/* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  */
extern char *tmpnam_r (char *__s) __THROW __wur;
#endif


#if defined __USE_SVID || defined __USE_XOPEN
/* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  */extern char *tempnam (const char *__dir, const char *__pfx)      __THROW __attribute_malloc__ __wur;    
#endif
  __BEGIN_NAMESPACE_STD /* Close STREAM.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern int fclose (FILE *__stream);  /* Flush STREAM, or all streams if STREAM is NULL.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern int fflush (FILE *__stream);  __END_NAMESPACE_STD    
#ifdef __USE_MISC
/* Faster versions when locking is not required.     This function is not part of POSIX and therefore no official    cancellation point.  But due to similarity with an POSIX interface    or due to the implementation it is a cancellation point and    therefore not marked with __THROW.  */extern int fflush_unlocked (FILE *__stream);    
#endif
   
#ifdef __USE_GNU
/* Close all streams.     This function is not part of POSIX and therefore no official    cancellation point.  But due to similarity with an POSIX interface    or due to the implementation it is a cancellation point and    therefore not marked with __THROW.  */extern int fcloseall (void);    
#endif
  __BEGIN_NAMESPACE_STD   
#ifndef __USE_FILE_OFFSET64
/* Open a file and create a new stream for it.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern FILE *fopen (const char *__restrict __filename, 		    const char *__restrict __modes) __wur;  /* Open a file, replacing an existing stream with it.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern FILE *freopen (const char *__restrict __filename, 		      const char *__restrict __modes, 		      FILE *__restrict __stream) __wur;    
#else
  
# ifdef __REDIRECT
extern FILE *__REDIRECT (fopen, (const char *__restrict __filename, 				 const char *__restrict __modes), fopen64)   __wur;  extern FILE *__REDIRECT (freopen, (const char *__restrict __filename, 				   const char *__restrict __modes, 				   FILE *__restrict __stream), freopen64)   __wur;    
# else
  
#  define fopen fopen64
  
#  define freopen freopen64
  
# endif
  
#endif
__END_NAMESPACE_STD   
#ifdef __USE_LARGEFILE64
extern FILE *fopen64 (const char *__restrict __filename, 		      const char *__restrict __modes) __wur;  extern FILE *freopen64 (const char *__restrict __filename, 			const char *__restrict __modes, 			FILE *__restrict __stream) __wur;    
#endif
   
  __BEGIN_NAMESPACE_STD /* Write formatted output to STREAM.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern int fprintf (FILE *__restrict __stream, 		    const char *__restrict __format, ...);  /* Write formatted output to stdout.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern int printf (const char *__restrict __format, ...);  /* Write formatted output to S.  */extern int sprintf (char *__restrict __s, 		    const char *__restrict __format, ...) __THROWNL;   /* Write formatted output to S from argument list ARG.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern int vfprintf (FILE *__restrict __s, const char *__restrict __format, 		     _G_va_list __arg);  /* Write formatted output to stdout from argument list ARG.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern int vprintf (const char *__restrict __format, _G_va_list __arg);  /* Write formatted output to S from argument list ARG.  */extern int vsprintf (char *__restrict __s, const char *__restrict __format, 		     _G_va_list __arg) __THROWNL;  __END_NAMESPACE_STD    
#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
__BEGIN_NAMESPACE_C99 /* Maximum chars of output to write in MAXLEN.  */extern int snprintf (char *__restrict __s, size_t __maxlen, 		     const char *__restrict __format, ...)      __THROWNL __attribute__ ((__format__ (__printf__, 3, 4)));   extern int vsnprintf (char *__restrict __s, size_t __maxlen, 		      const char *__restrict __format, _G_va_list __arg)      __THROWNL __attribute__ ((__format__ (__printf__, 3, 0)));  __END_NAMESPACE_C99   
#endif
   
#ifdef __USE_GNU
/* Write formatted output to a string dynamically allocated with `malloc'.
   Store the address of the string in *PTR.  */
extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
		      _G_va_list __arg)
     __THROWNL __attribute__ ((__format__ (__printf__, 2, 0))) __wur;
extern int __asprintf (char **__restrict __ptr,
		       const char *__restrict __fmt, ...)
     __THROWNL __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
extern int asprintf (char **__restrict __ptr,
		     const char *__restrict __fmt, ...)
     __THROWNL __attribute__ ((__format__ (__printf__, 2, 3))) __wur;
#endif

#ifdef __USE_XOPEN2K8
/* Write formatted output to a file descriptor.  */
extern int vdprintf (int __fd, const char *__restrict __fmt,
		     _G_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
#endif


__BEGIN_NAMESPACE_STD
/* Read formatted input from STREAM.
   marked with __THROW.  */
extern int scanf (const char *__restrict __format, ...) __wur;
/* Read formatted input from S.  */
extern int sscanf (const char *__restrict __s,
		   const char *__restrict __format, ...) __THROW;

#if defined __USE_ISOC99 && !defined __USE_GNU \
    && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
    && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
# ifdef __REDIRECT
/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int __REDIRECT (fscanf, (FILE *__restrict __stream,
				const char *__restrict __format, ...),
# endif
#endif

__END_NAMESPACE_STD

#ifdef	__USE_ISOC99
__BEGIN_NAMESPACE_C99
extern int vsscanf (const char *__restrict __s,
		    const char *__restrict __format, _G_va_list __arg)
     __THROW __attribute__ ((__format__ (__scanf__, 2, 0)));

# if !defined __USE_GNU \
     && (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     && (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)
#  ifdef __REDIRECT
extern int __isoc99_vsscanf (const char *__restrict __s,
			     const char *__restrict __format,
			     _G_va_list __arg) __THROW;
#   define vfscanf __isoc99_vfscanf
#   define vscanf __isoc99_vscanf
#   define vsscanf __isoc99_vsscanf
#  endif
# endif

__END_NAMESPACE_C99
#endif /* Use ISO C9x.  */


__BEGIN_NAMESPACE_STD
/* Read a character from STREAM.
   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getchar (void);
__END_NAMESPACE_STD

/* The C standard explicitly says this is a macro, so we always do the
   optimization for it.  */
#define getc(_fp) _IO_getc (_fp)

#if defined __USE_POSIX || defined __USE_MISC
/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
#endif /* Use POSIX or MISC.  */

#ifdef __USE_MISC
/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetc_unlocked (FILE *__stream);
#endif /* Use MISC.  */


__BEGIN_NAMESPACE_STD
/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputc (int __c, FILE *__stream);


#if defined __USE_SVID || defined __USE_MISC \
    || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
/* Get a word (int) from STREAM.  */
extern int getw (FILE *__stream);

/* Write a word (int) to STREAM.  */
#endif
    
#ifdef	__USE_XOPEN2K8
/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR    (and null-terminate it). *LINEPTR is a pointer returned from malloc (or    NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.


   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputs_unlocked (const char *__restrict __s,
			   FILE *__restrict __stream);
#endif
extern void rewind (FILE *__stream);
__END_NAMESPACE_STD

/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions    are originally defined in the Large File Support API.  */   
#if defined __USE_LARGEFILE || defined __USE_XOPEN2K
  
# ifndef __USE_FILE_OFFSET64
/* Seek to a certain position on STREAM.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern int fseeko (FILE *__stream, __off_t __off, int __whence);  /* Return the current position of STREAM.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern __off_t ftello (FILE *__stream) __wur;    
# else
  
#  ifdef __REDIRECT
extern int __REDIRECT (fseeko, 		       (FILE *__stream, __off64_t __off, int __whence), 		       fseeko64);  extern __off64_t __REDIRECT (ftello, (FILE *__stream), ftello64);    
#  else
  
#   define fseeko fseeko64
  
#   define ftello ftello64
  
#  endif
  
# endif
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
/* Set STREAM's position.     This function is a possible cancellation point and therefore not    marked with __THROW.  */extern int fsetpos (FILE *__stream, const fpos_t *__pos);    
#else
  
# ifdef __REDIRECT
extern int __REDIRECT (fgetpos, (FILE *__restrict __stream, 				 fpos_t *__restrict __pos), fgetpos64);  extern int __REDIRECT (fsetpos, 		       (FILE *__stream, const fpos_t *__pos), fsetpos64);    
# else
  
#  define fgetpos fgetpos64
  
#  define fsetpos fsetpos64
  
# endif
  
#endif
    
#if defined __USE_POSIX || defined __USE_MISC
/* These are defined in POSIX.1:1996.  */ /* Acquire ownership of STREAM.  */extern void flockfile (FILE *__stream) __THROW;   /* Try to acquire ownership of STREAM but do not block if it is not    possible.  */extern int ftrylockfile (FILE *__stream) __THROW __wur;   /* Relinquish the ownership granted for STREAM.  */extern void funlockfile (FILE *__stream) __THROW;    
#endif /* POSIX || misc */
   
#if defined __USE_XOPEN && !defined __USE_XOPEN2K && !defined __USE_GNU
/* The X/Open standard requires some functions and variables to be    declared here which do not belong into this header.  But we have to    follow.  In GNU mode we don't do this nonsense.  */
# define __need_getopt
#if 0 /* expanded by -frewrite-includes */
# include <getopt.h>
#endif /* expanded by -frewrite-includes */
#endif	/* X/Open, but not issue 6 and not for GNU.  */

/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */
#ifdef __USE_EXTERN_INLINES
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio.h>
#endif /* expanded by -frewrite-includes */
#endif
#if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio2.h>
#endif /* expanded by -frewrite-includes */
#endif
#ifdef __LDBL_COMPAT
#if 0 /* expanded by -frewrite-includes */
# include <bits/stdio-ldbl.h>
#endif /* expanded by -frewrite-includes */
#endif

__END_DECLS

#endif /* <stdio.h> included.  */

#endif /* !_STDIO_H */

#ifdef __cplusplus
#undef getc
#undef putc
#undef clearerr
#undef feof
#undef ferror

#endif

#endif  // _LIBCPP_STDIO_H

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::fclose;

#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE
using ::fopen;
using ::freopen;
using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;
using ::vprintf;
#endif

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_CSTDIO
#pragma clang module end /*std.compat.cstdio*/
#if 0 /* expanded by -frewrite-includes */
#include <memory>     // for __murmur2_or_cityhash
#endif /* expanded by -frewrite-includes */
#pragma clang module begin std.memory
// -*- C++ -*-
//===-------------------------- memory ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_MEMORY
#define _LIBCPP_MEMORY
template <class _ValueType>
inline _LIBCPP_ALWAYS_INLINE
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {
#if !defined(_LIBCPP_HAS_NO_THREADS) && \
    defined(__ATOMIC_RELAXED) &&        \
    (__has_builtin(__atomic_load_n) || _GNUC_VER >= 407)
    return __atomic_load_n(__value, __ATOMIC_RELAXED);
#else
#endif  // _LIBCPP_HAS_NO_VARIADICS

    template <class _Tp>
        _LIBCPP_INLINE_VISIBILITY
        static void destroy(allocator_type& __a, _Tp* __p)
            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}

    _LIBCPP_INLINE_VISIBILITY
 _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __libcpp_throw_debug_function(__libcpp_debug_info const&);   /// __libcpp_set_debug_function - Set the debug handler to the specified
///    function.
_LIBCPP_FUNC_VIS bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);   // Setup the throwing debug handler during dynamic initialization.
  
#if _LIBCPP_DEBUG_LEVEL >= 1 && defined(_LIBCPP_DEBUG_USE_EXCEPTIONS)
  
# if defined(_LIBCPP_NO_EXCEPTIONS)
  
#   error _LIBCPP_DEBUG_USE_EXCEPTIONS cannot be used when exceptions are disabled.
  
# endif
static bool __init_dummy = __libcpp_set_debug_function(__libcpp_throw_debug_function);    
#endif
   
#if _LIBCPP_DEBUG_LEVEL >= 1 || defined(_LIBCPP_BUILDING_LIBRARY)
class _LIBCPP_EXCEPTION_ABI __libcpp_debug_exception : public exception {  public:   __libcpp_debug_exception() _NOEXCEPT;    explicit __libcpp_debug_exception(__libcpp_debug_info const& __i);    __libcpp_debug_exception(__libcpp_debug_exception const&);    ~__libcpp_debug_exception() _NOEXCEPT;    const char* what() const _NOEXCEPT;  private:   struct __libcpp_debug_exception_imp;    __libcpp_debug_exception_imp *__imp_;  };    
    _LIBCPP_INLINE_VISIBILITY     __c_node(void* __c, __c_node* __next)         : __c_(__c), __next_(__next), beg_(nullptr), end_(nullptr), cap_(nullptr) {  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  // char_traits
 template <class _CharT> struct _LIBCPP_TEMPLATE_VIS char_traits {      typedef _CharT    char_type;      typedef int       int_type;      typedef streamoff off_type;      typedef streampos pos_type;      typedef mbstate_t state_type;       static inline void _LIBCPP_CONSTEXPR_AFTER_CXX14         assign(char_type& __c1, const char_type& __c2) _NOEXCEPT { __c1 = __c2; }      static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT         { return __c1 == __c2; }      static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT         { return __c1 < __c2; }       static _LIBCPP_CONSTEXPR_AFTER_CXX14     int compare(const char_type* __s1, const char_type* __s2, size_t __n);      _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14     size_t length(const char_type* __s);      _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14     const char_type* find(const char_type* __s, size_t __n, const char_type& __a);      static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);      _LIBCPP_INLINE_VISIBILITY     static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);      _LIBCPP_INLINE_VISIBILITY     static char_type*       assign(char_type* __s, size_t __n, char_type __a);       static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT         { return eq_int_type(__c, eof()) ? ~eof() : __c; }      static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT         { return char_type(__c); }      static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT         { return int_type(__c); }      static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT         { return __c1 == __c2; }      static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT         { return int_type(EOF); }  };   template <class _CharT> _LIBCPP_CONSTEXPR_AFTER_CXX14 int char_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n) {      for (;  __n;  --__n, ++__s1, ++__s2)     {          if (lt(*__s1, *__s2))             return -1;          if (lt(*__s2, *__s1))             return 1;      }      return 0;  }   template <class _CharT> inline _LIBCPP_CONSTEXPR_AFTER_CXX14 size_t char_traits<_CharT>::length(const char_type* __s) {      size_t __len = 0;      for (;  !eq(*__s, char_type(0));  ++__s)         ++__len;      return __len;  }   template <class _CharT> inline _LIBCPP_CONSTEXPR_AFTER_CXX14 const _CharT* char_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a) {      for (;  __n;  --__n)     {          if (eq(*__s, __a))             return __s;          ++__s;      }      return 0;  }   template <class _CharT> _CharT* char_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n) {      char_type* __r = __s1;      if (__s1 < __s2)     {          for (;  __n;  --__n, ++__s1, ++__s2)             assign(*__s1, *__s2);      }      else if (__s2 < __s1)     {          __s1 += __n;          __s2 += __n;          for (;  __n;  --__n)             assign(*--__s1, *--__s2);      }      return __r;  }   template <class _CharT> inline _CharT* char_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n) {      _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");      char_type* __r = __s1;      for (;  __n;  --__n, ++__s1, ++__s2)         assign(*__s1, *__s2);      return __r;  }   template <class _CharT> inline _CharT* char_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a) {      char_type* __r = __s;      for (;  __n;  --__n, ++__s)         assign(*__s, __a);      return __r;  }   // char_traits<char>
 template <> struct _LIBCPP_TEMPLATE_VIS char_traits<char> {      typedef char      char_type;      typedef int       int_type;      typedef streamoff off_type;      typedef streampos pos_type;      typedef mbstate_t state_type;       static inline _LIBCPP_CONSTEXPR_AFTER_CXX14     void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT { __c1 = __c2; }      static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT             { return __c1 == __c2; }      static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT         { return (unsigned char)__c1 < (unsigned char)__c2; }       static _LIBCPP_CONSTEXPR_AFTER_CXX14     int compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;      static inline size_t _LIBCPP_CONSTEXPR_AFTER_CXX14     length(const char_type* __s)  _NOEXCEPT { return __builtin_strlen(__s); }      static _LIBCPP_CONSTEXPR_AFTER_CXX14     const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;      static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT         { return __n == 0 ? __s1 : (char_type*) memmove(__s1, __s2, __n); }      static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT         {              _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");              return __n == 0 ? __s1 : (char_type*)memcpy(__s1, __s2, __n);          }      static inline char_type* assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT         { return __n == 0 ? __s : (char_type*)memset(__s, to_int_type(__a), __n); }       static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT         { return eq_int_type(__c, eof()) ? ~eof() : __c; }      static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT         { return char_type(__c); }      static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT         { return int_type((unsigned char)__c); }      static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT         { return __c1 == __c2; }      static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT         { return int_type(EOF); }  };   inline _LIBCPP_CONSTEXPR_AFTER_CXX14 int char_traits<char>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT {      if (__n == 0)         return 0;    
#if __has_feature(cxx_constexpr_string_builtins)
    return __builtin_memcmp(__s1, __s2, __n);    
#elif _LIBCPP_STD_VER <= 14
    return memcmp(__s1, __s2, __n);    
#else
    for (;  __n;  --__n, ++__s1, ++__s2)     {          if (lt(*__s1, *__s2))             return -1;          if (lt(*__s2, *__s1))             return 1;      }      return 0;    
#endif
}   inline _LIBCPP_CONSTEXPR_AFTER_CXX14 const char* char_traits<char>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT {      if (__n == 0)         return NULL;    
#if __has_feature(cxx_constexpr_string_builtins)
    return __builtin_char_memchr(__s, to_int_type(__a), __n);    
#elif _LIBCPP_STD_VER <= 14
    return (const char_type*) memchr(__s, to_int_type(__a), __n);    
#elif _LIBCPP_STD_VER <= 14
    return wmemchr(__s, __a, __n);    
#else
    for (;  __n;  --__n)     {          if (eq(*__s, __a))             return __s;          ++__s;      }      return NULL;    
#endif
}      
#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
 template <> struct _LIBCPP_TEMPLATE_VIS char_traits<char16_t> {      typedef char16_t       char_type;      typedef uint_least16_t int_type;      typedef streamoff      off_type;      typedef u16streampos   pos_type;      typedef mbstate_t      state_type;       static inline _LIBCPP_CONSTEXPR_AFTER_CXX14     void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT { __c1 = __c2; }      static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT         { return __c1 == __c2; }      static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT         { return __c1 < __c2; }       _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14     int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14     size_t           length(const char_type* __s) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14     const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;       static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT         { return eq_int_type(__c, eof()) ? ~eof() : __c; }      static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT         { return char_type(__c); }      static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT         { return int_type(__c); }      static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT         { return __c1 == __c2; }      static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT         { return int_type(0xFFFF); }  };   inline _LIBCPP_CONSTEXPR_AFTER_CXX14 int char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT {      for (;  __n;  --__n, ++__s1, ++__s2)     {          if (lt(*__s1, *__s2))             return -1;          if (lt(*__s2, *__s1))             return 1;      }      return 0;  }   inline _LIBCPP_CONSTEXPR_AFTER_CXX14 size_t char_traits<char16_t>::length(const char_type* __s) _NOEXCEPT {      size_t __len = 0;      for (;  !eq(*__s, char_type(0));  ++__s)         ++__len;      return __len;  }   inline _LIBCPP_CONSTEXPR_AFTER_CXX14 const char16_t* char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT {      for (;  __n;  --__n)     {          if (eq(*__s, __a))             return __s;          ++__s;      }      return 0;  }   inline char16_t* char_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT {      char_type* __r = __s1;      if (__s1 < __s2)     {          for (;  __n;  --__n, ++__s1, ++__s2)             assign(*__s1, *__s2);      }      else if (__s2 < __s1)     {          __s1 += __n;          __s2 += __n;          for (;  __n;  --__n)             assign(*--__s1, *--__s2);      }      return __r;  }   inline char16_t* char_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT {      _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");      char_type* __r = __s1;      for (;  __n;  --__n, ++__s1, ++__s2)         assign(*__s1, *__s2);      return __r;  }   inline char16_t* char_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT {      char_type* __r = __s;      for (;  __n;  --__n, ++__s)         assign(*__s, __a);      return __r;  }   template <> struct _LIBCPP_TEMPLATE_VIS char_traits<char32_t> {      typedef char32_t       char_type;      typedef uint_least32_t int_type;      typedef streamoff      off_type;      typedef u32streampos   pos_type;      typedef mbstate_t      state_type;       static inline _LIBCPP_CONSTEXPR_AFTER_CXX14     void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT { __c1 = __c2; }      static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT         { return __c1 == __c2; }      static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT         { return __c1 < __c2; }       _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14     int              compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14     size_t           length(const char_type* __s) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR_AFTER_CXX14     const char_type* find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT;      _LIBCPP_INLINE_VISIBILITY     static char_type*       assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT;       static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT         { return eq_int_type(__c, eof()) ? ~eof() : __c; }      static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT         { return char_type(__c); }      static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT         { return int_type(__c); }      static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT         { return __c1 == __c2; }      static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT         { return int_type(0xFFFFFFFF); }  };   inline _LIBCPP_CONSTEXPR_AFTER_CXX14 int char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT {      for (;  __n;  --__n, ++__s1, ++__s2)     {          if (lt(*__s1, *__s2))             return -1;          if (lt(*__s2, *__s1))             return 1;      }      return 0;  }   inline _LIBCPP_CONSTEXPR_AFTER_CXX14 size_t char_traits<char32_t>::length(const char_type* __s) _NOEXCEPT {      size_t __len = 0;      for (;  !eq(*__s, char_type(0));  ++__s)         ++__len;      return __len;  }   inline _LIBCPP_CONSTEXPR_AFTER_CXX14 const char32_t* char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) _NOEXCEPT {      for (;  __n;  --__n)     {          if (eq(*__s, __a))             return __s;          ++__s;      }      return 0;  }   inline char32_t* char_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT {      char_type* __r = __s1;      if (__s1 < __s2)     {          for (;  __n;  --__n, ++__s1, ++__s2)             assign(*__s1, *__s2);      }      else if (__s2 < __s1)     {          __s1 += __n;          __s2 += __n;          for (;  __n;  --__n)             assign(*--__s1, *--__s2);      }      return __r;  }   inline char32_t* char_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n) _NOEXCEPT {      _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, "char_traits::copy overlapped range");      char_type* __r = __s1;      for (;  __n;  --__n, ++__s1, ++__s2)         assign(*__s1, *__s2);      return __r;  }   inline char32_t* char_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a) _NOEXCEPT {      char_type* __r = __s;      for (;  __n;  --__n, ++__s)         assign(*__s, __a);      return __r;  }     
#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
 // helper fns for basic_string and string_view
 // __str_find
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_find(const _CharT *__p, _SizeT __sz,               _CharT __c, _SizeT __pos) _NOEXCEPT {      if (__pos >= __sz)         return __npos;      const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);      if (__r == 0)         return __npos;      return static_cast<_SizeT>(__r - __p);  }   template <class _CharT, class _Traits> inline _LIBCPP_CONSTEXPR_AFTER_CXX11 const _CharT * __search_substring(const _CharT *__first1, const _CharT *__last1,                    const _CharT *__first2, const _CharT *__last2) {    // Take advantage of knowing source and pattern lengths.
  // Stop short when source is smaller than pattern.
  const ptrdiff_t __len2 = __last2 - __first2;    if (__len2 == 0)     return __first1;     ptrdiff_t __len1 = __last1 - __first1;    if (__len1 < __len2)     return __last1;     // First element of __first2 is loop invariant.
  _CharT __f2 = *__first2;    while (true) {      __len1 = __last1 - __first1;      // Check whether __first1 still has at least __len2 bytes.
    if (__len1 < __len2)       return __last1;       // Find __f2 the first byte matching in __first1.
    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);      if (__first1 == 0)       return __last1;       // It is faster to compare from the first byte of __first1 even if we
    // already know that it matches the first byte of __first2: this is because
    // __first2 is most likely aligned, as it is user's "pattern" string, and
    // __first1 + 1 is most likely not aligned, as the match is in the middle of
    // the string.
    if (_Traits::compare(__first1, __first2, __len2) == 0)       return __first1;       ++__first1;    }  }   template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_find(const _CharT *__p, _SizeT __sz,         const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT {      if (__pos > __sz)         return __npos;       if (__n == 0) // There is nothing to search, just return __pos.
        return __pos;       const _CharT *__r = __search_substring<_CharT, _Traits>(         __p + __pos, __p + __sz, __s, __s + __n);       if (__r == __p + __sz)         return __npos;      return static_cast<_SizeT>(__r - __p);  }    // __str_rfind
 template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_rfind(const _CharT *__p, _SizeT __sz,                _CharT __c, _SizeT __pos) _NOEXCEPT {      if (__sz < 1)         return __npos;      if (__pos < __sz)         ++__pos;      else         __pos = __sz;      for (const _CharT* __ps = __p + __pos;  __ps != __p; )     {          if (_Traits::eq(*--__ps, __c))             return static_cast<_SizeT>(__ps - __p);      }      return __npos;  }   template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_rfind(const _CharT *__p, _SizeT __sz,          const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT {      __pos = _VSTD::min(__pos, __sz);      if (__n < __sz - __pos)         __pos += __n;      else         __pos = __sz;      const _CharT* __r = _VSTD::__find_end(                   __p, __p + __pos, __s, __s + __n, _Traits::eq,                          random_access_iterator_tag(), random_access_iterator_tag());      if (__n > 0 && __r == __p + __pos)         return __npos;      return static_cast<_SizeT>(__r - __p);  }   // __str_find_first_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_find_first_of(const _CharT *__p, _SizeT __sz,                 const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT {      if (__pos >= __sz || __n == 0)         return __npos;      const _CharT* __r = _VSTD::__find_first_of_ce         (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );      if (__r == __p + __sz)         return __npos;      return static_cast<_SizeT>(__r - __p);  }    // __str_find_last_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_find_last_of(const _CharT *__p, _SizeT __sz,                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT     {      if (__n != 0)     {          if (__pos < __sz)             ++__pos;          else             __pos = __sz;          for (const _CharT* __ps = __p + __pos;  __ps != __p; )         {              const _CharT* __r = _Traits::find(__s, __n, *--__ps);              if (__r)                 return static_cast<_SizeT>(__ps - __p);          }      }      return __npos;  }    // __str_find_first_not_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_find_first_not_of(const _CharT *__p, _SizeT __sz,                     const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT {      if (__pos < __sz)     {          const _CharT* __pe = __p + __sz;          for (const _CharT* __ps = __p + __pos;  __ps != __pe;  ++__ps)             if (_Traits::find(__s, __n, *__ps) == 0)                 return static_cast<_SizeT>(__ps - __p);      }      return __npos;  }    template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_find_first_not_of(const _CharT *__p, _SizeT __sz,                           _CharT __c, _SizeT __pos) _NOEXCEPT {      if (__pos < __sz)     {          const _CharT* __pe = __p + __sz;          for (const _CharT* __ps = __p + __pos;  __ps != __pe;  ++__ps)             if (!_Traits::eq(*__ps, __c))                 return static_cast<_SizeT>(__ps - __p);      }      return __npos;  }    // __str_find_last_not_of
template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_find_last_not_of(const _CharT *__p, _SizeT __sz,                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT {      if (__pos < __sz)         ++__pos;      else         __pos = __sz;      for (const _CharT* __ps = __p + __pos;  __ps != __p; )         if (_Traits::find(__s, __n, *--__ps) == 0)             return static_cast<_SizeT>(__ps - __p);      return __npos;  }    template<class _CharT, class _SizeT, class _Traits, _SizeT __npos> inline _SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY __str_find_last_not_of(const _CharT *__p, _SizeT __sz,                          _CharT __c, _SizeT __pos) _NOEXCEPT {      if (__pos < __sz)         ++__pos;      else         __pos = __sz;      for (const _CharT* __ps = __p + __pos;  __ps != __p; )         if (!_Traits::eq(*--__ps, __c))             return static_cast<_SizeT>(__ps - __p);      return __npos;  }   template<class _Ptr> inline _LIBCPP_INLINE_VISIBILITY size_t __do_string_hash(_Ptr __p, _Ptr __e) {      typedef typename iterator_traits<_Ptr>::value_type value_type;      return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));  }   template <class _CharT, class _Iter, class _Traits=char_traits<_CharT> > struct __quoted_output_proxy {      _Iter  __first;      _Iter  __last;      _CharT  __delim;      _CharT  __escape;       __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)     : __first(__f), __last(__l), __delim(__d), __escape(__e) { }      //  This would be a nice place for a string_ref 
};   _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP___STRING
  
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ALGORITHM
  
#define _LIBCPP_ALGORITHM
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_length_error(const char*__msg) {    
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw length_error(__msg);    
#else
    ((void)__msg);  	  _VSTD::abort();    
#endif
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_overflow_error(const char*__msg) {    
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw overflow_error(__msg);    
#else
    ((void)__msg);      _VSTD::abort();      
#endif // _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
    
#ifdef min
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template<class _CharT, class _Traits = char_traits<_CharT> > class _LIBCPP_TEMPLATE_VIS basic_string_view {  public: 	// types
	typedef _Traits                                    traits_type;  	typedef _CharT                                     value_type;  	typedef const _CharT*                              pointer;  	typedef const _CharT*                              const_pointer;  	typedef const _CharT&                              reference;  	typedef const _CharT&                              const_reference;  	typedef const_pointer                              const_iterator;  // See [string.view.iterators]
	typedef const_iterator                             iterator;  	typedef _VSTD::reverse_iterator<const_iterator>    const_reverse_iterator;  	typedef const_reverse_iterator                     reverse_iterator;  	typedef size_t                                     size_type;  	typedef ptrdiff_t                                  difference_type;  	static _LIBCPP_CONSTEXPR const size_type npos = -1;  // size_type(-1);
     static_assert(is_pod<value_type>::value, "Character type of basic_string_view must be a POD");      static_assert((is_same<_CharT, typename traits_type::char_type>::value),                   "traits_type::char_type must be the same type as CharT");   	// [string.view.cons], construct/copy
	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	basic_string_view() _NOEXCEPT : __data (nullptr), __size(0) { }   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	basic_string_view(const basic_string_view&) _NOEXCEPT = default;   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	basic_string_view& operator=(const basic_string_view&) _NOEXCEPT = default;   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	basic_string_view(const _CharT* __s, size_type __len) 		: __data(__s), __size(__len) 	{  // #if _LIBCPP_STD_VER > 11
//         _LIBCPP_ASSERT(__len == 0 || __s != nullptr, "string_view::string_view(_CharT *, size_t): received nullptr");
// #endif
	}   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	basic_string_view(const _CharT* __s) 		: __data(__s), __size(_Traits::length(__s)) { }   	// [string.view.iterators], iterators
	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_iterator begin()  const _NOEXCEPT {  return cbegin();  }   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_iterator end()    const _NOEXCEPT {  return cend();  }   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_iterator cbegin() const _NOEXCEPT {  return __data;  }   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_iterator cend()   const _NOEXCEPT {  return __data + __size;  }   	_LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY 	const_reverse_iterator rbegin()   const _NOEXCEPT {  return const_reverse_iterator(cend());  }   	_LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY 	const_reverse_iterator rend()     const _NOEXCEPT {  return const_reverse_iterator(cbegin());  }   	_LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY 	const_reverse_iterator crbegin()  const _NOEXCEPT {  return const_reverse_iterator(cend());  }   	_LIBCPP_CONSTEXPR_AFTER_CXX14 _LIBCPP_INLINE_VISIBILITY 	const_reverse_iterator crend()    const _NOEXCEPT {  return const_reverse_iterator(cbegin());  }   	// [string.view.capacity], capacity
	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	size_type size()     const _NOEXCEPT {  return __size;  }   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	size_type length()   const _NOEXCEPT {  return __size;  }   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	size_type max_size() const _NOEXCEPT {  return numeric_limits<size_type>::max();  }   	_LIBCPP_CONSTEXPR bool _LIBCPP_INLINE_VISIBILITY 	empty()         const _NOEXCEPT {  return __size == 0;  }   	// [string.view.access], element access
	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_reference operator[](size_type __pos) const _NOEXCEPT {  return __data[__pos];  }   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_reference at(size_type __pos) const 	{  		return __pos >= size() 			? (__throw_out_of_range("string_view::at"), __data[0]) 			: __data[__pos];  	}   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_reference front() const 	{  		return _LIBCPP_ASSERT(!empty(), "string_view::front(): string is empty"), __data[0];  	}   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_reference back() const 	{  		return _LIBCPP_ASSERT(!empty(), "string_view::back(): string is empty"), __data[__size-1];  	}   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	const_pointer data() const _NOEXCEPT {  return __data;  }   	// [string.view.modifiers], modifiers:
	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	void remove_prefix(size_type __n) _NOEXCEPT 	{  		_LIBCPP_ASSERT(__n <= size(), "remove_prefix() can't remove more than size()");  		__data += __n;  		__size -= __n;  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	void remove_suffix(size_type __n) _NOEXCEPT 	{  		_LIBCPP_ASSERT(__n <= size(), "remove_suffix() can't remove more than size()");  		__size -= __n;  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	void swap(basic_string_view& __other) _NOEXCEPT 	{  		const value_type *__p = __data;  		__data = __other.__data;  		__other.__data = __p;   		size_type __sz = __size;  		__size = __other.__size;  		__other.__size = __sz;  	}   	_LIBCPP_INLINE_VISIBILITY 	size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const 	{  		if (__pos > size()) 			__throw_out_of_range("string_view::copy");  		size_type __rlen = _VSTD::min(__n, size() - __pos);  		_Traits::copy(__s, data() + __pos, __rlen);  		return __rlen;  	}   	_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY 	basic_string_view substr(size_type __pos = 0, size_type __n = npos) const 	{  		return __pos > size() 			? (__throw_out_of_range("string_view::substr"), basic_string_view()) 			: basic_string_view(data() + __pos, _VSTD::min(__n, size() - __pos));  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 int compare(basic_string_view __sv) const _NOEXCEPT 	{  		size_type __rlen = _VSTD::min( size(), __sv.size());  		int __retval = _Traits::compare(data(), __sv.data(), __rlen);  		if ( __retval == 0 ) // first __rlen chars matched
			__retval = size() == __sv.size() ? 0 : ( size() < __sv.size() ? -1 : 1 );  		return __retval;  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	int compare(size_type __pos1, size_type __n1, basic_string_view __sv) const 	{  		return substr(__pos1, __n1).compare(__sv);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	int compare(                       size_type __pos1, size_type __n1,  				basic_string_view __sv, size_type __pos2, size_type __n2) const 	{  		return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	int compare(const _CharT* __s) const _NOEXCEPT 	{  		return compare(basic_string_view(__s));  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	int compare(size_type __pos1, size_type __n1, const _CharT* __s) const 	{  		return substr(__pos1, __n1).compare(basic_string_view(__s));  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const 	{  		return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));  	}   	// find
	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find(basic_string_view __s, size_type __pos = 0) const _NOEXCEPT 	{  		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find(): received nullptr");  		return __str_find<value_type, size_type, traits_type, npos> 			(data(), size(), __s.data(), __pos, __s.size());  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find(_CharT __c, size_type __pos = 0) const _NOEXCEPT 	{  		return __str_find<value_type, size_type, traits_type, npos> 			(data(), size(), __c, __pos);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find(const _CharT* __s, size_type __pos, size_type __n) const 	{  		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find(): received nullptr");  		return __str_find<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, __n);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find(const _CharT* __s, size_type __pos = 0) const 	{  		_LIBCPP_ASSERT(__s != nullptr, "string_view::find(): received nullptr");  		return __str_find<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, traits_type::length(__s));  	}   	// rfind
	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type rfind(basic_string_view __s, size_type __pos = npos) const _NOEXCEPT 	{  		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find(): received nullptr");  		return __str_rfind<value_type, size_type, traits_type, npos> 			(data(), size(), __s.data(), __pos, __s.size());  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type rfind(_CharT __c, size_type __pos = npos) const _NOEXCEPT 	{  		return __str_rfind<value_type, size_type, traits_type, npos> 			(data(), size(), __c, __pos);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const 	{  		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::rfind(): received nullptr");  		return __str_rfind<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, __n);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type rfind(const _CharT* __s, size_type __pos=npos) const 	{  		_LIBCPP_ASSERT(__s != nullptr, "string_view::rfind(): received nullptr");  		return __str_rfind<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, traits_type::length(__s));  	}   	// find_first_of
	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_first_of(basic_string_view __s, size_type __pos = 0) const _NOEXCEPT 	{  		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_first_of(): received nullptr");  		return __str_find_first_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s.data(), __pos, __s.size());  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_first_of(_CharT __c, size_type __pos = 0) const _NOEXCEPT 	{  return find(__c, __pos);  }   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const 	{  		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_first_of(): received nullptr");  		return __str_find_first_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, __n);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_first_of(const _CharT* __s, size_type __pos=0) const 	{  		_LIBCPP_ASSERT(__s != nullptr, "string_view::find_first_of(): received nullptr");  		return __str_find_first_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, traits_type::length(__s));  	}   	// find_last_of
	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_last_of(basic_string_view __s, size_type __pos=npos) const _NOEXCEPT 	{  		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_last_of(): received nullptr");  		return __str_find_last_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s.data(), __pos, __s.size());  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_last_of(_CharT __c, size_type __pos = npos) const _NOEXCEPT 	{  return rfind(__c, __pos);  }   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const 	{  		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_last_of(): received nullptr");  		return __str_find_last_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, __n);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_last_of(const _CharT* __s, size_type __pos=npos) const 	{  		_LIBCPP_ASSERT(__s != nullptr, "string_view::find_last_of(): received nullptr");  		return __str_find_last_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, traits_type::length(__s));  	}   	// find_first_not_of
	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_first_not_of(basic_string_view __s, size_type __pos=0) const _NOEXCEPT 	{  		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_first_not_of(): received nullptr");  		return __str_find_first_not_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s.data(), __pos, __s.size());  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_first_not_of(_CharT __c, size_type __pos=0) const _NOEXCEPT 	{  		return __str_find_first_not_of<value_type, size_type, traits_type, npos> 			(data(), size(), __c, __pos);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const 	{  		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_first_not_of(): received nullptr");  		return __str_find_first_not_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, __n);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const 	{  		_LIBCPP_ASSERT(__s != nullptr, "string_view::find_first_not_of(): received nullptr");  		return __str_find_first_not_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, traits_type::length(__s));  	}   	// find_last_not_of
	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const _NOEXCEPT 	{  		_LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_last_not_of(): received nullptr");  		return __str_find_last_not_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s.data(), __pos, __s.size());  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_last_not_of(_CharT __c, size_type __pos=npos) const _NOEXCEPT 	{  		return __str_find_last_not_of<value_type, size_type, traits_type, npos> 			(data(), size(), __c, __pos);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const 	{  		_LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_last_not_of(): received nullptr");  		return __str_find_last_not_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, __n);  	}   	_LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 	size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const 	{  		_LIBCPP_ASSERT(__s != nullptr, "string_view::find_last_not_of(): received nullptr");  		return __str_find_last_not_of<value_type, size_type, traits_type, npos> 			(data(), size(), __s, __pos, traits_type::length(__s));  	}   private: 	const   value_type* __data;  	size_type           __size;  };    // [string.view.comparison]
// operator ==
template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator==(basic_string_view<_CharT, _Traits> __lhs, 				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	if ( __lhs.size() != __rhs.size()) return false;  	return __lhs.compare(__rhs) == 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator==(basic_string_view<_CharT, _Traits> __lhs, 				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT {  	if ( __lhs.size() != __rhs.size()) return false;  	return __lhs.compare(__rhs) == 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator==(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,  				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	if ( __lhs.size() != __rhs.size()) return false;  	return __lhs.compare(__rhs) == 0;  }    // operator !=
template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	if ( __lhs.size() != __rhs.size()) 		return true;  	return __lhs.compare(__rhs) != 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator!=(basic_string_view<_CharT, _Traits> __lhs, 				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT {  	if ( __lhs.size() != __rhs.size()) 		return true;  	return __lhs.compare(__rhs) != 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator!=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,  				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	if ( __lhs.size() != __rhs.size()) 		return true;  	return __lhs.compare(__rhs) != 0;  }    // operator <
template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) < 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator<(basic_string_view<_CharT, _Traits> __lhs, 				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) < 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator<(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,  				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) < 0;  }    // operator >
template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) > 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator>(basic_string_view<_CharT, _Traits> __lhs, 				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) > 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator>(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,  				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) > 0;  }    // operator <=
template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) <= 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator<=(basic_string_view<_CharT, _Traits> __lhs, 				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) <= 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator<=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,  				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) <= 0;  }    // operator >=
template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) >= 0;  }    template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator>=(basic_string_view<_CharT, _Traits> __lhs, 				typename common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) >= 0;  }   template<class _CharT, class _Traits> _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY bool operator>=(typename common_type<basic_string_view<_CharT, _Traits> >::type __lhs,  				basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT {  	return __lhs.compare(__rhs) >= 0;  }   typedef basic_string_view<char>     string_view;  typedef basic_string_view<char16_t> u16string_view;  typedef basic_string_view<char32_t> u32string_view;  typedef basic_string_view<wchar_t>  wstring_view;   // [string.view.hash]
template<class _CharT, class _Traits> struct _LIBCPP_TEMPLATE_VIS hash<basic_string_view<_CharT, _Traits> >     : public unary_function<basic_string_view<_CharT, _Traits>, size_t> {      size_t operator()(const basic_string_view<_CharT, _Traits> __val) const _NOEXCEPT;  };   template<class _CharT, class _Traits> size_t hash<basic_string_view<_CharT, _Traits> >::operator()(         const basic_string_view<_CharT, _Traits> __val) const _NOEXCEPT {      return __do_string_hash(__val.data(), __val.data() + __val.size());  }      
#if _LIBCPP_STD_VER > 11 
inline namespace literals {    inline namespace string_view_literals   {      inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     basic_string_view<char> operator "" sv(const char *__str, size_t __len)     {          return basic_string_view<char> (__str, __len);      }       inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     basic_string_view<wchar_t> operator "" sv(const wchar_t *__str, size_t __len)     {          return basic_string_view<wchar_t> (__str, __len);      }       inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     basic_string_view<char16_t> operator "" sv(const char16_t *__str, size_t __len)     {          return basic_string_view<char16_t> (__str, __len);      }       inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     basic_string_view<char32_t> operator "" sv(const char32_t *__str, size_t __len)     {          return basic_string_view<char32_t> (__str, __len);      }    }  }    
#endif
_LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif // _LIBCPP_STRING_VIEW
  
#pragma clang module end /*std.string_view*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <iosfwd>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.iosfwd
// -*- C++ -*-
//===--------------------------- iosfwd -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_IOSFWD
  
#define _LIBCPP_IOSFWD
#if 0 /* expanded by -frewrite-includes */
  
#include <wchar.h>  // for mbstate_t
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CCTYPE
  
#define _LIBCPP_CCTYPE
 /*     cctype synopsis  namespace std {   int isalnum(int c);  int isalpha(int c);  int isblank(int c);   // C99
int iscntrl(int c);  int isdigit(int c);  int isgraph(int c);  int islower(int c);  int isprint(int c);  int ispunct(int c);  int isspace(int c);  int isupper(int c);  int isxdigit(int c);  int tolower(int c);  int toupper(int c);   }
    // std
*/
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
       __i_node& operator=(const __i_node&) = delete;
     
#else
private:     __i_node(const __i_node&);
       __i_node& operator=(const __i_node&);
   public:   
#endif
        __libcpp_db();
   public:   
#ifndef _LIBCPP_CXX03_LANG
    __libcpp_db(const __libcpp_db&) = delete;
       __libcpp_db& operator=(const __libcpp_db&) = delete;
  _LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  // fpos
 template <class _StateT> class _LIBCPP_TEMPLATE_VIS fpos {
   private:     _StateT __st_;
       streamoff __off_;
   public:     _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {
  }
        _LIBCPP_INLINE_VISIBILITY operator streamoff() const {
  return __off_;
  }
        _LIBCPP_INLINE_VISIBILITY _StateT state() const {
  }
   };
    template <class _StateT> inline _LIBCPP_INLINE_VISIBILITY streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)     {
  return streamoff(__x) - streamoff(__y);
  }
    template <class _StateT> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)     {
  return streamoff(__x) == streamoff(__y);
  }
    template <class _StateT> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)     {
  return streamoff(__x) != streamoff(__y);
  }
    // basic_string
 template<class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator>& __x,           const basic_string<_CharT, _Traits, _Allocator>& __y);
    template<class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);
    template<class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);
    template<class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);
    template<class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);
    _LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))  template <bool> class _LIBCPP_TEMPLATE_VIS __basic_string_common {
   protected:     _LIBCPP_NORETURN void __throw_length_error() const;
       _LIBCPP_NORETURN void __throw_out_of_range() const;
   };
    template <bool __b> void __basic_string_common<__b>::__throw_length_error() const {
       _VSTD::__throw_length_error("basic_string");
   }
    template <bool __b> void __basic_string_common<__b>::__throw_out_of_range() const {
       _VSTD::__throw_out_of_range("basic_string");
   }
    _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __basic_string_common<true>)    
#ifdef _LIBCPP_NO_EXCEPTIONS
template <class _Iter> struct __libcpp_string_gets_noexcept_iterator_impl : public true_type {
  };
     
#elif defined(_LIBCPP_HAS_NO_NOEXCEPT)
template <class _Iter> struct __libcpp_string_gets_noexcept_iterator_impl : public false_type {
  };
     
#else
template <class _Iter, bool = __is_forward_iterator<_Iter>::value> struct __libcpp_string_gets_noexcept_iterator_impl : public _LIBCPP_BOOL_CONSTANT((     noexcept(++(declval<_Iter&>())) &&      is_nothrow_assignable<_Iter&, _Iter>::value &&      noexcept(declval<_Iter>() == declval<_Iter>()) &&      noexcept(*declval<_Iter>()) )) {
  };
    template <class _Iter>  struct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false> : public false_type {
  };
     
#endif
  template <class _Iter> struct __libcpp_string_gets_noexcept_iterator     : public _LIBCPP_BOOL_CONSTANT(__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value) {
  };
    template <class _CharT, class _Traits, class _Tp> struct __can_be_converted_to_string_view : public _LIBCPP_BOOL_CONSTANT( 	( is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&      !is_convertible<const _Tp&, const _CharT*>::value)) {
  };
      
#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
 template <class _CharT, size_t = sizeof(_CharT)> struct __padding {
       unsigned char __xx[sizeof(_CharT)-1];
   };
    template <class _CharT> struct __padding<_CharT, 1> {
   };
      
#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
 template<class _CharT, class _Traits, class _Allocator> class _LIBCPP_TEMPLATE_VIS basic_string     : private __basic_string_common<true> {
   public:     typedef basic_string                                 __self;
       typedef basic_string_view<_CharT, _Traits>           __self_view;
       typedef _Traits                                      traits_type;
       typedef _CharT                                       value_type;
       typedef _Allocator                                   allocator_type;
       typedef allocator_traits<allocator_type>             __alloc_traits;
       typedef typename __alloc_traits::size_type           size_type;
       typedef typename __alloc_traits::difference_type     difference_type;
       typedef value_type&                                  reference;
       typedef const value_type&                            const_reference;
       typedef typename __alloc_traits::pointer             pointer;
       typedef typename __alloc_traits::const_pointer       const_pointer;
        static_assert(is_pod<value_type>::value, "Character type of basic_string must be a POD");
       static_assert((is_same<_CharT, typename traits_type::char_type>::value),                   "traits_type::char_type must be the same type as CharT");
       static_assert((is_same<typename allocator_type::value_type, value_type>::value),                   "Allocator::value_type must be same type as value_type");
     
#if defined(_LIBCPP_RAW_ITERATORS)
    typedef pointer                                      iterator;
       typedef const_pointer                                const_iterator;
     
#else  // defined(_LIBCPP_RAW_ITERATORS)
    typedef __wrap_iter<pointer>                         iterator;
       typedef __wrap_iter<const_pointer>                   const_iterator;
     
#endif  // defined(_LIBCPP_RAW_ITERATORS)
    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;
       typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;
    private:    
#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
     struct __long     {
           pointer   __data_;
           size_type __size_;
           size_type __cap_;
       };
      
#if _LIBCPP_BIG_ENDIAN
    static const size_type __short_mask = 0x01;
       static const size_type __long_mask  = 0x1ul;
     
#else  // _LIBCPP_BIG_ENDIAN
    static const size_type __short_mask = 0x80;
       static const size_type __long_mask  = ~(size_type(~0) >> 1);
     
#endif  // _LIBCPP_BIG_ENDIAN
#else
     struct __long     {
           size_type __cap_;
           size_type __size_;
           pointer   __data_;
       };
      
#if _LIBCPP_BIG_ENDIAN
    static const size_type __short_mask = 0x80;
       static const size_type __long_mask  = ~(size_type(~0) >> 1);
     
#else  // _LIBCPP_BIG_ENDIAN
    static const size_type __short_mask = 0x01;
       static const size_type __long_mask  = 0x1ul;
     
#endif  // _LIBCPP_BIG_ENDIAN
     enum {
  __min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?                       (sizeof(__long) - 1)/sizeof(value_type) : 2};
        struct __short     {
           union         {              unsigned char __size_;              value_type __lx;          };
           value_type __data_[__min_cap];
       };
      
#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
     union __ulx{
  __long __lx;
   __short __lxx;
  };
        enum {
  __n_words = sizeof(__ulx) / sizeof(size_type)};
        struct __raw     {
           size_type __words[__n_words];
       };
        struct __rep     {
           union         {              __long  __l;              __short __s;              __raw   __r;          };
       };
        __compressed_pair<__rep, allocator_type> __r_;
    public:     static const size_type npos = -1;
        _LIBCPP_INLINE_VISIBILITY basic_string()         _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);
        _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a)   
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);
     
#else
        _NOEXCEPT;
     
#endif
     basic_string(const basic_string& __str);
       basic_string(const basic_string& __str, const allocator_type& __a);
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     basic_string(basic_string&& __str)   
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
     
#else
        _NOEXCEPT;
     
#endif
     _LIBCPP_INLINE_VISIBILITY     basic_string(basic_string&& __str, const allocator_type& __a);
     
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY basic_string(const _CharT* __s);
       _LIBCPP_INLINE_VISIBILITY     basic_string(const _CharT* __s, const _Allocator& __a);
       _LIBCPP_INLINE_VISIBILITY     basic_string(const _CharT* __s, size_type __n);
       _LIBCPP_INLINE_VISIBILITY     basic_string(const _CharT* __s, size_type __n, const _Allocator& __a);
       _LIBCPP_INLINE_VISIBILITY     basic_string(size_type __n, _CharT __c);
       _LIBCPP_INLINE_VISIBILITY     basic_string(size_type __n, _CharT __c, const _Allocator& __a);
       basic_string(const basic_string& __str, size_type __pos, size_type __n,                  const _Allocator& __a = _Allocator());
       _LIBCPP_INLINE_VISIBILITY     basic_string(const basic_string& __str, size_type __pos,                  const _Allocator& __a = _Allocator());
       template<class _Tp>         _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS         basic_string(const _Tp& __t, size_type __pos, size_type __n,                      const allocator_type& __a = allocator_type(),                      typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type* = 0);
       _LIBCPP_INLINE_VISIBILITY explicit     basic_string(__self_view __sv);
       _LIBCPP_INLINE_VISIBILITY     basic_string(__self_view __sv, const _Allocator& __a);
       template<class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         basic_string(_InputIterator __first, _InputIterator __last);
       template<class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     basic_string(initializer_list<_CharT> __il);
       _LIBCPP_INLINE_VISIBILITY     basic_string(initializer_list<_CharT> __il, const _Allocator& __a);
     
#endif  // _LIBCPP_CXX03_LANG
     inline ~basic_string();
        _LIBCPP_INLINE_VISIBILITY     operator __self_view() const _NOEXCEPT {
   return __self_view(data(), size());
   }
        basic_string& operator=(const basic_string& __str);
      
#ifndef _LIBCPP_CXX03_LANG
    template <class = void>   
#endif
    _LIBCPP_INLINE_VISIBILITY     basic_string& operator=(__self_view __sv)  {
  return assign(__sv);
  }
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     basic_string& operator=(basic_string&& __str)         _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
        _LIBCPP_INLINE_VISIBILITY     basic_string& operator=(initializer_list<value_type> __il) {
  return assign(__il.begin(), __il.size());
  }
     
#endif
    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {
  return assign(__s);
  }
       basic_string& operator=(value_type __c);
      
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     iterator begin() _NOEXCEPT         {
       _LIBCPP_INLINE_VISIBILITY     const_iterator end() const _NOEXCEPT         {
  return const_iterator(this, __get_pointer() + size());
  }
     
#else
    _LIBCPP_INLINE_VISIBILITY     iterator begin() _NOEXCEPT         {
  return iterator(__get_pointer());
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin() const _NOEXCEPT         {
  return const_iterator(__get_pointer());
  }
       _LIBCPP_INLINE_VISIBILITY     iterator end() _NOEXCEPT         {
  return iterator(__get_pointer() + size());
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator end() const _NOEXCEPT         {
  return const_iterator(__get_pointer() + size());
  }
     
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     reverse_iterator rbegin() _NOEXCEPT         {
  return reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rbegin() const _NOEXCEPT         {
  return const_reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     reverse_iterator rend() _NOEXCEPT         {
  return reverse_iterator(begin());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rend() const _NOEXCEPT         {
  return const_reverse_iterator(begin());
  }
        _LIBCPP_INLINE_VISIBILITY     const_iterator cbegin() const _NOEXCEPT         {
  return begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator cend() const _NOEXCEPT         {
  return end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crbegin() const _NOEXCEPT         {
  return rbegin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crend() const _NOEXCEPT         {
  return rend();
  }
        _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT         {
  return __is_long() ? __get_long_size() : __get_short_size();
  }
       _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {
  return size();
  }
       _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT         {
  return (__is_long() ? __get_long_cap()                              : static_cast<size_type>(__min_cap)) - 1;
  }
        void resize(size_type __n, value_type __c);
       _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {
  resize(__n, value_type());
  }
        void reserve(size_type __res_arg = 0);
       _LIBCPP_INLINE_VISIBILITY     void shrink_to_fit() _NOEXCEPT {
  reserve();
  }
       _LIBCPP_INLINE_VISIBILITY     void clear() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {
  return size() == 0;
  }
        _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos)       _NOEXCEPT;
        const_reference at(size_type __n) const;
       reference       at(size_type __n);
        _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {
  return append(__str);
  }
       _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(__self_view __sv)          {
  return append(__sv);
  }
       _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)     {
  return append(__s);
  }
       _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {
  push_back(__c);
   return *this;
  }
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {
  return append(__il);
  }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     basic_string& append(const basic_string& __str);
       _LIBCPP_INLINE_VISIBILITY     basic_string& append(__self_view __sv) {
   return append(__sv.data(), __sv.size());
   }
       basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);
       template <class _Tp>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,             basic_string&         >::type                   append(const _Tp& __t, size_type __pos, size_type __n=npos);
       basic_string& append(const value_type* __s, size_type __n);
       basic_string& append(const value_type* __s);
       basic_string& append(size_type __n, value_type __c);
       template <class _ForwardIterator>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     basic_string& __append_forward_unsafe(_ForwardIterator, _ForwardIterator);
       template<class _InputIterator>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __is_exactly_input_iterator<_InputIterator>::value                 || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,             basic_string&         >::type     _LIBCPP_INLINE_VISIBILITY     append(_InputIterator __first, _InputIterator __last) {
         const basic_string __temp (__first, __last, __alloc());
         append(__temp.data(), __temp.size());
         return *this;
       }
       template<class _ForwardIterator>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value                 && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,             basic_string&         >::type     _LIBCPP_INLINE_VISIBILITY     append(_ForwardIterator __first, _ForwardIterator __last) {
         return __append_forward_unsafe(__first, __last);
       }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     basic_string& append(initializer_list<value_type> __il) {
  return append(__il.begin(), __il.size());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     void push_back(value_type __c);
       _LIBCPP_INLINE_VISIBILITY     void pop_back();
       _LIBCPP_INLINE_VISIBILITY reference       front();
       _LIBCPP_INLINE_VISIBILITY const_reference front() const;
       _LIBCPP_INLINE_VISIBILITY reference       back();
       _LIBCPP_INLINE_VISIBILITY const_reference back() const;
        _LIBCPP_INLINE_VISIBILITY     basic_string& assign(__self_view __sv) {
   return assign(__sv.data(), __sv.size());
   }
       _LIBCPP_INLINE_VISIBILITY     basic_string& assign(const basic_string& __str) {
   return *this = __str;
   }
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     basic_string& assign(basic_string&& __str)         _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))         {
  *this = _VSTD::move(__str);
   return *this;
  }
     
#endif
    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);
       template <class _Tp>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,             basic_string&         >::type                   assign(const _Tp & __t, size_type __pos, size_type __n=npos);
       basic_string& assign(const value_type* __s, size_type __n);
       basic_string& assign(const value_type* __s);
       basic_string& assign(size_type __n, value_type __c);
       template<class _InputIterator>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <            __is_exactly_input_iterator<_InputIterator>::value                 || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,             basic_string&         >::type         assign(_InputIterator __first, _InputIterator __last);
       template<class _ForwardIterator>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value                  && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,             basic_string&         >::type         assign(_ForwardIterator __first, _ForwardIterator __last);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     basic_string& assign(initializer_list<value_type> __il) {
  return assign(__il.begin(), __il.size());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     basic_string& insert(size_type __pos1, const basic_string& __str);
       _LIBCPP_INLINE_VISIBILITY     basic_string& insert(size_type __pos1, __self_view __sv) {
   return insert(__pos1, __sv.data(), __sv.size());
   }
       template <class _Tp>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,             basic_string&         >::type                   insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n=npos);
       basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);
       basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
       basic_string& insert(size_type __pos, const value_type* __s);
       basic_string& insert(size_type __pos, size_type __n, value_type __c);
       iterator      insert(const_iterator __pos, value_type __c);
       _LIBCPP_INLINE_VISIBILITY     iterator      insert(const_iterator __pos, size_type __n, value_type __c);
       template<class _InputIterator>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <            __is_exactly_input_iterator<_InputIterator>::value                 || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,             iterator         >::type         insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
       template<class _ForwardIterator>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value                  && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,             iterator         >::type         insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __pos, initializer_list<value_type> __il)                     {
  return insert(__pos, __il.begin(), __il.end());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     basic_string& erase(size_type __pos = 0, size_type __n = npos);
       _LIBCPP_INLINE_VISIBILITY     iterator      erase(const_iterator __pos);
       _LIBCPP_INLINE_VISIBILITY     iterator      erase(const_iterator __first, const_iterator __last);
        _LIBCPP_INLINE_VISIBILITY     basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);
       _LIBCPP_INLINE_VISIBILITY     basic_string& replace(size_type __pos1, size_type __n1, __self_view __sv) {
   return replace(__pos1, __n1, __sv.data(), __sv.size());
   }
       basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);
       template <class _Tp>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,             basic_string&         >::type                   replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos);
       basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
       basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
       basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);
       _LIBCPP_INLINE_VISIBILITY     basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);
       _LIBCPP_INLINE_VISIBILITY     basic_string& replace(const_iterator __i1, const_iterator __i2, __self_view __sv) {
   return replace(__i1 - begin(), __i2 - __i1, __sv);
   }
       _LIBCPP_INLINE_VISIBILITY     basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);
       _LIBCPP_INLINE_VISIBILITY     basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);
       _LIBCPP_INLINE_VISIBILITY     basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);
       template<class _InputIterator>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     typename enable_if         <             __is_input_iterator<_InputIterator>::value,             basic_string&         >::type         replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)         {
  return replace(__i1, __i2, __il.begin(), __il.end());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;
       _LIBCPP_INLINE_VISIBILITY     basic_string substr(size_type __pos = 0, size_type __n = npos) const;
        _LIBCPP_INLINE_VISIBILITY     void swap(basic_string& __str)   
#if _LIBCPP_STD_VER >= 14
        _NOEXCEPT_DEBUG;
     
#else
        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||                     __is_nothrow_swappable<allocator_type>::value);
     
#endif
     _LIBCPP_INLINE_VISIBILITY     const value_type* c_str() const _NOEXCEPT {
  return data();
  }
       _LIBCPP_INLINE_VISIBILITY     const value_type* data() const _NOEXCEPT  {
  return _VSTD::__to_raw_pointer(__get_pointer());
  }
     
#if _LIBCPP_STD_VER > 14
    _LIBCPP_INLINE_VISIBILITY     value_type* data()             _NOEXCEPT  {
  return _VSTD::__to_raw_pointer(__get_pointer());
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     allocator_type get_allocator() const _NOEXCEPT {
  return __alloc();
  }
       _LIBCPP_INLINE_VISIBILITY     int compare(__self_view __sv) const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     int compare(size_type __pos1, size_type __n1, __self_view __sv) const;
       _LIBCPP_INLINE_VISIBILITY     int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
       int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;
       template <class _Tp>     inline _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,             int         >::type         compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2=npos) const;
       int compare(const value_type* __s) const _NOEXCEPT;
       int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
       int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;
        _LIBCPP_INLINE_VISIBILITY bool __invariants() const;
        _LIBCPP_INLINE_VISIBILITY     bool __is_long() const _NOEXCEPT         {
  return bool(__r_.first().__s.__size_ & __short_mask);
  }
      
#if _LIBCPP_DEBUG_LEVEL >= 2
     bool __dereferenceable(const const_iterator* __i) const;
       bool __decrementable(const const_iterator* __i) const;
       bool __addable(const const_iterator* __i, ptrdiff_t __n) const;
       bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;
      
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
 private:     _LIBCPP_INLINE_VISIBILITY     allocator_type& __alloc() _NOEXCEPT         {
  return __r_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     const allocator_type& __alloc() const _NOEXCEPT         {
  return __r_.second();
  }
      
#ifdef _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
     _LIBCPP_INLINE_VISIBILITY     void __set_short_size(size_type __s) _NOEXCEPT   
#   if _LIBCPP_BIG_ENDIAN
#   else
        {
  return __r_.first().__s.__size_;
  }
     
#   endif
   
#else  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
     _LIBCPP_INLINE_VISIBILITY     void __set_short_size(size_type __s) _NOEXCEPT   
#   if _LIBCPP_BIG_ENDIAN
        {
  __r_.first().__s.__size_ = (unsigned char)(__s);
  }
     
#   else
        {
  __r_.first().__s.__size_ = (unsigned char)(__s << 1);
  }
     
#   endif
     _LIBCPP_INLINE_VISIBILITY     size_type __get_short_size() const _NOEXCEPT   
#   if _LIBCPP_BIG_ENDIAN
        {
  return __r_.first().__s.__size_;
  }
     
#   else
        {
  return __r_.first().__s.__size_ >> 1;
  }
     
#   endif
   
#endif  // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
     _LIBCPP_INLINE_VISIBILITY     void __set_long_size(size_type __s) _NOEXCEPT         {
  __r_.first().__l.__size_ = __s;
  }
       _LIBCPP_INLINE_VISIBILITY     size_type __get_long_size() const _NOEXCEPT         {
  return __r_.first().__l.__size_;
  }
       _LIBCPP_INLINE_VISIBILITY     void __set_size(size_type __s) _NOEXCEPT         {
  if (__is_long()) __set_long_size(__s);
   else __set_short_size(__s);
  }
        _LIBCPP_INLINE_VISIBILITY     void __set_long_cap(size_type __s) _NOEXCEPT         {
  __r_.first().__l.__cap_  = __long_mask | __s;
  }
       _LIBCPP_INLINE_VISIBILITY     size_type __get_long_cap() const _NOEXCEPT         {
  return __r_.first().__l.__cap_ & size_type(~__long_mask);
  }
        _LIBCPP_INLINE_VISIBILITY     void __set_long_pointer(pointer __p) _NOEXCEPT         {
  __r_.first().__l.__data_ = __p;
  }
       _LIBCPP_INLINE_VISIBILITY     pointer __get_long_pointer() _NOEXCEPT         {
  return __r_.first().__l.__data_;
  }
       _LIBCPP_INLINE_VISIBILITY     const_pointer __get_long_pointer() const _NOEXCEPT         {
  return __r_.first().__l.__data_;
  }
       _LIBCPP_INLINE_VISIBILITY     pointer __get_short_pointer() _NOEXCEPT         {
  return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);
  }
       _LIBCPP_INLINE_VISIBILITY     const_pointer __get_short_pointer() const _NOEXCEPT         {
  return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);
  }
       _LIBCPP_INLINE_VISIBILITY     pointer __get_pointer() _NOEXCEPT         {
  return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }
       _LIBCPP_INLINE_VISIBILITY     const_pointer __get_pointer() const _NOEXCEPT         {
  return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }
        _LIBCPP_INLINE_VISIBILITY     void __zero() _NOEXCEPT         {
               size_type (&__a)[__n_words] = __r_.first().__r.__words;
               for (unsigned __i = 0;
   __i < __n_words;
   ++__i)                 __a[__i] = 0;
           }
        template <size_type __a> static         _LIBCPP_INLINE_VISIBILITY         size_type __align_it(size_type __s) _NOEXCEPT             {
  return (__s + (__a-1)) & ~(__a-1);
  }
       enum {
  __alignment = 16};
       static _LIBCPP_INLINE_VISIBILITY     size_type __recommend(size_type __s) _NOEXCEPT         {
  return (__s < __min_cap ? static_cast<size_type>(__min_cap) :                  __align_it<sizeof(value_type) < __alignment ?                             __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;
  }
        inline     void __init(const value_type* __s, size_type __sz, size_type __reserve);
       inline     void __init(const value_type* __s, size_type __sz);
       inline     void __init(size_type __n, value_type __c);
        template <class _InputIterator>     inline     typename enable_if     <         __is_exactly_input_iterator<_InputIterator>::value,         void     >::type     __init(_InputIterator __first, _InputIterator __last);
        template <class _ForwardIterator>     inline     typename enable_if     <         __is_forward_iterator<_ForwardIterator>::value,         void     >::type     __init(_ForwardIterator __first, _ForwardIterator __last);
        void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,                    size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);
       void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,                                size_type __n_copy,  size_type __n_del,                                size_type __n_add, const value_type* __p_new_stuff);
        _LIBCPP_INLINE_VISIBILITY     void __erase_to_end(size_type __pos);
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const basic_string& __str)         {
  __copy_assign_alloc(__str, integral_constant<bool,                       __alloc_traits::propagate_on_container_copy_assignment::value>());
  }
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const basic_string& __str, true_type)         {
               if (__alloc() == __str.__alloc())                 __alloc() = __str.__alloc();
               else             {                  if (!__str.__is_long())                 {                      clear();                      shrink_to_fit();                      __alloc() = __str.__alloc();                  }                  else                 {                      allocator_type __a = __str.__alloc();                      pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());                      clear();                      shrink_to_fit();                      __alloc() = _VSTD::move(__a);                      __set_long_pointer(__p);                      __set_long_cap(__str.__get_long_cap());                      __set_long_size(__str.size());                  }              }
           }
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT         {
  }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     void __move_assign(basic_string& __str, false_type)         _NOEXCEPT_(__alloc_traits::is_always_equal::value);
       _LIBCPP_INLINE_VISIBILITY     void __move_assign(basic_string& __str, true_type)   
#if _LIBCPP_STD_VER > 14
        _NOEXCEPT;
     
#else
        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);
     
#endif
  
#endif
     _LIBCPP_INLINE_VISIBILITY     void     __move_assign_alloc(basic_string& __str)         _NOEXCEPT_(             !__alloc_traits::propagate_on_container_move_assignment::value ||             is_nothrow_move_assignable<allocator_type>::value)     {
  __move_assign_alloc(__str, integral_constant<bool,                       __alloc_traits::propagate_on_container_move_assignment::value>());
  }
        _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(basic_string& __c, true_type)         _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)         {
               __alloc() = _VSTD::move(__c.__alloc());
           }
        _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(basic_string&, false_type)         _NOEXCEPT         {
  }
        _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();
       _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);
        friend basic_string operator+<>(const basic_string&, const basic_string&);
       friend basic_string operator+<>(const value_type*, const basic_string&);
       friend basic_string operator+<>(value_type, const basic_string&);
       friend basic_string operator+<>(const basic_string&, const value_type*);
       friend basic_string operator+<>(const basic_string&, value_type);
   };
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators() {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__invalidate_all(this);
     
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
}
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type   
#if _LIBCPP_DEBUG_LEVEL >= 2
                                                                        __pos   
#endif
                                                                      ) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
#endif
    __zero();
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)   
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)   
#else
        _NOEXCEPT   
#endif
: __r_(__second_tag(), __a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __zero();
   }
    template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s,                                                        size_type __sz,                                                        size_type __reserve) {
       if (__reserve > max_size())         this->__throw_length_error();
       pointer __p;
       if (__reserve < __min_cap)     {
           __set_short_size(__sz);
           __p = __get_short_pointer();
       }
       else     {
           size_type __cap = __recommend(__reserve);
           __p = __alloc_traits::allocate(__alloc(), __cap+1);
           __set_long_pointer(__p);
           __set_long_cap(__cap+1);
           __set_long_size(__sz);
       }
}
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT* __s, size_type __n) {
       _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "basic_string(const char*, n) detected nullptr");
       __init(__s, __n);
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
    __get_db()->__insert_c(this);
     
#endif
}
    template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>::basic_string(     const basic_string& __str, const allocator_type& __a)     : __r_(__second_tag(), __a) {
       if (!__str.__is_long())         __r_.first().__r = __str.__r_.first().__r;
       else         __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
}
      
#ifndef _LIBCPP_CXX03_LANG
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c) {
       if (__n > max_size())         this->__throw_length_error();
       pointer __p;
       if (__n < __min_cap)     {
           __set_short_size(__n);
           __p = __get_short_pointer();
       }
       traits_type::assign(__p[__n], value_type());
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, _CharT __c) {
       __init(__n, __c);
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
}
    template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str,                                                         size_type __pos, size_type __n,                                                         const _Allocator& __a)     : __r_(__second_tag(), __a) {
       size_type __str_sz = __str.size();
       if (__pos > __str_sz)         this->__throw_out_of_range();
       __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));
}
    template <class _CharT, class _Traits, class _Allocator> template <class _Tp> basic_string<_CharT, _Traits, _Allocator>::basic_string(              const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a, 			 typename enable_if<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, void>::type *)     : __r_(__second_tag(), __a) {
   	__self_view __sv = __self_view(__t).substr(__pos, __n);
       __init(__sv.data(), __sv.size());
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
       catch (...)     {
           if (__is_long())             __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
           throw;
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
}
    template <class _CharT, class _Traits, class _Allocator> template <class _ForwardIterator> typename enable_if <     __is_forward_iterator<_ForwardIterator>::value,     void >::type basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last) {
       size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));
       if (__sz > max_size())         this->__throw_length_error();
       pointer __p;
       if (__sz < __min_cap)     {
           __set_short_size(__sz);
           __p = __get_short_pointer();
       }
       else     {
           size_type __cap = __recommend(__sz);
           __p = __alloc_traits::allocate(__alloc(), __cap+1);
           __set_long_pointer(__p);
           __set_long_cap(__cap+1);
           __set_long_size(__sz);
       }
       for (;
   __first != __last;
   ++__first, (void) ++__p)         traits_type::assign(*__p, *__first);
       traits_type::assign(*__p, value_type());
   }
    template <class _CharT, class _Traits, class _Allocator> template<class _InputIterator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last) {
       __init(__first, __last);
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
}
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator>::basic_string(     initializer_list<_CharT> __il) {
       __init(__il.begin(), __il.end());
       __init(__il.begin(), __il.end());
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
}
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>::~basic_string() {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__erase_c(this);
     
#endif
    if (__is_long())         __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
   }
    template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace     (size_type __old_cap, size_type __delta_cap, size_type __old_sz,      size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff) {
       size_type __ms = max_size();
       if (__delta_cap > __ms - __old_cap - 1)         this->__throw_length_error();
       pointer __old_p = __get_pointer();
       size_type __cap = __old_cap < __ms / 2 - __alignment ?                           __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :                           __ms - 1;
       pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);
       __invalidate_all_iterators();
       if (__n_copy != 0)         traits_type::copy(_VSTD::__to_raw_pointer(__p),                           _VSTD::__to_raw_pointer(__old_p), __n_copy);
       if (__n_add != 0)         traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);
       size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
       if (__sec_cp_sz != 0)         traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,                           _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);
       if (__old_cap+1 != __min_cap)         __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);
       __set_long_pointer(__p);
       __set_long_cap(__cap+1);
       __old_sz = __n_copy + __n_add + __sec_cp_sz;
       __set_long_size(__old_sz);
       traits_type::assign(__p[__old_sz], value_type());
   }
    template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c) {
       bool __is_short = !__is_long();
       size_type __cap;
       size_type __sz;
       if (__is_short)     {
           __cap = __min_cap - 1;
           __sz = __get_short_size();
       }
       else     {
           __cap = __get_long_cap() - 1;
           __sz = __get_long_size();
       }
       if (__sz == __cap)     {
           __grow_by(__cap, 1, __sz, __sz, 0);
           __is_short = !__is_long();
       }
       pointer __p;
       if (__is_short)     {
           __p = __get_short_pointer() + __sz;
           __set_short_size(__sz+1);
       }
       else     {
           __p = __get_long_pointer() + __sz;
           __set_long_size(__sz+1);
       }
       traits_type::assign(*__p, __c);
       traits_type::assign(*++__p, value_type());
   }
    template <class _Tp> bool __ptr_in_range (const _Tp* __p, const _Tp* __first, const _Tp* __last) {
       return __first <= __p && __p < __last;
   }
    template <class _Tp1, class _Tp2> bool __ptr_in_range (const _Tp1*, const _Tp2*, const _Tp2*) {
       return false;
   }
    template <class _CharT, class _Traits, class _Allocator> template<class _ForwardIterator> basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(     _ForwardIterator __first, _ForwardIterator __last) {
       static_assert(__is_forward_iterator<_ForwardIterator>::value,                   "function requires a ForwardIterator");
       size_type __sz = size();
       size_type __cap = capacity();
       size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));
       if (__n)     {
           typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
           _CharRef __tmp_ref = *__first;
           if (__ptr_in_range(_VSTD::addressof(__tmp_ref), data(), data() + size()))         {              const basic_string __temp (__first, __last, __alloc());              append(__temp.data(), __temp.size());          }
           else          {              if (__cap - __sz < __n)                 __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);              pointer __p = __get_pointer() + __sz;              for (;  __first != __last;  ++__p, ++__first)                 traits_type::assign(*__p, *__first);              traits_type::assign(*__p, value_type());              __set_size(__sz + __n);          }
       }
       return *this;
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str) {
       return append(__str.data(), __str.size());
   }
    // insert
 template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n) {
       _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string::insert received nullptr");
       size_type __sz = size();
       if (__pos > __sz)         this->__throw_out_of_range();
       size_type __cap = capacity();
       if (__cap - __sz >= __n)     {
           if (__n)         {              value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());              size_type __n_move = __sz - __pos;              if (__n_move != 0)             {                  if (__p + __pos <= __s && __s < __p + __sz)                     __s += __n;                  traits_type::move(__p + __pos + __n, __p + __pos, __n_move);              }              traits_type::move(__p + __pos, __s, __n);              __sz += __n;              __set_size(__sz);              traits_type::assign(__p[__sz], value_type());          }
       }
       else         __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
       return *this;
   }
    template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c) {
       size_type __sz = size();
       if (__pos > __sz)         this->__throw_out_of_range();
       if (__n)     {
           size_type __cap = capacity();
           value_type* __p;
           if (__cap - __sz >= __n)         {              __p = _VSTD::__to_raw_pointer(__get_pointer());              size_type __n_move = __sz - __pos;              if (__n_move != 0)                 traits_type::move(__p + __pos + __n, __p + __pos, __n_move);          }
           else         {              __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);              __p = _VSTD::__to_raw_pointer(__get_long_pointer());          }
           traits_type::assign(__p + __pos, __n, __c);
           __sz += __n;
           __set_size(__sz);
           traits_type::assign(__p[__sz], value_type());
       }
       return *this;
   }
    template <class _CharT, class _Traits, class _Allocator> template<class _InputIterator> typename enable_if <    __is_exactly_input_iterator<_InputIterator>::value         || !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,    typename basic_string<_CharT, _Traits, _Allocator>::iterator >::type basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,         "string::insert(iterator, range) called with an iterator not"         " referring to this string");
     
#endif
    const basic_string __temp(__first, __last, __alloc());
       return insert(__pos, __temp.data(), __temp.data() + __temp.size());
   }
    template <class _CharT, class _Traits, class _Allocator> template<class _ForwardIterator> typename enable_if <     __is_forward_iterator<_ForwardIterator>::value         && __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,     typename basic_string<_CharT, _Traits, _Allocator>::iterator >::type basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,         "string::insert(iterator, range) called with an iterator not"         " referring to this string");
     
#endif
    size_type __ip = static_cast<size_type>(__pos - begin());
       size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));
       if (__n)     {
           typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
           _CharRef __tmp_char = *__first;
           if (__ptr_in_range(_VSTD::addressof(__tmp_char), data(), data() + size()))         {              const basic_string __temp(__first, __last, __alloc());              return insert(__pos, __temp.data(), __temp.data() + __temp.size());          }
            size_type __sz = size();
           size_type __cap = capacity();
           value_type* __p;
           if (__cap - __sz >= __n)         {              __p = _VSTD::__to_raw_pointer(__get_pointer());              size_type __n_move = __sz - __ip;              if (__n_move != 0)                 traits_type::move(__p + __ip + __n, __p + __ip, __n_move);          }
           else         {              __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);              __p = _VSTD::__to_raw_pointer(__get_long_pointer());          }
           __sz += __n;
           __set_size(__sz);
           traits_type::assign(__p[__sz], value_type());
           for (__p += __ip;
   __first != __last;
   ++__p, ++__first)             traits_type::assign(*__p, *__first);
       }
       return begin() + __ip;
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str) {
       return insert(__pos1, __str.data(), __str.size());
   }
    template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,                                                   size_type __pos2, size_type __n) {
       size_type __str_sz = __str.size();
       if (__pos2 > __str_sz)         this->__throw_out_of_range();
       return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));
   }
    template <class _CharT, class _Traits, class _Allocator> template <class _Tp> typename enable_if <     __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, 	basic_string<_CharT, _Traits, _Allocator>& >::type basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t,                                                   size_type __pos2, size_type __n) {
       __self_view __sv = __t;
       size_type __str_sz = __sv.size();
       if (__pos2 > __str_sz)         this->__throw_out_of_range();
       return insert(__pos1, __sv.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));
   }
    template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s) {
       _LIBCPP_ASSERT(__s != nullptr, "string::insert received nullptr");
       return insert(__pos, __s, traits_type::length(__s));
   }
    template <class _CharT, class _Traits, class _Allocator> typename basic_string<_CharT, _Traits, _Allocator>::iterator basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c) {
       size_type __ip = static_cast<size_type>(__pos - begin());
       size_type __sz = size();
       size_type __cap = capacity();
       value_type* __p;
       if (__cap == __sz)     {
           __grow_by(__cap, 1, __sz, __ip, 0, 1);
           __p = _VSTD::__to_raw_pointer(__get_long_pointer());
       }
       else     {
           __p = _VSTD::__to_raw_pointer(__get_pointer());
           size_type __n_move = __sz - __ip;
           if (__n_move != 0)             traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
       }
       traits_type::assign(__p[__ip], __c);
       traits_type::assign(__p[++__sz], value_type());
       __set_size(__sz);
       return begin() + static_cast<difference_type>(__ip);
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename basic_string<_CharT, _Traits, _Allocator>::iterator basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,         "string::insert(iterator, n, value) called with an iterator not"         " referring to this string");
     
#endif
    difference_type __p = __pos - begin();
       insert(static_cast<size_type>(__p), __n, __c);
       return begin() + __p;
   }
    // replace
 template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK {
       _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, "string::replace received nullptr");
       size_type __sz = size();
       if (__pos > __sz)         this->__throw_out_of_range();
       __n1 = _VSTD::min(__n1, __sz - __pos);
       size_type __cap = capacity();
       if (__cap - __sz + __n1 >= __n2)     {
           value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());
           if (__n1 != __n2)         {              size_type __n_move = __sz - __pos - __n1;              if (__n_move != 0)             {                  if (__n1 > __n2)                 {                     traits_type::move(__p + __pos, __s, __n2);                     traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);                     goto __finish;                 }                  if (__p + __pos < __s && __s < __p + __sz)                 {                     if (__p + __pos + __n1 <= __s)                         __s += __n2 - __n1;                     else // __p + __pos < __s < __p + __pos + __n1
                    {                         traits_type::move(__p + __pos, __s, __n1);                         __pos += __n1;                         __s += __n2;                         __n2 -= __n1;                         __n1 = 0;                     }                 }                  traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);              }          }
           traits_type::move(__p + __pos, __s, __n2);
   __finish: // __sz += __n2 - __n1; in this and the below function below can cause unsigned integer overflow,
// but this is a safe operation, so we disable the check.
        __sz += __n2 - __n1;
           __set_size(__sz);
           __invalidate_iterators_past(__sz);
           traits_type::assign(__p[__sz], value_type());
       }
       else         __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
       return *this;
   }
    template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator>& basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)     _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK {
       size_type __sz = size();
       if (__pos > __sz)         this->__throw_out_of_range();
       __n1 = _VSTD::min(__n1, __sz - __pos);
       size_type __cap = capacity();
       value_type* __p;
       if (__cap - __sz + __n1 >= __n2)     {
       }
       __invalidate_iterators_past(__pos);
   }
    template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c) {
       size_type __sz = size();
       if (__n > __sz)         append(__n - __sz, __c);
       else         __erase_to_end(__n);
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename basic_string<_CharT, _Traits, _Allocator>::size_type basic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT {
       size_type __m = __alloc_traits::max_size(__alloc());
     
#if _LIBCPP_BIG_ENDIAN
    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;
     
#else
    return __m - __alignment;
     
#endif
}
    template <class _CharT, class _Traits, class _Allocator> void basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg) {
       if (__res_arg > max_size())         this->__throw_length_error();
       size_type __cap = capacity();
       size_type __sz = size();
       __res_arg = _VSTD::max(__res_arg, __sz);
       __res_arg = __recommend(__res_arg);
       if (__res_arg != __cap)     {
           pointer __new_data, __p;
           bool __was_long, __now_long;
           if (__res_arg == __min_cap - 1)         {              __was_long = true;              __now_long = false;              __new_data = __get_short_pointer();              __p = __get_long_pointer();          }
           else         {              if (__res_arg > __cap)                 __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);              else             {                
#ifndef _LIBCPP_NO_EXCEPTIONS
                try                 {               
#endif  // _LIBCPP_NO_EXCEPTIONS
                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);               
#ifndef _LIBCPP_NO_EXCEPTIONS
                }                  catch (...)                 {                     return;                 }                
#else  // _LIBCPP_NO_EXCEPTIONS
                if (__new_data == nullptr)                     return;                
#endif  // _LIBCPP_NO_EXCEPTIONS
            }              __now_long = true;              __was_long = __is_long();              __p = __get_pointer();          }
           traits_type::copy(_VSTD::__to_raw_pointer(__new_data),                           _VSTD::__to_raw_pointer(__p), size()+1);
           if (__was_long)             __alloc_traits::deallocate(__alloc(), __p, __cap+1);
           if (__now_long)         {              __set_long_cap(__res_arg+1);              __set_long_size(__sz);              __set_long_pointer(__new_data);          }
           else             __set_short_size(__sz);
           __invalidate_all_iterators();
       }
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename basic_string<_CharT, _Traits, _Allocator>::const_reference basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const _NOEXCEPT {
       _LIBCPP_ASSERT(__pos <= size(), "string index out of bounds");
       return *(data() + __pos);
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename basic_string<_CharT, _Traits, _Allocator>::reference basic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) _NOEXCEPT {
       _LIBCPP_ASSERT(__pos <= size(), "string index out of bounds");
   }
    template <class _CharT, class _Traits, class _Allocator> int basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,                                                    size_type __n1,                                                    const value_type* __s,                                                    size_type __n2) const {
       _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, "string::compare(): received nullptr");
       size_type __sz = size();
       if (__pos1 > __sz || __n2 == npos)         this->__throw_out_of_range();
       size_type __rlen = _VSTD::min(__n1, __sz - __pos1);
       int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));
       if (__r == 0)     {
           if (__rlen < __n2)             __r = -1;
           else if (__rlen > __n2)             __r = 1;
       }
       return __r;
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY int basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,                                                    size_type __n1,                                                    __self_view __sv) const {
       return compare(__pos1, __n1, __sv.data(), __sv.size());
   }
#ifndef _LIBCPP_CXX03_LANG
 template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator> operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) {
       return _VSTD::move(__lhs.append(__rhs));
   }
    template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator> operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs) {
       return _VSTD::move(__rhs.insert(0, __lhs));
   }
    template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _Traits, _Allocator> operator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs) {
   }
      
#endif  // _LIBCPP_CXX03_LANG
 // swap
 template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(basic_string<_CharT, _Traits, _Allocator>& __lhs,      basic_string<_CharT, _Traits, _Allocator>& __rhs)      _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs))) {
       __lhs.swap(__rhs);
   }
   _LIBCPP_FUNC_VIS wstring to_wstring(long double __val);
    template<class _CharT, class _Traits, class _Allocator>     const typename basic_string<_CharT, _Traits, _Allocator>::size_type                    basic_string<_CharT, _Traits, _Allocator>::npos;
    template<class _CharT, class _Traits, class _Allocator> struct _LIBCPP_TEMPLATE_VIS hash<basic_string<_CharT, _Traits, _Allocator> >     : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t> {
       size_t         operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;
   };
    template<class _CharT, class _Traits, class _Allocator> size_t hash<basic_string<_CharT, _Traits, _Allocator> >::operator()(         const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT {
       return __do_string_hash(__val.data(), __val.data() + __val.size());
   }
    template<class _CharT, class _Traits, class _Allocator> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const basic_string<_CharT, _Traits, _Allocator>& __str);
    template<class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            basic_string<_CharT, _Traits, _Allocator>& __str);
    template<class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits>& getline(basic_istream<_CharT, _Traits>& __is,         basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);
    template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_istream<_CharT, _Traits>& getline(basic_istream<_CharT, _Traits>& __is,         basic_string<_CharT, _Traits, _Allocator>& __str);
      
#ifndef _LIBCPP_CXX03_LANG
 template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_istream<_CharT, _Traits>& getline(basic_istream<_CharT, _Traits>&& __is,         basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);
    template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_istream<_CharT, _Traits>& getline(basic_istream<_CharT, _Traits>&& __is,         basic_string<_CharT, _Traits, _Allocator>& __str);
      
#endif  // _LIBCPP_CXX03_LANG
   
#if _LIBCPP_DEBUG_LEVEL >= 2
 template<class _CharT, class _Traits, class _Allocator> bool basic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const {
       return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&            _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();
   }
   }
     
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_STRING
  
#pragma clang module end /*std.string*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <memory>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.memory
// -*- C++ -*-
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_MEMORY
  
#define _LIBCPP_MEMORY
 /*     memory synopsis  namespace std {
   
#include <stdexcept>
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cassert>
  
#endif /* expanded by -frewrite-includes */
  
#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#  include <atomic>
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
#endif
   reference __get() _NOEXCEPT {  return __value_;  }
     const_reference __get() const _NOEXCEPT {  return __value_;  }
    private:   _Tp __value_;
   };
    template <class _Tp, int _Idx> struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
     typedef _Tp _ParamT;
     typedef _Tp& reference;
    template <> struct _LIBCPP_TEMPLATE_VIS hash<double>     : public __scalar_hash<double> {      _LIBCPP_INLINE_VISIBILITY     size_t operator()(double __v) const _NOEXCEPT     {          // -0.0 and 0.0 should return same hash
       if (__v == 0)            return 0;          return __scalar_hash<double>::operator()(__v);      }  };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<long double>     : public __scalar_hash<long double> {      _LIBCPP_INLINE_VISIBILITY     size_t operator()(long double __v) const _NOEXCEPT     {          // -0.0 and 0.0 should return same hash
        if (__v == 0)             return 0;    
#if defined(__i386__)
        // Zero out padding bits
        union         {              long double __t;              struct             {                  size_t __a;                  size_t __b;                  size_t __c;                  size_t __d;              }  __s;          }  __u;          __u.__s.__a = 0;          __u.__s.__b = 0;          __u.__s.__c = 0;          __u.__s.__d = 0;          __u.__t = __v;          return __u.__s.__a ^ __u.__s.__b ^ __u.__s.__c ^ __u.__s.__d;    
#elif defined(__x86_64__)
   
#endif // !_LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_UTILITY
  
#pragma clang module end /*std.utility*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <mutex>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.mutex
// -*- C++ -*-
   
#ifndef _LIBCPP_MUTEX
  
#define _LIBCPP_MUTEX
 /*     mutex synopsis  namespace std {   class mutex {  public:      constexpr mutex() noexcept;       ~mutex();       mutex(const mutex&) = delete;      mutex& operator=(const mutex&) = delete;       void lock();      bool try_lock();      void unlock();       typedef pthread_mutex_t* native_handle_type;      native_handle_type native_handle();  };   class recursive_mutex {  public:      recursive_mutex();       ~recursive_mutex();       recursive_mutex(const recursive_mutex&) = delete;      recursive_mutex& operator=(const recursive_mutex&) = delete;       void lock();      bool try_lock() noexcept;      void unlock();       typedef pthread_mutex_t* native_handle_type;      native_handle_type native_handle();  };   class timed_mutex {  public:      timed_mutex();       ~timed_mutex();       timed_mutex(const timed_mutex&) = delete;      timed_mutex& operator=(const timed_mutex&) = delete;       void lock();      bool try_lock();      template <class Rep, class Period>         bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);      template <class Clock, class Duration>         bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);      void unlock();  };   class recursive_timed_mutex {  public:      recursive_timed_mutex();       ~recursive_timed_mutex();       recursive_timed_mutex(const recursive_timed_mutex&) = delete;      recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;       void lock();      bool try_lock() noexcept;      template <class Rep, class Period>         bool try_lock_for(const chrono::duration<Rep, Period>& rel_time);      template <class Clock, class Duration>         bool try_lock_until(const chrono::time_point<Clock, Duration>& abs_time);      void unlock();  };   struct defer_lock_t { };  struct try_to_lock_t { };  struct adopt_lock_t { };   constexpr defer_lock_t  defer_lock{ };  constexpr try_to_lock_t try_to_lock{ };  constexpr adopt_lock_t  adopt_lock{ };   template <class Mutex> class lock_guard {  public:     typedef Mutex mutex_type;       explicit lock_guard(mutex_type& m);      lock_guard(mutex_type& m, adopt_lock_t);      ~lock_guard();       lock_guard(lock_guard const&) = delete;      lock_guard& operator=(lock_guard const&) = delete;  };   template <class... MutexTypes> class scoped_lock // C++17
{  public:     using mutex_type = Mutex;   // If MutexTypes... consists of the single type Mutex
     explicit scoped_lock(MutexTypes&... m);      scoped_lock(adopt_lock_t, MutexTypes&... m);      ~scoped_lock();      scoped_lock(scoped_lock const&) = delete;      scoped_lock& operator=(scoped_lock const&) = delete;  private:     tuple<MutexTypes&...> pm;  // exposition only
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__mutex_base
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP___MUTEX_BASE
  
  
#pragma clang module begin std.chrono
// -*- C++ -*-
//===---------------------------- chrono ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CHRONO
  
#define _LIBCPP_CHRONO
 /*     chrono synopsis  namespace std {  namespace chrono {   template <class ToDuration, class Rep, class Period> constexpr ToDuration duration_cast(const duration<Rep, Period>& fd);   template <class Rep> struct treat_as_floating_point : is_floating_point<Rep> { };   template <class Rep> constexpr bool treat_as_floating_point_v     = treat_as_floating_point<Rep>::value;                        // C++17
  
#include <ctime>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.ctime
// -*- C++ -*-
//===---------------------------- ctime -----------------------------------===//
   
#ifndef _LIBCPP_CTIME
  
#define _LIBCPP_CTIME
 /*     ctime synopsis  Macros:      NULL     CLOCKS_PER_SEC  namespace std {
    Types:      clock_t     size_t     time_t     tm  clock_t clock();
   double difftime(time_t time1, time_t time0);
   time_t mktime(tm* timeptr);
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
 /*  *	ISO C99 Standard: 7.23 Date and time	<time.h>  */
   
#ifndef	_TIME_H
   
#if (! defined __need_time_t && !defined __need_clock_t && \
     ! defined __need_timespec)
  
# define _TIME_H	1
  
#if 0 /* expanded by -frewrite-includes */
  
# include <features.h>
  
#endif /* expanded by -frewrite-includes */
 __BEGIN_DECLS    
#endif
   
#ifdef	_TIME_H
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#if defined(__need_ptrdiff_t) || defined(__need_size_t) || \
    defined(__need_wchar_t) || defined(__need_NULL) || defined(__need_wint_t)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#undef __need_NULL
  
#endif /* defined(__need_NULL) */
   
#if defined(__need_STDDEF_H_misc)
  
#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
  
#if 0 /* expanded by -frewrite-includes */
  
#include "__stddef_max_align_t.h"
  
#endif /* expanded by -frewrite-includes */
  
#endif
  
#define offsetof(t, d) __builtin_offsetof(t, d)
  
#undef __need_STDDEF_H_misc
  
#if !defined(_WINT_T) || __has_feature(modules)
  
#if !__has_feature(modules)
  
#define _WINT_T
  
#endif
typedef __WINT_TYPE__ wint_t;
     
#endif
  
#undef __need_wint_t
  
#endif /* __need_wint_t */
   
#endif
   
#elif !defined(_LIBCPP_STDDEF_H)
  
#define _LIBCPP_STDDEF_H
 /*     stddef.h synopsis  Macros:      offsetof(type,member-designator)     NULL  Types:      ptrdiff_t     size_t     max_align_t     nullptr_t  */
   
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <stddef.h>
  
#endif /* expanded by -frewrite-includes */
   
#ifdef __cplusplus
#  ifdef __USE_POSIX199309
/* Identifier for system-wide realtime clock.  */
  
#   define CLOCK_REALTIME		0
/* Monotonic system-wide clock.  */
  
#   define CLOCK_MONOTONIC		1
#  endif
   
#  ifdef __USE_GNU
  
#if 0 /* expanded by -frewrite-includes */
  
#   include <bits/timex.h>
  
  
#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
    STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
   
#endif /* bits/timex.h */
 __BEGIN_DECLS  /* Tune a POSIX clock.  */
extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __THROW;
    __END_DECLS   
#  endif /* use GNU */
   
# endif	/* bits/time.h */
  
#endif
   
#undef __need_timeval
 __BEGIN_NAMESPACE_STD /* Returned by `clock'.  */
typedef __clock_t clock_t;
__END_NAMESPACE_STD
#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
__USING_NAMESPACE_STD(clock_t)
#endif

#endif /* clock_t not defined and <time.h> or need clock_t.  */
#undef	__need_clock_t

#if !defined __time_t_defined && (defined _TIME_H || defined __need_time_t)
# define __time_t_defined	1

#if 0 /* expanded by -frewrite-includes */
# include <bits/types.h>
  
#endif /* expanded by -frewrite-includes */
 /* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;

#endif /* timer_t not defined and <time.h> or need timer_t.  */
#undef	__need_timer_t


#if (!defined __timespec_defined					\
     && ((defined _TIME_H						\
	  && (defined __USE_POSIX199309 || defined __USE_MISC		\
	      || defined __USE_ISOC11))					\
	 || defined __need_timespec))
# define __timespec_defined	1
  		/* Seconds.  */
    __syscall_slong_t tv_nsec;
  	/* Nanoseconds.  */
  };
      
#endif /* timespec not defined and <time.h> or need timespec.  */
  
#undef	__need_timespec
    
#ifdef	_TIME_H
__BEGIN_NAMESPACE_STD /* Used by other time functions.  */
struct tm {
     int tm_sec;
  			/* Seconds.	[0-60] (1 leap second) */
  int tm_min;
  			/* Minutes.	[0-59] */
  int tm_hour;
  			/* Hours.	[0-23] */
  int tm_mday;
  			/* Day.		[1-31] */
  int tm_mon;
  			/* Month.	[0-11] */
  int tm_year;
  			/* Year	- 1900.  */
  int tm_wday;
  			/* Day of week.	[0-6] */
  int tm_yday;
  			/* Days in year.[0-365]	*/
  int tm_isdst;
  			/* DST.		[-1/0/1]*/
   
# ifdef	__USE_BSD
  long int tm_gmtoff;
  		/* Seconds east of UTC.  */
  const char *tm_zone;
  		/* Timezone abbreviation.  */
  
# else
  long int __tm_gmtoff;
  		/* Seconds east of UTC.  */
  const char *__tm_zone;
  	/* Timezone abbreviation.  */
  
# endif
};
   __END_NAMESPACE_STD   
#if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
__USING_NAMESPACE_STD(tm)   
#endif
    
# ifdef __USE_POSIX199309
/* POSIX.1b structure for timer start values and intervals.  */
struct itimerspec   {
       struct timespec it_interval;
       struct timespec it_value;
     };
    /* We can use a simple forward declaration.  */
struct sigevent;
      
# endif	/* POSIX.1b */
   
# ifdef __USE_XOPEN2K
  
#  ifndef __pid_t_defined
typedef __pid_t pid_t;
     
#   define __pid_t_defined
  
#  endif
  
# endif
  __BEGIN_NAMESPACE_STD /* Time used by the program so far (user time + system time).    The result / CLOCKS_PER_SECOND is program time in seconds.  */
extern clock_t clock (void) __THROW;
    /* Return the current time and put it in *TIMER if TIMER is not NULL.  */
extern time_t time (time_t *__timer) __THROW;
    /* Return the difference between TIME1 and TIME0.  */
extern double difftime (time_t __time1, time_t __time0)      __THROW __attribute__ ((__const__));
    /* Return the `time_t' representation of TP and normalize TP.  */
extern time_t mktime (struct tm *__tp) __THROW;


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
extern size_t strftime (char *__restrict __s, size_t __maxsize,
			const char *__restrict __format,
			const struct tm *__restrict __tp) __THROW;
__END_NAMESPACE_STD

# ifdef __USE_XOPEN
/* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  */
extern char *strptime (const char *__restrict __s,
# endif

# ifdef __USE_GNU
extern char *strptime_l (const char *__restrict __s,
			 const char *__restrict __fmt, struct tm *__tp,
			 __locale_t __loc) __THROW;
# endif


__BEGIN_NAMESPACE_STD
/* Return the `struct tm' representation of *TIMER    in Universal Coordinated Time (aka Greenwich Mean Time).  */
extern struct tm *gmtime (const time_t *__timer) __THROW;
    /* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
extern struct tm *localtime (const time_t *__timer) __THROW;
__END_NAMESPACE_STD

# if defined __USE_POSIX || defined __USE_MISC
/* Return the `struct tm' representation of *TIMER in UTC,    using *TP to store the result.  */
extern struct tm *gmtime_r (const time_t *__restrict __timer, 			    struct tm *__restrict __tp) __THROW;
    /* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
extern struct tm *localtime_r (const time_t *__restrict __timer,
			       struct tm *__restrict __tp) __THROW;
# endif	/* POSIX or misc */

__BEGIN_NAMESPACE_STD
/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
extern char *asctime (const struct tm *__tp) __THROW;

/* Equivalent to `asctime (localtime (timer))'.  */
extern char *ctime (const time_t *__timer) __THROW;
   __END_NAMESPACE_STD    
# if defined __USE_POSIX || defined __USE_MISC
/* Reentrant versions of the above functions.  */
 /* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"    that is the representation of TP in this format.  */
extern char *asctime_r (const struct tm *__restrict __tp, 			char *__restrict __buf) __THROW;
    /* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
extern char *ctime_r (const time_t *__restrict __timer,
		      char *__restrict __buf) __THROW;
# endif	/* POSIX or misc */


/* Defined in localtime.c.  */
extern char *__tzname[2];	/* Current timezone names.  */
    
# ifdef __USE_MISC
/* Miscellaneous functions many Unices inherited from the public domain    localtime package.  These are included only for compatibility.  */
 /* Like `mktime', but for TP represents Universal Time, not local time.  */
extern time_t timegm (struct tm *__tp) __THROW;

/* Another name for `mktime'.  */
     
# endif
    
# ifdef __USE_XOPEN_EXTENDED
/* Set to one of the following values to indicate an error.      1  the DATEMSK environment variable is null or undefined,      2  the template file cannot be opened for reading,      3  failed to get file status information,      4  the template file is not a regular file,      5  an error is encountered while reading the template file,      6  memory allication failed (not enough memory available),      7  there is no line in the template that matches the input,      8  invalid input specification Example: February 31 or a time is 	specified that can not be represented in a time_t (representing 	the time in seconds since 00:00:00 UTC, January 1, 1970) */
extern int getdate_err;
    /* Parse the given string as a date specification and return a value    representing the value.  The templates from the file identified by    the environment variable DATEMSK are used.  In case of an error    `getdate_err' is set.

   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.     This function is not part of POSIX and therefore no official    cancellation point.  But due to similarity with an POSIX interface    or due to the implementation it is a cancellation point and    therefore not marked with __THROW.  */
extern int getdate_r (const char *__restrict __string, 		      struct tm *__restrict __resbufp);
     
# endif
 __END_DECLS    
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  using ::clock_t;
   using ::size_t;
   using ::time_t;
   using ::tm;
   using ::clock;
   using ::difftime;
   using ::mktime;
   using ::time;
     
#ifndef _LIBCPP_HAS_NO_THREAD_UNSAFE_C_FUNCTIONS
using ::asctime;
   using ::ctime;
   using ::gmtime;
   using ::localtime;
     
#endif
using ::strftime;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CTIME
  
#pragma clang module end /*std.compat.ctime*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TYPE_TRAITS
       template <class T> constexpr bool is_nothrow_swappable_v         = is_nothrow_swappable<T>::value;
   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
 template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename remove_reference<_Tp>::type&& move(_Tp&& __t) _NOEXCEPT {
       typedef typename remove_reference<_Tp>::type _Up;
       return static_cast<_Up&&>(__t);
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR _Tp&& forward(typename remove_reference<_Tp>::type& __t) _NOEXCEPT {
       return static_cast<_Tp&&>(__t);
      
#else
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
   
#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)
 template <bool, bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;
    template <class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible</*is constructible*/true, /*is reference*/false, _Tp, _Args...>     : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))> {
    : integral_constant<bool, __has_nothrow_constructor(_Tp)>   
#else
    : integral_constant<bool, is_scalar<_Tp>::value>   
#endif
{
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_constructible<_Tp, _Tp,                                                        __is_construct::__nat>   
      
#endif  // _LIBCPP_HAS_NO_VARIADICS
  
#endif  // __has_feature(is_nothrow_constructible)
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
template <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_nothrow_constructible_v     = is_nothrow_constructible<_Tp, _Args...>::value;
     
#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_assign(_Tp)> {
  };
     
#else
    : integral_constant<bool, is_scalar<_Tp>::value> {
  };
     
 template <class _Tp> struct is_nothrow_assignable<_Tp&, _Tp&&>   
#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_nothrow_assign(_Tp)> {
  };
     
#else
    : integral_constant<bool, is_scalar<_Tp>::value> {
  };
     
#endif
   
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
   
#endif  // __has_feature(cxx_noexcept)
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_nothrow_copy_assignable_v     = is_nothrow_copy_assignable<_Tp>::value;
     
#endif
 // is_nothrow_move_assignable
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable     : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,   
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    }
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <ratio>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.ratio
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_RATIO
  
#define _LIBCPP_RATIO
 /*     ratio synopsis  namespace std {
    template <intmax_t N, intmax_t D = 1> class ratio {
   public:     static constexpr intmax_t num;
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.climits
// -*- C++ -*-
//===--------------------------- climits ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CLIMITS
  
#define _LIBCPP_CLIMITS
 /*     climits synopsis  Macros:      CHAR_BIT     SCHAR_MIN     SCHAR_MAX     UCHAR_MAX     CHAR_MIN     CHAR_MAX     MB_LEN_MAX     SHRT_MIN     SHRT_MAX     USHRT_MAX     INT_MIN     INT_MAX     UINT_MAX     LONG_MIN     LONG_MAX     ULONG_MAX     LLONG_MIN   // C99
    LLONG_MAX   // C99
    ULLONG_MAX  // C99
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <limits.h>
  
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===--------------------------- limits.h ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_LIMITS_H
  
#define _LIBCPP_LIMITS_H
 /*     limits.h synopsis  Macros:      CHAR_BIT     SCHAR_MIN     SCHAR_MAX     UCHAR_MAX     CHAR_MIN     CHAR_MAX     MB_LEN_MAX     SHRT_MIN     SHRT_MAX     USHRT_MAX     INT_MIN     INT_MAX     UINT_MAX     LONG_MIN     LONG_MAX     ULONG_MAX     LLONG_MIN   // C99
    LLONG_MAX   // C99
    ULLONG_MAX  // C99
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifndef __GNUC__
  
#if 0 /* expanded by -frewrite-includes */
  
#include_next <limits.h>
  
#endif /* expanded by -frewrite-includes */
  
#else
// GCC header limits.h recursively includes itself through another header called
// syslimits.h for some reason. This setup breaks down if we directly
// #include_next GCC's limits.h (reasons not entirely clear to me). Therefore,
// we manually re-create the necessary include sequence below:
 // Get the system limits.h defines (force recurse into the next level)
  
#define _GCC_LIMITS_H_
  
#define _GCC_NEXT_LIMITS_H
  
#if 0 /* expanded by -frewrite-includes */
  
#include_next <limits.h>
  
#endif /* expanded by -frewrite-includes */
/*===---- limits.h - Standard header for integer sizes --------------------===*\  *  * Copyright (c) 2009 Chris Lattner  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN  * THE SOFTWARE.  * \*===----------------------------------------------------------------------===*/
   
#ifndef __CLANG_LIMITS_H
  
#define __CLANG_LIMITS_H
 /* System headers include a number of constants from POSIX in <limits.h>.    Include it if we're hosted. */
#if __STDC_HOSTED__ && (1)/*__has_include_next(<limits.h>)*/
#if 0 /* expanded by -frewrite-includes */
#include_next <limits.h>
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

 *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
 */

#ifndef _LIBC_LIMITS_H_
#define _LIBC_LIMITS_H_	1

#if 0 /* expanded by -frewrite-includes */
#include <features.h>
# ifndef _LIMITS_H
#  define _LIMITS_H	1

#if 0 /* expanded by -frewrite-includes */
#include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */

  
#  ifdef __CHAR_UNSIGNED__
  
#   define CHAR_MIN	0
  
#   define CHAR_MAX	UCHAR_MAX
  
#  else
  
#   define CHAR_MIN	SCHAR_MIN
  
#   define CHAR_MAX	SCHAR_MAX
  
#  endif
 /* Minimum and maximum values a `signed short int' can hold.  */
#  if __WORDSIZE == 64
  
#   define ULONG_MAX	18446744073709551615UL
  
#  else
  
#   define ULONG_MAX	4294967295UL
/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)  */
  
#   define ULLONG_MAX	18446744073709551615ULL
   
#  endif /* ISO C99 */
   
# endif	/* limits.h  */
  
#endif	/* GCC 2.  */
   
#endif	/* !_LIBC_LIMITS_H_ */
  /* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  */
  
#if defined __GNUC__ && !defined _GCC_LIMITS_H_
/* `_GCC_LIMITS_H_' is what GCC's file defines.  */
  
#if 0 /* expanded by -frewrite-includes */
  
# include_next <limits.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
 /* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  */
#if defined __USE_ISOC99 && defined __GNUC__
/* Copyright (C) 1991-2014 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
   <http://www.gnu.org/licenses/>.  */

/*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */

#ifndef	_BITS_POSIX1_LIM_H
#define	_BITS_POSIX1_LIM_H	1


/* These are the standard-mandated minimum values.  */

/* Minimum number of operations in one list I/O call.  */
#define _POSIX_AIO_LISTIO_MAX	2
 /* Maximum value the semaphore can have.  */
 
#define SEM_VALUE_MAX   (2147483647)
   
#ifndef	SSIZE_MAX
 
# define SSIZE_MAX	LONG_MAX
#endif
 
#endif	/* bits/posix1_lim.h  */

#endif
 
#ifdef	__USE_POSIX2
 either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
 without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
 if not, see    <http://www.gnu.org/licenses/>.  */
 /*  * Never include this file directly;
 include <limits.h> instead.  */
 
#ifndef	_BITS_POSIX2_LIM_H
  you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
  either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
  without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
  if not, see    <http://www.gnu.org/licenses/>.  */
  
#if !defined _STDIO_H && !defined __need_FOPEN_MAX && !defined __need_IOV_MAX
 
#elif defined __INT_MAX__
  
# if __INT_MAX__ == 32767
  
#  define WORD_BIT	16
  
# else
  
#  if __INT_MAX__ == 2147483647
  
#   define WORD_BIT	32
  
#  else
/* Safe assumption.  */
  
#   define WORD_BIT	64
  
#  endif
  
# endif
  
#else
  
# define WORD_BIT	32
  
#endif
 /* Number of bits in a word of type `long int'.  */
#ifdef LONG_MAX
# if LONG_MAX == 2147483647
#  define LONG_BIT	32
# else
/* Safe assumption.  */
#  define LONG_BIT	64
# endif
#else
#if 0 /* expanded by -frewrite-includes */
# include <bits/wordsize.h>
#endif /* expanded by -frewrite-includes */
# if __WORDSIZE == 64
#  define LONG_BIT	64
# else
#  define LONG_BIT	32
# endif
#endif

#endif /* bits/xopen_lim.h */
#endif
#endif

/* Many system headers try to "help us out" by defining these.  No really, we
   know how big each datatype is. */
#undef  SCHAR_MIN
#undef  SCHAR_MAX
#undef  UCHAR_MAX
#define SCHAR_MAX __SCHAR_MAX__
#define SHRT_MAX  __SHRT_MAX__
#define INT_MAX   __INT_MAX__
#define LONG_MAX  __LONG_MAX__

#define SCHAR_MIN (-__SCHAR_MAX__-1)
#define SHRT_MIN  (-__SHRT_MAX__ -1)
#ifndef MB_LEN_MAX
#define MB_LEN_MAX 1
#endif

#define CHAR_BIT  __CHAR_BIT__

#ifdef __CHAR_UNSIGNED__  /* -funsigned-char */
#define LLONG_MAX  __LONG_LONG_MAX__
#define LLONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULLONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif

/* LONG_LONG_MIN/LONG_LONG_MAX/ULONG_LONG_MAX are a GNU extension.  It's too bad    that we don't have something like #pragma poison that could be used to
   deprecate a macro - the code should just use LLONG_MAX and friends.
 */
#if defined(__GNU_LIBRARY__) ? defined(__USE_GNU) : !defined(__STRICT_ANSI__)

#undef   LONG_LONG_MIN
#undef   LONG_LONG_MAX
#undef   ULONG_LONG_MAX

#define LONG_LONG_MAX  __LONG_LONG_MAX__
#define LONG_LONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULONG_LONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif

#endif /* __CLANG_LIMITS_H */

// Get the ISO C defines
#undef _GCC_LIMITS_H_
#if 0 /* expanded by -frewrite-includes */
#include_next <limits.h>
#endif /* expanded by -frewrite-includes */
#endif // __GNUC__

#endif  // _LIBCPP_LIMITS_H

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
#endif

#endif  // _LIBCPP_CLIMITS
#pragma clang module end /*std.compat.climits*/
#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_TYPE_TRAITS
#define _LIBCPP_TYPE_TRAITS

/*
    type_traits synopsis

namespace std
{

    // helper class:
    // Pointer transformations:
    template <class T> struct remove_pointer;
    template <class T> struct add_pointer;

#endif /* expanded by -frewrite-includes */
#if 0 /* expanded by -frewrite-includes */
#include <cstddef>
#endif /* expanded by -frewrite-includes */

template <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {};
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {typedef typename _Tp::type type;};

template <bool, class _Tp = void> struct _LIBCPP_TEMPLATE_VIS enable_if {};
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS enable_if<true, _Tp> {typedef _Tp type;};

#if _LIBCPP_STD_VER > 11

#endif // !defined(_LIBCPP_CXX03_LANG)

// is_const

template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const            : public false_type {};
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_const<_Tp const> : public true_type {};

};
 template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {
};
 template <class _Tp> struct __is_reference_wrapper     : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {
};
  
#ifndef _LIBCPP_CXX03_LANG
 // Check for complete types

#endif

#undef min

#endif
 
#ifdef max
#endif

#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  // __static_gcd
 template <intmax_t _Xp, intmax_t _Yp> struct __static_gcd {
     static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
 };
  template <intmax_t _Xp> struct __static_gcd<_Xp, 0> {
     static const intmax_t value = _Xp;
 };
  template <> struct __static_gcd<0, 0> {
     static const intmax_t value = 1;
 };
  // __static_lcm
 template <intmax_t _Xp, intmax_t _Yp> struct __static_lcm {
     static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
 };
  template <intmax_t _Xp> struct __static_abs {
     static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
 };
  template <intmax_t _Xp> struct __static_sign {
     static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
 };
  template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value> class __ll_add;
  template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, 1> {
     static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
     static const intmax_t max = -min;
      static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
 public:     static const intmax_t value = _Xp + _Yp;
 };
  template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, 0> {
 };
  template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value> class __ll_sub;
  template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, 1> {
     static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
     static const intmax_t max = -min;
      static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
 public:     static const intmax_t value = _Xp - _Yp;
 };
  template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, 0> {
 public:     static const intmax_t value = _Xp;
 };
  template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, -1> {
     static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
     static const intmax_t max = -min;
      static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
 public:     static const intmax_t value = _Xp - _Yp;
 };
  template <intmax_t _Xp, intmax_t _Yp> class __ll_mul {
     static const intmax_t nan = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1));
     static const intmax_t min = nan + 1;
     static const intmax_t max = -min;
     static const intmax_t __a_x = __static_abs<_Xp>::value;
     static const intmax_t __a_y = __static_abs<_Yp>::value;
      static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
 };
  template <> class __ll_mul<0, 0> {
 public:     static const intmax_t value = 0;
 };
  // Not actually used but left here in case needed in future maintenance
template <intmax_t _Xp, intmax_t _Yp> class __ll_div {
     static const intmax_t nan = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1));
     static const intmax_t min = nan + 1;
     static const intmax_t max = -min;
      static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
 public:     static const intmax_t value = _Xp / _Yp;
 };
  template <intmax_t _Num, intmax_t _Den = 1> class _LIBCPP_TEMPLATE_VIS ratio {
     static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
     static_assert(_Den != 0, "ratio divide by 0");
     static_assert(__static_abs<_Den>::value >  0, "ratio denominator is out of range");
     static _LIBCPP_CONSTEXPR const intmax_t __na = __static_abs<_Num>::value;
     static _LIBCPP_CONSTEXPR const intmax_t __da = __static_abs<_Den>::value;
     static _LIBCPP_CONSTEXPR const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
     static _LIBCPP_CONSTEXPR const intmax_t __gcd = __static_gcd<__na, __da>::value;
 public:     static _LIBCPP_CONSTEXPR const intmax_t num = __s * __na / __gcd;
     static _LIBCPP_CONSTEXPR const intmax_t den = __da / __gcd;
      typedef ratio<num, den> type;
 };
  template <intmax_t _Num, intmax_t _Den> _LIBCPP_CONSTEXPR const intmax_t ratio<_Num, _Den>::num;
  template <intmax_t _Num, intmax_t _Den> _LIBCPP_CONSTEXPR const intmax_t ratio<_Num, _Den>::den;
  template <class _Tp>                    struct __is_ratio                     : false_type {
};
 template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type  {
};
  typedef ratio<1LL, 1000000000000000000LL> atto;
 typedef ratio<1LL,    1000000000000000LL> femto;
 typedef ratio<1LL,       1000000000000LL> pico;
 typedef ratio<1LL,          1000000000LL> nano;
 typedef ratio<1LL,             1000000LL> micro;
 typedef ratio<1LL,                1000LL> milli;
 typedef ratio<1LL,                 100LL> centi;
 typedef ratio<1LL,                  10LL> deci;
 typedef ratio<                 10LL, 1LL> deca;
  template <class _R1, class _R2> struct __ratio_multiply {
 private:     static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
     static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
 public:     typedef typename ratio         <             __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,             __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value         >::type type;
 };
  
#ifndef _LIBCPP_CXX03_LANG
 template <class _R1, class _R2> using ratio_multiply                                     = typename __ratio_multiply<_R1, _R2>::type;
  
#else  // _LIBCPP_CXX03_LANG
 template <class _R1, class _R2> struct _LIBCPP_TEMPLATE_VIS ratio_multiply     : public __ratio_multiply<_R1, _R2>::type {
};
  
#endif  // _LIBCPP_CXX03_LANG
 template <class _R1, class _R2> struct __ratio_divide {
 private:     static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
     static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
 public:     typedef typename ratio         <             __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,             __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value         >::type type;
 };
  
#ifndef _LIBCPP_CXX03_LANG
 template <class _R1, class _R2> using ratio_divide                                       = typename __ratio_divide<_R1, _R2>::type;
  
  
#endif  // _LIBCPP_CXX03_LANG
 // ratio_equal
 template <class _R1, class _R2> struct _LIBCPP_TEMPLATE_VIS ratio_equal     : public _LIBCPP_BOOL_CONSTANT((_R1::num == _R2::num && _R1::den == _R2::den)) {
};
  template <class _R1, class _R2> struct _LIBCPP_TEMPLATE_VIS ratio_not_equal     : public _LIBCPP_BOOL_CONSTANT((!ratio_equal<_R1, _R2>::value)) {
};
  // ratio_less
 template <class _R1, class _R2, bool _Odd = false,           intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,           intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den> struct __ratio_less1 {
     static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
 };
  template <class _R1, class _R2, bool _Odd, intmax_t _Qp> struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0> {
     static const bool value = false;
 };
  template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2> struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2> {
 };
  template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,                                 intmax_t _S2 = __static_sign<_R2::num>::value> struct __ratio_less {
     static const bool value = _S1 < _S2;
 };
  template <class _R1, class _R2> struct __ratio_less<_R1, _R2, 1LL, 1LL> {
     static const bool value = __ratio_less1<_R1, _R2>::value;
 };
  template <class _R1, class _R2> struct __ratio_less<_R1, _R2, -1LL, -1LL> {
     static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
 };
  template <class _R1, class _R2> struct _LIBCPP_TEMPLATE_VIS ratio_less     : public _LIBCPP_BOOL_CONSTANT((__ratio_less<_R1, _R2>::value)) {
};
  template <class _R1, class _R2> struct _LIBCPP_TEMPLATE_VIS ratio_less_equal     : public _LIBCPP_BOOL_CONSTANT((!ratio_less<_R2, _R1>::value)) {
};
  template <class _R1, class _R2> struct _LIBCPP_TEMPLATE_VIS ratio_greater     : public _LIBCPP_BOOL_CONSTANT((ratio_less<_R2, _R1>::value)) {
};
  template <class _R1, class _R2> struct _LIBCPP_TEMPLATE_VIS ratio_greater_equal     : public _LIBCPP_BOOL_CONSTANT((!ratio_less<_R1, _R2>::value)) {
};
  template <class _R1, class _R2> struct __ratio_gcd {
     typedef ratio<__static_gcd<_R1::num, _R2::num>::value,                   __static_lcm<_R1::den, _R2::den>::value> type;
 };
  
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_equal_v     = ratio_equal<_R1, _R2>::value;
  template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_not_equal_v     = ratio_not_equal<_R1, _R2>::value;
  template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_less_v     = ratio_less<_R1, _R2>::value;
  template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_less_equal_v     = ratio_less_equal<_R1, _R2>::value;
  template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_greater_v     = ratio_greater<_R1, _R2>::value;
  template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_greater_equal_v     = ratio_greater_equal<_R1, _R2>::value;
 
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS  
#endif  // _LIBCPP_RATIO

#pragma clang module end /*std.ratio*/

#if 0 /* expanded by -frewrite-includes */

#include <limits>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.limits
// -*- C++ -*-
//===---------------------------- limits ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_LIMITS
#if 0 /* expanded by -frewrite-includes */

#include <type_traits>

#endif /* expanded by -frewrite-includes */
 
#if defined(_LIBCPP_COMPILER_MSVC)


#endif /* expanded by -frewrite-includes */
  _LIBCPP_BEGIN_NAMESPACE_STD  enum float_round_style {
     round_indeterminate       = -1,     round_toward_zero         =  0,     round_to_nearest          =  1,     round_toward_infinity     =  2,     round_toward_neg_infinity =  3 };
  enum float_denorm_style {
     denorm_indeterminate = -1,     denorm_absent = 0,     denorm_present = 1 };
  template <class _Tp, bool = is_arithmetic<_Tp>::value> class __libcpp_numeric_limits {
 template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;
 template <class _Tp>     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;
  _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS  
#endif  // _LIBCPP_LIMITS

#pragma clang module end /*std.limits*/
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 _LIBCPP_PUSH_MACROS 
#if 0 /* expanded by -frewrite-includes */

#include <__undef_macros>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
  
#ifdef min

#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)

#endif

#undef min

#endif
 
#ifdef max

#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)

#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max") 
#else

#warning: macro max is incompatible with C++.  #undefing max

#endif

#endif

#undef max

#endif

#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  namespace chrono {
  template <class _Rep, class _Period = ratio<1> > class _LIBCPP_TEMPLATE_VIS duration;
  template <class _Tp> struct __is_duration : false_type {
};
  template <class _Rep, class _Period> struct __is_duration<duration<_Rep, _Period> > : true_type  {
};
  template <class _Rep, class _Period> struct __is_duration<const duration<_Rep, _Period> > : true_type  {
};
  template <class _Rep, class _Period> struct __is_duration<volatile duration<_Rep, _Period> > : true_type  {
};
  template <class _Rep, class _Period> struct __is_duration<const volatile duration<_Rep, _Period> > : true_type  {
};
  }
 // chrono
 template <class _Rep1, class _Period1, class _Rep2, class _Period2> struct _LIBCPP_TEMPLATE_VIS common_type<chrono::duration<_Rep1, _Period1>,                                          chrono::duration<_Rep2, _Period2> > {
     typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,                              typename __ratio_gcd<_Period1, _Period2>::type> type;
 };
  namespace chrono {
  // duration_cast
 template <class _FromDuration, class _ToDuration,           class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,           bool = _Period::num == 1,           bool = _Period::den == 1> struct __duration_cast;
  template <class _FromDuration, class _ToDuration, class _Period> struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true> {
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     _ToDuration operator()(const _FromDuration& __fd) const     {
         return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
     }
 };
  template <class _FromDuration, class _ToDuration, class _Period> struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false> {
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     _ToDuration operator()(const _FromDuration& __fd) const     {
         typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
         return _ToDuration(static_cast<typename _ToDuration::rep>(                            static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
     }
 };
  template <class _FromDuration, class _ToDuration, class _Period> struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true> {
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     _ToDuration operator()(const _FromDuration& __fd) const     {
         typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
         return _ToDuration(static_cast<typename _ToDuration::rep>(                            static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
     }
 };
  template <class _FromDuration, class _ToDuration, class _Period> struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false> {
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     _ToDuration operator()(const _FromDuration& __fd) const     {
         typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
         return _ToDuration(static_cast<typename _ToDuration::rep>(                            static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)                                                           / static_cast<_Ct>(_Period::den)));
     }
 };
  template <class _ToDuration, class _Rep, class _Period> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     __is_duration<_ToDuration>::value,     _ToDuration >::type duration_cast(const duration<_Rep, _Period>& __fd) {
     return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
 }
  template <class _Rep> struct _LIBCPP_TEMPLATE_VIS treat_as_floating_point : is_floating_point<_Rep> {
};
  
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Rep> _LIBCPP_CONSTEXPR bool treat_as_floating_point_v     = treat_as_floating_point<_Rep>::value;
 
#endif
 template <class _Rep> struct _LIBCPP_TEMPLATE_VIS duration_values {
 public:     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep zero() {
return _Rep(0);
}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep max()  {
return numeric_limits<_Rep>::max();
}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR _Rep min()  {
return numeric_limits<_Rep>::lowest();
}
 };
  
#if _LIBCPP_STD_VER > 14
template <class _ToDuration, class _Rep, class _Period> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     __is_duration<_ToDuration>::value,     _ToDuration >::type floor(const duration<_Rep, _Period>& __d) {
     _ToDuration __t = duration_cast<_ToDuration>(__d);
     if (__t > __d)         __t = __t - _ToDuration{
1};
     return __t;
 }
  template <class _ToDuration, class _Rep, class _Period> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     __is_duration<_ToDuration>::value,     _ToDuration >::type ceil(const duration<_Rep, _Period>& __d) {
     _ToDuration __t = duration_cast<_ToDuration>(__d);
     if (__t < __d)         __t = __t + _ToDuration{
1};
     return __t;
 }
  template <class _ToDuration, class _Rep, class _Period> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     __is_duration<_ToDuration>::value,     _ToDuration >::type round(const duration<_Rep, _Period>& __d) {
     _ToDuration __lower = floor<_ToDuration>(__d);
     _ToDuration __upper = __lower + _ToDuration{
1};
     auto __lowerDiff = __d - __lower;
     auto __upperDiff = __upper - __d;
     if (__lowerDiff < __upperDiff)         return __lower;
     if (__lowerDiff > __upperDiff)         return __upper;
     return __lower.count() & 1 ? __upper : __lower;
 }
 
#endif
 // duration
 template <class _Rep, class _Period> class _LIBCPP_TEMPLATE_VIS duration {
     static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
     static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
     static_assert(_Period::num > 0, "duration period must be positive");
      template <class _R1, class _R2>     struct __no_overflow     {
     private:         static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
         static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
         static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
         static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
         static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
         static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
         static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1);
          template <intmax_t _Xp, intmax_t _Yp, bool __overflow>         struct __mul    // __overflow == false
        {
             static const intmax_t value = _Xp * _Yp;
         };
          template <intmax_t _Xp, intmax_t _Yp>         struct __mul<_Xp, _Yp, true>         {
             static const intmax_t value = 1;
         };
      public:         static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
         typedef ratio<__mul<__n1, __d2, !value>::value,                       __mul<__n2, __d1, !value>::value> type;
     };
      public:     typedef _Rep rep;
     typedef typename _Period::type period;
 private:     rep __rep_;
 public:      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR 
#ifndef _LIBCPP_CXX03_LANG
        duration() = default;
 
#else
        duration() {
}
 
#endif
     template <class _Rep2>         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR         explicit duration(const _Rep2& __r,             typename enable_if             <                is_convertible<_Rep2, rep>::value &&                (treat_as_floating_point<rep>::value ||                !treat_as_floating_point<_Rep2>::value)             >::type* = 0)                 : __rep_(__r) {
}
      // conversions
    template <class _Rep2, class _Period2>         _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR         duration(const duration<_Rep2, _Period2>& __d,             typename enable_if             <                 __no_overflow<_Period2, period>::value && (                 treat_as_floating_point<rep>::value ||                 (__no_overflow<_Period2, period>::type::den == 1 &&                  !treat_as_floating_point<_Rep2>::value))             >::type* = 0)                 : __rep_(_VSTD::chrono::duration_cast<duration>(__d).count()) {
}
      // observer
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR rep count() const {
return __rep_;
}
      // arithmetic
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename common_type<duration>::type operator+() const {
}
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration  operator--(int)   {
return duration(__rep_--);
}
      _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator+=(const duration& __d) {
__rep_ += __d.count();
 return *this;
}
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14 duration& operator%=(const duration& rhs) {
__rep_ %= rhs.count();
 return *this;
}
      // special values
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration zero() {
return duration(duration_values<rep>::zero());
}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration min()  {
return duration(duration_values<rep>::min());
}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR duration max()  {
return duration(duration_values<rep>::max());
}
 };
  typedef duration<long long,         nano> nanoseconds;
 typedef duration<long long,        micro> microseconds;
 typedef duration<long long,        milli> milliseconds;
 typedef duration<long long              > seconds;
 typedef duration<     long, ratio<  60> > minutes;
 typedef duration<     long, ratio<3600> > hours;
  // Duration ==
 template <class _LhsDuration, class _RhsDuration> struct __duration_eq {
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const         {
             typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
             return _Ct(__lhs).count() == _Ct(__rhs).count();
         }
 };
  template <class _LhsDuration> struct __duration_eq<_LhsDuration, _LhsDuration> {
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const         {
return __lhs.count() == __rhs.count();
}
 };
  template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR bool operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
     return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
 }
  // Duration !=
 template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR bool operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
     return !(__lhs == __rhs);
 }
  // Duration <
 template <class _LhsDuration, class _RhsDuration> struct __duration_lt {
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const         {
             typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
             return _Ct(__lhs).count() < _Ct(__rhs).count();
         }
 };
  template <class _LhsDuration> struct __duration_lt<_LhsDuration, _LhsDuration> {
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR     bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const         {
return __lhs.count() < __rhs.count();
}
 };
  template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR bool operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
     return !(__rhs < __lhs);
 }
  // Duration >=
 template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR bool operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
     return !(__lhs < __rhs);
 }
  // Duration +
 template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
     typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
     return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
 }
  // Duration -
 template <class _Rep1, class _Period1, class _Rep2, class _Period2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
     typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
     return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
 }
  // Duration *
 template <class _Rep1, class _Period, class _Rep2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,     duration<typename common_type<_Rep1, _Rep2>::type, _Period> >::type operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s) {
     typedef typename common_type<_Rep1, _Rep2>::type _Cr;
     typedef duration<_Cr, _Period> _Cd;
     return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
 }
  template <class _Rep1, class _Period, class _Rep2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,     duration<typename common_type<_Rep1, _Rep2>::type, _Period> >::type operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d) {
     return __d * __s;
 }
  // Duration /
 template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value> struct __duration_divide_result {
 };
  template <class _Duration, class _Rep2,     bool = is_convertible<_Rep2,                           typename common_type<typename _Duration::rep, _Rep2>::type>::value> struct __duration_divide_imp {
 };
  template <class _Rep1, class _Period, class _Rep2> struct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true> {
     typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
 };
  template <class _Rep1, class _Period, class _Rep2> struct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>     : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2> {
 };
  template <class _Rep1, class _Period, class _Rep2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s) {
     typedef typename common_type<_Rep1, _Rep2>::type _Cr;
     typedef duration<_Cr, _Period> _Cd;
 }
  //////////////////////////////////////////////////////////
///////////////////// time_point /////////////////////////
//////////////////////////////////////////////////////////
 template <class _Clock, class _Duration = typename _Clock::duration> class _LIBCPP_TEMPLATE_VIS time_point {
     static_assert(__is_duration<_Duration>::value,                   "Second template parameter of time_point must be a std::chrono::duration");
 public:     typedef _Clock                    clock;
     typedef _Duration                 duration;
     typedef typename duration::rep    rep;
     typedef typename duration::period period;
 private:     duration __d_;
  public:     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point() : __d_(duration::zero()) {
}
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 explicit time_point(const duration& __d) : __d_(__d) {
}
      // conversions
    template <class _Duration2>     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     time_point(const time_point<clock, _Duration2>& t,         typename enable_if         <             is_convertible<_Duration2, duration>::value         >::type* = 0)             : __d_(t.time_since_epoch()) {
}
      // observer
     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 duration time_since_epoch() const {
return __d_;
}
      // arithmetic
     _LIBCPP_INLINE_VISIBILITY time_point& operator+=(const duration& __d) {
__d_ += __d;
 return *this;
}
     _LIBCPP_INLINE_VISIBILITY time_point& operator-=(const duration& __d) {
__d_ -= __d;
 return *this;
}
      // special values
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point min() {
return time_point(duration::min());
}
     _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR time_point max() {
return time_point(duration::max());
}
 };
  }
 // chrono
 template <class _Clock, class _Duration1, class _Duration2> struct _LIBCPP_TEMPLATE_VIS common_type<chrono::time_point<_Clock, _Duration1>,                                          chrono::time_point<_Clock, _Duration2> > {
     typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
 };
  namespace chrono {
  template <class _ToDuration, class _Clock, class _Duration> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point<_Clock, _ToDuration> time_point_cast(const time_point<_Clock, _Duration>& __t) {
     return time_point<_Clock, _ToDuration>(_VSTD::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
 }
  
#if _LIBCPP_STD_VER > 14
template <class _ToDuration, class _Clock, class _Duration> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     __is_duration<_ToDuration>::value,     time_point<_Clock, _ToDuration> >::type floor(const time_point<_Clock, _Duration>& __t) {
     return time_point<_Clock, _ToDuration>{
floor<_ToDuration>(__t.time_since_epoch())};
 }
  template <class _Rep, class _Period> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     numeric_limits<_Rep>::is_signed,     duration<_Rep, _Period> >::type abs(duration<_Rep, _Period> __d) {
     return __d >= __d.zero() ? __d : -__d;
 }
 
#endif
 // time_point ==
 template <class _Clock, class _Duration1, class _Duration2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
     return __lhs.time_since_epoch() == __rhs.time_since_epoch();
 }
  // time_point !=
 template <class _Clock, class _Duration1, class _Duration2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
     return !(__lhs == __rhs);
 }
  // time_point <
  // time_point operator+(time_point x, duration y);
 template <class _Clock, class _Duration1, class _Rep2, class _Period2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
     typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
     return _Tr (__lhs.time_since_epoch() + __rhs);
 }
  // time_point operator+(duration x, time_point y);
 template <class _Rep1, class _Period1, class _Clock, class _Duration2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type> operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
     return __rhs + __lhs;
 }
  // time_point operator-(time_point x, duration y);
 template <class _Clock, class _Duration1, class _Rep2, class _Period2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
     typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
     return _Ret(__lhs.time_since_epoch() -__rhs);
 }
  // duration operator-(time_point x, time_point y);
 template <class _Clock, class _Duration1, class _Duration2> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 typename common_type<_Duration1, _Duration2>::type operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
     return __lhs.time_since_epoch() - __rhs.time_since_epoch();
 }
  //////////////////////////////////////////////////////////
/////////////////////// clocks ///////////////////////////
//////////////////////////////////////////////////////////
 class _LIBCPP_TYPE_VIS system_clock {
 public:     typedef microseconds                     duration;
     typedef duration::rep                    rep;
     typedef duration::period                 period;
     typedef chrono::time_point<system_clock> time_point;
     static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = false;
      static time_point now() _NOEXCEPT;
     static time_t     to_time_t  (const time_point& __t) _NOEXCEPT;
     static time_point from_time_t(time_t __t) _NOEXCEPT;
 };
  
#ifndef _LIBCPP_HAS_NO_MONOTONIC_CLOCK
class _LIBCPP_TYPE_VIS steady_clock {
 public:     typedef nanoseconds                                   duration;
     typedef duration::rep                                 rep;
     typedef duration::period                              period;
     typedef chrono::time_point<steady_clock, duration>    time_point;
     static _LIBCPP_CONSTEXPR_AFTER_CXX11 const bool is_steady = true;
      static time_point now() _NOEXCEPT;
 };
  typedef steady_clock high_resolution_clock;
 
#else
typedef system_clock high_resolution_clock;
 
#endif
 }
 // chrono
 
#if _LIBCPP_STD_VER > 11
// Suffixes for duration literals [time.duration.literals]
inline namespace literals {
    inline namespace chrono_literals   {
           constexpr chrono::nanoseconds operator""ns(unsigned long long __ns)     {
         return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
     }
      constexpr chrono::duration<long double, nano> operator""ns(long double __ns)     {
         return chrono::duration<long double, nano> (__ns);
     }
  }
}
  namespace chrono {
 // hoist the literals into namespace std::chrono
   using namespace literals::chrono_literals;
 }
  
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS  
#endif  // _LIBCPP_CHRONO
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_SYSTEM_ERROR

#define _LIBCPP_SYSTEM_ERROR
 /*     system_error synopsis  namespace std {
  class error_category {
 public:     virtual ~error_category() noexcept;
      constexpr error_category();
     error_category(const error_category&) = delete;
     error_category& operator=(const error_category&) = delete;
      virtual const char* name() const noexcept = 0;
     virtual error_condition default_error_condition(int ev) const noexcept;

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.compat.cerrno
// -*- C++ -*-
//===-------------------------- cerrno ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_CERRNO

#define _LIBCPP_CERRNO
 /*     cerrno synopsis  Macros:      EDOM     EILSEQ  // C99
    ERANGE     errno  */
 
#if 0 /* expanded by -frewrite-includes */

#include <__config>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.depr.errno_h
// -*- C++ -*-
//===-------------------------- errno.h -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_ERRNO_H

#define _LIBCPP_ERRNO_H
 /*     errno.h synopsis  Macros:      EDOM     EILSEQ  // C99
    ERANGE     errno  */
 
#if 0 /* expanded by -frewrite-includes */

#include <__config>

#endif /* expanded by -frewrite-includes */
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#endif
 
#endif // __cplusplus
 
#endif  // _LIBCPP_ERRNO_H

#pragma clang module end /*std.depr.errno_h*/
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 
#endif  // _LIBCPP_CERRNO

#pragma clang module end /*std.compat.cerrno*/

#if 0 /* expanded by -frewrite-includes */

#include <type_traits>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.type_traits
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
#ifndef _LIBCPP_TYPE_TRAITS

#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {
      // helper class:
    template <class T, T v> struct integral_constant;
     typedef integral_constant<bool, true>  true_type;
   // C++11
      template<class B>          constexpr bool negation_v = negation<B>::value;
                  // C++17
 }
  */

#if 0 /* expanded by -frewrite-includes */

#include <__config>
 }
  // FIXME: Theis should have a version which takes a non-const alloc.
template <class _Tp, class _Allocator, class... _Args> inline _LIBCPP_INLINE_VISIBILITY void __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args) {
      __user_alloc_construct_impl(               __uses_alloc_ctor<_Tp, _Allocator>(),               __storage, __a, _VSTD::forward<_Args>(__args)...         );
 }
 
#endif  // _LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD  
#endif  // _LIBCPP_FUNCTIONAL_BASE

#pragma clang module end /*std.__functional_base*/
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  // is_error_code_enum
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_error_code_enum     : public false_type {
};
  
#if _LIBCPP_STD_VER > 14
template <class _Tp> constexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value;
 
#endif
 // is_error_condition_enum
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_error_condition_enum     : public false_type {
};
  
#if _LIBCPP_STD_VER > 14
template <class _Tp> constexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;
 
#endif
 // Some error codes are not present on all platforms, so we provide equivalents
// for them:
 //enum class errc
_LIBCPP_DECLARE_STRONG_ENUM(errc) {
     address_family_not_supported        = EAFNOSUPPORT,     address_in_use                      = EADDRINUSE,     address_not_available               = EADDRNOTAVAIL,     already_connected                   = EISCONN,     argument_list_too_long              = E2BIG,     argument_out_of_domain              = EDOM,     bad_address                         = EFAULT,     bad_file_descriptor                 = EBADF,     bad_message                         = EBADMSG,     broken_pipe                         = EPIPE,     connection_aborted                  = ECONNABORTED,     connection_already_in_progress      = EALREADY,     connection_refused                  = ECONNREFUSED,     connection_reset                    = ECONNRESET,     cross_device_link                   = EXDEV,     destination_address_required        = EDESTADDRREQ,     device_or_resource_busy             = EBUSY,     directory_not_empty                 = ENOTEMPTY,     executable_format_error             = ENOEXEC,     file_exists                         = EEXIST,     file_too_large                      = EFBIG,     filename_too_long                   = ENAMETOOLONG,     function_not_supported              = ENOSYS,     host_unreachable                    = EHOSTUNREACH,     identifier_removed                  = EIDRM,     illegal_byte_sequence               = EILSEQ,     inappropriate_io_control_operation  = ENOTTY,     interrupted                         = EINTR,     invalid_argument                    = EINVAL,     invalid_seek                        = ESPIPE,     io_error                            = EIO,     is_a_directory                      = EISDIR,     message_size                        = EMSGSIZE,     network_down                        = ENETDOWN,     network_reset                       = ENETRESET,     network_unreachable                 = ENETUNREACH,     no_buffer_space                     = ENOBUFS,     no_child_process                    = ECHILD,     no_link                             = ENOLINK,     no_lock_available                   = ENOLCK, 
#ifdef ENODATA
    no_message_available                = ENODATA, 
#else
    no_message_available                = ENOMSG, 
#endif
    no_message                          = ENOMSG,     no_protocol_option                  = ENOPROTOOPT,     no_space_on_device                  = ENOSPC, 
#ifdef ENOSR
    no_stream_resources                 = ENOSR, 
#else
    no_stream_resources                 = ENOMEM, 
#endif
    no_such_device_or_address           = ENXIO,     no_such_device                      = ENODEV,     no_such_file_or_directory           = ENOENT,     no_such_process                     = ESRCH,     not_a_directory                     = ENOTDIR,     not_a_socket                        = ENOTSOCK, 
#ifdef ENOSTR
    not_a_stream                        = ENOSTR, 
#else
    not_a_stream                        = EINVAL, 
#endif
    not_connected                       = ENOTCONN,     not_enough_memory                   = ENOMEM,     not_supported                       = ENOTSUP,     operation_canceled                  = ECANCELED,     operation_in_progress               = EINPROGRESS,     operation_not_permitted             = EPERM,     operation_not_supported             = EOPNOTSUPP,     operation_would_block               = EWOULDBLOCK,     owner_dead                          = EOWNERDEAD,     permission_denied                   = EACCES,     protocol_error                      = EPROTO,     protocol_not_supported              = EPROTONOSUPPORT,     read_only_file_system               = EROFS,     resource_deadlock_would_occur       = EDEADLK,     resource_unavailable_try_again      = EAGAIN,     result_out_of_range                 = ERANGE,     state_not_recoverable               = ENOTRECOVERABLE, 
#ifdef ETIME
    stream_timeout                      = ETIME, 
#else
    stream_timeout                      = ETIMEDOUT, 
#endif
    text_file_busy                      = ETXTBSY,     timed_out                           = ETIMEDOUT,     too_many_files_open_in_system       = ENFILE,     too_many_files_open                 = EMFILE,     too_many_links                      = EMLINK,     too_many_symbolic_link_levels       = ELOOP,     value_too_large                     = EOVERFLOW,     wrong_protocol_type                 = EPROTOTYPE };
 _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(errc)  template <> struct _LIBCPP_TEMPLATE_VIS is_error_condition_enum<errc>     : true_type {
 };
  
#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS
template <> struct _LIBCPP_TEMPLATE_VIS is_error_condition_enum<errc::__lx>     : true_type {
 };
 
#endif
 class _LIBCPP_TYPE_VIS error_condition;
 class _LIBCPP_TYPE_VIS error_code;
  // class error_category
 class _LIBCPP_HIDDEN __do_message;
  class _LIBCPP_TYPE_VIS error_category {
 public:     virtual ~error_category() _NOEXCEPT;
  
#if defined(_LIBCPP_BUILDING_SYSTEM_ERROR) && \
    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)
    error_category() _NOEXCEPT;
 
#else
    _LIBCPP_ALWAYS_INLINE     _LIBCPP_CONSTEXPR_AFTER_CXX11 error_category() _NOEXCEPT _LIBCPP_DEFAULT 
#endif
private:     error_category(const error_category&);
// = delete;
    error_category& operator=(const error_category&);
// = delete;
 public:     virtual const char* name() const _NOEXCEPT = 0;
     virtual error_condition default_error_condition(int __ev) const _NOEXCEPT;
     virtual bool equivalent(int __code, const error_condition& __condition) const _NOEXCEPT;
     virtual bool equivalent(const error_code& __code, int __condition) const _NOEXCEPT;
     virtual string message(int __ev) const = 0;
      _LIBCPP_ALWAYS_INLINE     bool operator==(const error_category& __rhs) const _NOEXCEPT {
return this == &__rhs;
}
      _LIBCPP_ALWAYS_INLINE     bool operator!=(const error_category& __rhs) const _NOEXCEPT {
return !(*this == __rhs);
}
      _LIBCPP_ALWAYS_INLINE     bool operator< (const error_category& __rhs) const _NOEXCEPT {
return this < &__rhs;
}
      friend class _LIBCPP_HIDDEN __do_message;
 };
  class _LIBCPP_HIDDEN __do_message     : public error_category {
 public:     virtual string message(int ev) const;
 };
  _LIBCPP_FUNC_VIS const error_category& generic_category() _NOEXCEPT;
 _LIBCPP_FUNC_VIS const error_category& system_category() _NOEXCEPT;
  class _LIBCPP_TYPE_VIS error_condition {
     int __val_;
     const error_category* __cat_;
 public:     _LIBCPP_ALWAYS_INLINE     error_condition() _NOEXCEPT : __val_(0), __cat_(&generic_category()) {
}
      _LIBCPP_ALWAYS_INLINE     error_condition(int __val, const error_category& __cat) _NOEXCEPT         : __val_(__val), __cat_(&__cat) {
}
      template <class _Ep>         _LIBCPP_ALWAYS_INLINE         error_condition(_Ep __e,               typename enable_if<is_error_condition_enum<_Ep>::value>::type* = 0                                                                      ) _NOEXCEPT             {
*this = make_error_condition(__e);
}
      _LIBCPP_ALWAYS_INLINE     void clear() _NOEXCEPT     {
         __val_ = 0;
         __cat_ = &generic_category();
     }
      _LIBCPP_ALWAYS_INLINE     int value() const _NOEXCEPT {
return __val_;
}
      _LIBCPP_ALWAYS_INLINE     const error_category& category() const _NOEXCEPT {
return *__cat_;
}
     string message() const;
      _LIBCPP_ALWAYS_INLINE         _LIBCPP_EXPLICIT         operator bool() const _NOEXCEPT {
return __val_ != 0;
}
 };
 class _LIBCPP_TYPE_VIS error_code {
     int __val_;
     const error_category* __cat_;
 public:     _LIBCPP_ALWAYS_INLINE     error_code() _NOEXCEPT : __val_(0), __cat_(&system_category()) {
}
      _LIBCPP_ALWAYS_INLINE     error_code(int __val, const error_category& __cat) _NOEXCEPT         : __val_(__val), __cat_(&__cat) {
}
      template <class _Ep>         _LIBCPP_ALWAYS_INLINE         error_code(_Ep __e,                    typename enable_if<is_error_code_enum<_Ep>::value>::type* = 0                                                                      ) _NOEXCEPT             {
*this = make_error_code(__e);
}
      _LIBCPP_ALWAYS_INLINE     void assign(int __val, const error_category& __cat) _NOEXCEPT     {
         __val_ = __val;
         __cat_ = &__cat;
     }
      template <class _Ep>         _LIBCPP_ALWAYS_INLINE         typename enable_if         <             is_error_code_enum<_Ep>::value,             error_code&         >::type         operator=(_Ep __e) _NOEXCEPT             {
*this = make_error_code(__e);
 return *this;
}
      _LIBCPP_ALWAYS_INLINE     void clear() _NOEXCEPT     {
         __val_ = 0;
         __cat_ = &system_category();
     }
      _LIBCPP_ALWAYS_INLINE     int value() const _NOEXCEPT {
return __val_;
}
      _LIBCPP_ALWAYS_INLINE     const error_category& category() const _NOEXCEPT {
return *__cat_;
}
      _LIBCPP_ALWAYS_INLINE     error_condition default_error_condition() const _NOEXCEPT         {
return __cat_->default_error_condition(__val_);
}
      string message() const;
      _LIBCPP_ALWAYS_INLINE         _LIBCPP_EXPLICIT         operator bool() const _NOEXCEPT {
return __val_ != 0;
}
 };
  inline _LIBCPP_INLINE_VISIBILITY error_code make_error_code(errc __e) _NOEXCEPT {
     return error_code(static_cast<int>(__e), generic_category());
 }
  inline _LIBCPP_INLINE_VISIBILITY bool operator<(const error_code& __x, const error_code& __y) _NOEXCEPT {
     return __x.category() < __y.category()         || (__x.category() == __y.category() && __x.value() < __y.value());
 }
  inline _LIBCPP_INLINE_VISIBILITY bool operator==(const error_code& __x, const error_code& __y) _NOEXCEPT {
     return __x.category() == __y.category() && __x.value() == __y.value();
 }
  inline _LIBCPP_INLINE_VISIBILITY bool operator==(const error_code& __x, const error_condition& __y) _NOEXCEPT {
     return __x.category().equivalent(__x.value(), __y)         || __y.category().equivalent(__x, __y.value());
 };
  template <> struct _LIBCPP_TEMPLATE_VIS hash<error_condition>     : public unary_function<error_condition, size_t> {
     _LIBCPP_INLINE_VISIBILITY     size_t operator()(const error_condition& __ec) const _NOEXCEPT     {
         return static_cast<size_t>(__ec.value());
     }
 };
  // system_error
 class _LIBCPP_TYPE_VIS system_error     : public runtime_error {
     error_code __ec_;
 public:     system_error(error_code __ec, const string& __what_arg);
     system_error(error_code __ec, const char* __what_arg);
     system_error(error_code __ec);
     system_error(int __ev, const error_category& __ecat, const string& __what_arg);
     system_error(int __ev, const error_category& __ecat, const char* __what_arg);
     system_error(int __ev, const error_category& __ecat);
     ~system_error() _NOEXCEPT;
      _LIBCPP_ALWAYS_INLINE     const error_code& code() const _NOEXCEPT {
return __ec_;
}
  private:     static string __init(const error_code&, string);
 };
  _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_system_error(int ev, const char* what_arg);
  _LIBCPP_END_NAMESPACE_STD  
#endif  // _LIBCPP_SYSTEM_ERROR

#pragma clang module end /*std.system_error*/

#if 0 /* expanded by -frewrite-includes */

#include <__threading_support>

#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_THREADING_SUPPORT

#define _LIBCPP_THREADING_SUPPORT
 

#if 0 /* expanded by -frewrite-includes */

#include <chrono>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.chrono
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_CHRONO

#define _LIBCPP_CHRONO
 /*     chrono synopsis  namespace std {
 namespace chrono {
 // C++14
constexpr chrono::nanoseconds                           operator ""ns(unsigned long long);
 // C++14
constexpr chrono::duration<unspecified , nano>          operator ""ns(long double);
 // C++14
 }
  // std
*/
 }
  
#if _LIBCPP_STD_VER > 14
template <class _ToDuration, class _Clock, class _Duration> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     __is_duration<_ToDuration>::value,     time_point<_Clock, _ToDuration> >::type floor(const time_point<_Clock, _Duration>& __t) {
     return time_point<_Clock, _ToDuration>{
floor<_ToDuration>(__t.time_since_epoch())};
 }
  template <class _ToDuration, class _Clock, class _Duration> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR typename enable_if <     __is_duration<_ToDuration>::value,     time_point<_Clock, _ToDuration> >::type ceil(const time_point<_Clock, _Duration>& __t) {
#ifndef EALREADY

#define EALREADY 9907

#endif
 
#ifndef ECONNREFUSED

#endif
 
#endif // __cplusplus
 
#endif  // _LIBCPP_ERRNO_H

#pragma clang module end /*std.depr.errno_h*/
 
#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 
#if defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)

#if 0 /* expanded by -frewrite-includes */

# include <__external_threading>

#endif /* expanded by -frewrite-includes */

#elif !defined(_LIBCPP_HAS_NO_THREADS)
 
#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD)

#if 0 /* expanded by -frewrite-includes */

# include <pthread.h>

#endif /* expanded by -frewrite-includes */
/* Copyright (C) 2002-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
 you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
 either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
 without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
 if not, see    <http://www.gnu.org/licenses/>.  */
 
#ifndef _PTHREAD_H

#define _PTHREAD_H	1
 
#if 0 /* expanded by -frewrite-includes */

#include <features.h>

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */


#endif /* expanded by -frewrite-includes */
/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.    Copyright (C) 1996-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
 you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
 either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
 without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
 if not, see    <http://www.gnu.org/licenses/>.  */
 
#ifndef	_SCHED_H

#define	_SCHED_H	1
 
#if 0 /* expanded by -frewrite-includes */

#include <features.h>
 
#if !defined(__STDDEF_H) || defined(__need_ptrdiff_t) ||                       \
    defined(__need_size_t) || defined(__need_wchar_t) ||                       \
    defined(__need_NULL) || defined(__need_wint_t)
 
#if !defined(__need_ptrdiff_t) && !defined(__need_size_t) &&                   \
    !defined(__need_wchar_t) && !defined(__need_NULL) &&                       \
    !defined(__need_wint_t)

#if !defined(_PTRDIFF_T) || __has_feature(modules)
/* Always define ptrdiff_t when modules are available. */

#if !__has_feature(modules)

#define _PTRDIFF_T

#define _SIZE_T

#endif
typedef __SIZE_TYPE__ size_t;
 
#endif

#ifndef __cplusplus
/* Always define wchar_t when modules are available. */

#if !defined(_WCHAR_T) || __has_feature(modules)

#if !__has_feature(modules)

#endif
typedef __WCHAR_TYPE__ wchar_t;
 
#endif

#endif

#undef __need_wchar_t

#endif /* defined(__need_wchar_t) */
 
#if defined(__need_NULL)

#undef NULL

#ifdef __cplusplus
#endif

#ifdef __cplusplus

#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)
namespace std {
 typedef decltype(nullptr) nullptr_t;
 }
 using ::std::nullptr_t;
 
#endif

#endif

#undef __need_NULL
#define offsetof(t, d) __builtin_offsetof(t, d)

#undef __need_STDDEF_H_misc

#endif  /* defined(__need_STDDEF_H_misc) */
 /* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use __WINT_TYPE__ directly;
 accommodate both by requiring __need_wint_t */

#if defined(__need_wint_t)
/* Always define wint_t when modules are available. */

#if !defined(_WINT_T) || __has_feature(modules)

#if !__has_feature(modules)

#define _WINT_T

#endif
typedef __WINT_TYPE__ wint_t;
 
#endif

#undef __need_wint_t

#endif /* __need_wint_t */
 
#endif
 
#elif !defined(_LIBCPP_STDDEF_H)

 /* The official definition.  */
/* Data structure to describe a process' schedulability.  */
struct __sched_param   {
      int __sched_priority;
    };
   
# undef __need_schedparam
 
#endif
   
#if defined _SCHED_H && !defined __cpu_set_t_defined
 
# define __cpu_set_t_defined
/* Size definition for CPU sets.  */
 
# define __CPU_SETSIZE	4096
 
# define __NCPUBITS	(8 * sizeof (__cpu_mask))
 /* Type for array elements in 'cpu_set_t'.  */
typedef unsigned long int __cpu_mask;
   /* Basic access functions.  */
 
# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
 
# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
 /* Data structure to describe CPU mask.  */
typedef struct {
    __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
  }
  cpu_set_t;
   /* Access functions for CPU masks.  */
 
# if __GNUC_PREREQ (2, 91)
 
#  define __CPU_ZERO_S(setsize, cpusetp) \
  do __builtin_memset (cpusetp, '\0', setsize); while (0)
 
# else
 
#  define __CPU_ZERO_S(setsize, cpusetp) \
 
# endif
 
# define __CPU_SET_S(cpu, setsize, cpusetp) \
  (__extension__							      \
   ({ size_t __cpu = (cpu);						      \
      __cpu / 8 < (setsize)						      \
      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
      ? ((((const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]	      \
	  & __CPUMASK (__cpu))) != 0					      \
      : 0; }))
  
# define __CPU_COUNT_S(setsize, cpusetp) \
  __sched_cpucount (setsize, cpusetp)
  
# if __GNUC_PREREQ (2, 91)
 
#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
  (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
 
# else
 
#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
  (__extension__							      \
      __i == __imax; }))
 
# endif
  
# define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) \
  (__extension__							      \
   ({ cpu_set_t *__dest = (destset);					      \
      const __cpu_mask *__arr1 = (srcset1)->__bits;			      \
  ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))
 
# define __CPU_ALLOC(count) __sched_cpualloc (count)
 
# define __CPU_FREE(cpuset) __sched_cpufree (cpuset)
 __BEGIN_DECLS  extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)   __THROW;
  extern cpu_set_t *__sched_cpualloc (size_t __count) __THROW __wur;
  extern void __sched_cpufree (cpu_set_t *__set) __THROW;
 
# define CPU_FREE(cpuset) __CPU_FREE (cpuset)
  /* Set the CPU affinity for a task */
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize, 			      const cpu_set_t *__cpuset) __THROW;
   /* Get the CPU affinity for a task */
extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize, 			      cpu_set_t *__cpuset) __THROW;
   
#endif
 __END_DECLS   
#endif /* sched.h */
 
#if 0 /* expanded by -frewrite-includes */
 
#include <time.h>
 
#endif /* expanded by -frewrite-includes */
    /* Mutex types.  */
enum {
    PTHREAD_MUTEX_TIMED_NP,   PTHREAD_MUTEX_RECURSIVE_NP,   PTHREAD_MUTEX_ERRORCHECK_NP,   PTHREAD_MUTEX_ADAPTIVE_NP  
#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
  ,   PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,   PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,   PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,   PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL  
#endif
 
#ifdef __USE_GNU
  /* For compatibility.  */
  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP  
#endif
};
     
#ifdef __USE_XOPEN2K
/* Robust mutex or not flags.  */
enum {
    PTHREAD_PRIO_NONE,   PTHREAD_PRIO_INHERIT,   PTHREAD_PRIO_PROTECT };
   
#endif
  /* Mutex initializers.  */
 
#if __PTHREAD_MUTEX_HAVE_ELISION == 1 /* 64bit layout.  */
 
#define __PTHREAD_SPINS 0, 0
 
#elif __PTHREAD_MUTEX_HAVE_ELISION == 2 /* 32bit layout.  */
 
#define __PTHREAD_SPINS { 0, 0 }
 
#else
 
#define __PTHREAD_SPINS 0
 
#endif
  
#ifdef __PTHREAD_MUTEX_HAVE_PREV
 
# define PTHREAD_MUTEX_INITIALIZER \
  { { 0, 0, 0, 0, 0, __PTHREAD_SPINS, { 0, 0 } } }
 
# ifdef __USE_GNU
 
#  define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, __PTHREAD_SPINS, { 0, 0 } } }
 
#  define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, __PTHREAD_SPINS, { 0, 0 } } }
 
#  define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __PTHREAD_SPINS, { 0, 0 } } }
 
#  define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \
  { { 0, 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, __PTHREAD_SPINS, { 0, 0 } } }
  
# endif
 
#else
 
# define PTHREAD_MUTEX_INITIALIZER \
  { { 0, 0, 0, 0, 0, { __PTHREAD_SPINS } } }
 
# ifdef __USE_GNU
  { { 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP, 0, { __PTHREAD_SPINS } } }
  
# endif
 
#endif
  /* Read-write lock types.  */
 
#if defined __USE_UNIX98 || defined __USE_XOPEN2K
enum {
    PTHREAD_RWLOCK_PREFER_READER_NP,   PTHREAD_RWLOCK_PREFER_WRITER_NP,   PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,   PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP };
   /* Define __PTHREAD_RWLOCK_INT_FLAGS_SHARED to 1 if pthread_rwlock_t    has the shared field.  All 64-bit architectures have the shared field    in pthread_rwlock_t.  */
 
#ifndef __PTHREAD_RWLOCK_INT_FLAGS_SHARED
 
# if __WORDSIZE == 64
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,					      \
	PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP } }
 
#  else
 
#   if __BYTE_ORDER == __LITTLE_ENDIAN
 
      0 } }
 
#   endif
 
#  endif
 
# endif
 
#endif  /* Unix98 or XOpen2K */
  /* Scheduler inheritance.  */
enum {
    PTHREAD_INHERIT_SCHED,  
#define PTHREAD_INHERIT_SCHED   PTHREAD_INHERIT_SCHED
  PTHREAD_EXPLICIT_SCHED  
#define PTHREAD_EXPLICIT_SCHED  PTHREAD_EXPLICIT_SCHED
};
 
#define PTHREAD_COND_INITIALIZER { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }
  /* Cleanup buffers */
struct _pthread_cleanup_buffer {
    void (*__routine) (void *);
              /* Function to call.  */
  void *__arg;
                             /* Its argument.  */
  int __canceltype;
                        /* Saved cancellation type. */
  struct _pthread_cleanup_buffer *__prev;
  /* Chaining of cleanup functions.  */
};
   /* Cancellation */
enum {
#define PTHREAD_CANCEL_DEFERRED	PTHREAD_CANCEL_DEFERRED
  PTHREAD_CANCEL_ASYNCHRONOUS  
#define PTHREAD_CANCEL_ASYNCHRONOUS	PTHREAD_CANCEL_ASYNCHRONOUS
};
   
#define PTHREAD_CANCELED ((void *) -1)
  /* Single execution handling.  */
 
  __BEGIN_DECLS  /* Create a new thread, starting with execution of START-ROUTINE    getting passed ARG.  Creation attributed come from ATTR.  The new    handle is stored in *NEWTHREAD.  */
extern int pthread_create (pthread_t *__restrict __newthread, 			   const pthread_attr_t *__restrict __attr, 			   void *(*__start_routine) (void *), 			   void *__restrict __arg) __THROWNL __nonnull ((1, 3));
   /* Terminate calling thread.     The registered cleanup handlers are called via exception handling    so we cannot mark this function with __THROW.*/
extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));
   /* Make calling thread wait for termination of the thread TH.  The    exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN    is not NULL.     This function is a cancellation point and therefore not marked with    __THROW.  */
extern int pthread_join (pthread_t __th, void **__thread_return);
    
#ifdef __USE_GNU
   /* Limit specified thread TH to run only on the processors represented    in CPUSET.  */
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize, 				   const cpu_set_t *__cpuset)      __THROW __nonnull ((3));
  /* Get bit set in CPUSET representing the processors TH can run on.  */
extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize, 				   cpu_set_t *__cpuset)      __THROW __nonnull ((3));
 
#endif
  /* Functions for handling initialization.  */
 /* Guarantee that the initialization function INIT_ROUTINE will be called    only once, even if pthread_once is executed several times with the    same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or    extern variable initialized to PTHREAD_ONCE_INIT.     The initialization functions might throw exception which is why    this function is not marked with __THROW.  */
extern int pthread_once (pthread_once_t *__once_control, 			 void (*__init_routine) (void)) __nonnull ((1, 2));
   /* Functions for handling cancellation.     Note that these functions are explicitly not marked to not throw an    exception in C++ code.  If cancellation is implemented by unwinding    this is necessary to have the compiler generate the unwind information.  */
 /* Set cancelability state of current thread to STATE, returning old    state in *OLDSTATE if OLDSTATE is not NULL.  */
extern int pthread_setcancelstate (int __state, int *__oldstate);
  /* Set cancellation state of current thread to TYPE, returning the old    type in *OLDTYPE if OLDTYPE is not NULL.  */
extern int pthread_setcanceltype (int __type, int *__oldtype);
  /* Cancel THREAD immediately or at the next possibility.  */
extern int pthread_cancel (pthread_t __th);
  /* Test for pending cancellation for the current thread and terminate    the thread as per pthread_exit(PTHREAD_CANCELED) if it has been    cancelled.  */
extern void pthread_testcancel (void);
   /* Cancellation handling with integration into exception handling.  */
 typedef struct {
   struct   {
     __jmp_buf __cancel_jmp_buf;
     int __mask_was_saved;
   }
 __cancel_jmp_buf[1];
   void *__pad[4];
 }
 __pthread_unwind_buf_t __attribute__ ((__aligned__));
  /* No special attributes by default.  */

#ifndef __cleanup_fct_attribute

# define __cleanup_fct_attribute

#endif
  /* Structure to hold the cleanup handler information.  */
struct __pthread_cleanup_frame {
   void (*__cancel_routine) (void *);
   void *__cancel_arg;
   int __do_it;
   int __cancel_type;
 };
  
#if defined __GNUC__ && defined __EXCEPTIONS

# ifdef __cplusplus
/* Class to handle cancellation handler invocation.  */
class __pthread_cleanup_class {
   void (*__cancel_routine) (void *);
   void *__cancel_arg;
   int __do_it;
   int __cancel_type;
   public:   __pthread_cleanup_class (void (*__fct) (void *), void *__arg)     : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) {
 }
   ~__pthread_cleanup_class () {
 }
   void __restore () const {
 pthread_setcanceltype (__cancel_type, 0);
 }
 };
  /* Install a cleanup handler: ROUTINE will be called with arguments ARG    when the thread is canceled or calls pthread_exit.  ROUTINE will also    be called with arguments ARG when the matching pthread_cleanup_pop    is executed with non-zero EXECUTE argument.     pthread_cleanup_push and pthread_cleanup_pop are macros and must always    be used in matching pairs at the same nesting level of braces.  */

#  define pthread_cleanup_push(routine, arg) \
  do {									      \
    __pthread_cleanup_class __clframe (routine, arg)
 /* Remove a cleanup handler installed by the matching pthread_cleanup_push.    If EXECUTE is non-zero, the handler function is called. */

#  define pthread_cleanup_pop(execute) \
    __clframe.__setdoit (execute);					      \
  } while (0)
 
#  ifdef __USE_GNU
/* Install a cleanup handler as pthread_cleanup_push does, but also    saves the current cancellation type and sets it to deferred    cancellation.  */

#   define pthread_cleanup_push_defer_np(routine, arg) \
  do {									      \
    __pthread_cleanup_class __clframe (routine, arg);			      \
    __clframe.__defer ()
 /* Remove a cleanup handler as pthread_cleanup_pop does, but also    restores the cancellation type that was in effect when the matching    pthread_cleanup_push_defer was called.  */

#   define pthread_cleanup_pop_restore_np(execute) \
    __clframe.__restore ();						      \
    __clframe.__setdoit (execute);					      \
  } while (0)

#  endif
     __attribute__ ((__weak__)) 
# endif
     ;
 
#endif
 /* Function used in the macros.  */
struct __jmp_buf_tag;
 extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __THROWNL;
   /* Mutex handling.  */
 /* Initialize a mutex.  */
extern int pthread_mutex_init (pthread_mutex_t *__mutex, 			       const pthread_mutexattr_t *__mutexattr)      __THROW __nonnull ((1));
  /* Destroy a mutex.  */
extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)      __THROW __nonnull ((1));
  /* Try locking a mutex.  */
extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)      __THROWNL __nonnull ((1));
  /* Lock a mutex.  */
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)      __THROWNL __nonnull ((1));
   /* Get the priority ceiling of MUTEX.  */
extern int pthread_mutex_getprioceiling (const pthread_mutex_t * 					 __restrict __mutex, 					 int *__restrict __prioceiling)      __THROW __nonnull ((1, 2));
  /* Set the priority ceiling of MUTEX to PRIOCEILING, return old    priority ceiling value in *OLD_CEILING.  */
extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex, 					 int __prioceiling, 					 int *__restrict __old_ceiling)      __THROW __nonnull ((1, 3));
   
#ifdef __USE_XOPEN2K8
#endif
  /* Functions for handling mutex attributes.  */
 /* Initialize mutex attribute object ATTR with default attributes    (kind is PTHREAD_MUTEX_TIMED_NP).  */
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)      __THROW __nonnull ((1));
  /* Destroy mutex attribute object ATTR.  */
extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)      __THROW __nonnull ((1));
  /* Get the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t * 					 __restrict __attr, 					 int *__restrict __pshared)      __THROW __nonnull ((1, 2));
  /* Set the process-shared flag of the mutex attribute ATTR.  */
extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr, 					 int __pshared)      __THROW __nonnull ((1));
  
#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
/* Return in *KIND the mutex kind attribute in *ATTR.  */
extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict 				      __attr, int *__restrict __kind)      __THROW __nonnull ((1, 2));
  /* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,    PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or    PTHREAD_MUTEX_DEFAULT).  */
extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)      __THROW __nonnull ((1));
 
#endif
 /* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */
extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t * 					  __restrict __attr, 					  int *__restrict __protocol)      __THROW __nonnull ((1, 2));
extern int pthread_cond_wait (pthread_cond_t *__restrict __cond, 			      pthread_mutex_t *__restrict __mutex)      __nonnull ((1, 2));
  /* Wait for condition variable COND to be signaled or broadcast until    ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an    absolute time specification;
extern int pthread_getcpuclockid (pthread_t __thread_id, 				  __clockid_t *__clock_id)      __THROW __nonnull ((2));
 
#endif
  /* Install handlers to be called when a new process is created with FORK.    The PREPARE handler is called in the parent process just before performing    FORK. The PARENT handler is called in the parent process just after FORK.    The CHILD handler is called in the child process.  Each of the three    handlers can be NULL, meaning that no handler needs to be called at that    point.    PTHREAD_ATFORK can be called several times, in which case the PREPARE    handlers are called in LIFO order (last added with PTHREAD_ATFORK,    first called before FORK), and the PARENT and CHILD handlers are called    in FIFO (first added, first called).  */
 extern int pthread_atfork (void (*__prepare) (void), 			   void (*__parent) (void), 			   void (*__child) (void)) __THROW;
   
#ifdef __USE_EXTERN_INLINES
/* Optimizations.  */
__extern_inline int __NTH (pthread_equal (pthread_t __thread1, pthread_t __thread2)) {
   return __thread1 == __thread2;
 }
 
#endif
 __END_DECLS  
#endif	/* pthread.h */

#if 0 /* expanded by -frewrite-includes */

#include <windows.h>

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#endif /* expanded by -frewrite-includes */

#endif
 _LIBCPP_PUSH_MACROS 
#if 0 /* expanded by -frewrite-includes */

#include <__undef_macros>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
  
#ifdef min

#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)

#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min") 
#else

#warning: macro min is incompatible with C++.  #undefing min

#warning: macro max is incompatible with C++.  #undefing max

#endif

#endif

#undef max

#endif

#pragma clang module end /*std.__undef_macros*/
  
#if defined(_LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL) || \
    defined(_LIBCPP_BUILDING_THREAD_LIBRARY_EXTERNAL)

#define _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_FUNC_VIS

#else

#define _LIBCPP_THREAD_ABI_VISIBILITY inline _LIBCPP_INLINE_VISIBILITY

#define _LIBCPP_NO_THREAD_SAFETY_ANALYSIS

#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  
#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
// Mutex
typedef pthread_mutex_t __libcpp_mutex_t;
 
#define _LIBCPP_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
 typedef pthread_mutex_t __libcpp_recursive_mutex_t;
  // Condition Variable
typedef pthread_cond_t __libcpp_condvar_t;
 
#define _LIBCPP_CONDVAR_INITIALIZER PTHREAD_COND_INITIALIZER
 // Execute once
typedef pthread_once_t __libcpp_exec_once_flag;
 
#define _LIBCPP_EXEC_ONCE_INITIALIZER PTHREAD_ONCE_INIT
 // Thread id
typedef pthread_t __libcpp_thread_id;
  // Thread

#define _LIBCPP_NULL_THREAD 0U
 typedef pthread_t __libcpp_thread_t;
  // Thrad Local Storage
typedef pthread_key_t __libcpp_tls_key;
  
#define _LIBCPP_TLS_DESTRUCTOR_CC

#else
// Mutex

#endif
 // Mutex
_LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);
  _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);
  _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);
  _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);
  _LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);
  _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);
  _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,                                timespec *__ts);
  _LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);
  // Execute once
_LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_execute_once(__libcpp_exec_once_flag *flag,                           void (*init_routine)(void));
  // Thread id
_LIBCPP_THREAD_ABI_VISIBILITY bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);
  _LIBCPP_THREAD_ABI_VISIBILITY bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);
  // Thread
_LIBCPP_THREAD_ABI_VISIBILITY bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);
  _LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),                            void *__arg);
  _LIBCPP_THREAD_ABI_VISIBILITY __libcpp_thread_id __libcpp_thread_get_current_id();
  _LIBCPP_THREAD_ABI_VISIBILITY __libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);
  _LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_thread_join(__libcpp_thread_t *__t);
  _LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_thread_detach(__libcpp_thread_t *__t);
  _LIBCPP_THREAD_ABI_VISIBILITY void __libcpp_thread_yield();
  _LIBCPP_THREAD_ABI_VISIBILITY void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns);
  // Thread local storage
_LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_tls_create(__libcpp_tls_key* __key,                         void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*));
  _LIBCPP_THREAD_ABI_VISIBILITY void *__libcpp_tls_get(__libcpp_tls_key __key);
  _LIBCPP_THREAD_ABI_VISIBILITY int __libcpp_tls_set(__libcpp_tls_key __key, void *__p);
  
#if !defined(_LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL) || \
    defined(_LIBCPP_BUILDING_THREAD_LIBRARY_EXTERNAL)
 
#if defined(_LIBCPP_HAS_THREAD_API_PTHREAD)
 int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m) {
   pthread_mutexattr_t attr;
   int __ec = pthread_mutexattr_init(&attr);
   if (__ec)     return __ec;
   __ec = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
   if (__ec) {
     pthread_mutexattr_destroy(&attr);
     return __ec;
   }
   __ec = pthread_mutex_init(__m, &attr);
   if (__ec) {
     pthread_mutexattr_destroy(&attr);
     return __ec;
   }
   __ec = pthread_mutexattr_destroy(&attr);
   if (__ec) {
     pthread_mutex_destroy(__m);
     return __ec;
   }
   return 0;
 }
  
#endif // _LIBCPP_HAS_THREAD_API_PTHREAD
 
#endif // !_LIBCPP_HAS_THREAD_LIBRARY_EXTERNAL || _LIBCPP_BUILDING_THREAD_LIBRARY_EXTERNAL
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS  
#endif // !_LIBCPP_HAS_NO_THREADS
 

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
  
#ifdef min

#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)

#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min") 
#else

#warning: macro min is incompatible with C++.  #undefing min

#endif

#endif

#undef min

#endif
 
#ifdef max

#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)

#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max") 
#else

#warning: macro max is incompatible with C++.  #undefing max

#endif

#endif

#undef max

#endif

#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  
#ifndef _LIBCPP_HAS_NO_THREADS
 
#ifndef _LIBCPP_THREAD_SAFETY_ANNOTATION

#  ifdef _LIBCPP_HAS_THREAD_SAFETY_ANNOTATIONS

#    define _LIBCPP_THREAD_SAFETY_ANNOTATION(x) __attribute__((x))

#  else

#    define _LIBCPP_THREAD_SAFETY_ANNOTATION(x)

#  endif

#endif  // _LIBCPP_THREAD_SAFETY_ANNOTATION
 class _LIBCPP_TYPE_VIS _LIBCPP_THREAD_SAFETY_ANNOTATION(capability("mutex")) mutex {
 
#ifndef _LIBCPP_CXX03_LANG
    __libcpp_mutex_t __m_ = _LIBCPP_MUTEX_INITIALIZER;
 
#else
    __libcpp_mutex_t __m_;
 
#endif
     bool try_lock() _NOEXCEPT _LIBCPP_THREAD_SAFETY_ANNOTATION(try_acquire_capability(true));
     void unlock() _NOEXCEPT _LIBCPP_THREAD_SAFETY_ANNOTATION(release_capability());
      typedef __libcpp_mutex_t* native_handle_type;
     _LIBCPP_INLINE_VISIBILITY native_handle_type native_handle() {
return &__m_;
}
 };
  static_assert(is_nothrow_default_constructible<mutex>::value,               "the default constructor for std::mutex must be nothrow");
  struct _LIBCPP_TYPE_VIS defer_lock_t {
};
 struct _LIBCPP_TYPE_VIS try_to_lock_t {
};
 struct _LIBCPP_TYPE_VIS adopt_lock_t {
};
  
#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_MUTEX)
 extern const defer_lock_t  defer_lock;
 extern const try_to_lock_t try_to_lock;
 extern const adopt_lock_t  adopt_lock;
  
#else
 constexpr defer_lock_t  defer_lock  = defer_lock_t();
 constexpr try_to_lock_t try_to_lock = try_to_lock_t();
 constexpr adopt_lock_t  adopt_lock  = adopt_lock_t();
  
#endif
 template <class _Mutex> class _LIBCPP_TEMPLATE_VIS _LIBCPP_THREAD_SAFETY_ANNOTATION(scoped_lockable) lock_guard {
 public:     typedef _Mutex mutex_type;
  private:     mutex_type& __m_;
 public:      _LIBCPP_INLINE_VISIBILITY     explicit lock_guard(mutex_type& __m) _LIBCPP_THREAD_SAFETY_ANNOTATION(acquire_capability(__m))         : __m_(__m) {
__m_.lock();
}
     _LIBCPP_INLINE_VISIBILITY     lock_guard(mutex_type& __m, adopt_lock_t) _LIBCPP_THREAD_SAFETY_ANNOTATION(requires_capability(__m))         : __m_(__m) {
}
     _LIBCPP_INLINE_VISIBILITY     ~lock_guard() _LIBCPP_THREAD_SAFETY_ANNOTATION(release_capability()) {
__m_.unlock();
}
  private:     lock_guard(lock_guard const&) _LIBCPP_EQUAL_DELETE;
     lock_guard& operator=(lock_guard const&) _LIBCPP_EQUAL_DELETE;
 };
  template <class _Mutex> class _LIBCPP_TEMPLATE_VIS unique_lock {
 public:     typedef _Mutex mutex_type;
  private:     mutex_type* __m_;
     bool __owns_;
  public:     _LIBCPP_INLINE_VISIBILITY     unique_lock() _NOEXCEPT : __m_(nullptr), __owns_(false) {
}
     _LIBCPP_INLINE_VISIBILITY     explicit unique_lock(mutex_type& __m)         : __m_(_VSTD::addressof(__m)), __owns_(true) {
__m_->lock();
}
     _LIBCPP_INLINE_VISIBILITY     unique_lock(mutex_type& __m, defer_lock_t) _NOEXCEPT         : __m_(_VSTD::addressof(__m)), __owns_(false) {
}
     _LIBCPP_INLINE_VISIBILITY     unique_lock(mutex_type& __m, try_to_lock_t)         : __m_(_VSTD::addressof(__m)), __owns_(__m.try_lock()) {
}
     _LIBCPP_INLINE_VISIBILITY     unique_lock(mutex_type& __m, adopt_lock_t)         : __m_(_VSTD::addressof(__m)), __owns_(true) {
}
     template <class _Clock, class _Duration>     _LIBCPP_INLINE_VISIBILITY         unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)             : __m_(_VSTD::addressof(__m)), __owns_(__m.try_lock_until(__t)) {
}
     template <class _Rep, class _Period>     _LIBCPP_INLINE_VISIBILITY         unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)             : __m_(_VSTD::addressof(__m)), __owns_(__m.try_lock_for(__d)) {
}
     _LIBCPP_INLINE_VISIBILITY     ~unique_lock()     {
         if (__owns_)             __m_->unlock();
     }
  private:     unique_lock(unique_lock const&);
 // = delete;
    unique_lock& operator=(unique_lock const&);
 // = delete;
 public: 
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     unique_lock(unique_lock&& __u) _NOEXCEPT         : __m_(__u.__m_), __owns_(__u.__owns_)         {
             __u.__owns_ = false;
             return *this;
         }
  
#endif  // _LIBCPP_CXX03_LANG
     void lock();
     bool try_lock();
      template <class _Rep, class _Period>         bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);
     template <class _Clock, class _Duration>         bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
      void unlock();
      _LIBCPP_INLINE_VISIBILITY     void swap(unique_lock& __u) _NOEXCEPT     {
         _VSTD::swap(__m_, __u.__m_);
         _VSTD::swap(__owns_, __u.__owns_);
     }
     _LIBCPP_INLINE_VISIBILITY     mutex_type* release() _NOEXCEPT     {
}
     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_EXPLICIT         operator bool () const _NOEXCEPT {
return __owns_;
}
     _LIBCPP_INLINE_VISIBILITY     mutex_type* mutex() const _NOEXCEPT {
return __m_;
}
 };
  template <class _Mutex> void unique_lock<_Mutex>::lock() {
     if (__m_ == nullptr)         __throw_system_error(EPERM, "unique_lock::lock: references null mutex");
     if (__owns_)         __throw_system_error(EDEADLK, "unique_lock::lock: already locked");
     __m_->lock();
     __owns_ = true;
 }
  template <class _Mutex> bool unique_lock<_Mutex>::try_lock() {
     if (__m_ == nullptr)         __throw_system_error(EPERM, "unique_lock::try_lock: references null mutex");
}
  //enum class cv_status
_LIBCPP_DECLARE_STRONG_ENUM(cv_status) {
     no_timeout,     timeout };
 _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(cv_status)  class _LIBCPP_TYPE_VIS condition_variable {
 
#ifndef _LIBCPP_CXX03_LANG
    __libcpp_condvar_t __cv_ = _LIBCPP_CONDVAR_INITIALIZER;
 
#else
    __libcpp_condvar_t __cv_;
 
#endif
 public:     _LIBCPP_INLINE_VISIBILITY 
#ifndef _LIBCPP_CXX03_LANG
#endif
    ~condition_variable();
  private:     condition_variable(const condition_variable&);
 // = delete;
    condition_variable& operator=(const condition_variable&);
 // = delete;
 public:     void notify_one() _NOEXCEPT;
     void notify_all() _NOEXCEPT;
      void wait(unique_lock<mutex>& __lk) _NOEXCEPT;
     template <class _Predicate>         _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS         void wait(unique_lock<mutex>& __lk, _Predicate __pred);
      template <class _Clock, class _Duration>         _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS         cv_status         wait_until(unique_lock<mutex>& __lk,                    const chrono::time_point<_Clock, _Duration>& __t);
      template <class _Clock, class _Duration, class _Predicate>         _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS         bool         wait_until(unique_lock<mutex>& __lk,                    const chrono::time_point<_Clock, _Duration>& __t,                    _Predicate __pred);
      template <class _Rep, class _Period>         _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS         cv_status         wait_for(unique_lock<mutex>& __lk,                  const chrono::duration<_Rep, _Period>& __d);
      template <class _Rep, class _Period, class _Predicate>         bool         _LIBCPP_INLINE_VISIBILITY         wait_for(unique_lock<mutex>& __lk,                  const chrono::duration<_Rep, _Period>& __d,                  _Predicate __pred);
      typedef __libcpp_condvar_t* native_handle_type;
     _LIBCPP_INLINE_VISIBILITY native_handle_type native_handle() {
return &__cv_;
}
  private:     void __do_timed_wait(unique_lock<mutex>& __lk,        chrono::time_point<chrono::system_clock, chrono::nanoseconds>) _NOEXCEPT;
 };
 
#endif // !_LIBCPP_HAS_NO_THREADS
 template <class _To, class _Rep, class _Period> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     chrono::__is_duration<_To>::value,     _To >::type __ceil(chrono::duration<_Rep, _Period> __d) {
     using namespace chrono;
     _To __r = duration_cast<_To>(__d);
     if (__r < __d)         ++__r;
     return __r;
 }
  
#ifndef _LIBCPP_HAS_NO_THREADS
template <class _Predicate> void condition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred) {
     while (!__pred())         wait(__lk);
 }
  template <class _Clock, class _Duration> cv_status condition_variable::wait_until(unique_lock<mutex>& __lk,                                const chrono::time_point<_Clock, _Duration>& __t) {
     using namespace chrono;
     wait_for(__lk, __t - _Clock::now());
     return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
 }
  template <class _Clock, class _Duration, class _Predicate> bool condition_variable::wait_until(unique_lock<mutex>& __lk,                    const chrono::time_point<_Clock, _Duration>& __t,                    _Predicate __pred) {
     while (!__pred())     {
         if (wait_until(__lk, __t) == cv_status::timeout)             return __pred();
     }
     return true;
 }
  template <class _Rep, class _Period> cv_status condition_variable::wait_for(unique_lock<mutex>& __lk,                              const chrono::duration<_Rep, _Period>& __d) {
     using namespace chrono;
     if (__d <= __d.zero())         return cv_status::timeout;
     typedef time_point<system_clock, duration<long double, nano> > __sys_tpf;
     typedef time_point<system_clock, nanoseconds> __sys_tpi;
     __sys_tpf _Max = __sys_tpi::max();
     steady_clock::time_point __c_now = steady_clock::now();
     system_clock::time_point __s_now = system_clock::now();
     if (_Max - __d > __s_now)         __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
     else         __do_timed_wait(__lk, __sys_tpi::max());
     return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :                                                  cv_status::timeout;
 }
  template <class _Rep, class _Period, class _Predicate> inline bool condition_variable::wait_for(unique_lock<mutex>& __lk,                              const chrono::duration<_Rep, _Period>& __d,                              _Predicate __pred) {
     return wait_until(__lk, chrono::steady_clock::now() + __d,                       _VSTD::move(__pred));
 }
  
#endif // !_LIBCPP_HAS_NO_THREADS
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS  
#endif  // _LIBCPP___MUTEX_BASE

#pragma clang module end /*std.__mutex_base*/

#if 0 /* expanded by -frewrite-includes */

#include <functional>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.functional
// -*- C++ -*-
//===------------------------ functional ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_FUNCTIONAL

#define _LIBCPP_FUNCTIONAL
 /*     functional synopsis  namespace std {
  template <class Arg, class Result> struct unary_function {
     typedef Arg    argument_type;
     typedef Result result_type;
 };
  template <class Arg1, class Arg2, class Result> struct binary_function {
 
#endif  // _LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD  
#endif  // _LIBCPP_FUNCTIONAL_BASE

#pragma clang module end /*std.__functional_base*/
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS plus : binary_function<_Tp, _Tp, _Tp> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     _Tp operator()(const _Tp& __x, const _Tp& __y) const         {
return __x + __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS plus<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS minus : binary_function<_Tp, _Tp, _Tp> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     _Tp operator()(const _Tp& __x, const _Tp& __y) const         {
return __x - __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS minus<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS multiplies : binary_function<_Tp, _Tp, _Tp> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     _Tp operator()(const _Tp& __x, const _Tp& __y) const         {
return __x * __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS multiplies<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS divides : binary_function<_Tp, _Tp, _Tp> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     _Tp operator()(const _Tp& __x, const _Tp& __y) const         {
return __x / __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS divides<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS modulus : binary_function<_Tp, _Tp, _Tp> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     _Tp operator()(const _Tp& __x, const _Tp& __y) const         {
return __x % __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS modulus<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS negate : unary_function<_Tp, _Tp> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     _Tp operator()(const _Tp& __x) const         {
return -__x;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS negate<void> {
     template <class _Tp>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_Tp&& __x) const     _NOEXCEPT_(noexcept(- _VSTD::forward<_Tp>(__x)))     -> decltype        (- _VSTD::forward<_Tp>(__x))         {
 return        - _VSTD::forward<_Tp>(__x);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS equal_to : binary_function<_Tp, _Tp, bool> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Tp& __x, const _Tp& __y) const         {
return __x == __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS equal_to<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS not_equal_to : binary_function<_Tp, _Tp, bool> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Tp& __x, const _Tp& __y) const         {
return __x != __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS not_equal_to<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS greater : binary_function<_Tp, _Tp, bool> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Tp& __x, const _Tp& __y) const         {
return __x > __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS greater<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  // less in <__functional_base>
 
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS greater_equal : binary_function<_Tp, _Tp, bool> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Tp& __x, const _Tp& __y) const         {
return __x >= __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS greater_equal<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS less_equal : binary_function<_Tp, _Tp, bool> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Tp& __x, const _Tp& __y) const         {
return __x <= __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS less_equal<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS logical_and : binary_function<_Tp, _Tp, bool> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Tp& __x, const _Tp& __y) const         {
return __x && __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS logical_and<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS logical_or : binary_function<_Tp, _Tp, bool> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Tp& __x, const _Tp& __y) const         {
return __x || __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS logical_or<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u))         {
 return        _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS logical_not : unary_function<_Tp, bool> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Tp& __x) const         {
return !__x;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS logical_not<void> {
     template <class _Tp>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_Tp&& __x) const     _NOEXCEPT_(noexcept(!_VSTD::forward<_Tp>(__x)))     -> decltype        (!_VSTD::forward<_Tp>(__x))         {
 return        !_VSTD::forward<_Tp>(__x);
 }
     typedef void is_transparent;
 };
 
#endif
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS bit_and : binary_function<_Tp, _Tp, _Tp> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     _Tp operator()(const _Tp& __x, const _Tp& __y) const         {
return __x & __y;
}
 };
  
  
#if _LIBCPP_STD_VER > 11
template <class _Tp = void> 
#else
template <class _Tp> 
#endif
struct _LIBCPP_TEMPLATE_VIS bit_xor : binary_function<_Tp, _Tp, _Tp> {
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     _Tp operator()(const _Tp& __x, const _Tp& __y) const         {
return __x ^ __y;
}
 };
  
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS bit_xor<void> {
     template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u))         {
 }
     typedef void is_transparent;
 };
 
#endif
 template <class _Predicate> class _LIBCPP_TEMPLATE_VIS unary_negate     : public unary_function<typename _Predicate::argument_type, bool> {
     _Predicate __pred_;
 public:     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     explicit unary_negate(const _Predicate& __pred)         : __pred_(__pred) {
}
     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const typename _Predicate::argument_type& __x) const         {
return !__pred_(__x);
}
 };
  template <class _Predicate> inline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY unary_negate<_Predicate> not1(const _Predicate& __pred) {
return unary_negate<_Predicate>(__pred);
}
  template <class _Predicate> class _LIBCPP_TEMPLATE_VIS binary_negate     : public binary_function<typename _Predicate::first_argument_type,                              typename _Predicate::second_argument_type,                              bool> {
     _Predicate __pred_;
 public:     _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11      binary_negate(const _Predicate& __pred) : __pred_(__pred) {
}
      _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator()(const typename _Predicate::first_argument_type& __x,                     const typename _Predicate::second_argument_type& __y) const         {
return !__pred_(__x, __y);
}
 };
  template <class _Predicate> inline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY binary_negate<_Predicate> not2(const _Predicate& __pred) {
return binary_negate<_Predicate>(__pred);
}
  
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_BINDERS)
template <class __Operation> class _LIBCPP_TEMPLATE_VIS binder1st     : public unary_function<typename __Operation::second_argument_type,                             typename __Operation::result_type> {
 protected:     __Operation                               op;
     if (__f_ == 0)         __throw_bad_function_call();
     return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);
 }
  
#ifndef _LIBCPP_NO_RTTI
 template<class _Rp, class ..._ArgTypes> const std::type_info& function<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT {
     if (__f_ == 0)         return typeid(void);
     return __f_->target_type();
#include <__functional_03>

#endif /* expanded by -frewrite-includes */
 
#endif
 ////////////////////////////////////////////////////////////////////////////////
//                                  BIND
//==============================================================================
 template<class _Tp> struct __is_bind_expression : public false_type {
};
 template<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_bind_expression     : public __is_bind_expression<typename remove_cv<_Tp>::type> {
};
  
#if _LIBCPP_STD_VER > 14
template <class _Tp> constexpr size_t is_bind_expression_v = is_bind_expression<_Tp>::value;
 
#endif
 template<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {
};
 template<class _Tp> struct _LIBCPP_TEMPLATE_VIS is_placeholder     : public __is_placeholder<typename remove_cv<_Tp>::type> {
};
  
#if _LIBCPP_STD_VER > 14
template <class _Tp> constexpr size_t is_placeholder_v = is_placeholder<_Tp>::value;
 
#endif
 namespace placeholders {
  template <int _Np> struct __ph {
};
  
#if defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)
_LIBCPP_FUNC_VIS extern const __ph<1>   _1;
 _LIBCPP_FUNC_VIS extern const __ph<2>   _2;
 _LIBCPP_FUNC_VIS extern const __ph<3>   _3;
 _LIBCPP_FUNC_VIS extern const __ph<4>   _4;
 _LIBCPP_FUNC_VIS extern const __ph<5>   _5;
 _LIBCPP_FUNC_VIS extern const __ph<6>   _6;
 constexpr __ph<10> _10{
};
 
#endif // defined(_LIBCPP_CXX03_LANG) || defined(_LIBCPP_BUILDING_BIND)
 }
  // placeholders
 template<int _Np> struct __is_placeholder<placeholders::__ph<_Np> >     : public integral_constant<int, _Np> {
};
   
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Uj> inline _LIBCPP_INLINE_VISIBILITY _Tp& __mu(reference_wrapper<_Tp> __t, _Uj&) {
     return __t.get();
 }
  template <class _Ti, class ..._Uj, size_t ..._Indx> inline _LIBCPP_INLINE_VISIBILITY typename __invoke_of<_Ti&, _Uj...>::type __mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>) {
     return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);
     return __ti;
 }
  template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,           class _TupleUj> struct ____mu_return;
  template <bool _Invokable, class _Ti, class ..._Uj> struct ____mu_return_invokable  // false
{
     typedef __nat type;
 };
  template <class _Ti, class _TupleUj> struct ____mu_return<_Ti, true, false, false, _TupleUj> {
     typedef typename _Ti::type& type;
 };
  template <class _Ti, class _TupleUj> struct ____mu_return<_Ti, false, false, false, _TupleUj> {
     typedef _Ti& type;
 };
  template <class _Ti, class _TupleUj> struct __mu_return     : public ____mu_return<_Ti,                            __is_reference_wrapper<_Ti>::value,                            is_bind_expression<_Ti>::value,                            0 < is_placeholder<_Ti>::value &&                            is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,                            _TupleUj> {
 };
  template <class _Fp, class _BoundArgs, class _TupleUj> struct __is_valid_bind_return {
     static const bool value = false;
 };
  template <class _Fp, class ..._BoundArgs, class _TupleUj> struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj> {
     static const bool value = __invokable<_Fp,                     typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
 };
  template <class _Fp, class ..._BoundArgs, class _TupleUj> struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj> {
     static const bool value = __invokable<_Fp,                     typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
 };
  template <class _Fp, class _BoundArgs, class _TupleUj,           bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value> struct __bind_return;
  template <class _Fp, class ..._BoundArgs, class _TupleUj> struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true> {
     typedef typename __invoke_of     <         _Fp&,         typename __mu_return         <             _BoundArgs,             _TupleUj         >::type...     >::type type;
 };
  template <class _Fp, class ..._BoundArgs, class _TupleUj> struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true> {
     typedef typename __invoke_of     <         _Fp&,         typename __mu_return         <             const _BoundArgs,             _TupleUj         >::type...     >::type type;
 };
  template <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args> inline _LIBCPP_INLINE_VISIBILITY typename __bind_return<_Fp, _BoundArgs, _Args>::type __apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,                 _Args&& __args) {
     return _VSTD::__invoke(__f, _VSTD::__mu(_VSTD::get<_Indx>(__bound_args), __args)...);
 }
  template<class _Fp, class ..._BoundArgs> class __bind     : public __weak_result_type<typename decay<_Fp>::type> {
 protected:     typedef typename decay<_Fp>::type _Fd;
     typedef tuple<typename decay<_BoundArgs>::type...> _Td;
 private:     _Fd __f_;
     _Td __bound_args_;
      typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;
 public:     template <class _Gp, class ..._BA,               class = typename enable_if                                <                                   is_constructible<_Fd, _Gp>::value &&                                   !is_same<typename remove_reference<_Gp>::type,                                            __bind>::value                                >::type>       _LIBCPP_INLINE_VISIBILITY       explicit __bind(_Gp&& __f, _BA&& ...__bound_args)         : __f_(_VSTD::forward<_Gp>(__f)),           __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {
}
      template <class ..._Args>         _LIBCPP_INLINE_VISIBILITY         typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type         operator()(_Args&& ...__args)         {
             return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
         }
      template <class ..._Args>         _LIBCPP_INLINE_VISIBILITY         typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type         operator()(_Args&& ...__args) const         {
             return _VSTD::__apply_functor(__f_, __bound_args_, __indices(),                                    tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));
         }
 };
  template<class _Fp, class ..._BoundArgs> struct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {
};
  template<class _Rp, class _Fp, class ..._BoundArgs> class __bind_r     : public __bind<_Fp, _BoundArgs...> {
     typedef __bind<_Fp, _BoundArgs...> base;
};
  template<class _Fp, class ..._BoundArgs> inline _LIBCPP_INLINE_VISIBILITY __bind<_Fp, _BoundArgs...> bind(_Fp&& __f, _BoundArgs&&... __bound_args) {
     typedef __bind<_Fp, _BoundArgs...> type;
     return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
 }
  template<class _Rp, class _Fp, class ..._BoundArgs> inline _LIBCPP_INLINE_VISIBILITY __bind_r<_Rp, _Fp, _BoundArgs...> bind(_Fp&& __f, _BoundArgs&&... __bound_args) {
     typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
     return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);
 }
  
#endif  // _LIBCPP_CXX03_LANG
 
#if _LIBCPP_STD_VER > 14
 
#define __cpp_lib_invoke 201411
 template <class _Fn, class ..._Args> result_of_t<_Fn&&(_Args&&...)> invoke(_Fn&& __f, _Args&&... __args)     noexcept(noexcept(_VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...))) {
     return _VSTD::__invoke(_VSTD::forward<_Fn>(__f), _VSTD::forward<_Args>(__args)...);
 }
  template <class _DecayFunc> class _LIBCPP_TEMPLATE_VIS __not_fn_imp {
   _DecayFunc __fd;
  public:     __not_fn_imp() = delete;
      template <class ..._Args>     _LIBCPP_INLINE_VISIBILITY     auto operator()(_Args&& ...__args) &             noexcept(noexcept(!_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...)))         -> decltype(          !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...))         {
 return              !_VSTD::invoke(__fd, _VSTD::forward<_Args>(__args)...);
 return              !_VSTD::invoke(_VSTD::move(__fd), _VSTD::forward<_Args>(__args)...);
 }
  private:     template <class _RawFunc,               class = enable_if_t<!is_same<decay_t<_RawFunc>, __not_fn_imp>::value>>     _LIBCPP_INLINE_VISIBILITY     explicit __not_fn_imp(_RawFunc&& __rf)         : __fd(_VSTD::forward<_RawFunc>(__rf)) {
}
      template <class _RawFunc>     friend inline _LIBCPP_INLINE_VISIBILITY     __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&&);
 };
  template <class _RawFunc> inline _LIBCPP_INLINE_VISIBILITY __not_fn_imp<decay_t<_RawFunc>> not_fn(_RawFunc&& __fn) {
     return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));
 }
  
#endif
 // struct hash<T*> in <memory>
 _LIBCPP_END_NAMESPACE_STD  
#endif  // _LIBCPP_FUNCTIONAL

#pragma clang module end /*std.functional*/
#pragma clang module begin std.memory
// -*- C++ -*-
//===-------------------------- memory ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_MEMORY

#define _LIBCPP_MEMORY
 /*     memory synopsis  namespace std {
  struct allocator_arg_t {
  void* align(size_t alignment, size_t size, void*& ptr, size_t& space);
  }
  // std
 */
 
#if 0 /* expanded by -frewrite-includes */

#include <__config>
}
   __compressed_pair_elem(_ParamT __p) : __value_(std::forward<_ParamT>(__p)) {
}
 
#endif
   reference __get() _NOEXCEPT {
 return __value_;
 }
 }
  template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT {
     return !__x;
 }
  template <typename _Alloc> inline _LIBCPP_INLINE_VISIBILITY void __swap_allocator(_Alloc &, _Alloc &, false_type) _NOEXCEPT {
}
  template <typename _Alloc, typename _Traits=allocator_traits<_Alloc> > struct __noexcept_move_assign_container : public integral_constant<bool,     _Traits::propagate_on_container_move_assignment::value 
#if _LIBCPP_STD_VER > 14
 _Traits::destroy(__a, __addr());
 }
     };
 
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS  
#endif  // _LIBCPP_MEMORY

#pragma clang module end /*std.memory*/

#ifndef _LIBCPP_CXX03_LANG

#if 0 /* expanded by -frewrite-includes */

#include <tuple>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.tuple
// -*- C++ -*-
//===--------------------------- tuple ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_TUPLE

#define _LIBCPP_TUPLE
 /*     tuple synopsis  namespace std {
  template <class... T> class tuple {
 public:     constexpr tuple();
     explicit tuple(const T&...);
  // constexpr in C++14
    template <class... U>         explicit tuple(U&&...);
  // constexpr in C++14

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#include <cstddef>

#endif /* expanded by -frewrite-includes */
#if 0 /* expanded by -frewrite-includes */

#include <__functional_base>

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

 }
  
#if _LIBCPP_STD_VER > 14
template <class _Tp> constexpr size_t tuple_size_v = tuple_size<_Tp>::value;
  
#define _LIBCPP_NOEXCEPT_RETURN(...) noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }
 template <class _Fn, class _Tuple, size_t ..._Id> inline _LIBCPP_INLINE_VISIBILITY constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,                                             __tuple_indices<_Id...>) _LIBCPP_NOEXCEPT_RETURN(     _VSTD::__invoke_constexpr(         _VSTD::forward<_Fn>(__f),         _VSTD::get<_Id>(_VSTD::forward<_Tuple>(__t))...) )  template <class _Fn, class _Tuple> inline _LIBCPP_INLINE_VISIBILITY constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t) _LIBCPP_NOEXCEPT_RETURN(     _VSTD::__apply_tuple_impl(         _VSTD::forward<_Fn>(__f), _VSTD::forward<_Tuple>(__t),         typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{
}
) )  template <class _Tp, class _Tuple, size_t... _Idx> inline _LIBCPP_INLINE_VISIBILITY constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>) _LIBCPP_NOEXCEPT_RETURN(     _Tp(_VSTD::get<_Idx>(_VSTD::forward<_Tuple>(__t))...) )  template <class _Tp, class _Tuple> inline _LIBCPP_INLINE_VISIBILITY constexpr _Tp make_from_tuple(_Tuple&& __t) _LIBCPP_NOEXCEPT_RETURN(     _VSTD::__make_from_tuple_impl<_Tp>(_VSTD::forward<_Tuple>(__t),         typename __make_tuple_indices<tuple_size_v<decay_t<_Tuple>>>::type{
}
) )  
#undef _LIBCPP_NOEXCEPT_RETURN
 
#endif // _LIBCPP_STD_VER > 14
 
#endif // !defined(_LIBCPP_CXX03_LANG)
 _LIBCPP_END_NAMESPACE_STD  
#endif  // _LIBCPP_TUPLE

#pragma clang module end /*std.tuple*/

#endif

 _LIBCPP_PUSH_MACROS 
#if 0 /* expanded by -frewrite-includes */

#include <__undef_macros>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.__undef_macros
//===----------------------------------------------------------------------===//
  
#ifdef min

#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)

#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min") 
#else

#warning: macro min is incompatible with C++.  #undefing min

#endif

#endif
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)

#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max") 
#else

#warning: macro max is incompatible with C++.  #undefing max

#endif

#endif

#undef max

#endif

#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  
#ifndef _LIBCPP_HAS_NO_THREADS
 class _LIBCPP_TYPE_VIS recursive_mutex {
     __libcpp_recursive_mutex_t __m_;
  public:      recursive_mutex();
      ~recursive_mutex();
  private:     recursive_mutex(const recursive_mutex&);
 // = delete;
    recursive_mutex& operator=(const recursive_mutex&);
 // = delete;
 public:     void lock();
     bool try_lock() _NOEXCEPT;
     void unlock()  _NOEXCEPT;
      typedef __libcpp_recursive_mutex_t* native_handle_type;
      _LIBCPP_INLINE_VISIBILITY     native_handle_type native_handle() {
return &__m_;
}
 };
  class _LIBCPP_TYPE_VIS timed_mutex {
     mutex              __m_;
     condition_variable __cv_;
     bool               __locked_;
     bool try_lock() _NOEXCEPT;
     template <class _Rep, class _Period>         _LIBCPP_INLINE_VISIBILITY         bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)             {
return try_lock_until(chrono::steady_clock::now() + __d);
}
     template <class _Clock, class _Duration>         _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS         bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
     void unlock() _NOEXCEPT;
 };
  template <class _Clock, class _Duration> bool timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t) {
     return false;
 }
  class _LIBCPP_TYPE_VIS recursive_timed_mutex {
     mutex              __m_;
     condition_variable __cv_;
     size_t             __count_;
     __libcpp_thread_id __id_;
 public:      recursive_timed_mutex();
     template <class _Rep, class _Period>         _LIBCPP_INLINE_VISIBILITY         bool try_lock_for(const chrono::duration<_Rep, _Period>& __d)             {
return try_lock_until(chrono::steady_clock::now() + __d);
}
     template <class _Clock, class _Duration>         _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS         bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
     void unlock() _NOEXCEPT;
 };
  template <class _Clock, class _Duration> bool recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t) {
     using namespace chrono;
     __libcpp_thread_id __id = __libcpp_thread_get_current_id();
     unique_lock<mutex> lk(__m_);
     if (__libcpp_thread_id_equal(__id, __id_))     {
         if (__count_ == numeric_limits<size_t>::max())             return false;
         ++__count_;
         return true;
     }
     bool no_timeout = _Clock::now() < __t;
     while (no_timeout && __count_ != 0)         no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
     if (__count_ == 0)     {
         __count_ = 1;
         __id_ = __id;
         return true;
     }
     return false;
 }
  template <class _L0, class _L1> int try_lock(_L0& __l0, _L1& __l1) {
     unique_lock<_L0> __u0(__l0, try_to_lock);
     if (__u0.owns_lock())     {
         if (__l1.try_lock())         {
             __u0.release();
             return -1;
         }
         else             return 1;
     }
     return 0;
 }
  
#ifndef _LIBCPP_CXX03_LANG
 template <class _L0, class _L1, class _L2, class... _L3> int try_lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3) {
     int __r = 0;
 }
  
#endif  // _LIBCPP_CXX03_LANG
 template <class _L0, class _L1> void lock(_L0& __l0, _L1& __l1) {
     while (true)     {
         {
             unique_lock<_L0> __u0(__l0);
             if (__l1.try_lock())             {
                 __u0.release();
                 break;
             }
         }
         __libcpp_thread_yield();
         {
             unique_lock<_L1> __u1(__l1);
             if (__l0.try_lock())             {
                 __u1.release();
                 break;
             }
         }
         __libcpp_thread_yield();
     }
 }
  
#ifndef _LIBCPP_CXX03_LANG
 template <class _L0, class _L1, class _L2, class ..._L3> void __lock_first(int __i, _L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3) {
     while (true)     {
         switch (__i)         {
         case 0:             {
                 unique_lock<_L0> __u0(__l0);
                 __i = try_lock(__l1, __l2, __l3...);
                 if (__i == -1)                 {                     __u0.release();                     return;                 }
             }
             ++__i;
             __libcpp_thread_yield();
             break;
         case 1:             {
                 unique_lock<_L1> __u1(__l1);
                 __i = try_lock(__l2, __l3..., __l0);
                 if (__i == -1)                 {                     __u1.release();                     return;                 }
             }
             if (__i == sizeof...(_L3) + 1)                 __i = 0;
             else                 __i += 2;
             __libcpp_thread_yield();
             break;
         default:             __lock_first(__i - 2, __l2, __l3..., __l0, __l1);
             return;
         }
     }
 }
  template <class _L0, class _L1, class _L2, class ..._L3> inline _LIBCPP_INLINE_VISIBILITY void lock(_L0& __l0, _L1& __l1, _L2& __l2, _L3& ...__l3) {
     __lock_first(0, __l0, __l1, __l2, __l3...);
 }
  template <class _L0> inline _LIBCPP_INLINE_VISIBILITY void __unlock(_L0& __l0) {
     __l0.unlock();
 }
  template <class _L0, class _L1> inline _LIBCPP_INLINE_VISIBILITY void __unlock(_L0& __l0, _L1& __l1) {
     __l0.unlock();
     __l1.unlock();
 }
  template <class _L0, class _L1, class _L2, class ..._L3> inline _LIBCPP_INLINE_VISIBILITY void __unlock(_L0& __l0, _L1& __l1, _L2& __l2, _L3&... __l3) {
     __l0.unlock();
     __l1.unlock();
     _VSTD::__unlock(__l2, __l3...);
 }
  
#endif  // _LIBCPP_CXX03_LANG
 
#if _LIBCPP_STD_VER > 14
template <class ..._Mutexes> class _LIBCPP_TEMPLATE_VIS scoped_lock;
  template <> class _LIBCPP_TEMPLATE_VIS scoped_lock<> {
 public:     explicit scoped_lock() {
}
     ~scoped_lock() = default;
      _LIBCPP_INLINE_VISIBILITY     explicit scoped_lock(adopt_lock_t) {
}
      scoped_lock(scoped_lock const&) = delete;
     scoped_lock& operator=(scoped_lock const&) = delete;
 };
  template <class _Mutex> class _LIBCPP_TEMPLATE_VIS scoped_lock<_Mutex> {
 public:     typedef _Mutex  mutex_type;
 private:     mutex_type& __m_;
 public:     explicit scoped_lock(mutex_type & __m) _LIBCPP_THREAD_SAFETY_ANNOTATION(acquire_capability(__m))         : __m_(__m) {
__m_.lock();
}
      ~scoped_lock() _LIBCPP_THREAD_SAFETY_ANNOTATION(release_capability()) {
__m_.unlock();
}
      _LIBCPP_INLINE_VISIBILITY     explicit scoped_lock(adopt_lock_t, mutex_type& __m) _LIBCPP_THREAD_SAFETY_ANNOTATION(requires_capability(__m))         : __m_(__m) {
}
      scoped_lock(scoped_lock const&) = delete;
     scoped_lock& operator=(scoped_lock const&) = delete;
 };
  template <class ..._MArgs> class _LIBCPP_TEMPLATE_VIS scoped_lock {
     static_assert(sizeof...(_MArgs) > 1, "At least 2 lock types required");
     typedef tuple<_MArgs&...> _MutexTuple;
  public:     _LIBCPP_INLINE_VISIBILITY     explicit scoped_lock(_MArgs&... __margs)       : __t_(__margs...)     {
         _VSTD::lock(__margs...);
     }
      _LIBCPP_INLINE_VISIBILITY     scoped_lock(adopt_lock_t, _MArgs&... __margs)         : __t_(__margs...)     {
     }
      _LIBCPP_INLINE_VISIBILITY     ~scoped_lock() {
         typedef typename __make_tuple_indices<sizeof...(_MArgs)>::type _Indices;
         __unlock_unpack(_Indices{
}
, __t_);
     }
      scoped_lock(scoped_lock const&) = delete;
     scoped_lock& operator=(scoped_lock const&) = delete;
  private:     template <size_t ..._Indx>     _LIBCPP_INLINE_VISIBILITY     static void __unlock_unpack(__tuple_indices<_Indx...>, _MutexTuple& __mt) {
         _VSTD::__unlock(_VSTD::get<_Indx>(__mt)...);
     }
      _MutexTuple __t_;
 };
  
#endif // _LIBCPP_STD_VER > 14

#endif // !_LIBCPP_HAS_NO_THREADS
 struct _LIBCPP_TEMPLATE_VIS once_flag;
  
#ifndef _LIBCPP_CXX03_LANG
 template<class _Callable, class... _Args> _LIBCPP_INLINE_VISIBILITY void call_once(once_flag&, _Callable&&, _Args&&...);
  
#else  // _LIBCPP_CXX03_LANG
 template<class _Callable> _LIBCPP_INLINE_VISIBILITY void call_once(once_flag&, _Callable&);
  template<class _Callable> _LIBCPP_INLINE_VISIBILITY void call_once(once_flag&, const _Callable&);
  
#endif  // _LIBCPP_CXX03_LANG
 struct _LIBCPP_TEMPLATE_VIS once_flag {
     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR         once_flag() _NOEXCEPT : __state_(0) {
}
  private:     once_flag(const once_flag&);
 // = delete;
    once_flag& operator=(const once_flag&);
 // = delete;
     unsigned long __state_;
  
#ifndef _LIBCPP_CXX03_LANG
    template<class _Callable, class... _Args>     friend     void call_once(once_flag&, _Callable&&, _Args&&...);
 
#else  // _LIBCPP_CXX03_LANG
    template<class _Callable>     friend     void call_once(once_flag&, _Callable&);
      template<class _Callable>     friend     void call_once(once_flag&, const _Callable&);
 
#endif  // _LIBCPP_CXX03_LANG
};
  
#ifndef _LIBCPP_CXX03_LANG
 template <class _Fp> class __call_once_param {
     _Fp& __f_;
 public:     _LIBCPP_INLINE_VISIBILITY     explicit __call_once_param(_Fp& __f) : __f_(__f) {
}
      _LIBCPP_INLINE_VISIBILITY     void operator()()     {
         typedef typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
         __execute(_Index());
     }
  private:     template <size_t ..._Indices>     _LIBCPP_INLINE_VISIBILITY     void __execute(__tuple_indices<_Indices...>)     {
         __invoke(_VSTD::get<0>(_VSTD::move(__f_)), _VSTD::get<_Indices>(_VSTD::move(__f_))...);
     }
 };
  
#else
 template <class _Fp> class __call_once_param {
     _Fp& __f_;
 public:     _LIBCPP_INLINE_VISIBILITY     explicit __call_once_param(_Fp& __f) : __f_(__f) {
}
      _LIBCPP_INLINE_VISIBILITY     void operator()()     {
         __f_();
     }
 };
  
#endif
 template <class _Fp> void __call_once_proxy(void* __vp) {
     __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
     (*__p)();
 }
  _LIBCPP_FUNC_VIS void __call_once(volatile unsigned long&, void*, void(*)(void*));
  
#ifndef _LIBCPP_CXX03_LANG
 template<class _Callable, class... _Args> inline _LIBCPP_INLINE_VISIBILITY void call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args) {
     if (__libcpp_acquire_load(&__flag.__state_) != ~0ul)     {
         typedef tuple<_Callable&&, _Args&&...> _Gp;
         _Gp __f(_VSTD::forward<_Callable>(__func), _VSTD::forward<_Args>(__args)...);
         __call_once_param<_Gp> __p(__f);
     }
 }
  
#endif  // _LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS  
#endif  // _LIBCPP_MUTEX

#pragma clang module end /*std.mutex*/

#if 0 /* expanded by -frewrite-includes */

#include <cstdint>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.compat.cstdint
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_CSTDINT

#define _LIBCPP_CSTDINT
 /*     cstdint synopsis  Macros:      INT8_MIN     INT16_MIN     INT32_MIN     INT64_MIN      INT8_MAX     INT16_MAX     INT32_MAX     INT64_MAX      UINT8_MAX     UINT16_MAX     UINT32_MAX     UINT64_MAX      INT_LEAST8_MIN     INT_LEAST16_MIN     INT_LEAST32_MIN     INT_LEAST64_MIN      INT_LEAST8_MAX     INT_LEAST16_MAX     INT_LEAST32_MAX     INT_LEAST64_MAX      UINT_LEAST8_MAX     UINT_LEAST16_MAX     UINT_LEAST32_MAX     UINT_LEAST64_MAX      INT_FAST8_MIN     INT_FAST16_MIN     INT_FAST32_MIN     INT_FAST64_MIN      INT_FAST8_MAX     INT_FAST16_MAX     INT_FAST32_MAX     INT_FAST64_MAX      UINT_FAST8_MAX     UINT_FAST16_MAX     UINT_FAST32_MAX     UINT_FAST64_MAX      INTPTR_MIN     INTPTR_MAX     UINTPTR_MAX      INTMAX_MIN     INTMAX_MAX      UINTMAX_MAX      PTRDIFF_MIN     PTRDIFF_MAX      SIG_ATOMIC_MIN     SIG_ATOMIC_MAX      SIZE_MAX      WCHAR_MIN     WCHAR_MAX      WINT_MIN     WINT_MAX      INT8_C(value)     INT16_C(value)     INT32_C(value)     INT64_C(value)      UINT8_C(value)     UINT16_C(value)     UINT32_C(value)     UINT64_C(value)      INTMAX_C(value)     UINTMAX_C(value)  namespace std {
  Types:      int8_t     int16_t     int32_t     int64_t      uint8_t     uint16_t     uint32_t     uint64_t      int_least8_t     int_least16_t     int_least32_t     int_least64_t      uint_least8_t     uint_least16_t     uint_least32_t     uint_least64_t      int_fast8_t     int_fast16_t     int_fast32_t     int_fast64_t      uint_fast8_t     uint_fast16_t     uint_fast32_t     uint_fast64_t      intptr_t     uintptr_t      intmax_t     uintmax_t  }
  // std
*/
 
#if 0 /* expanded by -frewrite-includes */

#include <__config>

#endif /* expanded by -frewrite-includes */
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  using::int8_t;
 using::int16_t;
 using::int32_t;
 using::int64_t;
  using::uint8_t;
 using::uint16_t;
 using::uint32_t;
 using::uint64_t;
  using::int_least8_t;
 using::int_least16_t;
 
#ifdef tolower

#undef tolower

#endif
 
#ifdef toupper

#undef toupper

#endif
 using ::ispunct;
 using ::isspace;
 using ::isupper;
 using ::isxdigit;
 using ::tolower;
 using ::toupper;
  _LIBCPP_END_NAMESPACE_STD  
#endif  // _LIBCPP_CCTYPE

#pragma clang module end /*std.compat.cctype*/

#if 0 /* expanded by -frewrite-includes */

#include <locale.h>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin std.depr.locale_h
// -*- C++ -*-
//===---------------------------- locale.h --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
 
#ifndef _LIBCPP_LOCALE_H

#define _LIBCPP_LOCALE_H
 
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 
#if 0 /* expanded by -frewrite-includes */

#include_next <locale.h>

#endif /* expanded by -frewrite-includes */
 
#endif  // _LIBCPP_LOCALE_H

#pragma clang module end /*std.depr.locale_h*/

#if defined(_LIBCPP_MSVCRT_LIKE)

#if 0 /* expanded by -frewrite-includes */

#pragma GCC system_header

#endif /* expanded by -frewrite-includes */

#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  
#if !defined(_LIBCPP_LOCALE__L_EXTENSIONS) || defined(_LIBCPP_MSVCRT)
struct __libcpp_locale_guard {
   _LIBCPP_INLINE_VISIBILITY   __libcpp_locale_guard(locale_t& __loc) : __old_loc_(uselocale(__loc)) {
}
    _LIBCPP_INLINE_VISIBILITY   ~__libcpp_locale_guard() {
     if (__old_loc_)       uselocale(__old_loc_);
   }
    locale_t __old_loc_;
 private:   __libcpp_locale_guard(__libcpp_locale_guard const&);
   __libcpp_locale_guard& operator=(__libcpp_locale_guard const&);
 };
 
#endif
  class _LIBCPP_TYPE_VIS locale;
  template <class _Facet> _LIBCPP_INLINE_VISIBILITY bool has_facet(const locale&) _NOEXCEPT;
  template <class _Facet> _LIBCPP_INLINE_VISIBILITY const _Facet& use_facet(const locale&);
  class _LIBCPP_TYPE_VIS locale {
 public:     // types:
    class _LIBCPP_TYPE_VIS facet;
     class _LIBCPP_TYPE_VIS id;
      typedef int category;
     _LIBCPP_AVAILABILITY_LOCALE_CATEGORY     static const category // values assigned here are for exposition only
        none     = 0,         collate  = LC_COLLATE_MASK,         ctype    = LC_CTYPE_MASK,         monetary = LC_MONETARY_MASK,         numeric  = LC_NUMERIC_MASK,         time     = LC_TIME_MASK,         messages = LC_MESSAGES_MASK,         all = collate | ctype | monetary | numeric | time | messages;
      // construct/copy/destroy:
    locale()  _NOEXCEPT;
     locale(const locale&)  _NOEXCEPT;
     explicit locale(const char*);
     explicit locale(const string&);
     locale(const locale&, const char*, category);
     locale(const locale&, const string&, category);
     template <class _Facet>         _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);
     locale(const locale&, const locale&, category);
      ~locale();
      const locale& operator=(const locale&)  _NOEXCEPT;
      template <class _Facet>       _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS       locale combine(const locale&) const;
      // locale operations:
    string name() const;
     bool operator==(const locale&) const;
     bool operator!=(const locale& __y) const {
return !(*this == __y);
}
     template <class _CharT, class _Traits, class _Allocator>       _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS       bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,                       const basic_string<_CharT, _Traits, _Allocator>&) const;
      // global locale objects:
    static locale global(const locale&);
     static const locale& classic();
  private:     class __imp;
     __imp* __locale_;
      void __install_ctor(const locale&, facet*, long);
     static locale& __global();
     bool has_facet(id&) const;
     const facet* use_facet(id&) const;
      template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;
     template <class _Facet> friend const _Facet& use_facet(const locale&);
 };
  class _LIBCPP_TYPE_VIS locale::facet     : public __shared_count {
 protected:     _LIBCPP_INLINE_VISIBILITY     explicit facet(size_t __refs = 0)         : __shared_count(static_cast<long>(__refs)-1) {
}
      virtual ~facet();
  //    facet(const facet&) = delete;     // effectively done in __shared_count
//    void operator=(const facet&) = delete;
private:     virtual void __on_zero_shared() _NOEXCEPT;
 };
  class _LIBCPP_TYPE_VIS locale::id {
     once_flag      __flag_;
     int32_t        __id_;
      static int32_t __next_id;
 public:     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {
}
 private:     void __init();
 };
  template <class _Facet> inline _LIBCPP_INLINE_VISIBILITY locale::locale(const locale& __other, _Facet* __f) {
     __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
 }
  template <class _Facet> locale locale::combine(const locale& __other) const {
     if (!_VSTD::has_facet<_Facet>(__other))         __throw_runtime_error("locale::combine: locale missing facet");
      return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));
 }
  template <class _Facet> inline _LIBCPP_INLINE_VISIBILITY bool has_facet(const locale& __l)  _NOEXCEPT {
     return __l.has_facet(_Facet::id);
 }
  template <class _Facet> inline _LIBCPP_INLINE_VISIBILITY const _Facet& use_facet(const locale& __l) {
     return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
 }
  // template <class _CharT> class collate;
 template <class _CharT> class _LIBCPP_TEMPLATE_VIS collate     : public locale::facet {
 public:     typedef _CharT char_type;
     typedef basic_string<char_type> string_type;
      _LIBCPP_INLINE_VISIBILITY     explicit collate(size_t __refs = 0)         : locale::facet(__refs) {
}
      _LIBCPP_INLINE_VISIBILITY     int compare(const char_type* __lo1, const char_type* __hi1,                 const char_type* __lo2, const char_type* __hi2) const     {
         return do_compare(__lo1, __hi1, __lo2, __hi2);
     }
      _LIBCPP_INLINE_VISIBILITY     string_type transform(const char_type* __lo, const char_type* __hi) const     {
         return do_transform(__lo, __hi);
     }
      _LIBCPP_INLINE_VISIBILITY     long hash(const char_type* __lo, const char_type* __hi) const     {
         return do_hash(__lo, __hi);
     }
      static locale::id id;
  protected:     ~collate();
     virtual int do_compare(const char_type* __lo1, const char_type* __hi1,                            const char_type* __lo2, const char_type* __hi2) const;
     virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const         {
return string_type(__lo, __hi);
}
     virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
 };
  template <class _CharT> locale::id collate<_CharT>::id;
  template <class _CharT> collate<_CharT>::~collate() {
 }
  template <class _CharT> int collate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,                             const char_type* __lo2, const char_type* __hi2) const {
     for (;
 __lo2 != __hi2;
 ++__lo1, ++__lo2)     {
         if (__lo1 == __hi1 || *__lo1 < *__lo2)             return -1;
         if (*__lo2 < *__lo1)             return 1;
     }
     return __lo1 != __hi1;
 }
  template <class _CharT> long collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const {
     size_t __h = 0;
     const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;
     const size_t __mask = size_t(0xF) << (__sr + 4);
 }
  _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS collate<wchar_t>)  // template <class CharT> class collate_byname;
 template <class _CharT> class _LIBCPP_TEMPLATE_VIS collate_byname;
  template <> class _LIBCPP_TYPE_VIS collate_byname<char>     : public collate<char> {
     locale_t __l;
 public:     typedef char char_type;
     typedef basic_string<char_type> string_type;
      explicit collate_byname(const char* __n, size_t __refs = 0);
     explicit collate_byname(const string& __n, size_t __refs = 0);
  protected:     ~collate_byname();
     virtual int do_compare(const char_type* __lo1, const char_type* __hi1,                            const char_type* __lo2, const char_type* __hi2) const;
     virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
 };
  template <> class _LIBCPP_TYPE_VIS collate_byname<wchar_t>     : public collate<wchar_t> {
     locale_t __l;
 public:     typedef wchar_t char_type;
     typedef basic_string<char_type> string_type;
      explicit collate_byname(const char* __n, size_t __refs = 0);
     explicit collate_byname(const string& __n, size_t __refs = 0);
  protected:     ~collate_byname();
      virtual int do_compare(const char_type* __lo1, const char_type* __hi1,                            const char_type* __lo2, const char_type* __hi2) const;
     virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;
 };
  template <class _CharT, class _Traits, class _Allocator> bool locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,                    const basic_string<_CharT, _Traits, _Allocator>& __y) const {
     return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(                                        __x.data(), __x.data() + __x.size(),                                        __y.data(), __y.data() + __y.size()) < 0;
 }
  // template <class charT> class ctype
 class _LIBCPP_TYPE_VIS ctype_base {
 public: 
#if defined(__GLIBC__)
    typedef unsigned short mask;
     static const mask space  = _ISspace;
     static const mask print  = _ISprint;
     static const mask cntrl  = _IScntrl;
     static const mask upper  = _ISupper;
     static const mask lower  = _ISlower;
     static const mask alpha  = _ISalpha;
     static const mask digit  = _ISdigit;
     static const mask punct  = _ISpunct;
     static const mask xdigit = _ISxdigit;
     static const mask blank  = _ISblank;
 
#elif defined(_LIBCPP_MSVCRT_LIKE)
    typedef unsigned short mask;
     static const mask space  = _SPACE;
     static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;
     
#endif
    static const mask alnum  = alpha | digit;
       static const mask graph  = alnum | punct;
        _LIBCPP_ALWAYS_INLINE ctype_base() {
  }
   };
    template <class _CharT> class _LIBCPP_TEMPLATE_VIS ctype;
    template <> class _LIBCPP_TYPE_VIS ctype<wchar_t>     : public locale::facet,       public ctype_base {
   public:     typedef wchar_t char_type;
        _LIBCPP_ALWAYS_INLINE     explicit ctype(size_t __refs = 0)         : locale::facet(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE     bool is(mask __m, char_type __c) const     {
           return do_is(__m, __c);
       }
        _LIBCPP_ALWAYS_INLINE     const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const     {
           return do_is(__low, __high, __vec);
       }
        _LIBCPP_ALWAYS_INLINE     const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const     {
           return do_scan_is(__m, __low, __high);
       }
        _LIBCPP_ALWAYS_INLINE     const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const     {
           return do_scan_not(__m, __low, __high);
       }
        _LIBCPP_ALWAYS_INLINE     const char* widen(const char* __low, const char* __high, char_type* __to) const     {
           return do_widen(__low, __high, __to);
       }
        _LIBCPP_ALWAYS_INLINE     char narrow(char_type __c, char __dfault) const     {
           return do_narrow(__c, __dfault);
       }
        _LIBCPP_ALWAYS_INLINE     const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const     {
           return do_narrow(__low, __high, __dfault, __to);
       }
        static locale::id id;
    protected:     ~ctype();
       virtual bool do_is(mask __m, char_type __c) const;
       virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
       virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
       virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
       virtual char_type do_toupper(char_type) const;
       virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
       virtual char_type do_tolower(char_type) const;
       virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
       virtual char_type do_widen(char) const;
       virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
       virtual char do_narrow(char_type, char __dfault) const;
       virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
   };
    template <> class _LIBCPP_TYPE_VIS ctype<char>     : public locale::facet, public ctype_base {
       const mask* __tab_;
       bool        __del_;
   public:     typedef char char_type;
        explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);
        _LIBCPP_ALWAYS_INLINE     bool is(mask __m, char_type __c) const     {
       }
        _LIBCPP_ALWAYS_INLINE     char narrow(char_type __c, char __dfault) const     {
           return do_narrow(__c, __dfault);
       }
        _LIBCPP_ALWAYS_INLINE     const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const     {
           return do_narrow(__low, __high, __dfault, __to);
       }
        static locale::id id;
      
#ifdef _CACHED_RUNES
    static const size_t table_size = _CACHED_RUNES;
     
#else
    static const size_t table_size = 256;
    // FIXME: Don't hardcode this.
  
     
#endif
 protected:     ~ctype();
       virtual char_type do_toupper(char_type __c) const;
       virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
       virtual char_type do_tolower(char_type __c) const;
       virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
       virtual char_type do_widen(char __c) const;
       virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
       virtual char do_narrow(char_type, char __dfault) const;
       virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
   };
    template <class _CharT> inline _LIBCPP_INLINE_VISIBILITY bool isspace(_CharT __c, const locale& __loc) {
       return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
   }
    template <class _CharT> inline _LIBCPP_INLINE_VISIBILITY bool isprint(_CharT __c, const locale& __loc) {
       return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
   }
    template <class _CharT> inline _LIBCPP_INLINE_VISIBILITY bool iscntrl(_CharT __c, const locale& __loc) {
       return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
   }
    template <class _CharT> inline _LIBCPP_INLINE_VISIBILITY bool isupper(_CharT __c, const locale& __loc) {
       return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
   }
    template <class _CharT> inline _LIBCPP_INLINE_VISIBILITY bool isalnum(_CharT __c, const locale& __loc) {
       return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
   }
    template <class _CharT> inline _LIBCPP_INLINE_VISIBILITY bool isgraph(_CharT __c, const locale& __loc) {
       return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
   }
    template <class _CharT> inline _LIBCPP_INLINE_VISIBILITY _CharT toupper(_CharT __c, const locale& __loc) {
       return use_facet<ctype<_CharT> >(__loc).toupper(__c);
   }
    template <class _CharT> inline _LIBCPP_INLINE_VISIBILITY _CharT tolower(_CharT __c, const locale& __loc) {
       return use_facet<ctype<_CharT> >(__loc).tolower(__c);
   }
    // codecvt_base
 class _LIBCPP_TYPE_VIS codecvt_base {
   public:     _LIBCPP_ALWAYS_INLINE codecvt_base() {
  }
       enum result {
  ok, partial, error, noconv};
   };
    // template <class internT, class externT, class stateT> class codecvt;
 template <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TEMPLATE_VIS codecvt;
    // template <> class codecvt<char, char, mbstate_t>
 template <> class _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>     : public locale::facet,       public codecvt_base {
   public:     typedef char      intern_type;
       typedef char      extern_type;
       typedef mbstate_t state_type;
        _LIBCPP_ALWAYS_INLINE     explicit codecvt(size_t __refs = 0)         : locale::facet(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE     result out(state_type& __st,                const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,                extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const     {
           return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
       }
        _LIBCPP_ALWAYS_INLINE     result unshift(state_type& __st,                    extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const     {
           return do_unshift(__st, __to, __to_end, __to_nxt);
       }
        _LIBCPP_ALWAYS_INLINE     result in(state_type& __st,               const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,               intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const     {
           return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
       }
        _LIBCPP_ALWAYS_INLINE     int encoding() const  _NOEXCEPT     {
           return do_encoding();
           return do_max_length();
       }
        static locale::id id;
    protected:     _LIBCPP_ALWAYS_INLINE     explicit codecvt(const char*, size_t __refs = 0)         : locale::facet(__refs) {
  }
        ~codecvt();
        virtual result do_out(state_type& __st,                           const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,                           extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
       virtual result do_in(state_type& __st,                          const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,                          intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
       virtual result do_unshift(state_type& __st,                               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
       virtual int do_encoding() const  _NOEXCEPT;
       virtual bool do_always_noconv() const  _NOEXCEPT;
       virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
       virtual int do_max_length() const  _NOEXCEPT;
   };
    // template <> class codecvt<wchar_t, char, mbstate_t>
 template <> class _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>     : public locale::facet,       public codecvt_base {
       locale_t __l;
   public:     typedef wchar_t   intern_type;
       typedef char      extern_type;
       typedef mbstate_t state_type;
        explicit codecvt(size_t __refs = 0);
        _LIBCPP_ALWAYS_INLINE     result out(state_type& __st,                const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,                extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const     {
           return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
       }
        _LIBCPP_ALWAYS_INLINE     result unshift(state_type& __st,                    extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const     {
           return do_unshift(__st, __to, __to_end, __to_nxt);
       }
        _LIBCPP_ALWAYS_INLINE     result in(state_type& __st,               const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,               intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const     {
           return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
       }
        virtual result do_out(state_type& __st,                           const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,                           extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
       virtual result do_in(state_type& __st,                          const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,                          intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
       virtual result do_unshift(state_type& __st,                               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
       virtual int do_encoding() const  _NOEXCEPT;
       virtual bool do_always_noconv() const  _NOEXCEPT;
       virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
       virtual int do_max_length() const  _NOEXCEPT;
   };
    // template <> class codecvt<char16_t, char, mbstate_t>
 template <> class _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>     : public locale::facet,       public codecvt_base {
   public:     typedef char16_t  intern_type;
       typedef char      extern_type;
       typedef mbstate_t state_type;
        _LIBCPP_ALWAYS_INLINE     explicit codecvt(size_t __refs = 0)         : locale::facet(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE     result out(state_type& __st,                const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,                extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const     {
  }
        ~codecvt();
        virtual result do_out(state_type& __st,                           const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,                           extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
       virtual result do_in(state_type& __st,                          const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,                          intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
       virtual result do_unshift(state_type& __st,                               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
       virtual int do_encoding() const  _NOEXCEPT;
       virtual bool do_always_noconv() const  _NOEXCEPT;
       virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
       virtual int do_max_length() const  _NOEXCEPT;
   };
    // template <> class codecvt<char32_t, char, mbstate_t>
 template <> class _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>     : public locale::facet,       public codecvt_base {
   public:     typedef char32_t  intern_type;
       typedef char      extern_type;
       typedef mbstate_t state_type;
        _LIBCPP_ALWAYS_INLINE     explicit codecvt(size_t __refs = 0)         : locale::facet(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE     result out(state_type& __st,                const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,                extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const     {
           return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
       }
        _LIBCPP_ALWAYS_INLINE     result unshift(state_type& __st,                    extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const     {
           return do_unshift(__st, __to, __to_end, __to_nxt);
       }
    protected:     _LIBCPP_ALWAYS_INLINE     explicit codecvt(const char*, size_t __refs = 0)         : locale::facet(__refs) {
  }
        ~codecvt();
        virtual result do_out(state_type& __st,                           const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,                           extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
       virtual result do_in(state_type& __st,                          const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,                          intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;
       virtual result do_unshift(state_type& __st,                               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
       virtual int do_encoding() const  _NOEXCEPT;
       virtual bool do_always_noconv() const  _NOEXCEPT;
       virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
       virtual int do_max_length() const  _NOEXCEPT;
   };
    // template <class _InternT, class _ExternT, class _StateT> class codecvt_byname
 template <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TEMPLATE_VIS codecvt_byname     : public codecvt<_InternT, _ExternT, _StateT> {
   public:     _LIBCPP_ALWAYS_INLINE     explicit codecvt_byname(const char* __nm, size_t __refs = 0)         : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {
  }
       _LIBCPP_ALWAYS_INLINE     explicit codecvt_byname(const string& __nm, size_t __refs = 0)         : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {
  }
   protected:     ~codecvt_byname();
   };
    template <class _InternT, class _ExternT, class _StateT> codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname() {
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char, char, mbstate_t>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)  _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);
    template <size_t _Np> struct __narrow_to_utf8 {
       template <class _OutputIterator, class _CharT>     _OutputIterator     operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
   };
    template <> struct __narrow_to_utf8<8> {
       template <class _OutputIterator, class _CharT>     _LIBCPP_ALWAYS_INLINE     _OutputIterator     operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const     {
           for (;
   __wb < __we;
   ++__wb, ++__s)             *__s = *__wb;
           return __s;
       }
   };
    template <> struct __narrow_to_utf8<16>     : public codecvt<char16_t, char, mbstate_t> {
       _LIBCPP_ALWAYS_INLINE     __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {
  }
        ~__narrow_to_utf8();
        template <class _OutputIterator, class _CharT>     _LIBCPP_ALWAYS_INLINE     _OutputIterator     operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const     {
           result __r = ok;
           mbstate_t __mb;
           while (__wb < __we && __r != error)         {
               const int __sz = 32;
               char __buf[__sz];
               char* __bn;
               const char16_t* __wn = (const char16_t*)__wb;
               __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,                          __buf, __buf+__sz, __bn);
               if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)                 __throw_runtime_error("locale not supported");
               for (const char* __p = __buf;
   __p < __bn;
   ++__p, ++__s)                 *__s = *__p;
               __wb = (const _CharT*)__wn;
           }
           return __s;
       }
   };
    template <> struct __narrow_to_utf8<32>     : public codecvt<char32_t, char, mbstate_t> {
       _LIBCPP_ALWAYS_INLINE     __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {
  }
        ~__narrow_to_utf8();
        template <class _OutputIterator, class _CharT>     _LIBCPP_ALWAYS_INLINE     _OutputIterator     operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const     {
           result __r = ok;
           mbstate_t __mb;
           while (__wb < __we && __r != error)         {
               const int __sz = 32;
               char __buf[__sz];
               char* __bn;
               const char32_t* __wn = (const char32_t*)__wb;
               __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,                          __buf, __buf+__sz, __bn);
               if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)                 __throw_runtime_error("locale not supported");
               for (const char* __p = __buf;
   __p < __bn;
   ++__p, ++__s)                 *__s = *__p;
               __wb = (const _CharT*)__wn;
           }
           return __s;
       }
   };
    template <size_t _Np> struct __widen_from_utf8 {
       template <class _OutputIterator>     _OutputIterator     operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
   };
    template <> struct __widen_from_utf8<8> {
       template <class _OutputIterator>     _LIBCPP_ALWAYS_INLINE     _OutputIterator     operator()(_OutputIterator __s, const char* __nb, const char* __ne) const     {
           for (;
   __nb < __ne;
   ++__nb, ++__s)             *__s = *__nb;
           return __s;
       }
   };
    template <> struct __widen_from_utf8<16>     : public codecvt<char16_t, char, mbstate_t> {
       _LIBCPP_ALWAYS_INLINE     __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {
  }
        ~__widen_from_utf8();
        template <class _OutputIterator>     _LIBCPP_ALWAYS_INLINE     _OutputIterator     operator()(_OutputIterator __s, const char* __nb, const char* __ne) const     {
           result __r = ok;
           mbstate_t __mb;
           while (__nb < __ne && __r != error)         {
               const int __sz = 32;
               char16_t __buf[__sz];
               char16_t* __bn;
               const char* __nn = __nb;
               __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,                         __buf, __buf+__sz, __bn);
               if (__r == codecvt_base::error || __nn == __nb)                 __throw_runtime_error("locale not supported");
               for (const char16_t* __p = __buf;
   __p < __bn;
   ++__p, ++__s)                 *__s = (wchar_t)*__p;
               __nb = __nn;
           }
           return __s;
       }
   };
    template <> struct __widen_from_utf8<32>     : public codecvt<char32_t, char, mbstate_t> {
       _LIBCPP_ALWAYS_INLINE     __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {
  }
        ~__widen_from_utf8();
        template <class _OutputIterator>     _LIBCPP_ALWAYS_INLINE     _OutputIterator     operator()(_OutputIterator __s, const char* __nb, const char* __ne) const     {
           result __r = ok;
           mbstate_t __mb;
           while (__nb < __ne && __r != error)         {
               const int __sz = 32;
               char32_t __buf[__sz];
               char32_t* __bn;
               const char* __nn = __nb;
               __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,                         __buf, __buf+__sz, __bn);
               if (__r == codecvt_base::error || __nn == __nb)                 __throw_runtime_error("locale not supported");
               for (const char32_t* __p = __buf;
   __p < __bn;
   ++__p, ++__s)                 *__s = (wchar_t)*__p;
               __nb = __nn;
           }
           return __s;
       }
   };
    // template <class charT> class numpunct
 template <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct;
    template <> class _LIBCPP_TYPE_VIS numpunct<char>     : public locale::facet {
   public:     typedef char char_type;
       typedef basic_string<char_type> string_type;
        explicit numpunct(size_t __refs = 0);
        char_type __decimal_point_;
       char_type __thousands_sep_;
       string __grouping_;
   };
    template <> class _LIBCPP_TYPE_VIS numpunct<wchar_t>     : public locale::facet {
   public:     typedef wchar_t char_type;
       typedef basic_string<char_type> string_type;
        explicit numpunct(size_t __refs = 0);
       char_type __thousands_sep_;
       string __grouping_;
   };
    // template <class charT> class numpunct_byname
 template <class _CharT> class _LIBCPP_TEMPLATE_VIS numpunct_byname;
    template <> class _LIBCPP_TYPE_VIS numpunct_byname<char> : public numpunct<char> {
   public:     typedef char char_type;
       typedef basic_string<char_type> string_type;
        explicit numpunct_byname(const char* __nm, size_t __refs = 0);
       explicit numpunct_byname(const string& __nm, size_t __refs = 0);
    protected:     ~numpunct_byname();
    private:     void __init(const char*);
   };
    template <> class _LIBCPP_TYPE_VIS numpunct_byname<wchar_t> : public numpunct<wchar_t> {
   public:     typedef wchar_t char_type;
       typedef basic_string<char_type> string_type;
        explicit numpunct_byname(const char* __nm, size_t __refs = 0);
       explicit numpunct_byname(const string& __nm, size_t __refs = 0);
    protected:     ~numpunct_byname();
    private:     void __init(const char*);
   };
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP___LOCALE
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_SYSTEM_ERROR
  
#define _LIBCPP_SYSTEM_ERROR
 /*     system_error synopsis  namespace std {
    class error_category {
   public:     virtual ~error_category() noexcept;
        constexpr error_category();
       error_category(const error_category&) = delete;
       error_category& operator=(const error_category&) = delete;
        virtual const char* name() const noexcept = 0;
       virtual error_condition default_error_condition(int ev) const noexcept;
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <stdexcept>
  
#endif /* expanded by -frewrite-includes */
  
  }
    private:     static string __init(const error_code&, string);
   };
    _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_system_error(int ev, const char* what_arg);
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_SYSTEM_ERROR
  
#pragma clang module end /*std.system_error*/
   
#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#include <atomic>     // for __xindex_
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.atomic
// -*- C++ -*-
//===--------------------------- atomic -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ATOMIC
  
#define _LIBCPP_ATOMIC
 /*     atomic synopsis  namespace std {
    // feature test macro
   
#define __cpp_lib_atomic_is_always_lock_free // as specified by SG10
 // order and consistency
 typedef enum memory_order {
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdint>
  
#endif /* expanded by -frewrite-includes */
  
                           __f == memory_order_acq_rel,   \
                        "memory order argument to atomic operation is invalid")
 _LIBCPP_BEGIN_NAMESPACE_STD  typedef enum memory_order {
       memory_order_relaxed, memory_order_consume, memory_order_acquire,     memory_order_release, memory_order_acq_rel, memory_order_seq_cst }
   memory_order;
      
#if defined(_LIBCPP_HAS_GCC_ATOMIC_IMP)
# define ATOMIC_LLONG_LOCK_FREE     __GCC_ATOMIC_LLONG_LOCK_FREE
  
# define ATOMIC_POINTER_LOCK_FREE   __GCC_ATOMIC_POINTER_LOCK_FREE
  
#endif
 // general atomic<T>
 template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value> struct __atomic_base  // false
{
#define ATOMIC_VAR_INIT(__v) {__v}
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_ATOMIC
  
#pragma clang module end /*std.atomic*/
  
#endif
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  typedef ptrdiff_t streamsize;
    class _LIBCPP_TYPE_VIS ios_base {
   public:     class _LIBCPP_EXCEPTION_ABI failure;
        typedef unsigned int fmtflags;
       static const fmtflags boolalpha   = 0x0001;
       static const fmtflags dec         = 0x0002;
       static const fmtflags fixed       = 0x0004;
       static const fmtflags hex         = 0x0008;
       static const fmtflags internal    = 0x0010;
       static const fmtflags left        = 0x0020;
       static const fmtflags oct         = 0x0040;
       static const fmtflags right       = 0x0080;
       static const fmtflags scientific  = 0x0100;
       static const fmtflags showbase    = 0x0200;
       static const fmtflags showpoint   = 0x0400;
       static const fmtflags showpos     = 0x0800;
       static const fmtflags skipws      = 0x1000;
       static const fmtflags unitbuf     = 0x2000;
       static const fmtflags uppercase   = 0x4000;
       static const fmtflags adjustfield = left | right | internal;
       static const fmtflags basefield   = dec | oct | hex;
       static const fmtflags floatfield  = scientific | fixed;
        typedef unsigned int iostate;
       static const iostate badbit  = 0x1;
       static const iostate eofbit  = 0x2;
       static const iostate failbit = 0x4;
       static const iostate goodbit = 0x0;
        typedef unsigned int openmode;
       static const openmode app    = 0x01;
       static const openmode ate    = 0x02;
       static const openmode binary = 0x04;
       static const openmode in     = 0x08;
       static const openmode out    = 0x10;
       static const openmode trunc  = 0x20;
        enum seekdir {
  beg, cur, end};
      
#if _LIBCPP_STD_VER <= 14
    typedef iostate      io_state;
       typedef openmode     open_mode;
       typedef seekdir      seek_dir;
        typedef _VSTD::streamoff streamoff;
       typedef _VSTD::streampos streampos;
     
#endif
     class _LIBCPP_TYPE_VIS Init;
        // 27.5.2.2 fmtflags state:
    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;
       _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);
       _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);
       _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
       _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);
        _LIBCPP_INLINE_VISIBILITY streamsize precision() const;
       _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);
       _LIBCPP_INLINE_VISIBILITY streamsize width() const;
       _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);
        // 27.5.2.3 locales:
    locale imbue(const locale& __loc);
       locale getloc() const;
        // 27.5.2.5 storage:
    static int xalloc();
       long& iword(int __index);
       void*& pword(int __index);
        // destructor
    virtual ~ios_base();
        // 27.5.2.6 callbacks;
    enum event {
   erase_event, imbue_event, copyfmt_event };
       typedef void (*event_callback)(event, ios_base&, int __index);
       void register_callback(event_callback __fn, int __index);
    private:     ios_base(const ios_base&);
   // = delete;
    ios_base& operator=(const ios_base&);
   // = delete;
 public:     static bool sync_with_stdio(bool __sync = true);
        _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;
       void clear(iostate __state = goodbit);
       _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);
        _LIBCPP_INLINE_VISIBILITY bool good() const;
       _LIBCPP_INLINE_VISIBILITY bool eof() const;
       _LIBCPP_INLINE_VISIBILITY bool fail() const;
       _LIBCPP_INLINE_VISIBILITY bool bad() const;
        _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;
       _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);
        void __set_badbit_and_consider_rethrow();
       void __set_failbit_and_consider_rethrow();
    protected:     _LIBCPP_INLINE_VISIBILITY     ios_base() {
  // purposefully does no initialization
               }
        void init(void* __sb);
       _LIBCPP_ALWAYS_INLINE void* rdbuf() const {
  return __rdbuf_;
  }
        _LIBCPP_ALWAYS_INLINE     void rdbuf(void* __sb)     {
           __rdbuf_ = __sb;
           clear();
       }
        void __call_callbacks(event);
       void copyfmt(const ios_base&);
       void move(ios_base&);
       void swap(ios_base&) _NOEXCEPT;
        _LIBCPP_ALWAYS_INLINE     void set_rdbuf(void* __sb)     {
           __rdbuf_ = __sb;
       }
    private:     // All data members must be scalars
    fmtflags        __fmtflags_;
       streamsize      __precision_;
       streamsize      __width_;
       iostate         __rdstate_;
       iostate         __exceptions_;
       void*           __rdbuf_;
       void*           __loc_;
       event_callback* __fn_;
       int*            __index_;
       size_t          __event_size_;
       size_t          __event_cap_;
   // TODO(EricWF): Enable this for both Clang and GCC. Currently it is only
// enabled with clang.
  
#if defined(_LIBCPP_HAS_C_ATOMIC_IMP) && !defined(_LIBCPP_HAS_NO_THREADS)
    static atomic<int> __xindex_;
     
#else
    static int      __xindex_;
     
#endif
    long*           __iarray_;
       size_t          __iarray_size_;
       size_t          __iarray_cap_;
       void**          __parray_;
       size_t          __parray_size_;
       size_t          __parray_cap_;
   };
    //enum class io_errc
_LIBCPP_DECLARE_STRONG_ENUM(io_errc) {
       stream = 1 };
   _LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)  template <> struct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc> : public true_type {
   };
      
#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS
template <> struct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc::__lx> : public true_type {
   };
     
#endif
 _LIBCPP_FUNC_VIS const error_category& iostream_category() _NOEXCEPT;
    inline _LIBCPP_INLINE_VISIBILITY error_code make_error_code(io_errc __e) _NOEXCEPT {
       return error_code(static_cast<int>(__e), iostream_category());
   }
    inline _LIBCPP_INLINE_VISIBILITY error_condition make_error_condition(io_errc __e) _NOEXCEPT {
       return error_condition(static_cast<int>(__e), iostream_category());
   }
    class _LIBCPP_EXCEPTION_ABI ios_base::failure     : public system_error {
   };
    // fmtflags
 inline _LIBCPP_INLINE_VISIBILITY ios_base::fmtflags ios_base::flags() const {
       return __fmtflags_;
   }
    inline _LIBCPP_INLINE_VISIBILITY ios_base::fmtflags ios_base::flags(fmtflags __fmtfl) {
       fmtflags __r = __fmtflags_;
       __fmtflags_ = __fmtfl;
       return __r;
   }
    inline _LIBCPP_INLINE_VISIBILITY ios_base::fmtflags ios_base::setf(fmtflags __fmtfl) {
       fmtflags __r = __fmtflags_;
       __fmtflags_ |= __fmtfl;
       return __r;
   }
    inline _LIBCPP_INLINE_VISIBILITY void ios_base::unsetf(fmtflags __mask) {
       __fmtflags_ &= ~__mask;
   }
    inline _LIBCPP_INLINE_VISIBILITY ios_base::fmtflags ios_base::setf(fmtflags __fmtfl, fmtflags __mask) {
       fmtflags __r = __fmtflags_;
       unsetf(__mask);
       __fmtflags_ |= __fmtfl & __mask;
       return __r;
   }
    // precision
 inline _LIBCPP_INLINE_VISIBILITY streamsize ios_base::precision() const {
       return __precision_;
   }
    inline _LIBCPP_INLINE_VISIBILITY streamsize ios_base::precision(streamsize __prec) {
       streamsize __r = __precision_;
       __precision_ = __prec;
   }
    inline _LIBCPP_INLINE_VISIBILITY bool ios_base::fail() const {
       return (__rdstate_ & (failbit | badbit)) != 0;
   }
    inline _LIBCPP_INLINE_VISIBILITY bool ios_base::bad() const {
       return (__rdstate_ & badbit) != 0;
   }
 template <class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS basic_ios     : public ios_base {
   public:     // types:
    typedef _CharT char_type;
       typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
      // __true_value will generate undefined references when linking unless
  // we give it internal linkage.
   
#if defined(_LIBCPP_CXX03_LANG)
    _LIBCPP_ALWAYS_INLINE     operator __cxx03_bool::__bool_type() const {
           return !fail() ? &__cxx03_bool::__true_value : nullptr;
       }
     
#else
    _LIBCPP_ALWAYS_INLINE     _LIBCPP_EXPLICIT operator bool() const {
  return !fail();
  }
     
#endif
     _LIBCPP_ALWAYS_INLINE bool operator!() const    {
  return  fail();
  }
       _LIBCPP_ALWAYS_INLINE bool fail() const {
  return ios_base::fail();
  }
       _LIBCPP_ALWAYS_INLINE bool bad() const  {
  return ios_base::bad();
  }
        _LIBCPP_ALWAYS_INLINE iostate exceptions() const {
  return ios_base::exceptions();
  }
       _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {
  ios_base::exceptions(__iostate);
  }
        // 27.5.4.1 Constructor/destructor:
    _LIBCPP_INLINE_VISIBILITY     explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);
       virtual ~basic_ios();
        // 27.5.4.2 Members:
    _LIBCPP_INLINE_VISIBILITY      basic_ostream<char_type, traits_type>* tie() const;
       _LIBCPP_INLINE_VISIBILITY      basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);
        _LIBCPP_INLINE_VISIBILITY      basic_streambuf<char_type, traits_type>* rdbuf() const;
       _LIBCPP_INLINE_VISIBILITY      basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);
        basic_ios& copyfmt(const basic_ios& __rhs);
        _LIBCPP_INLINE_VISIBILITY      char_type fill() const;
       _LIBCPP_INLINE_VISIBILITY      char_type fill(char_type __ch);
        _LIBCPP_INLINE_VISIBILITY      locale imbue(const locale& __loc);
        _LIBCPP_INLINE_VISIBILITY      char narrow(char_type __c, char __dfault) const;
       _LIBCPP_INLINE_VISIBILITY      char_type widen(char __c) const;
    protected:     _LIBCPP_ALWAYS_INLINE     basic_ios() {
  // purposefully does no initialization
                }
       _LIBCPP_INLINE_VISIBILITY      void init(basic_streambuf<char_type, traits_type>* __sb);
        _LIBCPP_INLINE_VISIBILITY      void move(basic_ios& __rhs);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_ALWAYS_INLINE     void move(basic_ios&& __rhs) {
  move(__rhs);
  }
     
#endif
    _LIBCPP_INLINE_VISIBILITY      void swap(basic_ios& __rhs) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY      void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);
   private:     basic_ostream<char_type, traits_type>* __tie_;
        mutable int_type __fill_;
   };
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb) {
       init(__sb);
   }
    template <class _CharT, class _Traits> basic_ios<_CharT, _Traits>::~basic_ios() {
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY void basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb) {
       ios_base::init(__sb);
       __tie_ = 0;
       __fill_ = traits_type::eof();
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_streambuf<_CharT, _Traits>* basic_ios<_CharT, _Traits>::rdbuf() const {
       return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_streambuf<_CharT, _Traits>* basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb) {
       basic_streambuf<char_type, traits_type>* __r = rdbuf();
       ios_base::rdbuf(__sb);
       return __r;
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY _CharT basic_ios<_CharT, _Traits>::fill(char_type __ch) {
       char_type __r = __fill_;
       __fill_ = __ch;
       return __r;
   }
    template <class _CharT, class _Traits> basic_ios<_CharT, _Traits>& basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs) {
       if (this != &__rhs)     {
           __call_callbacks(erase_event);
           ios_base::copyfmt(__rhs);
           __tie_ = __rhs.__tie_;
           __fill_ = __rhs.__fill_;
           __call_callbacks(copyfmt_event);
           exceptions(__rhs.exceptions());
       }
       return *this;
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY void basic_ios<_CharT, _Traits>::move(basic_ios& __rhs) {
       ios_base::move(__rhs);
       __tie_ = __rhs.__tie_;
       __rhs.__tie_ = 0;
       __fill_ = __rhs.__fill_;
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY void basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT {
       ios_base::swap(__rhs);
       _VSTD::swap(__tie_, __rhs.__tie_);
       _VSTD::swap(__fill_, __rhs.__fill_);
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY void basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb) {
       ios_base::set_rdbuf(__sb);
   }
    inline _LIBCPP_INLINE_VISIBILITY ios_base& boolalpha(ios_base& __str) {
       __str.setf(ios_base::boolalpha);
       return __str;
   }
    inline _LIBCPP_INLINE_VISIBILITY ios_base& noboolalpha(ios_base& __str) {
       __str.unsetf(ios_base::boolalpha);
       return __str;
       __str.setf(ios_base::dec, ios_base::basefield);
       return __str;
   }
    inline _LIBCPP_INLINE_VISIBILITY ios_base& hex(ios_base& __str) {
       __str.setf(ios_base::hex, ios_base::basefield);
       return __str;
   }
    inline _LIBCPP_INLINE_VISIBILITY ios_base& defaultfloat(ios_base& __str) {
       __str.unsetf(ios_base::floatfield);
       return __str;
   }
    template <class _CharT, class _Traits> class __save_flags {
       typedef basic_ios<_CharT, _Traits> __stream_type;
       typedef typename __stream_type::fmtflags fmtflags;
        __stream_type& __stream_;
       fmtflags       __fmtflags_;
       _CharT         __fill_;
        __save_flags(const __save_flags&);
       __save_flags& operator=(const __save_flags&);
   public:     _LIBCPP_INLINE_VISIBILITY     explicit __save_flags(__stream_type& __stream)         : __stream_(__stream),           __fmtflags_(__stream.flags()),           __fill_(__stream.fill())         {
  }
       _LIBCPP_INLINE_VISIBILITY     ~__save_flags()     {
           __stream_.flags(__fmtflags_);
           __stream_.fill(__fill_);
       }
   };
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_IOS
  
#pragma clang module end /*std.ios*/
#pragma clang module begin std.streambuf
// -*- C++ -*-
//===------------------------- streambuf ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_STEAMBUF
  
#define _LIBCPP_STEAMBUF
 /*     streambuf synopsis  namespace std {
#include <iosfwd>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.iosfwd
// -*- C++ -*-
//===--------------------------- iosfwd -----------------------------------===//
//
#ifndef _LIBCPP_IOSFWD
  
#define _LIBCPP_IOSFWD
 /*     iosfwd synopsis  namespace std {
    template<class charT> struct char_traits;
   template<class T>     class allocator;
    class ios_base;
   template <class charT, class traits = char_traits<charT> > class basic_ios;
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
     return __str;
#endif  // _LIBCPP_IOS
  
#pragma clang module end /*std.ios*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max")   
#else
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS basic_streambuf {
   public:     // types:
    typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
        virtual ~basic_streambuf();
        // 27.6.2.2.1 locales:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     locale pubimbue(const locale& __loc) {
           imbue(__loc);
           locale __r = __loc_;
           __loc_ = __loc;
           return __r;
       }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     locale getloc() const {
   return __loc_;
   }
        // 27.6.2.2.2 buffer and positioning:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_streambuf* pubsetbuf(char_type* __s, streamsize __n)     {
   return setbuf(__s, __n);
   }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     pos_type pubseekoff(off_type __off, ios_base::seekdir __way,                         ios_base::openmode __which = ios_base::in | ios_base::out)     {
   return seekoff(__off, __way, __which);
   }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     pos_type pubseekpos(pos_type __sp,                         ios_base::openmode __which = ios_base::in | ios_base::out)     {
   return seekpos(__sp, __which);
   }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     int pubsync() {
   return sync();
   }
        // Get and put areas:
    // 27.6.2.2.3 Get area:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     streamsize in_avail() {
           if (__ninp_ < __einp_)             return static_cast<streamsize>(__einp_ - __ninp_);
           return showmanyc();
       }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     int_type snextc() {
           if (sbumpc() == traits_type::eof())             return traits_type::eof();
           return sgetc();
       }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     int_type sbumpc() {
           if (__ninp_ == __einp_)             return uflow();
           return traits_type::to_int_type(*__ninp_++);
       }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     int_type sgetc() {
           if (__ninp_ == __einp_)             return underflow();
           return traits_type::to_int_type(*__ninp_);
       }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     streamsize sgetn(char_type* __s, streamsize __n)     {
   return xsgetn(__s, __n);
   }
        // 27.6.2.2.4 Putback:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     int_type sputbackc(char_type __c) {
           if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))             return pbackfail(traits_type::to_int_type(__c));
           if (__nout_ == __eout_)             return overflow(traits_type::to_int_type(__c));
           *__nout_++ = __c;
           return traits_type::to_int_type(__c);
       }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     streamsize sputn(const char_type* __s, streamsize __n)     {
   return xsputn(__s, __n);
   }
    protected:     basic_streambuf();
       basic_streambuf(const basic_streambuf& __rhs);
       basic_streambuf& operator=(const basic_streambuf& __rhs);
       void swap(basic_streambuf& __rhs);
        // 27.6.2.3.2 Get area:
    _LIBCPP_ALWAYS_INLINE char_type* eback() const {
  return __binp_;
  }
    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {
  return __bout_;
  }
       _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {
  return __nout_;
  }
       _LIBCPP_ALWAYS_INLINE char_type* epptr() const {
       }
        // 27.6.2.4 virtual functions:
    // 27.6.2.4.1 Locales:
    virtual void imbue(const locale& __loc);
        // 27.6.2.4.2 Buffer management and positioning:
    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
       virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,                              ios_base::openmode __which = ios_base::in | ios_base::out);
       virtual pos_type seekpos(pos_type __sp,                              ios_base::openmode __which = ios_base::in | ios_base::out);
       virtual int sync();
        // 27.6.2.4.3 Get area:
    virtual streamsize showmanyc();
       virtual streamsize xsgetn(char_type* __s, streamsize __n);
       virtual int_type underflow();
       virtual int_type uflow();
        // 27.6.2.4.4 Putback:
    virtual int_type pbackfail(int_type __c = traits_type::eof());
        // 27.6.2.4.5 Put area:
    virtual streamsize xsputn(const char_type* __s, streamsize __n);
       virtual int_type overflow(int_type __c = traits_type::eof());
    private:     locale __loc_;
       char_type* __binp_;
       char_type* __ninp_;
       char_type* __einp_;
       char_type* __bout_;
       char_type* __nout_;
       char_type* __eout_;
   };
    template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits>::~basic_streambuf() {
   }
    template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits>::basic_streambuf()     : __binp_(0),       __ninp_(0),       __einp_(0),       __bout_(0),       __nout_(0),       __eout_(0) {
   }
    template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)     : __loc_(__sb.__loc_),       __binp_(__sb.__binp_),       __ninp_(__sb.__ninp_),       __einp_(__sb.__einp_),       __bout_(__sb.__bout_),       __nout_(__sb.__nout_),       __eout_(__sb.__eout_) {
   }
    template <class _CharT, class _Traits> basic_streambuf<_CharT, _Traits>& basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb) {
       __loc_ = __sb.__loc_;
       __binp_ = __sb.__binp_;
       __ninp_ = __sb.__ninp_;
       __einp_ = __sb.__einp_;
       return pos_type(off_type(-1));
   }
    template <class _CharT, class _Traits> int basic_streambuf<_CharT, _Traits>::sync() {
       return 0;
   }
    template <class _CharT, class _Traits> streamsize basic_streambuf<_CharT, _Traits>::showmanyc() {
       return 0;
   }
    template <class _CharT, class _Traits> streamsize basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n) {
       const int_type __eof = traits_type::eof();
       int_type __c;
       streamsize __i = 0;
       while(__i < __n)     {
           if (__ninp_ < __einp_)         {
               const streamsize __len = _VSTD::min(static_cast<streamsize>(INT_MAX),                                 _VSTD::min(__einp_ - __ninp_, __n - __i));
               traits_type::copy(__s, __ninp_, __len);
           }
       }
       return __i;
   }
    template <class _CharT, class _Traits> typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::overflow(int_type) {
       return traits_type::eof();
   }
      
#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<char>) _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_streambuf<wchar_t>)  _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<char>) _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ios<wchar_t>)   
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_STEAMBUF
  
#pragma clang module end /*std.streambuf*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <locale>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.locale
// -*- C++ -*-
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_LOCALE
  
#define _LIBCPP_LOCALE
 /*     locale synopsis  namespace std {
    class locale {
   public:     // types:
   template <class _Tp>     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_LIMITS
  
#pragma clang module end /*std.limits*/
  
#ifndef __APPLE__
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdarg>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cstdarg
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CSTDARG
  
#define _LIBCPP_CSTDARG
 /*     cstdarg synopsis  Macros:      type va_arg(va_list ap, type);
       void va_copy(va_list dest, va_list src);
    // C99
    void va_end(va_list ap);
       void va_start(va_list ap, parmN);
    namespace std {
    Types:      va_list  }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <stdarg.h>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  using ::va_list;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CSTDARG
  
#pragma clang module end /*std.compat.cstdarg*/
  
#endif
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdlib>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cstdlib
// -*- C++ -*-
   
#ifndef _LIBCPP_CSTDLIB
  
#define _LIBCPP_CSTDLIB
 /*     cstdlib synopsis  Macros:      EXIT_FAILURE     EXIT_SUCCESS     MB_CUR_MAX     NULL     RAND_MAX  namespace std {
    Types:      size_t     div_t     ldiv_t     lldiv_t                                                               // C99
 double    atof (const char* nptr);
   void srand(unsigned int seed);
   void* calloc(size_t nmemb, size_t size);
   void free(void* ptr);
   void* malloc(size_t size);
   void* realloc(void* ptr, size_t size);
   void abort(void);
    
#endif /* expanded by -frewrite-includes */
      
#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE
using ::fopen;
   using ::freopen;
   using ::remove;
   using ::rename;
   using ::tmpfile;
   using ::tmpnam;
     
#endif
   
#ifndef _LIBCPP_HAS_NO_STDIN
using ::getchar;
     
#if _LIBCPP_STD_VER <= 11 && !defined(_LIBCPP_MSVCRT)
using ::gets;
     
#endif
using ::scanf;
   using ::vscanf;
     
#endif
   
#endif  // _LIBCPP_CSTDIO
  
#pragma clang module end /*std.compat.cstdio*/
  
#ifdef _LIBCPP_HAS_CATOPEN
  
#if 0 /* expanded by -frewrite-includes */
  
#include <nl_types.h>
  
#endif /* expanded by -frewrite-includes */
/* Copyright (C) 1996-2014 Free Software Foundation, Inc.    This file is part of the GNU C Library.     The GNU C Library is free software;
   you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation;
   either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY;
   without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library;
   if not, see    <http://www.gnu.org/licenses/>.  */
   
#ifndef _NL_TYPES_H
  
#define _NL_TYPES_H 1
   
#if 0 /* expanded by -frewrite-includes */
  
#include <features.h>
  
#endif /* expanded by -frewrite-includes */
 /* The default message set used by the gencat program.  */
  
#define NL_SETD 1
 /* Value for FLAG parameter of `catgets' to say we want XPG4 compliance.  */
extern int catclose (nl_catd __catalog) __THROW __nonnull ((1));
    __END_DECLS    
#endif /* nl_types.h  */
  
#endif
   
#ifdef __APPLE__
  
#if 0 /* expanded by -frewrite-includes */
  
#include <Availability.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifdef _LIBCPP_LOCALE__L_EXTENSIONS
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__bsd_locale_defaults.h>
  
#endif /* expanded by -frewrite-includes */
  
#else
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__bsd_locale_fallbacks.h>
  
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===---------------------- __bsd_locale_fallbacks.h ----------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// The BSDs have lots of *_l functions.  This file provides reimplementations
// of those functions for non-BSD platforms.
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_BSD_LOCALE_FALLBACKS_DEFAULTS_H
//===----------------------------------------------------------------------===//
   
#if defined(__need_malloc_and_calloc)
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <stdlib.h>
  
#endif /* expanded by -frewrite-includes */
   
#elif !defined(_LIBCPP_STDLIB_H)
  
#define _LIBCPP_STDLIB_H
 /*     stdlib.h synopsis  Macros:      EXIT_FAILURE     EXIT_SUCCESS     MB_CUR_MAX     NULL     RAND_MAX  Types:      size_t     div_t     ldiv_t     lldiv_t                                                               // C99
 double    atof (const char* nptr);
   int       atoi (const char* nptr);
   long      atol (const char* nptr);
   long long atoll(const char* nptr);
                                          // C99
double             strtod  (const char* restrict nptr, char** restrict endptr);
   float              strtof  (const char* restrict nptr, char** restrict endptr);
#endif  // __cplusplus
   
#endif  // _LIBCPP_STDLIB_H
  
#if 0 /* expanded by -frewrite-includes */
  
#include <stdarg.h>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <memory>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.memory
// -*- C++ -*-
//===-------------------------- memory ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_MEMORY
  
#define _LIBCPP_MEMORY
 /*     memory synopsis  namespace std {
    struct allocator_arg_t {
   };
   constexpr allocator_arg_t allocator_arg = allocator_arg_t();
    template <class T, class Alloc> struct uses_allocator;
    template <class Ptr> struct pointer_traits {
       typedef Ptr pointer;
       typedef <details> element_type;
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(_Tp&& __element)         {
  ::new(&*__x_) _Tp(_VSTD::move(__element));
   return *this;
  }
     
#endif
    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {
    template<class _CharT, class _Traits, class _Yp> inline _LIBCPP_INLINE_VISIBILITY basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
       
#if !defined(_LIBCPP_HAS_NO_ATOMIC_HEADER)
 class _LIBCPP_TYPE_VIS __sp_mut {
       void* __lx;
   public:     void lock() _NOEXCEPT;
       void unlock() _NOEXCEPT;
     
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_MEMORY
  
#pragma clang module end /*std.memory*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  inline _LIBCPP_ALWAYS_INLINE decltype(MB_CUR_MAX) __libcpp_mb_cur_max_l(locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return MB_CUR_MAX;
   }
    inline _LIBCPP_ALWAYS_INLINE wint_t __libcpp_btowc_l(int __c, locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return btowc(__c);
   }
    inline _LIBCPP_ALWAYS_INLINE size_t __libcpp_wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return wcrtomb(__s, __wc, __ps);
   }
    inline _LIBCPP_ALWAYS_INLINE size_t __libcpp_mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,                       size_t __len, mbstate_t *__ps, locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return mbsnrtowcs(__dest, __src, __nms, __len, __ps);
   }
    inline _LIBCPP_ALWAYS_INLINE size_t __libcpp_mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,                    mbstate_t *__ps, locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return mbrtowc(__pwc, __s, __n, __ps);
   }
    inline _LIBCPP_ALWAYS_INLINE int __libcpp_mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return mbtowc(__pwc, __pmb, __max);
   }
    inline _LIBCPP_ALWAYS_INLINE size_t __libcpp_mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return mbrlen(__s, __n, __ps);
   }
    inline _LIBCPP_ALWAYS_INLINE lconv *__libcpp_localeconv_l(locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return localeconv();
   }
    inline _LIBCPP_ALWAYS_INLINE size_t __libcpp_mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,                      mbstate_t *__ps, locale_t __l) {
       __libcpp_locale_guard __current(__l);
       return mbsrtowcs(__dest, __src, __len, __ps);
   }
    inline int __libcpp_snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {
       va_list __va;
       va_start(__va, __format);
       __libcpp_locale_guard __current(__l);
       int __res = vsnprintf(__s, __n, __format, __va);
       va_end(__va);
       return __res;
   }
    inline int __libcpp_asprintf_l(char **__s, locale_t __l, const char *__format, ...) {
       va_list __va;
       va_start(__va, __format);
       __libcpp_locale_guard __current(__l);
       int __res = vasprintf(__s, __format, __va);
       va_end(__va);
       return __res;
   }
    inline int __libcpp_sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {
       va_list __va;
       va_start(__va, __format);
       __libcpp_locale_guard __current(__l);
       int __res = vsscanf(__s, __format, __va);
       va_end(__va);
       return __res;
   }
    _LIBCPP_END_NAMESPACE_STD    
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD    
#if defined(__APPLE__) || defined(__FreeBSD__)
  
#  define _LIBCPP_GET_C_LOCALE 0
  
#elif defined(__CloudABI__) || defined(__NetBSD__)
  
#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE
  
#else
  
#  define _LIBCPP_GET_C_LOCALE __cloc()
   // Get the C locale object
   _LIBCPP_FUNC_VIS locale_t __cloc();
     
#define __cloc_defined
  
#endif
 // __scan_keyword
// Scans [__b, __e) until a match is found in the basic_strings range
//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).
//  __b will be incremented (visibly), consuming CharT until a match is found
//  or proved to not exist.  A keyword may be "", in which will match anything.
//  __ct is used to force to lower case before comparing characters.
//  Examples:
//  Keywords:  "a", "abb"
//  If the input is "a", the first keyword matches and eofbit is set.
//  If the input is "abc", no match is found and "ab" are consumed.
template <class _InputIterator, class _ForwardIterator, class _Ctype> _LIBCPP_HIDDEN _ForwardIterator __scan_keyword(_InputIterator& __b, _InputIterator __e,                _ForwardIterator __kb, _ForwardIterator __ke,                const _Ctype& __ct, ios_base::iostate& __err,                bool __case_sensitive = true) {
       typedef typename iterator_traits<_InputIterator>::value_type _CharT;
       size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));
       const unsigned char __doesnt_match = '\0';
       const unsigned char __might_match = '\1';
       const unsigned char __does_match = '\2';
       unsigned char __statbuf[100];
       unsigned char* __status = __statbuf;
       unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);
       if (__nkw > sizeof(__statbuf))     {
           __status = (unsigned char*)malloc(__nkw);
           if (__status == 0)             __throw_bad_alloc();
           __stat_hold.reset(__status);
       }
       size_t __n_might_match = __nkw;
    // At this point, any keyword might match
    size_t __n_does_match = 0;
         // but none of them definitely do
    // Initialize all statuses to __might_match, except for "" keywords are __does_match
    unsigned char* __st = __status;
       for (_ForwardIterator __ky = __kb;
   __ky != __ke;
   ++__ky, (void) ++__st)     {
           if (!__ky->empty())             *__st = __might_match;
           else         {
               *__st = __does_match;
               --__n_might_match;
               ++__n_does_match;
           }
       }
       // While there might be a match, test keywords against the next CharT
    for (size_t __indx = 0;
   __b != __e && __n_might_match > 0;
   ++__indx)     {
           // Peek at the next CharT but don't consume it
        _CharT __c = *__b;
           if (!__case_sensitive)             __c = __ct.toupper(__c);
           bool __consume = false;
           // For each keyword which might match, see if the __indx character is __c
        // If a match if found, consume __c
        // If a match is found, and that is the last character in the keyword,
        //    then that keyword matches.
        // If the keyword doesn't match this character, then change the keyword
        //    to doesn't match
        __st = __status;
           for (_ForwardIterator __ky = __kb;
   __ky != __ke;
   ++__ky, (void) ++__st)         {
               if (*__st == __might_match)             {
                   _CharT __kc = (*__ky)[__indx];
                   if (!__case_sensitive)                     __kc = __ct.toupper(__kc);
                   if (__c == __kc)                 {
                      __consume = true;
                      if (__ky->size() == __indx+1)                     {
                          *__st = __does_match;
                          --__n_might_match;
                          ++__n_does_match;
                      }
                  }
                   else                 {
                      *__st = __doesnt_match;
                      --__n_might_match;
                  }
               }
           }
           // consume if we matched a character
        if (__consume)         {
               ++__b;
               // If we consumed a character and there might be a matched keyword that
            //   was marked matched on a previous iteration, then such keywords
            //   which are now marked as not matching.
            if (__n_might_match + __n_does_match > 1)             {
                   __st = __status;
                   for (_ForwardIterator __ky = __kb;
   __ky != __ke;
   ++__ky, (void) ++__st)                 {
                      if (*__st == __does_match && __ky->size() != __indx+1)                     {
                          *__st = __doesnt_match;
                          --__n_does_match;
                      }
                  }
               }
           }
       }
       // We've exited the loop because we hit eof and/or we have no more "might matches".
    if (__b == __e)         __err |= ios_base::eofbit;
       // Return the first matching result
    for (__st = __status;
   __kb != __ke;
   ++__kb, (void) ++__st)         if (*__st == __does_match)             break;
       if (__kb == __ke)         __err |= ios_base::failbit;
       return __kb;
   }
    struct _LIBCPP_TYPE_VIS __num_get_base {
       static const int __num_get_buf_sz = 40;
        static int __get_base(ios_base&);
       static const char __src[33];
   };
    _LIBCPP_FUNC_VIS void __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,                       ios_base::iostate& __err);
    template <class _CharT> struct __num_get     : protected __num_get_base {
       static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,                                       _CharT& __thousands_sep);
        static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,                                    char* __a, char*& __a_end,                                    _CharT __decimal_point, _CharT __thousands_sep,                                    const string& __grouping, unsigned* __g,                                    unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);
     
#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
       static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,                   unsigned& __dc, _CharT __thousands_sep, const string& __grouping,                   unsigned* __g, unsigned*& __g_end, _CharT* __atoms);
      
#else
    static string __stage2_int_prep(ios_base& __iob, _CharT& __thousands_sep)     {
           locale __loc = __iob.getloc();
         (void)__atoms;
         return __src;
       }
     
#endif
};
      
#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
#endif
 template <class _CharT> string __num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,                     _CharT& __thousands_sep) {
       locale __loc = __iob.getloc();
       use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
       const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
       __decimal_point = __np.decimal_point();
       __thousands_sep = __np.thousands_sep();
       return __np.grouping();
   }
    template <class _CharT> int   
#ifndef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,                   unsigned& __dc, _CharT __thousands_sep, const string& __grouping,                   unsigned* __g, unsigned*& __g_end, _CharT* __atoms)   
#else
__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,                   unsigned& __dc, _CharT __thousands_sep, const string& __grouping,                   unsigned* __g, unsigned*& __g_end, const _CharT* __atoms)    
#endif
{
       if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))     {
           *__a_end++ = __ct == __atoms[24] ? '+' : '-';
           __dc = 0;
           return 0;
       }
       if (__grouping.size() != 0 && __ct == __thousands_sep)     {
           if (__g_end-__g < __num_get_buf_sz)         {
               *__g_end++ = __dc;
               __dc = 0;
           }
           return 0;
       }
       ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
       if (__f >= 24)         return -1;
       switch (__base)     {
       case 8:     case 10:         if (__f >= __base)             return -1;
           break;
       case 16:         if (__f < 22)             break;
           if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')         {
               __dc = 0;
               *__a_end++ = __src[__f];
               return 0;
           }
           return -1;
       }
       *__a_end++ = __src[__f];
       ++__dc;
       return 0;
   }
    template <class _CharT> int __num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,                     _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,                     unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms) {
       if (__ct == __decimal_point)     {
           if (!__in_units)             return -1;
           __in_units = false;
           *__a_end++ = '.';
           if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)             *__g_end++ = __dc;
           return 0;
       }
       ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
       if (__f >= 32)         return -1;
       char __x = __src[__f];
       if (__x == '-' || __x == '+')     {
           if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))         {
               *__a_end++ = __x;
               return 0;
           }
           return -1;
       }
       if (__x == 'x' || __x == 'X')         __exp = 'P';
       else if ((__x & 0x5F) == __exp)     {
           __exp |= 0x80;
           if (__in_units)         {
               __in_units = false;
               if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)                 *__g_end++ = __dc;
           }
       }
       *__a_end++ = __x;
       if (__f >= 22)         return 0;
       ++__dc;
       return 0;
   }
    _LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<char>) _LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_get<wchar_t>)  template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> > class _LIBCPP_TEMPLATE_VIS num_get     : public locale::facet,       private __num_get<_CharT> {
   public:     typedef _CharT char_type;
       typedef _InputIterator iter_type;
        _LIBCPP_ALWAYS_INLINE     explicit num_get(size_t __refs = 0)         : locale::facet(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE     iter_type get(iter_type __b, iter_type __e, ios_base& __iob,                   ios_base::iostate& __err, bool& __v) const     {
           return do_get(__b, __e, __iob, __err, __v);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type get(iter_type __b, iter_type __e, ios_base& __iob,                   ios_base::iostate& __err, long& __v) const     {
           return do_get(__b, __e, __iob, __err, __v);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type get(iter_type __b, iter_type __e, ios_base& __iob,                   ios_base::iostate& __err, long long& __v) const     {
           return do_get(__b, __e, __iob, __err, __v);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type get(iter_type __b, iter_type __e, ios_base& __iob,                   ios_base::iostate& __err, unsigned short& __v) const     {
           return do_get(__b, __e, __iob, __err, __v);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type get(iter_type __b, iter_type __e, ios_base& __iob,                   ios_base::iostate& __err, long double& __v) const     {
           return do_get(__b, __e, __iob, __err, __v);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type get(iter_type __b, iter_type __e, ios_base& __iob,                   ios_base::iostate& __err, void*& __v) const     {
           return do_get(__b, __e, __iob, __err, __v);
       }
        static locale::id id;
    protected:     _LIBCPP_ALWAYS_INLINE     ~num_get() {
  }
        template <class _Fp>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     iter_type __do_get_floating_point                             (iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, _Fp& __v) const;
        template <class _Signed>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     iter_type __do_get_signed                             (iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, _Signed& __v) const;
        template <class _Unsigned>     _LIBCPP_METHOD_TEMPLATE_IMPLICIT_INSTANTIATION_VIS     iter_type __do_get_unsigned                             (iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, _Unsigned& __v) const;
         virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, bool& __v) const;
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, long& __v) const     {
   return this->__do_get_signed ( __b, __e, __iob, __err, __v );
   }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, float& __v) const     {
   return this->__do_get_floating_point ( __b, __e, __iob, __err, __v );
   }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, double& __v) const     {
   return this->__do_get_floating_point ( __b, __e, __iob, __err, __v );
   }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, long double& __v) const     {
   return this->__do_get_floating_point ( __b, __e, __iob, __err, __v );
   }
        virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, void*& __v) const;
   };
    template <class _CharT, class _InputIterator> locale::id num_get<_CharT, _InputIterator>::id;
    template <class _Tp> _Tp __num_get_signed_integral(const char* __a, const char* __a_end,                           ios_base::iostate& __err, int __base) {
       if (__a != __a_end)     {
           typename remove_reference<decltype(errno)>::type __save_errno = errno;
           errno = 0;
           char *__p2;
           long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
           typename remove_reference<decltype(errno)>::type __current_errno = errno;
           if (__current_errno == 0)             errno = __save_errno;
           if (__p2 != __a_end)         {
               __err = ios_base::failbit;
               return 0;
           }
           else if (__current_errno == ERANGE         ||                  __ll < numeric_limits<_Tp>::min() ||                  numeric_limits<_Tp>::max() < __ll)         {
               __err = ios_base::failbit;
               if (__ll > 0)                 return numeric_limits<_Tp>::max();
               else                 return numeric_limits<_Tp>::min();
           }
           return static_cast<_Tp>(__ll);
       }
       __err = ios_base::failbit;
       return 0;
   }
    template <class _Tp> _Tp __num_get_unsigned_integral(const char* __a, const char* __a_end,                             ios_base::iostate& __err, int __base) {
       if (__a != __a_end)     {
           if (*__a == '-')         {
               __err = ios_base::failbit;
               return 0;
           }
           typename remove_reference<decltype(errno)>::type __save_errno = errno;
           errno = 0;
           char *__p2;
           unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);
           typename remove_reference<decltype(errno)>::type __current_errno = errno;
           if (__current_errno == 0)             errno = __save_errno;
           if (__p2 != __a_end)         {
               __err = ios_base::failbit;
               return 0;
           }
           else if (__current_errno == ERANGE ||                  numeric_limits<_Tp>::max() < __ll)         {
               __err = ios_base::failbit;
               return numeric_limits<_Tp>::max();
           }
           return static_cast<_Tp>(__ll);
       }
       __err = ios_base::failbit;
       return 0;
   }
    template <class _Tp> _LIBCPP_INLINE_VISIBILITY _Tp __do_strtod(const char* __a, char** __p2);
    template <> inline _LIBCPP_INLINE_VISIBILITY float __do_strtod<float>(const char* __a, char** __p2) {
       return strtof_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
   }
    template <> inline _LIBCPP_INLINE_VISIBILITY double __do_strtod<double>(const char* __a, char** __p2) {
       return strtod_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
   }
    template <> inline _LIBCPP_INLINE_VISIBILITY long double __do_strtod<long double>(const char* __a, char** __p2) {
       return strtold_l(__a, __p2, _LIBCPP_GET_C_LOCALE);
   }
    template <class _Tp> _LIBCPP_HIDDEN _Tp __num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err) {
       if (__a != __a_end)     {
           typename remove_reference<decltype(errno)>::type __save_errno = errno;
           errno = 0;
           char *__p2;
           _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
           typename remove_reference<decltype(errno)>::type __current_errno = errno;
       }
       __err = ios_base::failbit;
       return 0;
   }
    template <class _CharT, class _InputIterator> _InputIterator num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,                                         ios_base& __iob,                                         ios_base::iostate& __err,                                         bool& __v) const {
       if ((__iob.flags() & ios_base::boolalpha) == 0)     {
           long __lv = -1;
           __b = do_get(__b, __e, __iob, __err, __lv);
           switch (__lv)         {
           case 0:             __v = false;
               break;
           case 1:             __v = true;
               break;
           default:             __v = true;
               __err = ios_base::failbit;
               break;
           }
           return __b;
       }
       const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());
       const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());
       typedef typename numpunct<_CharT>::string_type string_type;
       const string_type __names[2] = {
  __np.truename(), __np.falsename()};
       const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,                                             __ct, __err);
       __v = __i == __names;
       return __b;
   }
    // signed
 template <class _CharT, class _InputIterator> template <class _Signed> _InputIterator num_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,                                         ios_base& __iob,                                         ios_base::iostate& __err,                                         _Signed& __v) const {
       // Stage 1
    int __base = this->__get_base(__iob);
       // Stage 2
    char_type __thousands_sep;
       const int __atoms_size = 26;
     
#ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
    char_type __atoms1[__atoms_size];
       const char_type *__atoms = this->__do_widen(__iob, __atoms1);
       string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);
     
#else
    char_type __atoms[__atoms_size];
       string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
     
#endif
    string __buf;
       __buf.resize(__buf.capacity());
       char* __a = &__buf[0];
       char* __a_end = __a;
       unsigned __g[__num_get_base::__num_get_buf_sz];
       unsigned* __g_end = __g;
       unsigned __dc = 0;
       for (;
   __b != __e;
   ++__b)     {
           if (__a_end == __a + __buf.size())         {
               size_t __tmp = __buf.size();
               __buf.resize(2*__buf.size());
               __buf.resize(__buf.capacity());
               __a = &__buf[0];
               __a_end = __a + __tmp;
           }
           if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,                                     __thousands_sep, __grouping, __g, __g_end,                                     __atoms))             break;
       }
       if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)         *__g_end++ = __dc;
       // Stage 3
    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);
       // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
       // EOF checked
    if (__b == __e)         __err |= ios_base::eofbit;
       return __b;
   }
    // unsigned
 template <class _CharT, class _InputIterator> template <class _Unsigned> _InputIterator num_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,                                         ios_base& __iob,                                         ios_base::iostate& __err,                                         _Unsigned& __v) const {
       // Stage 1
    int __base = this->__get_base(__iob);
       // Stage 2
    char_type __thousands_sep;
       const int __atoms_size = 26;
     
#ifdef _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET
    char_type __atoms1[__atoms_size];
       const char_type *__atoms = this->__do_widen(__iob, __atoms1);
       string __grouping = this->__stage2_int_prep(__iob, __thousands_sep);
     
#else
    char_type __atoms[__atoms_size];
       string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
     
#endif
    string __buf;
       __buf.resize(__buf.capacity());
       char* __a = &__buf[0];
       char* __a_end = __a;
       unsigned __g[__num_get_base::__num_get_buf_sz];
       unsigned* __g_end = __g;
       unsigned __dc = 0;
       for (;
   __b != __e;
   ++__b)     {
           if (__a_end == __a + __buf.size())         {
               size_t __tmp = __buf.size();
               __buf.resize(2*__buf.size());
               __buf.resize(__buf.capacity());
               __a = &__buf[0];
               __a_end = __a + __tmp;
           }
           if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,                                     __thousands_sep, __grouping, __g, __g_end,                                     __atoms))             break;
       }
       if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)         *__g_end++ = __dc;
       // Stage 3
    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);
       // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
       // EOF checked
    if (__b == __e)         __err |= ios_base::eofbit;
       return __b;
   }
    // floating point
 template <class _CharT, class _InputIterator> template <class _Fp> _InputIterator num_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,                                         ios_base& __iob,                                         ios_base::iostate& __err,                                         _Fp& __v) const {
       // Stage 1, nothing to do
    // Stage 2
    char_type __atoms[32];
       char_type __decimal_point;
       char_type __thousands_sep;
       string __grouping = this->__stage2_float_prep(__iob, __atoms,                                                   __decimal_point,                                                   __thousands_sep);
       string __buf;
       __buf.resize(__buf.capacity());
       char* __a = &__buf[0];
       char* __a_end = __a;
       unsigned __g[__num_get_base::__num_get_buf_sz];
       unsigned* __g_end = __g;
       unsigned __dc = 0;
       bool __in_units = true;
       char __exp = 'E';
       for (;
   __b != __e;
   ++__b)     {
           if (__a_end == __a + __buf.size())         {
               size_t __tmp = __buf.size();
               __buf.resize(2*__buf.size());
               __buf.resize(__buf.capacity());
               __a = &__buf[0];
               __a_end = __a + __tmp;
           }
           if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,                                       __decimal_point, __thousands_sep,                                       __grouping, __g, __g_end,                                       __dc, __atoms))             break;
       }
       if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)         *__g_end++ = __dc;
       // Stage 3
    __v = __num_get_float<_Fp>(__a, __a_end, __err);
       // Digit grouping checked
    __check_grouping(__grouping, __g, __g_end, __err);
       // EOF checked
    if (__b == __e)         __err |= ios_base::eofbit;
       return __b;
   }
    template <class _CharT, class _InputIterator> _InputIterator num_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,                                         ios_base& __iob,                                         ios_base::iostate& __err,                                         void*& __v) const {
       // Stage 1
    int __base = 16;
       // Stage 2
    char_type __atoms[26];
       char_type __thousands_sep = 0;
       string __grouping;
       use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,                                                     __num_get_base::__src + 26, __atoms);
       string __buf;
       __buf.resize(__buf.capacity());
       char* __a = &__buf[0];
       char* __a_end = __a;
       unsigned __g[__num_get_base::__num_get_buf_sz];
       unsigned* __g_end = __g;
       unsigned __dc = 0;
       for (;
   __b != __e;
   ++__b)     {
           if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,                                     __thousands_sep, __grouping,                                     __g, __g_end, __atoms))             break;
       }
       // Stage 3
    __buf.resize(__a_end - __a);
       if (__libcpp_sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, "%p", &__v) != 1)         __err = ios_base::failbit;
       // EOF checked
    if (__b == __e)         __err |= ios_base::eofbit;
       return __b;
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_get<wchar_t>)  struct _LIBCPP_TYPE_VIS __num_put_base {
   protected:     static void __format_int(char* __fmt, const char* __len, bool __signd,                              ios_base::fmtflags __flags);
       static bool __format_float(char* __fmt, const char* __len,                                ios_base::fmtflags __flags);
       static char* __identify_padding(char* __nb, char* __ne,                                     const ios_base& __iob);
   };
    template <class _CharT> struct __num_put     : protected __num_put_base {
       static void __widen_and_group_int(char* __nb, char* __np, char* __ne,                                       _CharT* __ob, _CharT*& __op, _CharT*& __oe,                                       const locale& __loc);
       static void __widen_and_group_float(char* __nb, char* __np, char* __ne,                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,                                         const locale& __loc);
   };
    template <class _CharT> void __num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,                                          _CharT* __ob, _CharT*& __op, _CharT*& __oe,                                          const locale& __loc) {
       const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);
       const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
       string __grouping = __npt.grouping();
       if (__grouping.empty())     {
           __ct.widen(__nb, __ne, __ob);
           __oe = __ob + (__ne - __nb);
       }
       else     {
           __oe = __ob;
           char* __nf = __nb;
           if (*__nf == '-' || *__nf == '+')             *__oe++ = __ct.widen(*__nf++);
           if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||                                                    __nf[1] == 'X'))         {
               *__oe++ = __ct.widen(*__nf++);
               *__oe++ = __ct.widen(*__nf++);
           }
           reverse(__nf, __ne);
           _CharT __thousands_sep = __npt.thousands_sep();
           unsigned __dc = 0;
           unsigned __dg = 0;
           for (char* __p = __nf;
   __p < __ne;
   ++__p)         {
               if (static_cast<unsigned>(__grouping[__dg]) > 0 &&                 __dc == static_cast<unsigned>(__grouping[__dg]))             {
                   *__oe++ = __thousands_sep;
                   __dc = 0;
                   if (__dg < __grouping.size()-1)                     ++__dg;
               }
               *__oe++ = __ct.widen(*__p);
               ++__dc;
           }
           reverse(__ob + (__nf - __nb), __oe);
       }
       if (__np == __ne)         __op = __oe;
       else         __op = __ob + (__np - __nb);
   }
    template <class _CharT> void __num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,                                            _CharT* __ob, _CharT*& __op, _CharT*& __oe,                                            const locale& __loc) {
       const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);
       const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);
       string __grouping = __npt.grouping();
       __oe = __ob;
       char* __nf = __nb;
       if (*__nf == '-' || *__nf == '+')         *__oe++ = __ct.widen(*__nf++);
       char* __ns;
       if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||                                                __nf[1] == 'X'))     {
           *__oe++ = __ct.widen(*__nf++);
           *__oe++ = __ct.widen(*__nf++);
           for (__ns = __nf;
   __ns < __ne;
   ++__ns)             if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))                 break;
       }
       else     {
           for (__ns = __nf;
   __ns < __ne;
   ++__ns)             if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))                 break;
       }
       if (__grouping.empty())     {
           __ct.widen(__nf, __ns, __oe);
           __oe += __ns - __nf;
       }
       else     {
           reverse(__nf, __ns);
           _CharT __thousands_sep = __npt.thousands_sep();
           unsigned __dc = 0;
           unsigned __dg = 0;
           for (char* __p = __nf;
   __p < __ns;
   ++__p)         {
           }
           reverse(__ob + (__nf - __nb), __oe);
       }
       for (__nf = __ns;
   __nf < __ne;
   ++__nf)     {
           if (*__nf == '.')         {
               *__oe++ = __npt.decimal_point();
               ++__nf;
               break;
           }
           else             *__oe++ = __ct.widen(*__nf);
       }
       __ct.widen(__nf, __ne, __oe);
       __oe += __ne - __nf;
       if (__np == __ne)         __op = __oe;
       else         __op = __ob + (__np - __nb);
   }
    _LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<char>) _LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __num_put<wchar_t>)  template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> > class _LIBCPP_TEMPLATE_VIS num_put     : public locale::facet,       private __num_put<_CharT> {
   public:     typedef _CharT char_type;
       typedef _OutputIterator iter_type;
        _LIBCPP_ALWAYS_INLINE     explicit num_put(size_t __refs = 0)         : locale::facet(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE     iter_type put(iter_type __s, ios_base& __iob, char_type __fl,                   double __v) const     {
           return do_put(__s, __iob, __fl, __v);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type put(iter_type __s, ios_base& __iob, char_type __fl,                   long double __v) const     {
           return do_put(__s, __iob, __fl, __v);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type put(iter_type __s, ios_base& __iob, char_type __fl,                   const void* __v) const     {
           return do_put(__s, __iob, __fl, __v);
       }
        static locale::id id;
    protected:     _LIBCPP_ALWAYS_INLINE     ~num_put() {
  }
        virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,                              bool __v) const;
       virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,                              long __v) const;
       virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,                              long long __v) const;
       virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,                              unsigned long) const;
       virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,                              unsigned long long) const;
       virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,                              double __v) const;
       virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,                              long double __v) const;
       virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,                              const void* __v) const;
   };
    template <class _CharT, class _OutputIterator> locale::id num_put<_CharT, _OutputIterator>::id;
    template <class _CharT, class _OutputIterator> _LIBCPP_HIDDEN _OutputIterator __pad_and_output(_OutputIterator __s,                  const _CharT* __ob, const _CharT* __op, const _CharT* __oe,                  ios_base& __iob, _CharT __fl) {
       streamsize __sz = __oe - __ob;
       streamsize __ns = __iob.width();
       if (__ns > __sz)         __ns -= __sz;
       else         __ns = 0;
       for (;
  __ob < __op;
   ++__ob, ++__s)         *__s = *__ob;
       for (;
   __ns;
   --__ns, ++__s)         *__s = __fl;
       for (;
   __ob < __oe;
   ++__ob, ++__s)         *__s = *__ob;
       __iob.width(0);
       return __s;
   }
      
#if !defined(__APPLE__) || \
    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \
    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)
 template <class _CharT, class _Traits> _LIBCPP_HIDDEN ostreambuf_iterator<_CharT, _Traits> __pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,                  const _CharT* __ob, const _CharT* __op, const _CharT* __oe,                  ios_base& __iob, _CharT __fl) {
       if (__s.__sbuf_ == nullptr)         return __s;
       streamsize __sz = __oe - __ob;
       streamsize __ns = __iob.width();
       if (__ns > __sz)         __ns -= __sz;
       else         __ns = 0;
       streamsize __np = __op - __ob;
       if (__np > 0)     {
           if (__s.__sbuf_->sputn(__ob, __np) != __np)         {
               __s.__sbuf_ = nullptr;
           }
       }
       __np = __oe - __op;
       if (__np > 0)     {
           if (__s.__sbuf_->sputn(__op, __np) != __np)         {
               __s.__sbuf_ = nullptr;
               return __s;
           }
       }
       __iob.width(0);
       return __s;
   }
      
#endif
 template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,                                          char_type __fl, bool __v) const {
       if ((__iob.flags() & ios_base::boolalpha) == 0)         return do_put(__s, __iob, __fl, (unsigned long)__v);
       // Stage 1 - Get number in narrow char
    char __fmt[6] = {
  '%', 0};
       const char* __len = "l";
       this->__format_int(__fmt+1, __len, false, __iob.flags());
       const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)                           + ((numeric_limits<unsigned long>::digits % 3) != 0)                           + ((__iob.flags() & ios_base::showbase) != 0)                           + 1;
       char __nar[__nbuf];
       int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
       char* __ne = __nar + __nc;
       char* __np = this->__identify_padding(__nar, __ne, __iob);
       // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
       char_type* __op;
    // pad here
    char_type* __oe;
    // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
       // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
   }
    template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,                                          char_type __fl, unsigned long long __v) const {
       // Stage 1 - Get number in narrow char
    char __fmt[8] = {
  '%', 0};
       const char* __len = "ll";
       this->__format_int(__fmt+1, __len, false, __iob.flags());
       const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)                           + ((numeric_limits<unsigned long long>::digits % 3) != 0)                           + ((__iob.flags() & ios_base::showbase) != 0)                           + 1;
       char __nar[__nbuf];
       int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
       char* __ne = __nar + __nc;
       char* __np = this->__identify_padding(__nar, __ne, __iob);
       // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
       char_type* __op;
    // pad here
    char_type* __oe;
    // end of output
    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
       // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
   }
    template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,                                          char_type __fl, double __v) const {
       // Stage 1 - Get number in narrow char
    char __fmt[8] = {
  '%', 0};
       const char* __len = "";
       bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
       const unsigned __nbuf = 30;
       char __nar[__nbuf];
       char* __nb = __nar;
       int __nc;
       if (__specify_precision)         __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,                                    (int)__iob.precision(), __v);
       char* __ne = __nb + __nc;
       char* __np = this->__identify_padding(__nb, __ne, __iob);
       // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
       char_type* __ob = __o;
       unique_ptr<char_type, void(*)(void*)> __obh(0, free);
       if (__nb != __nar)     {
           __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
           if (__ob == 0)             __throw_bad_alloc();
           __obh.reset(__ob);
       }
       char_type* __op;
    // pad here
    char_type* __oe;
    // end of output
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
       // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
       return __s;
   }
    template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,                                          char_type __fl, long double __v) const {
       // Stage 1 - Get number in narrow char
    char __fmt[8] = {
  '%', 0};
       const char* __len = "L";
       bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());
       const unsigned __nbuf = 30;
       char __nar[__nbuf];
       char* __nb = __nar;
       int __nc;
       if (__specify_precision)         __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,                                    (int)__iob.precision(), __v);
       else         __nc = __libcpp_snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);
       unique_ptr<char, void(*)(void*)> __nbh(0, free);
       if (__nc > static_cast<int>(__nbuf-1))     {
           if (__specify_precision)             __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);
           else             __nc = __libcpp_asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);
           if (__nb == 0)             __throw_bad_alloc();
           __nbh.reset(__nb);
       }
       char* __ne = __nb + __nc;
       char* __np = this->__identify_padding(__nb, __ne, __iob);
       // Stage 2 - Widen __nar while adding thousands separators
    char_type __o[2*(__nbuf-1) - 1];
       char_type* __ob = __o;
       unique_ptr<char_type, void(*)(void*)> __obh(0, free);
       if (__nb != __nar)     {
           __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));
           if (__ob == 0)             __throw_bad_alloc();
           __obh.reset(__ob);
       }
       char_type* __op;
    // pad here
    char_type* __oe;
    // end of output
    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());
       // [__o, __oe) contains thousands_sep'd wide number
    // Stage 3 & 4
    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
       return __s;
   }
    template <class _CharT, class _OutputIterator> _OutputIterator num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,                                          char_type __fl, const void* __v) const {
       // Stage 1 - Get pointer in narrow char
    char __fmt[6] = "%p";
       const unsigned __nbuf = 20;
       char __nar[__nbuf];
       int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
       char* __ne = __nar + __nc;
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<wchar_t>)  template <class _CharT, class _InputIterator> _LIBCPP_HIDDEN int __get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,                      ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n) {
       // Precondition:  __n >= 1
    if (__b == __e)     {
           __err |= ios_base::eofbit | ios_base::failbit;
           return 0;
       }
       // get first digit
    _CharT __c = *__b;
       if (!__ct.is(ctype_base::digit, __c))     {
           __err |= ios_base::failbit;
           return 0;
       }
       int __r = __ct.narrow(__c, 0) - '0';
       for (++__b, (void) --__n;
   __b != __e && __n > 0;
   ++__b, (void) --__n)     {
           // get next digit
        __c = *__b;
           if (!__ct.is(ctype_base::digit, __c))             return __r;
           __r = __r * 10 + __ct.narrow(__c, 0) - '0';
       }
       if (__b == __e)         __err |= ios_base::eofbit;
       return __r;
   }
    class _LIBCPP_TYPE_VIS time_base {
   public:     enum dateorder {
  no_order, dmy, mdy, ymd, ydm};
   };
    template <class _CharT> class _LIBCPP_TEMPLATE_VIS __time_get_c_storage {
   protected:     typedef basic_string<_CharT> string_type;
        virtual const string_type* __weeks() const;
       virtual const string_type* __months() const;
       virtual const string_type* __am_pm() const;
       virtual const string_type& __c() const;
       virtual const string_type& __r() const;
       virtual const string_type& __x() const;
       virtual const string_type& __X() const;
        _LIBCPP_ALWAYS_INLINE     ~__time_get_c_storage() {
  }
   };
    template <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__weeks() const;
   template <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__months() const;
   template <> _LIBCPP_FUNC_VIS const string* __time_get_c_storage<char>::__am_pm() const;
   template <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__c() const;
   template <> _LIBCPP_FUNC_VIS const string& __time_get_c_storage<char>::__r() const;
   template <> _LIBCPP_FUNC_VIS const wstring& __time_get_c_storage<wchar_t>::__X() const;
    template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> > class _LIBCPP_TEMPLATE_VIS time_get     : public locale::facet,       public time_base,       private __time_get_c_storage<_CharT> {
   public:     typedef _CharT                  char_type;
       typedef _InputIterator          iter_type;
       typedef time_base::dateorder    dateorder;
       typedef basic_string<char_type> string_type;
        _LIBCPP_ALWAYS_INLINE     explicit time_get(size_t __refs = 0)         : locale::facet(__refs) {
       }
        _LIBCPP_ALWAYS_INLINE     iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,                        ios_base::iostate& __err, tm* __tm) const     {
           return do_get_year(__b, __e, __iob, __err, __tm);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type get(iter_type __b, iter_type __e, ios_base& __iob,                   ios_base::iostate& __err, tm *__tm,                   char __fmt, char __mod = 0) const     {
           return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
       }
        iter_type get(iter_type __b, iter_type __e, ios_base& __iob,                   ios_base::iostate& __err, tm* __tm,                   const char_type* __fmtb, const char_type* __fmte) const;
        static locale::id id;
    protected:     _LIBCPP_ALWAYS_INLINE     ~time_get() {
  }
        virtual dateorder do_date_order() const;
       virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,                                   ios_base::iostate& __err, tm* __tm) const;
       virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,                                   ios_base::iostate& __err, tm* __tm) const;
       virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,                                      ios_base::iostate& __err, tm* __tm) const;
       virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,                                        ios_base::iostate& __err, tm* __tm) const;
       virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,                                   ios_base::iostate& __err, tm* __tm) const;
       virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,                              ios_base::iostate& __err, tm* __tm,                              char __fmt, char __mod) const;
   private:     void __get_white_space(iter_type& __b, iter_type __e,                            ios_base::iostate& __err, const ctype<char_type>& __ct) const;
       void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,                        const ctype<char_type>& __ct) const;
        void __get_weekdayname(int& __m,                            iter_type& __b, iter_type __e,                            ios_base::iostate& __err,                            const ctype<char_type>& __ct) const;
       void __get_monthname(int& __m,                          iter_type& __b, iter_type __e,                          ios_base::iostate& __err,                          const ctype<char_type>& __ct) const;
       void __get_day(int& __d,                    iter_type& __b, iter_type __e,                    ios_base::iostate& __err,                    const ctype<char_type>& __ct) const;
       void __get_month(int& __m,                      iter_type& __b, iter_type __e,                      ios_base::iostate& __err,                      const ctype<char_type>& __ct) const;
       void __get_year(int& __y,                    iter_type& __b, iter_type __e,                    ios_base::iostate& __err,                    const ctype<char_type>& __ct) const;
       void __get_year4(int& __y,                     iter_type& __b, iter_type __e,                     ios_base::iostate& __err,                     const ctype<char_type>& __ct) const;
       void __get_hour(int& __d,                     iter_type& __b, iter_type __e,                     ios_base::iostate& __err,                     const ctype<char_type>& __ct) const;
       void __get_12_hour(int& __h,                        iter_type& __b, iter_type __e,                        ios_base::iostate& __err,                        const ctype<char_type>& __ct) const;
       void __get_am_pm(int& __h,                      iter_type& __b, iter_type __e,                      ios_base::iostate& __err,                      const ctype<char_type>& __ct) const;
       void __get_minute(int& __m,                       iter_type& __b, iter_type __e,                       ios_base::iostate& __err,                       const ctype<char_type>& __ct) const;
       void __get_second(int& __s,                       iter_type& __b, iter_type __e,                       ios_base::iostate& __err,                       const ctype<char_type>& __ct) const;
       void __get_weekday(int& __w,                        iter_type& __b, iter_type __e,                        ios_base::iostate& __err,                        const ctype<char_type>& __ct) const;
       void __get_day_year_num(int& __w,                             iter_type& __b, iter_type __e,                             ios_base::iostate& __err,                             const ctype<char_type>& __ct) const;
   };
    template <class _CharT, class _InputIterator> locale::id time_get<_CharT, _InputIterator>::id;
    // time_get primitives
 template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,                                                     iter_type& __b, iter_type __e,                                                     ios_base::iostate& __err,                                                     const ctype<char_type>& __ct) const {
       // Note:  ignoring case comes from the POSIX strptime spec
    const string_type* __wk = this->__weeks();
   }
    template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_day(int& __d,                                             iter_type& __b, iter_type __e,                                             ios_base::iostate& __err,                                             const ctype<char_type>& __ct) const {
       int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
       if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)         __d = __t;
       else         __err |= ios_base::failbit;
   }
    template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_month(int& __m,                                               iter_type& __b, iter_type __e,                                               ios_base::iostate& __err,                                               const ctype<char_type>& __ct) const {
       int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
       if (!(__err & ios_base::failbit) && __t <= 11)         __m = __t;
       else         __err |= ios_base::failbit;
   }
    template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_year(int& __y,                                              iter_type& __b, iter_type __e,                                              ios_base::iostate& __err,                                              const ctype<char_type>& __ct) const {
       int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
       if (!(__err & ios_base::failbit))     {
           if (__t < 69)             __t += 2000;
           else if (69 <= __t && __t <= 99)             __t += 1900;
           __y = __t - 1900;
       }
   }
    template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_year4(int& __y,                                               iter_type& __b, iter_type __e,                                               ios_base::iostate& __err,                                               const ctype<char_type>& __ct) const {
       int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
       if (!(__err & ios_base::failbit))         __y = __t - 1900;
   }
    template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_hour(int& __h,                                              iter_type& __b, iter_type __e,                                              ios_base::iostate& __err,                                              const ctype<char_type>& __ct) const {
       int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
       if (!(__err & ios_base::failbit) && __t <= 23)         __h = __t;
       else         __err |= ios_base::failbit;
   }
    template <class _CharT, class _InputIterator> void time_get<_CharT, _InputIterator>::__get_12_hour(int& __h,                                                 iter_type& __b, iter_type __e,                                                 ios_base::iostate& __err,                                                 const ctype<char_type>& __ct) const {
       int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
       if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)         __h = __t;
       return __b;
   }
    template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,                                                    ios_base& __iob,                                                    ios_base::iostate& __err,                                                    tm* __tm) const {
       const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
       __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
       return __b;
   }
    template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,                                               ios_base& __iob,                                               ios_base::iostate& __err,                                               tm* __tm) const {
       const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
       __get_year(__tm->tm_year, __b, __e, __err, __ct);
       return __b;
   }
    template <class _CharT, class _InputIterator> _InputIterator time_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,                                          ios_base& __iob,                                          ios_base::iostate& __err, tm* __tm,                                          char __fmt, char) const {
       __err = ios_base::goodbit;
       const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
       switch (__fmt)     {
       case 'a':     case 'A':         __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
           break;
       case 'b':     case 'B':     case 'h':         __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
           break;
       case 'c':         {
           const string_type& __fm = this->__c();
           __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
           }
           break;
       case 'F':         {
           const char_type __fm[] = {
  '%', 'Y', '-', '%', 'm', '-', '%', 'd'};
           __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));
           }
       case 'Y':         __get_year4(__tm->tm_year, __b, __e, __err, __ct);
           break;
       case '%':         __get_percent(__b, __e, __err, __ct);
           break;
       default:         __err |= ios_base::failbit;
       }
       return __b;
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get<wchar_t>)  class _LIBCPP_TYPE_VIS __time_get {
   protected:     locale_t __loc_;
        __time_get(const char* __nm);
       __time_get(const string& __nm);
       ~__time_get();
   };
    template <class _CharT> class _LIBCPP_TEMPLATE_VIS __time_get_storage     : public __time_get {
   protected:     typedef basic_string<_CharT> string_type;
       explicit __time_get_storage(const string& __nm);
        _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {
  }
        time_base::dateorder __do_date_order() const;
    private:     void init(const ctype<_CharT>&);
       string_type __analyze(char __fmt, const ctype<_CharT>&);
   };
    template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> > class _LIBCPP_TEMPLATE_VIS time_get_byname     : public time_get<_CharT, _InputIterator>,       private __time_get_storage<_CharT> {
   public:     typedef time_base::dateorder    dateorder;
       typedef _InputIterator          iter_type;
       typedef _CharT                  char_type;
       typedef basic_string<char_type> string_type;
        _LIBCPP_INLINE_VISIBILITY     explicit time_get_byname(const char* __nm, size_t __refs = 0)         : time_get<_CharT, _InputIterator>(__refs),           __time_get_storage<_CharT>(__nm) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit time_get_byname(const string& __nm, size_t __refs = 0)         : time_get<_CharT, _InputIterator>(__refs),           __time_get_storage<_CharT>(__nm) {
  return this->__weeks_;
  }
       _LIBCPP_INLINE_VISIBILITY     virtual const string_type* __months() const {
  return this->__months_;
  }
       _LIBCPP_INLINE_VISIBILITY     virtual const string_type* __am_pm() const  {
  return this->__am_pm_;
  }
       _LIBCPP_INLINE_VISIBILITY     virtual const string_type& __c() const      {
  return this->__c_;
  }
       _LIBCPP_INLINE_VISIBILITY     virtual const string_type& __r() const      {
  return this->__r_;
  }
       _LIBCPP_INLINE_VISIBILITY     virtual const string_type& __x() const      {
  return this->__x_;
  }
       _LIBCPP_INLINE_VISIBILITY     virtual const string_type& __X() const      {
  return this->__X_;
  }
   };
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_get_byname<wchar_t>)  class _LIBCPP_TYPE_VIS __time_put {
       locale_t __loc_;
   protected:     _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {
  }
       __time_put(const char* __nm);
       __time_put(const string& __nm);
       ~__time_put();
       void __do_put(char* __nb, char*& __ne, const tm* __tm,                   char __fmt, char __mod) const;
       void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,                   char __fmt, char __mod) const;
   };
    template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> > class _LIBCPP_TEMPLATE_VIS time_put     : public locale::facet,       private __time_put {
   public:     typedef _CharT char_type;
       typedef _OutputIterator iter_type;
        _LIBCPP_ALWAYS_INLINE     explicit time_put(size_t __refs = 0)         : locale::facet(__refs) {
  }
        iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,                   const char_type* __pb, const char_type* __pe) const;
        _LIBCPP_ALWAYS_INLINE     iter_type put(iter_type __s, ios_base& __iob, char_type __fl,                   const tm* __tm, char __fmt, char __mod = 0) const     {
           return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
       }
        static locale::id id;
    protected:     _LIBCPP_ALWAYS_INLINE     ~time_put() {
  }
       virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,                              char __fmt, char __mod) const;
        _LIBCPP_ALWAYS_INLINE     explicit time_put(const char* __nm, size_t __refs)         : locale::facet(__refs),           __time_put(__nm) {
  }
       _LIBCPP_ALWAYS_INLINE     explicit time_put(const string& __nm, size_t __refs)         : locale::facet(__refs),           __time_put(__nm) {
  }
   };
    template <class _CharT, class _OutputIterator> locale::id time_put<_CharT, _OutputIterator>::id;
    template <class _CharT, class _OutputIterator> _OutputIterator time_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,                                        char_type __fl, const tm* __tm,                                        const char_type* __pb,                                        const char_type* __pe) const {
       const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());
       for (;
   __pb != __pe;
   ++__pb)     {
           if (__ct.narrow(*__pb, 0) == '%')         {
               if (++__pb == __pe)             {
                   *__s++ = __pb[-1];
                   break;
               }
               char __mod = 0;
               char __fmt = __ct.narrow(*__pb, 0);
               if (__fmt == 'E' || __fmt == 'O')             {
                   if (++__pb == __pe)                 {
                      *__s++ = __pb[-2];
                      *__s++ = __pb[-1];
                      break;
                  }
                   __mod = __fmt;
                   __fmt = __ct.narrow(*__pb, 0);
               }
               __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
           }
           else             *__s++ = *__pb;
       }
       return __s;
   }
    template <class _CharT, class _OutputIterator> _OutputIterator time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,                                           char_type, const tm* __tm,                                           char __fmt, char __mod) const {
       char_type __nar[100];
       char_type* __nb = __nar;
       char_type* __ne = __nb + 100;
       __do_put(__nb, __ne, __tm, __fmt, __mod);
       return _VSTD::copy(__nb, __ne, __s);
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put<wchar_t>)  template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> > class _LIBCPP_TEMPLATE_VIS time_put_byname     : public time_put<_CharT, _OutputIterator> {
   public:     _LIBCPP_ALWAYS_INLINE     explicit time_put_byname(const char* __nm, size_t __refs = 0)         : time_put<_CharT, _OutputIterator>(__nm, __refs) {
  }
        _LIBCPP_ALWAYS_INLINE     explicit time_put_byname(const string& __nm, size_t __refs = 0)         : time_put<_CharT, _OutputIterator>(__nm, __refs) {
  }
    protected:     _LIBCPP_ALWAYS_INLINE     ~time_put_byname() {
  }
   };
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS time_put_byname<wchar_t>)  // money_base
 class _LIBCPP_TYPE_VIS money_base {
   public:     enum part {
  none, space, symbol, sign, value};
       struct pattern {
  char field[4];
  };
        _LIBCPP_ALWAYS_INLINE money_base() {
  }
   };
    // moneypunct
 template <class _CharT, bool _International = false> class _LIBCPP_TEMPLATE_VIS moneypunct     : public locale::facet,       public money_base {
   public:     typedef _CharT                  char_type;
       typedef basic_string<char_type> string_type;
        _LIBCPP_ALWAYS_INLINE     explicit moneypunct(size_t __refs = 0)         : locale::facet(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {
  return do_decimal_point();
  }
       _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {
  return do_thousands_sep();
  }
       _LIBCPP_ALWAYS_INLINE string      grouping()      const {
  return do_grouping();
  }
       _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {
  return do_neg_format();
  }
        static locale::id id;
       static const bool intl = _International;
    protected:     _LIBCPP_ALWAYS_INLINE     ~moneypunct() {
  }
        virtual char_type   do_decimal_point() const {
  return numeric_limits<char_type>::max();
  }
       virtual char_type   do_thousands_sep() const {
  return numeric_limits<char_type>::max();
  }
       virtual string      do_grouping()      const {
  return string();
  }
       virtual string_type do_curr_symbol()   const {
  return string_type();
  }
       virtual string_type do_positive_sign() const {
  return string_type();
  }
       virtual string_type do_negative_sign() const {
  return string_type(1, '-');
  }
       virtual int         do_frac_digits()   const {
  return 0;
  }
       virtual pattern     do_pos_format()    const         {
  pattern __p = {
  {
  symbol, sign, none, value}
  };
   return __p;
  }
       virtual pattern     do_neg_format()    const         {
  pattern __p = {
  {
  symbol, sign, none, value}
  };
   return __p;
  }
   };
    template <class _CharT, bool _International> locale::id moneypunct<_CharT, _International>::id;
    template <class _CharT, bool _International> const bool moneypunct<_CharT, _International>::intl;
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, false>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<char, true>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, false>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct<wchar_t, true>)  // moneypunct_byname
 template <class _CharT, bool _International = false> class _LIBCPP_TEMPLATE_VIS moneypunct_byname     : public moneypunct<_CharT, _International> {
   public:     typedef money_base::pattern  pattern;
       typedef _CharT                  char_type;
       typedef basic_string<char_type> string_type;
        _LIBCPP_ALWAYS_INLINE     explicit moneypunct_byname(const char* __nm, size_t __refs = 0)         : moneypunct<_CharT, _International>(__refs) {
  init(__nm);
  return __neg_format_;
  }
    private:     char_type   __decimal_point_;
       char_type   __thousands_sep_;
       string      __grouping_;
       string_type __curr_symbol_;
       string_type __positive_sign_;
       string_type __negative_sign_;
       int         __frac_digits_;
       pattern     __pos_format_;
       pattern     __neg_format_;
        void init(const char*);
   };
    template<> _LIBCPP_FUNC_VIS void moneypunct_byname<char, false>::init(const char*);
   template<> _LIBCPP_FUNC_VIS void moneypunct_byname<char, true>::init(const char*);
   template<> _LIBCPP_FUNC_VIS void moneypunct_byname<wchar_t, false>::init(const char*);
   template<> _LIBCPP_FUNC_VIS void moneypunct_byname<wchar_t, true>::init(const char*);
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, false>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<char, true>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, false>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS moneypunct_byname<wchar_t, true>)  // money_get
 template <class _CharT> class __money_get {
   protected:     typedef _CharT                  char_type;
       typedef basic_string<char_type> string_type;
        _LIBCPP_ALWAYS_INLINE __money_get() {
  }
        static void __gather_info(bool __intl, const locale& __loc,                               money_base::pattern& __pat, char_type& __dp,                               char_type& __ts, string& __grp,                               string_type& __sym, string_type& __psn,                               string_type& __nsn, int& __fd);
   };
    template <class _CharT> void __money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,                                    money_base::pattern& __pat, char_type& __dp,                                    char_type& __ts, string& __grp,                                    string_type& __sym, string_type& __psn,                                    string_type& __nsn, int& __fd) {
       if (__intl)     {
           const moneypunct<char_type, true>& __mp =             use_facet<moneypunct<char_type, true> >(__loc);
           __pat = __mp.neg_format();
           __nsn = __mp.negative_sign();
           __psn = __mp.positive_sign();
           __dp = __mp.decimal_point();
           __ts = __mp.thousands_sep();
           __grp = __mp.grouping();
           __sym = __mp.curr_symbol();
           __fd = __mp.frac_digits();
       }
       else     {
           const moneypunct<char_type, false>& __mp =             use_facet<moneypunct<char_type, false> >(__loc);
           __pat = __mp.neg_format();
           __nsn = __mp.negative_sign();
           __psn = __mp.positive_sign();
           __dp = __mp.decimal_point();
           __ts = __mp.thousands_sep();
           __grp = __mp.grouping();
           __sym = __mp.curr_symbol();
           __fd = __mp.frac_digits();
       }
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_get<wchar_t>)  template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> > class _LIBCPP_TEMPLATE_VIS money_get     : public locale::facet,       private __money_get<_CharT> {
   public:     typedef _CharT                  char_type;
       typedef _InputIterator          iter_type;
       typedef basic_string<char_type> string_type;
        static locale::id id;
    protected:      _LIBCPP_ALWAYS_INLINE     ~money_get() {
  }
        virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,                              ios_base& __iob, ios_base::iostate& __err,                              long double& __v) const;
       virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,                              ios_base& __iob, ios_base::iostate& __err,                              string_type& __v) const;
    private:     static bool __do_get(iter_type& __b, iter_type __e,                          bool __intl, const locale& __loc,                          ios_base::fmtflags __flags, ios_base::iostate& __err,                          bool& __neg, const ctype<char_type>& __ct,                          unique_ptr<char_type, void(*)(void*)>& __wb,                          char_type*& __wn, char_type* __we);
   };
    template <class _CharT, class _InputIterator> locale::id money_get<_CharT, _InputIterator>::id;
    _LIBCPP_FUNC_VIS void __do_nothing(void*);
    template <class _Tp> _LIBCPP_HIDDEN void __double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e) {
       bool __owns = __b.get_deleter() != __do_nothing;
       size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);
       size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?                        2 * __cur_cap : numeric_limits<size_t>::max();
       if (__new_cap == 0)         __new_cap = sizeof(_Tp);
       size_t __n_off = static_cast<size_t>(__n - __b.get());
       _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);
       if (__t == 0)         __throw_bad_alloc();
       if (__owns)         __b.release();
       __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);
       __new_cap /= sizeof(_Tp);
       __n = __b.get() + __n_off;
       __e = __b.get() + __new_cap;
   }
    // true == success
template <class _CharT, class _InputIterator> bool money_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,                                             bool __intl, const locale& __loc,                                             ios_base::fmtflags __flags,                                             ios_base::iostate& __err,                                             bool& __neg,                                             const ctype<char_type>& __ct,                                             unique_ptr<char_type, void(*)(void*)>& __wb,                                             char_type*& __wn, char_type* __we) {
       const unsigned __bz = 100;
       unsigned __gbuf[__bz];
       unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);
       unsigned* __gn = __gb.get();
       unsigned* __ge = __gn + __bz;
       money_base::pattern __pat;
       char_type __dp;
       char_type __ts;
       string __grp;
       string_type __sym;
       string_type __psn;
       string_type __nsn;
       // Capture the spaces read into money_base::{space,none} so they
    // can be compared to initial spaces in __sym.
    string_type __spaces;
       int __fd;
       __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,                                        __sym, __psn, __nsn, __fd);
       const string_type* __trailing_sign = 0;
       __wn = __wb.get();
       for (unsigned __p = 0;
   __p < 4 && __b != __e;
   ++__p)     {
           switch (__pat.field[__p])         {
           case money_base::space:             if (__p != 3)             {
                   if (__ct.is(ctype_base::space, *__b))                     __spaces.push_back(*__b++);
                   else                 {
                      __err |= ios_base::failbit;
                      return false;
                  }
               }
               _LIBCPP_FALLTHROUGH();
           case money_base::none:             if (__p != 3)             {
                   while (__b != __e && __ct.is(ctype_base::space, *__b))                     __spaces.push_back(*__b++);
               }
               break;
           case money_base::sign:             if (__psn.size() + __nsn.size() > 0)             {
                   if (__psn.size() == 0 || __nsn.size() == 0)                 {
    // sign is optional
                    if (__psn.size() > 0)                     {
    // __nsn.size() == 0
                        if (*__b == __psn[0])                         {
                              ++__b;
                              if (__psn.size() > 1)                                 __trailing_sign = &__psn;
                          }
                          else                             __neg = true;
                      }
                  }
               }
               break;
           case money_base::symbol:             {
               bool __more_needed = __trailing_sign ||                                  (__p < 2)       ||                                  (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
               bool __sb = (__flags & ios_base::showbase) != 0;
               if (__sb || __more_needed)             {
                  typename string_type::const_iterator __sym_space_end = __sym.begin();
                  if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||                                 __pat.field[__p - 1] == money_base::space)) {
                      // Match spaces we've already read against spaces at
                    // the beginning of __sym.
                    while (__sym_space_end != __sym.end() &&                            __ct.is(ctype_base::space, *__sym_space_end))                         ++__sym_space_end;
                      const size_t __num_spaces = __sym_space_end - __sym.begin();
                      if (__num_spaces > __spaces.size() ||                         !equal(__spaces.end() - __num_spaces, __spaces.end(),                                __sym.begin())) {
                          // No match. Put __sym_space_end back at the
                        // beginning of __sym, which will prevent a
                        // match in the next loop.
                        __sym_space_end = __sym.begin();
                      }
                  }
                  typename string_type::const_iterator __sym_curr_char = __sym_space_end;
                  while (__sym_curr_char != __sym.end() && __b != __e &&                        *__b == *__sym_curr_char) {
                      ++__b;
                      ++__sym_curr_char;
                  }
                  if (__sb && __sym_curr_char != __sym.end())                 {
                      __err |= ios_base::failbit;
                      return false;
                  }
              }
               }
               break;
           case money_base::value:             {
               unsigned __ng = 0;
               for (;
   __b != __e;
   ++__b)             {
                  char_type __c = *__b;
              }
               if (__fd > 0)             {
                  if (__b == __e || *__b != __dp)                 {
                      __err |= ios_base::failbit;
                      return false;
                  }
                  for (++__b;
  __fd > 0;
  --__fd, ++__b)                 {
                      if (__b == __e || !__ct.is(ctype_base::digit, *__b))                     {
                          __err |= ios_base::failbit;
                          return false;
                      }
                      if (__wn == __we)                         __double_or_nothing(__wb, __wn, __we);
                      *__wn++ = *__b;
                  }
              }
               if (__wn == __wb.get())             {
                  __err |= ios_base::failbit;
                  return false;
              }
               }
               break;
           }
       }
       if (__trailing_sign)     {
           for (unsigned __i = 1;
   __i < __trailing_sign->size();
   ++__i, ++__b)         {
               if (__b == __e || *__b != (*__trailing_sign)[__i])             {
                   __err |= ios_base::failbit;
                   return false;
               }
           }
       }
       if (__gb.get() != __gn)     {
           ios_base::iostate __et = ios_base::goodbit;
           __check_grouping(__grp, __gb.get(), __gn, __et);
           if (__et)         {
               __err |= ios_base::failbit;
               return false;
           }
       }
       return true;
   }
    template <class _CharT, class _InputIterator> _InputIterator money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,                                           bool __intl, ios_base& __iob,                                           ios_base::iostate& __err,                                           long double& __v) const {
       const int __bz = 100;
       char_type __wbuf[__bz];
       unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
       char_type* __wn;
       char_type* __we = __wbuf + __bz;
       locale __loc = __iob.getloc();
       const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
       bool __neg = false;
       if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,                  __wb, __wn, __we))     {
           const char __src[] = "0123456789";
           char_type __atoms[sizeof(__src)-1];
           __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);
           char __nbuf[__bz];
           char* __nc = __nbuf;
           unique_ptr<char, void(*)(void*)> __h(0, free);
           if (__wn - __wb.get() > __bz-2)         {
               __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
               if (__h.get() == 0)                 __throw_bad_alloc();
               __nc = __h.get();
           }
           if (__neg)             *__nc++ = '-';
           for (const char_type* __w = __wb.get();
   __w < __wn;
   ++__w, ++__nc)             *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];
           *__nc = char();
           if (sscanf(__nbuf, "%Lf", &__v) != 1)             __throw_runtime_error("money_get error");
       }
       if (__b == __e)         __err |= ios_base::eofbit;
       return __b;
   }
    template <class _CharT, class _InputIterator> _InputIterator money_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,                                           bool __intl, ios_base& __iob,                                           ios_base::iostate& __err,                                           string_type& __v) const {
       const int __bz = 100;
       char_type __wbuf[__bz];
       unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);
       char_type* __wn;
       char_type* __we = __wbuf + __bz;
       locale __loc = __iob.getloc();
       const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
       bool __neg = false;
       if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,                  __wb, __wn, __we))     {
           __v.clear();
           if (__neg)             __v.push_back(__ct.widen('-'));
           char_type __z = __ct.widen('0');
           char_type* __w;
           for (__w = __wb.get();
   __w < __wn-1;
   ++__w)             if (*__w != __z)                 break;
           __v.append(__w, __wn);
       }
       if (__b == __e)         __err |= ios_base::eofbit;
       return __b;
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_get<wchar_t>)  // money_put
 template <class _CharT> class __money_put {
   protected:     typedef _CharT                  char_type;
       typedef basic_string<char_type> string_type;
        _LIBCPP_ALWAYS_INLINE __money_put() {
  }
        static void __gather_info(bool __intl, bool __neg, const locale& __loc,                               money_base::pattern& __pat, char_type& __dp,                               char_type& __ts, string& __grp,                               string_type& __sym, string_type& __sn,                               int& __fd);
       static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,                          ios_base::fmtflags __flags,                          const char_type* __db, const char_type* __de,                          const ctype<char_type>& __ct, bool __neg,                          const money_base::pattern& __pat, char_type __dp,                          char_type __ts, const string& __grp,                          const string_type& __sym, const string_type& __sn,                          int __fd);
   };
    template <class _CharT> void __money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,                                    money_base::pattern& __pat, char_type& __dp,                                    char_type& __ts, string& __grp,                                    string_type& __sym, string_type& __sn,                                    int& __fd) {
       if (__intl)     {
           const moneypunct<char_type, true>& __mp =             use_facet<moneypunct<char_type, true> >(__loc);
           if (__neg)         {
               __pat = __mp.neg_format();
               __sn = __mp.negative_sign();
           }
           __fd = __mp.frac_digits();
       }
   }
    template <class _CharT> void __money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,                               ios_base::fmtflags __flags,                               const char_type* __db, const char_type* __de,                               const ctype<char_type>& __ct, bool __neg,                               const money_base::pattern& __pat, char_type __dp,                               char_type __ts, const string& __grp,                               const string_type& __sym, const string_type& __sn,                               int __fd) {
       __me = __mb;
       for (unsigned __p = 0;
   __p < 4;
   ++__p)     {
           switch (__pat.field[__p])         {
           case money_base::none:             __mi = __me;
               break;
           case money_base::space:             __mi = __me;
               *__me++ = __ct.widen(' ');
               break;
           case money_base::sign:             if (!__sn.empty())                 *__me++ = __sn[0];
               break;
           case money_base::symbol:             if (!__sym.empty() && (__flags & ios_base::showbase))                 __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);
               break;
           case money_base::value:             {
               // remember start of value so we can reverse it
            char_type* __t = __me;
               // find beginning of digits
            if (__neg)                 ++__db;
               // find end of digits
            const char_type* __d;
               for (__d = __db;
   __d < __de;
   ++__d)                 if (!__ct.is(ctype_base::digit, *__d))                     break;
               // print fractional part
            if (__fd > 0)             {
                  int __f;
                  *__me++ = __dp;
              }
               // print units part
            if (__d == __db)             {
                  *__me++ = __ct.widen('0');
              }
               else             {
                  unsigned __ng = 0;
                  unsigned __ig = 0;
                  unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()                                               : static_cast<unsigned>(__grp[__ig]);
                  while (__d != __db)                 {
                      if (__ng == __gl)                     {
                          *__me++ = __ts;
                          __ng = 0;
                          if (++__ig < __grp.size())                             __gl = __grp[__ig] == numeric_limits<char>::max() ?                                         numeric_limits<unsigned>::max() :                                         static_cast<unsigned>(__grp[__ig]);
                      }
                      *__me++ = *--__d;
                      ++__ng;
                  }
              }
               // reverse it
            reverse(__t, __me);
               }
               break;
           }
       }
       // print rest of sign, if any
    if (__sn.size() > 1)         __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);
       // set alignment
    if ((__flags & ios_base::adjustfield) == ios_base::left)         __mi = __me;
       else if ((__flags & ios_base::adjustfield) != ios_base::internal)         __mi = __mb;
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __money_put<wchar_t>)  template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> > class _LIBCPP_TEMPLATE_VIS money_put     : public locale::facet,       private __money_put<_CharT> {
   public:     typedef _CharT                  char_type;
       typedef _OutputIterator         iter_type;
       typedef basic_string<char_type> string_type;
        _LIBCPP_ALWAYS_INLINE     explicit money_put(size_t __refs = 0)         : locale::facet(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE     iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,                   long double __units) const     {
           return do_put(__s, __intl, __iob, __fl, __units);
       }
        _LIBCPP_ALWAYS_INLINE     iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,                   const string_type& __digits) const     {
           return do_put(__s, __intl, __iob, __fl, __digits);
       }
        static locale::id id;
    protected:     _LIBCPP_ALWAYS_INLINE     ~money_put() {
  }
        virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,                              char_type __fl, long double __units) const;
       virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,                              char_type __fl, const string_type& __digits) const;
   };
    template <class _CharT, class _OutputIterator> locale::id money_put<_CharT, _OutputIterator>::id;
    template <class _CharT, class _OutputIterator> _OutputIterator money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,                                            ios_base& __iob, char_type __fl,                                            long double __units) const {
       // convert to char
    const size_t __bs = 100;
       char __buf[__bs];
       char* __bb = __buf;
       char_type __digits[__bs];
       char_type* __db = __digits;
       size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
       unique_ptr<char, void(*)(void*)> __hn(0, free);
       unique_ptr<char_type, void(*)(void*)> __hd(0, free);
       // secure memory for digit storage
    if (__n > __bs-1)     {
           __n = static_cast<size_t>(__libcpp_asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, "%.0Lf", __units));
           if (__bb == 0)             __throw_bad_alloc();
           __hn.reset(__bb);
           __hd.reset((char_type*)malloc(__n * sizeof(char_type)));
           if (__hd == nullptr)             __throw_bad_alloc();
           __db = __hd.get();
       }
       // gather info
    locale __loc = __iob.getloc();
       const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
       __ct.widen(__bb, __bb + __n, __db);
       bool __neg = __n > 0 && __bb[0] == '-';
       money_base::pattern __pat;
       char_type __dp;
       char_type __ts;
       string __grp;
       string_type __sym;
       string_type __sn;
       int __fd;
       this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
       // secure memory for formatting
    char_type __mbuf[__bs];
       char_type* __mb = __mbuf;
       unique_ptr<char_type, void(*)(void*)> __hw(0, free);
       size_t __exn = static_cast<int>(__n) > __fd ?                    (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +                     __sym.size() + static_cast<size_t>(__fd) + 1                  : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
       if (__exn > __bs)     {
           __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
           __mb = __hw.get();
           if (__mb == 0)             __throw_bad_alloc();
       }
       // format
    char_type* __mi;
       char_type* __me;
       this->__format(__mb, __mi, __me, __iob.flags(),                    __db, __db + __n, __ct,                    __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
       return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
   }
    template <class _CharT, class _OutputIterator> _OutputIterator money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,                                            ios_base& __iob, char_type __fl,                                            const string_type& __digits) const {
       // gather info
    locale __loc = __iob.getloc();
       const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);
       bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
       money_base::pattern __pat;
       char_type __dp;
       char_type __ts;
       string __grp;
       string_type __sym;
       string_type __sn;
       int __fd;
       this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
       // secure memory for formatting
    char_type __mbuf[100];
       char_type* __mb = __mbuf;
       // format
    char_type* __mi;
       char_type* __me;
       this->__format(__mb, __mi, __me, __iob.flags(),                    __digits.data(), __digits.data() + __digits.size(), __ct,                    __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
       return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
   }
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS money_put<wchar_t>)  // messages
 class _LIBCPP_TYPE_VIS messages_base {
   public:     typedef ptrdiff_t catalog;
        _LIBCPP_ALWAYS_INLINE messages_base() {
  }
   };
    template <class _CharT> class _LIBCPP_TEMPLATE_VIS messages     : public locale::facet,       public messages_base {
   public:     typedef _CharT               char_type;
       typedef basic_string<_CharT> string_type;
        _LIBCPP_ALWAYS_INLINE     void close(catalog __c) const     {
           do_close(__c);
       }
        static locale::id id;
    protected:     _LIBCPP_ALWAYS_INLINE     ~messages() {
  }
        virtual catalog do_open(const basic_string<char>&, const locale&) const;
       virtual string_type do_get(catalog, int __set, int __msgid,                                const string_type& __dflt) const;
       virtual void do_close(catalog) const;
   };
    template <class _CharT> locale::id messages<_CharT>::id;
    template <class _CharT> typename messages<_CharT>::catalog messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const {
     
#ifdef _LIBCPP_HAS_CATOPEN
    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);
     
#endif // _LIBCPP_HAS_CATOPEN
}
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages<wchar_t>)  template <class _CharT> class _LIBCPP_TEMPLATE_VIS messages_byname     : public messages<_CharT> {
   public:     typedef messages_base::catalog catalog;
       typedef basic_string<_CharT> string_type;
        _LIBCPP_ALWAYS_INLINE     explicit messages_byname(const char*, size_t __refs = 0)         : messages<_CharT>(__refs) {
  }
        _LIBCPP_ALWAYS_INLINE     explicit messages_byname(const string&, size_t __refs = 0)         : messages<_CharT>(__refs) {
  }
    protected:     _LIBCPP_ALWAYS_INLINE     ~messages_byname() {
  }
   };
    _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<char>) _LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS messages_byname<wchar_t>)  template<class _Codecvt, class _Elem = wchar_t,          class _Wide_alloc = allocator<_Elem>,          class _Byte_alloc = allocator<char> > class _LIBCPP_TEMPLATE_VIS wstring_convert {
   public:     typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;
       typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
       typedef typename _Codecvt::state_type                        state_type;
       typedef typename wide_string::traits_type::int_type          int_type;
    private:     byte_string __byte_err_string_;
       wide_string __wide_err_string_;
       _Codecvt* __cvtptr_;
       state_type __cvtstate_;
       size_t __cvtcount_;
        wstring_convert(const wstring_convert& __wc);
       wstring_convert& operator=(const wstring_convert& __wc);
   public:     _LIBCPP_ALWAYS_INLINE     _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);
       _LIBCPP_ALWAYS_INLINE     wstring_convert(_Codecvt* __pcvt, state_type __state);
       _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,                     const wide_string& __wide_err = wide_string());
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_ALWAYS_INLINE     wstring_convert(wstring_convert&& __wc);
     
#endif
    ~wstring_convert();
        _LIBCPP_ALWAYS_INLINE     wide_string from_bytes(char __byte)         {
  return from_bytes(&__byte, &__byte+1);
  }
       _LIBCPP_ALWAYS_INLINE     wide_string from_bytes(const char* __ptr)         {
  return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));
  }
       _LIBCPP_ALWAYS_INLINE     wide_string from_bytes(const byte_string& __str)         {
  return from_bytes(__str.data(), __str.data() + __str.size());
  }
       wide_string from_bytes(const char* __first, const char* __last);
        _LIBCPP_ALWAYS_INLINE     byte_string to_bytes(_Elem __wchar)         {
  return to_bytes(&__wchar, &__wchar+1);
  }
       _LIBCPP_ALWAYS_INLINE     byte_string to_bytes(const _Elem* __wptr)         {
  return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));
  }
       _LIBCPP_ALWAYS_INLINE     byte_string to_bytes(const wide_string& __wstr)         {
  return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());
  }
       byte_string to_bytes(const _Elem* __first, const _Elem* __last);
        _LIBCPP_ALWAYS_INLINE     size_t converted() const _NOEXCEPT {
  return __cvtcount_;
  }
       _LIBCPP_ALWAYS_INLINE     state_type state() const {
  return __cvtstate_;
  }
   };
    template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> inline wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::     wstring_convert(_Codecvt* __pcvt)         : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0) {
   }
    template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::     from_bytes(const char* __frm, const char* __frm_end) {
       __cvtcount_ = 0;
       if (__cvtptr_ != nullptr)     {
           wide_string __ws(2*(__frm_end - __frm), _Elem());
           if (__frm != __frm_end)             __ws.resize(__ws.capacity());
           codecvt_base::result __r = codecvt_base::ok;
           state_type __st = __cvtstate_;
           if (__frm != __frm_end)         {
               _Elem* __to = &__ws[0];
               _Elem* __to_end = __to + __ws.size();
               const char* __frm_nxt;
               do             {
                   _Elem* __to_nxt;
                   __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,                                           __to, __to_end, __to_nxt);
                   __cvtcount_ += __frm_nxt - __frm;
                   if (__frm_nxt == __frm)                 {
                      __r = codecvt_base::error;
                  }
                   else if (__r == codecvt_base::noconv)                 {
                      __ws.resize(__to - &__ws[0]);
                      // This only gets executed if _Elem is char
                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
                      ptrdiff_t __s = __to_nxt - &__ws[0];
                      __ws.resize(2 * __s);
                      __to = &__ws[0] + __s;
                      __to_end = &__ws[0] + __ws.size();
                      __frm = __frm_nxt;
                  }
               }
   while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
           }
           if (__r == codecvt_base::ok)             return __ws;
       }
        if (__wide_err_string_.empty())         __throw_range_error("wstring_convert: from_bytes error");
        return __wide_err_string_;
   }
    template<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc> typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::     to_bytes(const _Elem* __frm, const _Elem* __frm_end) {
       __cvtcount_ = 0;
       if (__cvtptr_ != nullptr)     {
           byte_string __bs(2*(__frm_end - __frm), char());
           if (__frm != __frm_end)             __bs.resize(__bs.capacity());
           codecvt_base::result __r = codecvt_base::ok;
           state_type __st = __cvtstate_;
           if (__frm != __frm_end)         {
               char* __to = &__bs[0];
               char* __to_end = __to + __bs.size();
               const _Elem* __frm_nxt;
               do             {
                   char* __to_nxt;
                   __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,                                            __to, __to_end, __to_nxt);
                   __cvtcount_ += __frm_nxt - __frm;
                   if (__frm_nxt == __frm)                 {
                      __r = codecvt_base::error;
                      ptrdiff_t __sp = __to_nxt - &__bs[0];
                      __bs.resize(2 * __sp);
                      __to = &__bs[0] + __sp;
                      __to_end = &__bs[0] + __bs.size();
                  }
               }
   while (__r == codecvt_base::partial);
               if (__r == codecvt_base::ok)                 return __bs;
           }
       }
        if (__byte_err_string_.empty())         __throw_range_error("wstring_convert: to_bytes error");
        return __byte_err_string_;
   }
    template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> > class _LIBCPP_TEMPLATE_VIS wbuffer_convert     : public basic_streambuf<_Elem, _Tr> {
   public:     // types:
    typedef _Elem                          char_type;
       typedef _Tr                            traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef typename _Codecvt::state_type  state_type;
    private:     char*       __extbuf_;
       const char* __extbufnext_;
       const char* __extbufend_;
       char __extbuf_min_[8];
       size_t __ebs_;
       char_type* __intbuf_;
       size_t __ibs_;
       streambuf* __bufptr_;
       _Codecvt* __cv_;
       state_type __st_;
       ios_base::openmode __cm_;
       bool __owns_eb_;
       bool __owns_ib_;
       bool __always_noconv_;
        wbuffer_convert(const wbuffer_convert&);
       wbuffer_convert& operator=(const wbuffer_convert&);
   public:     _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0,              _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());
       ~wbuffer_convert();
        _LIBCPP_INLINE_VISIBILITY     streambuf* rdbuf() const {
  return __bufptr_;
  }
       _LIBCPP_INLINE_VISIBILITY     streambuf* rdbuf(streambuf* __bytebuf)     {
           streambuf* __r = __bufptr_;
           __bufptr_ = __bytebuf;
           return __r;
       }
        _LIBCPP_INLINE_VISIBILITY     state_type state() const {
  return __st_;
  }
    protected:     virtual int_type underflow();
       virtual int_type pbackfail(int_type __c = traits_type::eof());
       virtual int_type overflow (int_type __c = traits_type::eof());
       virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,                                                             streamsize __n);
       virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,                              ios_base::openmode __wch = ios_base::in | ios_base::out);
       virtual pos_type seekpos(pos_type __sp,                              ios_base::openmode __wch = ios_base::in | ios_base::out);
       virtual int sync();
    private:     bool __read_mode();
       void __write_mode();
       wbuffer_convert* __close();
   };
    template <class _Codecvt, class _Elem, class _Tr> wbuffer_convert<_Codecvt, _Elem, _Tr>::     wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)     : __extbuf_(0),       __extbufnext_(0),       __extbufend_(0),       __ebs_(0),       __intbuf_(0),       __ibs_(0),       __bufptr_(__bytebuf),       __cv_(__pcvt),       __st_(__state),       __cm_(0),       __owns_eb_(false),       __owns_ib_(false),       __always_noconv_(__cv_ ? __cv_->always_noconv() : false) {
       setbuf(0, 4096);
   }
    template <class _Codecvt, class _Elem, class _Tr> wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert() {
       __close();
       delete __cv_;
       if (__owns_eb_)         delete [] __extbuf_;
       if (__owns_ib_)         delete [] __intbuf_;
   }
    template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow() {
       if (__cv_ == 0 || __bufptr_ == 0)         return traits_type::eof();
       bool __initial = __read_mode();
       char_type __1buf;
       if (this->gptr() == 0)         this->setg(&__1buf, &__1buf+1, &__1buf+1);
       const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
       int_type __c = traits_type::eof();
       if (this->gptr() == this->egptr())     {
           memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
           if (__always_noconv_)         {
               streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
               __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
               if (__nmemb != 0)             {
                   this->setg(this->eback(),                            this->eback() + __unget_sz,                            this->eback() + __unget_sz + __nmemb);
                   __c = *this->gptr();
               }
           }
           else         {
                _LIBCPP_ASSERT(!(__extbufnext_ == NULL && (__extbufend_ != __extbufnext_)), "underflow moving from NULL" );
                if (__extbufend_ != __extbufnext_)                 memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
               __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
               __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
               streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),                                  static_cast<streamsize>(__extbufend_ - __extbufnext_));
               codecvt_base::result __r;
               // FIXME: Do we ever need to restore the state here?
            //state_type __svs = __st_;
            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
               if (__nr != 0)             {
                   __extbufend_ = __extbufnext_ + __nr;
                   char_type*  __inext;
                   __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,                                        this->eback() + __unget_sz,                                        this->egptr(), __inext);
                   if (__r == codecvt_base::noconv)                 {
                      this->setg((char_type*)__extbuf_, (char_type*)__extbuf_,                                 (char_type*) const_cast<char *>(__extbufend_));
                      __c = *this->gptr();
                  }
                   else if (__inext != this->eback() + __unget_sz)                 {
                      this->setg(this->eback(), this->eback() + __unget_sz, __inext);
                      __c = *this->gptr();
                  }
               }
           }
       }
       else         __c = *this->gptr();
       if (this->eback() == &__1buf)         this->setg(0, 0, 0);
       return __c;
   }
    template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c) {
       if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())     {
           if (traits_type::eq_int_type(__c, traits_type::eof()))         {
               this->gbump(-1);
               return traits_type::not_eof(__c);
           }
           if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))         {
               this->gbump(-1);
               *this->gptr() = traits_type::to_char_type(__c);
               return __c;
           }
       }
       return traits_type::eof();
   }
    template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c) {
       if (__cv_ == 0 || __bufptr_ == 0)         return traits_type::eof();
       __write_mode();
       char_type __1buf;
       char_type* __pb_save = this->pbase();
       char_type* __epb_save = this->epptr();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))     {
           if (this->pptr() == 0)             this->setp(&__1buf, &__1buf+1);
           else         {
               char* __extbe = __extbuf_;
               codecvt_base::result __r;
               do             {
                   const char_type* __e;
                   __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
                   if (__e == this->pbase())                     return traits_type::eof();
                   if (__r == codecvt_base::noconv)                 {
                      streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
                      if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)                         return traits_type::eof();
                  }
                   else if (__r == codecvt_base::ok || __r == codecvt_base::partial)                 {
                      streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
                      if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)                         return traits_type::eof();
                      if (__r == codecvt_base::partial)                     {
                          this->setp(const_cast<char_type *>(__e), this->pptr());
                          this->pbump(this->epptr() - this->pbase());
                      }
                  }
                   else                     return traits_type::eof();
               }
   while (__r == codecvt_base::partial);
           }
           this->setp(__pb_save, __epb_save);
       }
       return traits_type::not_eof(__c);
   }
    template <class _Codecvt, class _Elem, class _Tr> basic_streambuf<_Elem, _Tr>* wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n) {
       this->setg(0, 0, 0);
       this->setp(0, 0);
       if (__owns_eb_)         delete [] __extbuf_;
       if (__owns_ib_)         delete [] __intbuf_;
       __ebs_ = __n;
       if (__ebs_ > sizeof(__extbuf_min_))     {
           if (__always_noconv_ && __s)         {
               __extbuf_ = (char*)__s;
               __owns_eb_ = false;
           }
           __intbuf_ = 0;
           __owns_ib_ = false;
       }
       return this;
   }
    template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,                                         ios_base::openmode __om) {
       int __width = __cv_->encoding();
       if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())         return pos_type(off_type(-1));
       // __width > 0 || __off == 0, now check __way
    if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)         return pos_type(off_type(-1));
       pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
       __r.state(__st_);
       return __r;
   }
    template <class _Codecvt, class _Elem, class _Tr> typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch) {
       if (__cv_ == 0 || __bufptr_ == 0 || sync())         return pos_type(off_type(-1));
       if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))         return pos_type(off_type(-1));
       return __sp;
   }
    template <class _Codecvt, class _Elem, class _Tr> int wbuffer_convert<_Codecvt, _Elem, _Tr>::sync() {
       if (__cv_ == 0 || __bufptr_ == 0)         return 0;
       if (__cm_ & ios_base::out)     {
           if (this->pptr() != this->pbase())             if (overflow() == traits_type::eof())                 return -1;
           codecvt_base::result __r;
           do         {
               char* __extbe;
               __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
               streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
               if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)                 return -1;
           }
   while (__r == codecvt_base::partial);
           if (__r == codecvt_base::error)             return -1;
           if (__bufptr_->pubsync())             return -1;
       }
       else if (__cm_ & ios_base::in)     {
           off_type __c;
           if (__always_noconv_)             __c = this->egptr() - this->gptr();
           else         {
               int __width = __cv_->encoding();
               __c = __extbufend_ - __extbufnext_;
               if (__width > 0)                 __c += __width * (this->egptr() - this->gptr());
               else             {
                   if (this->gptr() != this->egptr())                 {
                      reverse(this->gptr(), this->egptr());
                      codecvt_base::result __r;
                      const char_type* __e = this->gptr();
                      char* __extbe;
                      do                     {
                          __r = __cv_->out(__st_, __e, this->egptr(), __e,                                          __extbuf_, __extbuf_ + __ebs_, __extbe);
                          switch (__r)                         {
                          case codecvt_base::noconv:                             __c += this->egptr() - this->gptr();
                              break;
                          case codecvt_base::ok:                         case codecvt_base::partial:                             __c += __extbe - __extbuf_;
                              break;
                          default:                             return -1;
                          }
                      }
  while (__r == codecvt_base::partial);
                  }
               }
           }
           if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))             return -1;
           this->setg(0, 0, 0);
           __cm_ = 0;
       }
       return 0;
   }
    template <class _Codecvt, class _Elem, class _Tr> bool wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode() {
   }
    template <class _Codecvt, class _Elem, class _Tr> void wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode() {
       if (!(__cm_ & ios_base::out))     {
           this->setg(0, 0, 0);
           if (__ebs_ > sizeof(__extbuf_min_))         {
               if (__always_noconv_)                 this->setp((char_type*)__extbuf_,                            (char_type*)__extbuf_ + (__ebs_ - 1));
               else                 this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
           }
           else             this->setp(0, 0);
           __cm_ = ios_base::out;
       }
   }
    template <class _Codecvt, class _Elem, class _Tr> wbuffer_convert<_Codecvt, _Elem, _Tr>* wbuffer_convert<_Codecvt, _Elem, _Tr>::__close() {
       wbuffer_convert* __rt = 0;
       if (__cv_ != 0 && __bufptr_ != 0)     {
           __rt = this;
           if ((__cm_ & ios_base::out) && sync())             __rt = 0;
       }
       return __rt;
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_LOCALE
  
#pragma clang module end /*std.locale*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <iterator>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.iterator
// -*- C++ -*-
//===-------------------------- iterator ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ITERATOR
  
#define _LIBCPP_ITERATOR
 /*     iterator synopsis  namespace std {
    template<class Iterator> struct iterator_traits {
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
       return !(__y < __x);
   }
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY auto operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG -> decltype(__x.base() - __y.base()) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),                    "Attempted to subtract incompatible iterators");
     
#endif
    return __x.base() - __y.base();
   }
     
#else
template <class _Iter1, class _Iter2> inline _LIBCPP_INLINE_VISIBILITY typename __wrap_iter<_Iter1>::difference_type operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG {
    template <class _Ep> constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept {
   return __il.begin();
   }
     
#endif
  _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_ITERATOR
  
#pragma clang module end /*std.iterator*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <bitset>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.bitset
// -*- C++ -*-
//===---------------------------- bitset ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_BITSET
  
#define _LIBCPP_BITSET
 /*     bitset synopsis  namespace std {
    template <size_t N> bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;
    template <class charT, class traits, size_t N> basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
    template <class charT, class traits, size_t N> basic_ostream<charT, traits>& operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
    template <size_t N> struct hash<std::bitset<N>>;
    }
    // std
 */
#pragma clang module begin std.__bit_reference
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP___BIT_REFERENCE
  
#define _LIBCPP___BIT_REFERENCE
   
#if 0 /* expanded by -frewrite-includes */
  
#include <algorithm>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.algorithm
// -*- C++ -*-
   
#ifndef _LIBCPP_ALGORITHM
  
#define _LIBCPP_ALGORITHM
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
   template <class _Cp> class __bit_const_reference;
    template <class _Tp> struct __has_storage_type {
       static const bool value = false;
   };
    template <class _Cp, bool = __has_storage_type<_Cp>::value> class __bit_reference {
       typedef typename _Cp::__storage_type    __storage_type;
       typedef typename _Cp::__storage_pointer __storage_pointer;
        __storage_pointer __seg_;
       __storage_type    __mask_;
        friend typename _Cp::__self;
        friend class __bit_const_reference<_Cp>;
       friend class __bit_iterator<_Cp, false>;
   public:     _LIBCPP_INLINE_VISIBILITY operator bool() const _NOEXCEPT         {
  return static_cast<bool>(*__seg_ & __mask_);
  return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));
  }
   private:     _LIBCPP_INLINE_VISIBILITY     __bit_reference(__storage_pointer __s, __storage_type __m) _NOEXCEPT         : __seg_(__s), __mask_(__m) {
  }
   };
    template <class _Cp> class __bit_reference<_Cp, false> {
   };
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY void swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) _NOEXCEPT {
       bool __t = __x;
       __x = __y;
       __y = __t;
   }
    template <class _Cp> class __bit_const_reference {
       typedef typename _Cp::__storage_type          __storage_type;
       typedef typename _Cp::__const_storage_pointer __storage_pointer;
        __storage_pointer        __seg_;
       __storage_type __mask_;
        friend typename _Cp::__self;
       friend class __bit_iterator<_Cp, true>;
   public:     _LIBCPP_INLINE_VISIBILITY     __bit_const_reference(const __bit_reference<_Cp>& __x) _NOEXCEPT         : __seg_(__x.__seg_), __mask_(__x.__mask_) {
  }
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR operator bool() const _NOEXCEPT         {
  return static_cast<bool>(*__seg_ & __mask_);
  }
        _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, true> operator&() const _NOEXCEPT         {
  return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));
  }
   private:     _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR     __bit_const_reference(__storage_pointer __s, __storage_type __m) _NOEXCEPT         : __seg_(__s), __mask_(__m) {
  }
        __bit_const_reference& operator=(const __bit_const_reference& __x);
   };
    // find
 template <class _Cp, bool _IsConst> __bit_iterator<_Cp, _IsConst> __find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n) {
       typedef __bit_iterator<_Cp, _IsConst> _It;
       typedef typename _It::__storage_type __storage_type;
       static const int __bits_per_word = _It::__bits_per_word;
       // do first partial word
    if (__first.__ctz_ != 0)     {
           __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
           __storage_type __dn = _VSTD::min(__clz_f, __n);
           __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
           __storage_type __b = *__first.__seg_ & __m;
           if (__b)             return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));
           if (__n == __dn)             return __first + __n;
           __n -= __dn;
           ++__first.__seg_;
       }
       // do middle whole words
    for (;
   __n >= __bits_per_word;
   ++__first.__seg_, __n -= __bits_per_word)         if (*__first.__seg_)             return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(*__first.__seg_)));
       // do last partial word
    if (__n > 0)     {
           __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
           __storage_type __b = *__first.__seg_ & __m;
           if (__b)             return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));
       }
       return _It(__first.__seg_, static_cast<unsigned>(__n));
   }
    template <class _Cp, bool _IsConst, class _Tp> inline _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, _IsConst> find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_) {
       if (static_cast<bool>(__value_))         return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
       return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
   }
    // count
 template <class _Cp, bool _IsConst> typename __bit_iterator<_Cp, _IsConst>::difference_type __count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n) {
       typedef __bit_iterator<_Cp, _IsConst> _It;
       typedef typename _It::__storage_type __storage_type;
       typedef typename _It::difference_type difference_type;
       const int __bits_per_word = _It::__bits_per_word;
       difference_type __r = 0;
       // do first partial word
    if (__first.__ctz_ != 0)     {
           __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
           __storage_type __dn = _VSTD::min(__clz_f, __n);
           __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
           __r = _VSTD::__pop_count(*__first.__seg_ & __m);
           __n -= __dn;
           ++__first.__seg_;
           __r += _VSTD::__pop_count(*__first.__seg_ & __m);
       }
       return __r;
   }
    template <class _Cp, bool _IsConst> typename __bit_iterator<_Cp, _IsConst>::difference_type __count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n) {
       typedef __bit_iterator<_Cp, _IsConst> _It;
       typedef typename _It::__storage_type __storage_type;
       typedef typename _It::difference_type difference_type;
       const int __bits_per_word = _It::__bits_per_word;
       difference_type __r = 0;
       // do first partial word
    if (__first.__ctz_ != 0)     {
           __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
           __storage_type __dn = _VSTD::min(__clz_f, __n);
           __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
           __r = _VSTD::__pop_count(~*__first.__seg_ & __m);
           __n -= __dn;
           ++__first.__seg_;
       }
       // do middle whole words
    for (;
   __n >= __bits_per_word;
   ++__first.__seg_, __n -= __bits_per_word)         __r += _VSTD::__pop_count(~*__first.__seg_);
       // do last partial word
    if (__n > 0)     {
           __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
           __r += _VSTD::__pop_count(~*__first.__seg_ & __m);
       }
       return __r;
   }
    template <class _Cp, bool _IsConst, class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename __bit_iterator<_Cp, _IsConst>::difference_type count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_) {
       if (static_cast<bool>(__value_))         return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
       return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
   }
    // fill_n
 template <class _Cp> void __fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n) {
       typedef __bit_iterator<_Cp, false> _It;
       typedef typename _It::__storage_type __storage_type;
       const int __bits_per_word = _It::__bits_per_word;
       // do first partial word
    if (__first.__ctz_ != 0)     {
           __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
           __storage_type __dn = _VSTD::min(__clz_f, __n);
           __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
           *__first.__seg_ &= ~__m;
           __n -= __dn;
           ++__first.__seg_;
       }
       // do middle whole words
    __storage_type __nw = __n / __bits_per_word;
       _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));
       __n -= __nw * __bits_per_word;
       // do last partial word
    if (__n > 0)     {
           __first.__seg_ += __nw;
           __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
           *__first.__seg_ &= ~__m;
       }
   }
    template <class _Cp> void __fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n) {
       typedef __bit_iterator<_Cp, false> _It;
       typedef typename _It::__storage_type __storage_type;
       const int __bits_per_word = _It::__bits_per_word;
       // do first partial word
    if (__first.__ctz_ != 0)     {
           __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
           __storage_type __dn = _VSTD::min(__clz_f, __n);
           __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
           *__first.__seg_ |= __m;
           __n -= __dn;
           ++__first.__seg_;
       }
       // do middle whole words
    __storage_type __nw = __n / __bits_per_word;
       _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));
       __n -= __nw * __bits_per_word;
       // do last partial word
    if (__n > 0)     {
           __first.__seg_ += __nw;
           __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
           *__first.__seg_ |= __m;
       }
   }
    template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY void fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_) {
       if (__n > 0)     {
           if (__value_)             __fill_n_true(__first, __n);
           else             __fill_n_false(__first, __n);
       }
   }
    // fill
 template <class _Cp> inline _LIBCPP_INLINE_VISIBILITY void fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_) {
       _VSTD::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
   }
    // copy
 template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,                                                      __bit_iterator<_Cp, false> __result) {
       typedef __bit_iterator<_Cp, _IsConst> _In;
       typedef  typename _In::difference_type difference_type;
       typedef typename _In::__storage_type __storage_type;
       const int __bits_per_word = _In::__bits_per_word;
       difference_type __n = __last - __first;
       if (__n > 0)     {
           // do first word
        if (__first.__ctz_ != 0)         {
               unsigned __clz = __bits_per_word - __first.__ctz_;
               difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);
               __n -= __dn;
        }
           // __first.__ctz_ == 0;
        // do middle words
        __storage_type __nw = __n / __bits_per_word;
           _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),                        _VSTD::__to_raw_pointer(__first.__seg_),                        __nw * sizeof(__storage_type));
           __n -= __nw * __bits_per_word;
           __result.__seg_ += __nw;
           // do last word
        if (__n > 0)         {
               __first.__seg_ += __nw;
               __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
               __storage_type __b = *__first.__seg_ & __m;
               *__result.__seg_ &= ~__m;
               *__result.__seg_ |= __b;
               __result.__ctz_ = static_cast<unsigned>(__n);
           }
       }
       return __result;
   }
    template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,                                                        __bit_iterator<_Cp, false> __result) {
       typedef __bit_iterator<_Cp, _IsConst> _In;
       typedef  typename _In::difference_type difference_type;
       typedef typename _In::__storage_type __storage_type;
       static const int __bits_per_word = _In::__bits_per_word;
       difference_type __n = __last - __first;
       if (__n > 0)     {
           // do first word
        if (__first.__ctz_ != 0)         {
               unsigned __clz_f = __bits_per_word - __first.__ctz_;
               difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);
               __n -= __dn;
               __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
               __storage_type __b = *__first.__seg_ & __m;
               unsigned __clz_r = __bits_per_word - __result.__ctz_;
               __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);
               __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
               *__result.__seg_ &= ~__m;
               if (__result.__ctz_ > __first.__ctz_)                 *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
               else                 *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
               __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
               *__result.__seg_ &= ~__m;
               *__result.__seg_ |= __b << __result.__ctz_;
               __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
               __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);
               __n -= __dn;
               if (__n > 0)             {
                  __m = ~__storage_type(0) >> (__bits_per_word - __n);
                  *__result.__seg_ &= ~__m;
                  *__result.__seg_ |= __b >> __dn;
                  __result.__ctz_ = static_cast<unsigned>(__n);
              }
           }
       }
       return __result;
   }
    template <class _Cp, bool _IsConst> inline _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, false> copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
       if (__first.__ctz_ == __result.__ctz_)         return __copy_aligned(__first, __last, __result);
       return __copy_unaligned(__first, __last, __result);
   }
    // copy_backward
 template <class _Cp, bool _IsConst> __bit_iterator<_Cp, false> __copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,                                                      __bit_iterator<_Cp, false> __result) {
       typedef __bit_iterator<_Cp, _IsConst> _In;
       typedef  typename _In::difference_type difference_type;
       typedef typename _In::__storage_type __storage_type;
       const int __bits_per_word = _In::__bits_per_word;
       difference_type __n = __last - __first;
       if (__n > 0)     {
           // do first word
        if (__last.__ctz_ != 0)         {
               difference_type __dn = _VSTD::min(static_cast<difference_type>(__last.__ctz_), __n);
               __n -= __dn;
               unsigned __clz = __bits_per_word - __last.__ctz_;
               __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
               __storage_type __b = *__last.__seg_ & __m;
               *__result.__seg_ &= ~__m;
               *__result.__seg_ |= __b;
               __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +                                                        __result.__ctz_)  % __bits_per_word);
               // __last.__ctz_ = 0
        }
           // __first.__ctz_ == 0;
        // do middle words
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
           unsigned __clz_r = __bits_per_word - __result.__ctz_;
           for (;
   __n >= __bits_per_word;
   __n -= __bits_per_word, ++__first.__seg_)         {
               __storage_type __b1 = *__first.__seg_;
               __storage_type __b2 = *__result.__seg_ & __m;
               *__result.__seg_ &= ~__m;
               *__result.__seg_ |= __b1 << __result.__ctz_;
               *__first.__seg_  = __b2 >> __result.__ctz_;
               ++__result.__seg_;
               __b2 = *__result.__seg_ & ~__m;
               *__result.__seg_ &= __m;
               *__result.__seg_ |= __b1 >> __clz_r;
               *__first.__seg_  |= __b2 << __clz_r;
           }
           // do last word
        if (__n > 0)         {
               __m = ~__storage_type(0) >> (__bits_per_word - __n);
               __storage_type __b1 = *__first.__seg_ & __m;
               *__first.__seg_ &= ~__m;
               __storage_type __dn = _VSTD::min<__storage_type>(__n, __clz_r);
               __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
               __storage_type __b2 = *__result.__seg_ & __m;
               *__result.__seg_ &= ~__m;
               *__result.__seg_ |= __b1 << __result.__ctz_;
               *__first.__seg_  |= __b2 >> __result.__ctz_;
               __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
               __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);
               __n -= __dn;
               if (__n > 0)             {
                  __m = ~__storage_type(0) >> (__bits_per_word - __n);
                  __b2 = *__result.__seg_ & __m;
                  *__result.__seg_ &= ~__m;
                  *__result.__seg_ |= __b1 >> __dn;
                  *__first.__seg_  |= __b2 << __dn;
                  __result.__ctz_ = static_cast<unsigned>(__n);
              }
           }
       }
       return __result;
   }
    template <class __C1, class __C2> inline _LIBCPP_INLINE_VISIBILITY __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,             __bit_iterator<__C2, false> __first2) {
       if (__first1.__ctz_ == __first2.__ctz_)         return __swap_ranges_aligned(__first1, __last1, __first2);
       return __swap_ranges_unaligned(__first1, __last1, __first2);
   }
    // rotate
 template <class _Cp> struct __bit_array {
       typedef typename _Cp::difference_type difference_type;
       typedef typename _Cp::__storage_type  __storage_type;
       typedef typename _Cp::__storage_pointer __storage_pointer;
       typedef typename _Cp::iterator        iterator;
       static const unsigned __bits_per_word = _Cp::__bits_per_word;
       static const unsigned _Np = 4;
        difference_type __size_;
       __storage_type __word_[_Np];
       _LIBCPP_INLINE_VISIBILITY iterator end()     {
           return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,                                                   static_cast<unsigned>(__size_ % __bits_per_word));
       }
   };
    template <class _Cp> __bit_iterator<_Cp, false> rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last) {
       typedef __bit_iterator<_Cp, false> _I1;
       typedef  typename _I1::difference_type difference_type;
       difference_type __d1 = __middle - __first;
       difference_type __d2 = __last - __middle;
       _I1 __r = __first + __d2;
       while (__d1 != 0 && __d2 != 0)     {
           if (__d1 <= __d2)         {
               if (__d1 <= __bit_array<_Cp>::capacity())             {
                  __bit_array<_Cp> __b(__d1);
                  _VSTD::copy(__first, __middle, __b.begin());
                  _VSTD::copy(__b.begin(), __b.end(), _VSTD::copy(__middle, __last, __first));
              }
               else             {
                  __bit_iterator<_Cp, false> __mp = __first + __d2;
                  _VSTD::swap_ranges(__first, __mp, __middle);
                  __first = __mp;
                  __d1 -= __d2;
              }
           }
       }
       return __r;
   }
    // equal
 template <class _Cp, bool _IC1, bool _IC2> bool __equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,                   __bit_iterator<_Cp, _IC2> __first2) {
       typedef __bit_iterator<_Cp, _IC1> _It;
       typedef  typename _It::difference_type difference_type;
       typedef typename _It::__storage_type __storage_type;
       static const int __bits_per_word = _It::__bits_per_word;
       difference_type __n = __last1 - __first1;
       if (__n > 0)     {
           // do first word
        if (__first1.__ctz_ != 0)         {
               unsigned __clz_f = __bits_per_word - __first1.__ctz_;
               difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);
               __n -= __dn;
               __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
               __storage_type __b = *__first1.__seg_ & __m;
               unsigned __clz_r = __bits_per_word - __first2.__ctz_;
               __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);
               __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
               if (__first2.__ctz_ > __first1.__ctz_)             {
                  if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))                     return false;
              }
               else             {
                  if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))                     return false;
              }
               __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
               __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_)  % __bits_per_word);
               __dn -= __ddn;
               if (__dn > 0)             {
                  __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                  if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))                     return false;
                  __first2.__ctz_ = static_cast<unsigned>(__dn);
              }
               ++__first1.__seg_;
               // __first1.__ctz_ = 0;
        }
           // __first1.__ctz_ == 0;
        // do middle words
        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
           __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
           for (;
   __n >= __bits_per_word;
   __n -= __bits_per_word, ++__first1.__seg_)         {
               __storage_type __b = *__first1.__seg_ & __m;
               __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__clz_r));
               __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
               if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))                 return false;
               __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
               __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_)  % __bits_per_word);
               __n -= __dn;
               if (__n > 0)             {
                  __m = ~__storage_type(0) >> (__bits_per_word - __n);
                  if ((*__first2.__seg_ & __m) != (__b >> __dn))                     return false;
              }
           }
       }
       return true;
   }
    template <class _Cp, bool _IC1, bool _IC2> bool __equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,                 __bit_iterator<_Cp, _IC2> __first2) {
   }
    template <class _Cp, bool _IC1, bool _IC2> inline _LIBCPP_INLINE_VISIBILITY bool equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) {
       if (__first1.__ctz_ == __first2.__ctz_)         return __equal_aligned(__first1, __last1, __first2);
       return __equal_unaligned(__first1, __last1, __first2);
   }
    template <class _Cp, bool _IsConst,           typename _Cp::__storage_type> class __bit_iterator {
   public:     typedef typename _Cp::difference_type                                                          difference_type;
       typedef bool                                                                                  value_type;
       typedef __bit_iterator                                                                        pointer;
       typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
       typedef random_access_iterator_tag                                                            iterator_category;
    private:     typedef typename _Cp::__storage_type                                           __storage_type;
       typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,                                            typename _Cp::__storage_pointer>::type  __storage_pointer;
       static const unsigned __bits_per_word = _Cp::__bits_per_word;
        __storage_pointer __seg_;
       unsigned          __ctz_;
    public:     _LIBCPP_INLINE_VISIBILITY __bit_iterator() _NOEXCEPT   
#if _LIBCPP_STD_VER > 11
    : __seg_(nullptr), __ctz_(0)   
#endif
    {
  }
        _LIBCPP_INLINE_VISIBILITY     __bit_iterator(const __bit_iterator<_Cp, false>& __it) _NOEXCEPT         : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {
  }
        _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT         {
  return reference(__seg_, __storage_type(1) << __ctz_);
  }
        _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator++()     {
           if (__ctz_ != __bits_per_word-1)             ++__ctz_;
           else         {
           }
           return *this;
       }
        _LIBCPP_INLINE_VISIBILITY __bit_iterator operator--(int)     {
           __bit_iterator __tmp = *this;
           --(*this);
           return __tmp;
       }
        _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator+=(difference_type __n)     {
           if (__n >= 0)             __seg_ += (__n + __ctz_) / __bits_per_word;
           else             __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)                     / static_cast<difference_type>(__bits_per_word);
           __n &= (__bits_per_word - 1);
           __ctz_ = static_cast<unsigned>((__n + __ctz_)  % __bits_per_word);
           return *this;
       }
        _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator-=(difference_type __n)     {
           return *this += -__n;
       }
        _LIBCPP_INLINE_VISIBILITY __bit_iterator operator+(difference_type __n) const     {
           __bit_iterator __t(*this);
           __t += __n;
           return __t;
       }
        _LIBCPP_INLINE_VISIBILITY friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)         {
  return __y < __x;
  }
        _LIBCPP_INLINE_VISIBILITY friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)         {
  return !(__y < __x);
  }
        _LIBCPP_INLINE_VISIBILITY friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)         {
  return !(__x < __y);
  }
    private:     _LIBCPP_INLINE_VISIBILITY     __bit_iterator(__storage_pointer __s, unsigned __ctz) _NOEXCEPT         : __seg_(__s), __ctz_(__ctz) {
  }
        friend typename _Cp::__self;
        friend class __bit_reference<_Cp>;
       friend class __bit_const_reference<_Cp>;
       friend class __bit_iterator<_Cp, true>;
       template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,                                                                           typename _Dp::size_type);
       template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,                                                                            typename _Dp::size_type);
       template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type                    __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
       template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type                    __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
   };
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP___BIT_REFERENCE
  
#pragma clang module end /*std.__bit_reference*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cstddef
// -*- C++ -*-
//===--------------------------- cstddef ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_STRING
  
 }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
}
       _LIBCPP_INLINE_VISIBILITY     const_iterator end() const _NOEXCEPT         {
  return const_iterator(__get_pointer() + size());
  }
     
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     reverse_iterator rbegin() _NOEXCEPT         {
  return reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rbegin() const _NOEXCEPT         {
#ifndef _LIBCPP_CXX03_LANG
    template <class ..._Args>     static _Ret __call(_Args&&... __args) {
           return __invoke(_VSTD::forward<_Args>(__args)...);
       }
     
#else
    template <class _Fn>     static _Ret __call(_Fn __f) {
        __user_alloc_construct_impl(               __uses_alloc_ctor<_Tp, _Allocator>(),               __storage, __a, _VSTD::forward<_Args>(__args)...         );
   }
     
#endif  // _LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_FUNCTIONAL_BASE
  
#pragma clang module end /*std.__functional_base*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template <size_t _N_words, size_t _Size> class __bitset;
    template <size_t _N_words, size_t _Size> struct __has_storage_type<__bitset<_N_words, _Size> > {
       static const bool value = true;
   };
    template <size_t _N_words, size_t _Size> class __bitset {
   public:     typedef ptrdiff_t              difference_type;
       typedef size_t                 size_type;
       typedef size_type              __storage_type;
   protected:     typedef __bitset __self;
       typedef       __storage_type*  __storage_pointer;
       typedef const __storage_type*  __const_storage_pointer;
       static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);
        friend class __bit_reference<__bitset>;
       friend class __bit_const_reference<__bitset>;
       friend class __bit_iterator<__bitset, false>;
       friend class __bit_iterator<__bitset, true>;
       friend struct __bit_array<__bitset>;
        __storage_type __first_[_N_words];
        typedef __bit_reference<__bitset>                  reference;
       typedef __bit_const_reference<__bitset>            const_reference;
       typedef __bit_iterator<__bitset, false>            iterator;
       typedef __bit_iterator<__bitset, true>             const_iterator;
        _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR __bitset() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     explicit _LIBCPP_CONSTEXPR __bitset(unsigned long long __v) _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY reference __make_ref(size_t __pos) _NOEXCEPT         {
  return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR const_reference __make_ref(size_t __pos) const _NOEXCEPT         {
  return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
       _LIBCPP_INLINE_VISIBILITY iterator __make_iter(size_t __pos) _NOEXCEPT         {
  return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }
       _LIBCPP_INLINE_VISIBILITY const_iterator __make_iter(size_t __pos) const _NOEXCEPT         {
  return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }
        _LIBCPP_INLINE_VISIBILITY     void operator&=(const __bitset& __v) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     void operator|=(const __bitset& __v) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     void operator^=(const __bitset& __v) _NOEXCEPT;
        void flip() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY unsigned long to_ulong() const         {
  return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * CHAR_BIT>());
  }
       _LIBCPP_INLINE_VISIBILITY unsigned long long to_ullong() const         {
  return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * CHAR_BIT>());
  }
        bool all() const _NOEXCEPT;
       bool any() const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     size_t __hash_code() const _NOEXCEPT;
   private:   
#ifdef _LIBCPP_CXX03_LANG
    void __init(unsigned long long __v, false_type) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     void __init(unsigned long long __v, true_type) _NOEXCEPT;
     
#endif  // _LIBCPP_CXX03_LANG
    unsigned long to_ulong(false_type) const;
       _LIBCPP_INLINE_VISIBILITY     unsigned long to_ulong(true_type) const;
       unsigned long long to_ullong(false_type) const;
       _LIBCPP_INLINE_VISIBILITY     unsigned long long to_ullong(true_type) const;
       _LIBCPP_INLINE_VISIBILITY     unsigned long long to_ullong(true_type, false_type) const;
       unsigned long long to_ullong(true_type, true_type) const;
   };
    template <size_t _N_words, size_t _Size> inline _LIBCPP_CONSTEXPR __bitset<_N_words, _Size>::__bitset() _NOEXCEPT   
#ifndef _LIBCPP_CXX03_LANG
    : __first_{
  0}
     
#endif
{
     
#ifdef _LIBCPP_CXX03_LANG
    _VSTD::fill_n(__first_, _N_words, __storage_type(0));
     
#endif
}
      
#ifdef _LIBCPP_CXX03_LANG
 template <size_t _N_words, size_t _Size> void __bitset<_N_words, _Size>::__init(unsigned long long __v, false_type) _NOEXCEPT {
       __storage_type __t[sizeof(unsigned long long) / sizeof(__storage_type)];
       for (size_t __i = 0;
   __i < sizeof(__t)/sizeof(__t[0]);
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <size_t _N_words, size_t _Size> inline _LIBCPP_CONSTEXPR __bitset<_N_words, _Size>::__bitset(unsigned long long __v) _NOEXCEPT   
#ifndef _LIBCPP_CXX03_LANG
  
#if __SIZEOF_SIZE_T__ == 8
    : __first_{
  __v}
     
#elif __SIZEOF_SIZE_T__ == 4
    : __first_{
  static_cast<__storage_type>(__v), static_cast<__storage_type>(__v >> __bits_per_word)}
     
#else
  
#error This constructor has not been ported to this platform
  
#endif
  
#endif
{
     
#ifdef _LIBCPP_CXX03_LANG
    __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(__storage_type)>());
     
#endif
}
    template <size_t _N_words, size_t _Size> inline void __bitset<_N_words, _Size>::operator&=(const __bitset& __v) _NOEXCEPT {
       for (size_type __i = 0;
   __i < _N_words;
   ++__i)         __first_[__i] &= __v.__first_[__i];
   }
    template <size_t _N_words, size_t _Size> inline void __bitset<_N_words, _Size>::operator|=(const __bitset& __v) _NOEXCEPT {
       for (size_type __i = 0;
   __i < _N_words;
   ++__i)         __first_[__i] |= __v.__first_[__i];
   }
    template <size_t _N_words, size_t _Size> inline void __bitset<_N_words, _Size>::operator^=(const __bitset& __v) _NOEXCEPT {
       for (size_type __i = 0;
   __i < _N_words;
   ++__i)         __first_[__i] ^= __v.__first_[__i];
   }
    template <size_t _N_words, size_t _Size> void __bitset<_N_words, _Size>::flip() _NOEXCEPT {
       // do middle whole words
    size_type __n = _Size;
       __storage_pointer __p = __first_;
       for (;
   __n >= __bits_per_word;
   ++__p, __n -= __bits_per_word)         *__p = ~*__p;
       // do last partial word
    if (__n > 0)     {
           __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
           __storage_type __b = *__p & __m;
           *__p &= ~__m;
           *__p |= ~__b & __m;
       }
   }
    template <size_t _N_words, size_t _Size> unsigned long __bitset<_N_words, _Size>::to_ulong(false_type) const {
       const_iterator __e = __make_iter(_Size);
       const_iterator __i = _VSTD::find(__make_iter(sizeof(unsigned long) * CHAR_BIT), __e, true);
       if (__i != __e)         __throw_overflow_error("bitset to_ulong overflow error");
       // do middle whole words
    size_type __n = _Size;
       __const_storage_pointer __p = __first_;
       for (;
   __n >= __bits_per_word;
   ++__p, __n -= __bits_per_word)         if (*__p)             return true;
       // do last partial word
    if (__n > 0)     {
           __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
           if (*__p & __m)             return true;
       }
       return false;
   }
    template <size_t _N_words, size_t _Size> inline size_t __bitset<_N_words, _Size>::__hash_code() const _NOEXCEPT {
       size_t __h = 0;
       for (size_type __i = 0;
   __i < _N_words;
   ++__i)         __h ^= __first_[__i];
       return __h;
   }
    template <size_t _Size> class __bitset<1, _Size> {
   public:     typedef ptrdiff_t              difference_type;
       typedef size_t                 size_type;
       typedef size_type              __storage_type;
   protected:     typedef __bitset __self;
       typedef       __storage_type*  __storage_pointer;
       typedef const __storage_type*  __const_storage_pointer;
       static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);
        friend class __bit_reference<__bitset>;
       friend class __bit_const_reference<__bitset>;
       friend class __bit_iterator<__bitset, false>;
       friend class __bit_iterator<__bitset, true>;
       friend struct __bit_array<__bitset>;
        __storage_type __first_;
        typedef __bit_reference<__bitset>                  reference;
       typedef __bit_const_reference<__bitset>            const_reference;
       typedef __bit_iterator<__bitset, false>            iterator;
       typedef __bit_iterator<__bitset, true>             const_iterator;
        _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR __bitset() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     explicit _LIBCPP_CONSTEXPR __bitset(unsigned long long __v) _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY reference __make_ref(size_t __pos) _NOEXCEPT         {
  return reference(&__first_, __storage_type(1) << __pos);
  }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR const_reference __make_ref(size_t __pos) const _NOEXCEPT         {
  return const_reference(&__first_, __storage_type(1) << __pos);
  }
       _LIBCPP_INLINE_VISIBILITY iterator __make_iter(size_t __pos) _NOEXCEPT         {
  return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }
       _LIBCPP_INLINE_VISIBILITY const_iterator __make_iter(size_t __pos) const _NOEXCEPT         {
  return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }
        _LIBCPP_INLINE_VISIBILITY     void operator&=(const __bitset& __v) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     void operator|=(const __bitset& __v) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     void operator^=(const __bitset& __v) _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     void flip() _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     unsigned long to_ulong() const;
       _LIBCPP_INLINE_VISIBILITY     unsigned long long to_ullong() const;
        _LIBCPP_INLINE_VISIBILITY     bool all() const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     bool any() const _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     size_t __hash_code() const _NOEXCEPT;
   };
    template <size_t _Size> inline _LIBCPP_CONSTEXPR __bitset<1, _Size>::__bitset() _NOEXCEPT     : __first_(0) {
   }
    template <size_t _Size> inline _LIBCPP_CONSTEXPR __bitset<1, _Size>::__bitset(unsigned long long __v) _NOEXCEPT     : __first_(static_cast<__storage_type>(__v)) {
   }
    template <size_t _Size> inline void __bitset<1, _Size>::operator&=(const __bitset& __v) _NOEXCEPT {
       __first_ &= __v.__first_;
       __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
       return __first_ & __m;
   }
    template <size_t _Size> inline size_t __bitset<1, _Size>::__hash_code() const _NOEXCEPT {
       return __first_;
   }
    template <> class __bitset<0, 0> {
   public:     typedef ptrdiff_t              difference_type;
       typedef size_t                 size_type;
       typedef size_type              __storage_type;
   protected:     typedef __bitset __self;
       typedef       __storage_type*  __storage_pointer;
       typedef const __storage_type*  __const_storage_pointer;
       static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);
        friend class __bit_reference<__bitset>;
       friend class __bit_const_reference<__bitset>;
       friend class __bit_iterator<__bitset, false>;
       friend class __bit_iterator<__bitset, true>;
       friend struct __bit_array<__bitset>;
        typedef __bit_reference<__bitset>                  reference;
       typedef __bit_const_reference<__bitset>            const_reference;
       typedef __bit_iterator<__bitset, false>            iterator;
       typedef __bit_iterator<__bitset, true>             const_iterator;
        _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR __bitset() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     explicit _LIBCPP_CONSTEXPR __bitset(unsigned long long) _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY reference __make_ref(size_t) _NOEXCEPT         {
  return reference(0, 1);
  }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR const_reference __make_ref(size_t) const _NOEXCEPT         {
  return const_reference(0, 1);
  }
       _LIBCPP_INLINE_VISIBILITY iterator __make_iter(size_t) _NOEXCEPT         {
  return iterator(0, 0);
  }
       _LIBCPP_INLINE_VISIBILITY const_iterator __make_iter(size_t) const _NOEXCEPT         {
  return const_iterator(0, 0);
  }
        _LIBCPP_INLINE_VISIBILITY void operator&=(const __bitset&) _NOEXCEPT {
  }
       _LIBCPP_INLINE_VISIBILITY bool any() const _NOEXCEPT {
  return false;
  }
        _LIBCPP_INLINE_VISIBILITY size_t __hash_code() const _NOEXCEPT {
  return 0;
  }
   };
    inline _LIBCPP_CONSTEXPR __bitset<0, 0>::__bitset() _NOEXCEPT {
   }
    inline _LIBCPP_CONSTEXPR __bitset<0, 0>::__bitset(unsigned long long) _NOEXCEPT {
   }
    template <size_t _Size> class _LIBCPP_TEMPLATE_VIS bitset;
   template <size_t _Size> struct hash<bitset<_Size> >;
    template <size_t _Size> class _LIBCPP_TEMPLATE_VIS bitset     : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * CHAR_BIT) + 1, _Size> {
   public:     static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * CHAR_BIT) + 1;
       typedef __bitset<__n_words, _Size> base;
    public:     typedef typename base::reference       reference;
       typedef typename base::const_reference const_reference;
        // 23.3.5.1 constructors:
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR bitset() _NOEXCEPT {
  }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR         bitset(unsigned long long __v) _NOEXCEPT : base(__v) {
  }
       template<class _CharT>         explicit bitset(const _CharT* __str,                         typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,                         _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
       template<class _CharT, class _Traits, class _Allocator>         explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,                         typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,                         typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =                                 (basic_string<_CharT,_Traits,_Allocator>::npos),                         _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
        // 23.3.5.2 bitset operations:
    _LIBCPP_INLINE_VISIBILITY     bitset& operator&=(const bitset& __rhs) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     bitset& operator|=(const bitset& __rhs) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     bitset& operator^=(const bitset& __rhs) _NOEXCEPT;
       bitset& operator<<=(size_t __pos) _NOEXCEPT;
       bitset& operator>>=(size_t __pos) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     bitset& set() _NOEXCEPT;
       bitset& set(size_t __pos, bool __val = true);
       _LIBCPP_INLINE_VISIBILITY     bitset& reset() _NOEXCEPT;
       bitset& reset(size_t __pos);
       _LIBCPP_INLINE_VISIBILITY     bitset  operator~() const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     bitset& flip() _NOEXCEPT;
       bitset& flip(size_t __pos);
   };
    template <size_t _Size> template<class _CharT> bitset<_Size>::bitset(const _CharT* __str,                       typename basic_string<_CharT>::size_type __n,                       _CharT __zero, _CharT __one) {
       size_t __rlen = _VSTD::min(__n, char_traits<_CharT>::length(__str));
       for (size_t __i = 0;
   __i < __rlen;
   ++__i)         if (__str[__i] != __zero && __str[__i] != __one)             __throw_invalid_argument("bitset string ctor has invalid argument");
        size_t _Mp = _VSTD::min(__rlen, _Size);
       size_t __i = 0;
       for (;
   __i < _Mp;
   ++__i)     {
           _CharT __c = __str[_Mp - 1 - __i];
           if (__c == __zero)             (*this)[__i] = false;
           else             (*this)[__i] = true;
       }
       _VSTD::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
   }
    template <size_t _Size> template<class _CharT, class _Traits, class _Allocator> bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,        _CharT __zero, _CharT __one) {
       if (__pos > __str.size())         __throw_out_of_range("bitset string pos out of range");
        size_t __rlen = _VSTD::min(__n, __str.size() - __pos);
       for (size_t __i = __pos;
   __i < __pos + __rlen;
   ++__i)         if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))             __throw_invalid_argument("bitset string ctor has invalid argument");
        size_t _Mp = _VSTD::min(__rlen, _Size);
       size_t __i = 0;
       for (;
   __i < _Mp;
   ++__i)     {
           _CharT __c = __str[__pos + _Mp - 1 - __i];
           if (_Traits::eq(__c, __zero))             (*this)[__i] = false;
           else             (*this)[__i] = true;
       }
       _VSTD::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
   }
    template <size_t _Size> inline bitset<_Size>& bitset<_Size>::operator&=(const bitset& __rhs) _NOEXCEPT {
       base::operator&=(__rhs);
       return *this;
   }
    template <size_t _Size> bitset<_Size>& bitset<_Size>::operator<<=(size_t __pos) _NOEXCEPT {
       __pos = _VSTD::min(__pos, _Size);
       _VSTD::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
       _VSTD::fill_n(base::__make_iter(0), __pos, false);
       return *this;
   }
    template <size_t _Size> bitset<_Size>& bitset<_Size>::operator>>=(size_t __pos) _NOEXCEPT {
   }
    template <size_t _Size> inline _LIBCPP_INLINE_VISIBILITY bitset<_Size> operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) _NOEXCEPT {
       bitset<_Size> __r = __x;
       __r ^= __y;
       return __r;
   }
    template <size_t _Size> struct _LIBCPP_TEMPLATE_VIS hash<bitset<_Size> >     : public unary_function<bitset<_Size>, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(const bitset<_Size>& __bs) const _NOEXCEPT         {
  return __bs.__hash_code();
  }
   };
    template <class _CharT, class _Traits, size_t _Size> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);
    template <class _CharT, class _Traits, size_t _Size> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_BITSET
  
#pragma clang module end /*std.bitset*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS basic_ostream     : virtual public basic_ios<_CharT, _Traits> {
   public:     // types (inherited from basic_ios (27.5.4)):
    typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
        // 27.7.2.2 Constructor/destructor:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb)     {
   this->init(__sb);
   }
       virtual ~basic_ostream();
   protected:   
#ifndef _LIBCPP_CXX03_LANG
    inline _LIBCPP_INLINE_VISIBILITY     basic_ostream(basic_ostream&& __rhs);
        // 27.7.2.3 Assign/swap
    inline _LIBCPP_INLINE_VISIBILITY     basic_ostream& operator=(basic_ostream&& __rhs);
     
     
#else
    basic_ostream           (const basic_ostream& __rhs);
   // not defined
    basic_ostream& operator=(const basic_ostream& __rhs);
   // not defined
  
#endif
public:      // 27.7.2.4 Prefix/suffix:
    class _LIBCPP_TEMPLATE_VIS sentry;
        // 27.7.2.6 Formatted output:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&))     {
   return __pf(*this);
   }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_ostream& operator<<(basic_ios<char_type, traits_type>&                               (*__pf)(basic_ios<char_type,traits_type>&))     {
   __pf(*this);
   return *this;
   }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_ostream& operator<<(ios_base& (*__pf)(ios_base&))     {
   __pf(*this);
   return *this;
   }
        basic_ostream& operator<<(bool __n);
       basic_ostream& operator<<(short __n);
       basic_ostream& operator<<(unsigned short __n);
       basic_ostream& operator<<(int __n);
       basic_ostream& operator<<(unsigned int __n);
       basic_ostream& operator<<(long __n);
       basic_ostream& operator<<(unsigned long __n);
       basic_ostream& operator<<(long long __n);
       basic_ostream& operator<<(unsigned long long __n);
       basic_ostream& operator<<(float __f);
       basic_ostream& operator<<(double __f);
       basic_ostream& operator<<(long double __f);
       basic_ostream& operator<<(const void* __p);
       basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);
        // 27.7.2.7 Unformatted output:
    basic_ostream& put(char_type __c);
       basic_ostream& write(const char_type* __s, streamsize __n);
       basic_ostream& flush();
        // 27.7.2.5 seeks:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     pos_type tellp();
       inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_ostream& seekp(pos_type __pos);
       inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);
    protected:     _LIBCPP_ALWAYS_INLINE     basic_ostream() {
  }
    // extension, intentially does not initialize
};
    template <class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS basic_ostream<_CharT, _Traits>::sentry {
       bool __ok_;
       basic_ostream<_CharT, _Traits>& __os_;
        sentry(const sentry&);
   // = delete;
    sentry& operator=(const sentry&);
   // = delete;
 public:     explicit sentry(basic_ostream<_CharT, _Traits>& __os);
       ~sentry();
        _LIBCPP_ALWAYS_INLINE         _LIBCPP_EXPLICIT         operator bool() const {
  return __ok_;
  }
   };
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)     : __ok_(false),       __os_(__os) {
       if (__os.good())     {
           if (__os.tie())             __os.tie()->flush();
           __ok_ = true;
       }
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>::sentry::~sentry() {
       if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)                       && !uncaught_exception())     {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            if (__os_.rdbuf()->pubsync() == -1)                 __os_.setstate(ios_base::badbit);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs) {
       this->move(__rhs);
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs) {
       swap(__rhs);
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>::~basic_ostream() {
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               if (__sb)             {   
#ifndef _LIBCPP_NO_EXCEPTIONS
                try                 {   
#endif  // _LIBCPP_NO_EXCEPTIONS
                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;                     typedef ostreambuf_iterator<_CharT, _Traits> _Op;                     _Ip __i(__sb);                     _Ip __eof;                     _Op __o(*this);                     size_t __c = 0;                     for (; __i != __eof; ++__i, ++__o, ++__c)                     {                         *__o = *__i;                         if (__o.failed())                             break;                     }                     if (__c == 0)                         this->setstate(ios_base::failbit);   
#ifndef _LIBCPP_NO_EXCEPTIONS
                }                 catch (...)                 {                     this->__set_failbit_and_consider_rethrow();                 }   
#endif  // _LIBCPP_NO_EXCEPTIONS
            }
               else                 this->setstate(ios_base::badbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(bool __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), __n).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(short __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(),                         __flags == ios_base::oct || __flags == ios_base::hex ?                         static_cast<long>(static_cast<unsigned short>(__n))  :                         static_cast<long>(__n)).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(int __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), __n).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), __n).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long long __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), __n).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), __n).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(float __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(double __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), __n).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long double __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(const void* __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
               const _Fp& __f = use_facet<_Fp>(this->getloc());
               if (__f.put(*this, *this, this->fill(), __n).failed())                 this->setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& __put_character_sequence(basic_ostream<_CharT, _Traits>& __os,                           const _CharT* __str, size_t __len) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
           if (__s)         {
               typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
               if (__pad_and_output(_Ip(__os),                                  __str,                                  (__os.flags() & ios_base::adjustfield) == ios_base::left ?                                      __str + __len :                                      __str,                                  __str + __len,                                  __os,                                  __os.fill()).failed())                 __os.setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           __os.__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __os;
   }
     template<class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c) {
       return _VSTD::__put_character_sequence(__os, &__c, 1);
       return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);
   }
    template<class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str) {
       return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));
   }
    template<class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
           if (__s)         {
               typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
               size_t __len = char_traits<char>::length(__strn);
               const int __bs = 100;
               _CharT __wbb[__bs];
               _CharT* __wb = __wbb;
               unique_ptr<_CharT, void(*)(void*)> __h(0, free);
               if (__len > __bs)             {                 __wb = (_CharT*)malloc(__len*sizeof(_CharT));                 if (__wb == 0)                     __throw_bad_alloc();                 __h.reset(__wb);             }
               for (_CharT* __p = __wb;
   *__strn != '\0';
   ++__strn, ++__p)                 *__p = __os.widen(*__strn);
               if (__pad_and_output(_Ip(__os),                                  __wb,                                  (__os.flags() & ios_base::adjustfield) == ios_base::left ?                                      __wb + __len :                                      __wb,                                  __wb + __len,                                  __os,                                  __os.fill()).failed())                 __os.setstate(ios_base::badbit | ios_base::failbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           __os.__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __os;
   }
    template<class _Traits> basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& __os, const char* __str) {
       return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::put(char_type __c) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef ostreambuf_iterator<_CharT, _Traits> _Op;
               _Op __o(*this);
               *__o = __c;
               if (__o.failed())                 this->setstate(ios_base::badbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this);
           if (__sen && __n)         {
               if (this->rdbuf()->sputn(__s, __n) != __n)                 this->setstate(ios_base::badbit);
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::flush() {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        if (this->rdbuf())         {
               sentry __s(*this);
               if (__s)             {                 if (this->rdbuf()->pubsync() == -1)                     this->setstate(ios_base::badbit);             }
           }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> typename basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp() {
       if (this->fail())         return pos_type(-1);
       return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::seekp(pos_type __pos) {
       sentry __s(*this);
       if (!this->fail())     {
           if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))             this->setstate(ios_base::failbit);
       }
       return *this;
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir) {
       sentry __s(*this);
       if (!this->fail())     {
           if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))             this->setstate(ios_base::failbit);
       }
       return *this;
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_ostream<_CharT, _Traits>& endl(basic_ostream<_CharT, _Traits>& __os) {
       __os.put(__os.widen('\n'));
       __os.flush();
       return __os;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Stream, class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     !is_lvalue_reference<_Stream>::value &&     is_base_of<ios_base, _Stream>::value,     _Stream&& >::type operator<<(_Stream&& __os, const _Tp& __x) {
       __os << __x;
       return _VSTD::move(__os);
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template<class _CharT, class _Traits, class _Allocator> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const basic_string<_CharT, _Traits, _Allocator>& __str) {
       return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());
   }
    template<class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const basic_string_view<_CharT, _Traits> __sv) {
       return _VSTD::__put_character_sequence(__os, __sv.data(), __sv.size());
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec) {
       return __os << __ec.category().name() << ':' << __ec.value();
   }
    template<class _CharT, class _Traits, class _Yp> inline _LIBCPP_INLINE_VISIBILITY basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p) {
       return __os << __p.get();
   }
    template <class _CharT, class _Traits, size_t _Size> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x) {
       return __os << __x.template to_string<_CharT, _Traits>                         (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),                          use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
   }
      
#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<char>) _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<wchar_t>)   
#endif
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_OSTREAM
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ISTREAM
  
#define _LIBCPP_ISTREAM
 /*     istream synopsis  template <class charT, class traits = char_traits<charT> > class basic_istream     : virtual public basic_ios<charT,traits> {
   public:     // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
       typedef traits                         traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.ostream
// -*- C++ -*-
//===-------------------------- ostream -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_OSTREAM
  
#define _LIBCPP_OSTREAM
 /*     ostream synopsis  template <class charT, class traits = char_traits<charT> > class basic_ostream     : virtual public basic_ios<charT,traits> {
   public:     // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
       typedef traits                         traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
#include <bitset>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS basic_ostream     : virtual public basic_ios<_CharT, _Traits> {
   public:     // types (inherited from basic_ios (27.5.4)):
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template <class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS basic_istream     : virtual public basic_ios<_CharT, _Traits> {
       streamsize __gc_;
   public:     // types (inherited from basic_ios (27.5.4)):
    typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
        // 27.7.1.1.1 Constructor/destructor:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb) : __gc_(0)     {
   this->init(__sb);
   }
       virtual ~basic_istream();
   protected:   
#ifndef _LIBCPP_CXX03_LANG
    inline _LIBCPP_INLINE_VISIBILITY     basic_istream(basic_istream&& __rhs);
        // 27.7.1.1.2 Assign/swap:
    inline _LIBCPP_INLINE_VISIBILITY     basic_istream& operator=(basic_istream&& __rhs);
     
#endif
     inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     void swap(basic_istream& __rhs) {
         _VSTD::swap(__gc_, __rhs.__gc_);
         basic_ios<char_type, traits_type>::swap(__rhs);
       }
      
#ifndef _LIBCPP_CXX03_LANG
    basic_istream           (const basic_istream& __rhs) = delete;
       basic_istream& operator=(const basic_istream& __rhs) = delete;
     
#endif
public:      // 27.7.1.1.3 Prefix/suffix:
    class _LIBCPP_TEMPLATE_VIS sentry;
        // 27.7.1.2 Formatted input:
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&))     {
   return __pf(*this);
   }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_istream& operator>>(basic_ios<char_type, traits_type>&                               (*__pf)(basic_ios<char_type, traits_type>&))     {
   __pf(*this);
   return *this;
   }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_istream& operator>>(ios_base& (*__pf)(ios_base&))     {
   __pf(*this);
   return *this;
   }
        basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
       basic_istream& operator>>(bool& __n);
       basic_istream& operator>>(short& __n);
       basic_istream& operator>>(unsigned short& __n);
       basic_istream& operator>>(int& __n);
       basic_istream& operator>>(unsigned int& __n);
       basic_istream& operator>>(long& __n);
       basic_istream& operator>>(unsigned long& __n);
       basic_istream& operator>>(long long& __n);
       basic_istream& operator>>(unsigned long long& __n);
       basic_istream& operator>>(float& __f);
       basic_istream& operator>>(double& __f);
       basic_istream& operator>>(long double& __f);
       basic_istream& operator>>(void*& __p);
        // 27.7.1.3 Unformatted input:
    _LIBCPP_INLINE_VISIBILITY     streamsize gcount() const {
  return __gc_;
  }
       int_type get();
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_istream& get(char_type& __c) {
         int_type __ch = get();
         if (__ch != traits_type::eof())         __c = traits_type::to_char_type(__ch);
         return *this;
       }
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_istream& get(char_type* __s, streamsize __n)     {
   return get(__s, __n, this->widen('\n'));
   }
        basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_istream& get(basic_streambuf<char_type, traits_type>& __sb)     {
   return get(__sb, this->widen('\n'));
   }
        basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);
        inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     basic_istream& getline(char_type* __s, streamsize __n)     {
   return getline(__s, __n, this->widen('\n'));
   }
        basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);
        basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
       int_type peek();
       basic_istream& read (char_type* __s, streamsize __n);
       streamsize readsome(char_type* __s, streamsize __n);
        basic_istream& putback(char_type __c);
       basic_istream& unget();
       int sync();
        pos_type tellg();
       basic_istream& seekg(pos_type __pos);
       basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
   };
    template <class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS basic_istream<_CharT, _Traits>::sentry {
       bool __ok_;
        sentry(const sentry&);
   // = delete;
    sentry& operator=(const sentry&);
   // = delete;
 public:     explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
   //    ~sentry() = default;
     _LIBCPP_INLINE_VISIBILITY         _LIBCPP_EXPLICIT         operator bool() const {
  return __ok_;
  }
   };
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,                                                bool __noskipws)     : __ok_(false) {
       if (__is.good())     {
           if (__is.tie())             __is.tie()->flush();
           if (!__noskipws && (__is.flags() & ios_base::skipws))         {              typedef istreambuf_iterator<_CharT, _Traits> _Ip;              const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());              _Ip __i(__is);              _Ip __eof;              for (;  __i != __eof;  ++__i)                 if (!__ct.is(__ct.space, *__i))                     break;              if (__i == __eof)                 __is.setstate(ios_base::failbit | ios_base::eofbit);          }
           __ok_ = __is.good();
       }
       else         __is.setstate(ios_base::failbit);
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)     : __gc_(__rhs.__gc_) {
       __rhs.__gc_ = 0;
       this->move(__rhs);
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs) {
       swap(__rhs);
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>::~basic_istream() {
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(long& __n) {
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(long long& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(float& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(double& __n) {
     
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(long double& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(bool& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(void*& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(short& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              long __temp;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);              if (__temp < numeric_limits<short>::min())             {                  __err |= ios_base::failbit;                  __n = numeric_limits<short>::min();              }              else if (__temp > numeric_limits<short>::max())             {                  __err |= ios_base::failbit;                  __n = numeric_limits<short>::max();              }              else                 __n = static_cast<short>(__temp);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(int& __n) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {              typedef istreambuf_iterator<char_type, traits_type> _Ip;              typedef num_get<char_type, _Ip> _Fp;              ios_base::iostate __err = ios_base::goodbit;              long __temp;              use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);              if (__temp < numeric_limits<int>::min())             {                  __err |= ios_base::failbit;                  __n = numeric_limits<int>::min();              }              else if (__temp > numeric_limits<int>::max())             {                  __err |= ios_base::failbit;                  __n = numeric_limits<int>::max();              }              else                 __n = static_cast<int>(__temp);              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s) {
     
   }
    template<class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s) {
       return __is >> (char*)__s;
   }
    template<class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& __is, signed char* __s) {
       return __is >> (char*)__s;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
           if (__sen)         {              typename _Traits::int_type __i = __is.rdbuf()->sbumpc();              if (_Traits::eq_int_type(__i, _Traits::eof()))                 __is.setstate(ios_base::eofbit | ios_base::failbit);              else                 __c = _Traits::to_char_type(__i);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           __is.__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __is;
   }
    template<class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c) {
       return __is >> (char&)__c;
   }
    template<class _Traits> inline _LIBCPP_INLINE_VISIBILITY basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& __is, signed char& __c) {
       return __is >> (char&)__c;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb) {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this, true);
           if (__s)         {              if (__sb)             {    
#ifndef _LIBCPP_NO_EXCEPTIONS
                try                 {    
#endif  // _LIBCPP_NO_EXCEPTIONS
                    ios_base::iostate __err = ios_base::goodbit;                      while (true)                     {                         typename traits_type::int_type __i = this->rdbuf()->sgetc();                         if (traits_type::eq_int_type(__i, _Traits::eof()))                         {                            __err |= ios_base::eofbit;                            break;                         }                         if (traits_type::eq_int_type(                                 __sb->sputc(traits_type::to_char_type(__i)),                                 traits_type::eof()))                             break;                         ++__gc_;                         this->rdbuf()->sbumpc();                     }                      if (__gc_ == 0)                        __err |= ios_base::failbit;                      this->setstate(__err);    
#ifndef _LIBCPP_NO_EXCEPTIONS
                }                  catch (...)                 {                      if (__gc_ == 0)                         this->__set_failbit_and_consider_rethrow();                  }    
#endif  // _LIBCPP_NO_EXCEPTIONS
            }              else                 this->setstate(ios_base::failbit);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get() {
       __gc_ = 0;
       int_type __r = traits_type::eof();
    return __r;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm) {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)         {              if (__n > 0)             {                  ios_base::iostate __err = ios_base::goodbit;                  while (__gc_ < __n-1)                 {                      int_type __i = this->rdbuf()->sgetc();                      if (traits_type::eq_int_type(__i, traits_type::eof()))                     {                        __err |= ios_base::eofbit;                        break;                     }                      char_type __ch = traits_type::to_char_type(__i);                      if (traits_type::eq(__ch, __dlm))                         break;                      *__s++ = __ch;                      ++__gc_;                       this->rdbuf()->sbumpc();                  }                  *__s = char_type();                  if (__gc_ == 0)                    __err |= ios_base::failbit;                  this->setstate(__err);              }              else                 this->setstate(ios_base::failbit);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,                                     char_type __dlm) {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)         {              ios_base::iostate __err = ios_base::goodbit;    
#ifndef _LIBCPP_NO_EXCEPTIONS
            try             {    
#endif  // _LIBCPP_NO_EXCEPTIONS
                while (true)                 {                      typename traits_type::int_type __i = this->rdbuf()->sgetc();                      if (traits_type::eq_int_type(__i, traits_type::eof()))                     {                        __err |= ios_base::eofbit;                        break;                     }                      char_type __ch = traits_type::to_char_type(__i);                      if (traits_type::eq(__ch, __dlm))                         break;                      if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))                         break;                      ++__gc_;                      this->rdbuf()->sbumpc();                  }    
#ifndef _LIBCPP_NO_EXCEPTIONS
            }              catch (...)             {              }    
#endif  // _LIBCPP_NO_EXCEPTIONS
            if (__gc_ == 0)                __err |= ios_base::failbit;              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm) {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)         {              ios_base::iostate __err = ios_base::goodbit;              while (true)             {                  typename traits_type::int_type __i = this->rdbuf()->sgetc();                  if (traits_type::eq_int_type(__i, traits_type::eof()))                 {                     __err |= ios_base::eofbit;                     break;                  }                  char_type __ch = traits_type::to_char_type(__i);                  if (traits_type::eq(__ch, __dlm))                 {                      this->rdbuf()->sbumpc();                      ++__gc_;                      break;                  }                  if (__gc_ >= __n-1)                 {                      __err |= ios_base::failbit;                      break;                  }                  *__s++ = __ch;                  this->rdbuf()->sbumpc();                  ++__gc_;              }              if (__n > 0)                 *__s = char_type();              if (__gc_ == 0)                __err |= ios_base::failbit;              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm) {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)         {              ios_base::iostate __err = ios_base::goodbit;              if (__n == numeric_limits<streamsize>::max())             {                  while (true)                 {                      typename traits_type::int_type __i = this->rdbuf()->sbumpc();                      if (traits_type::eq_int_type(__i, traits_type::eof()))                     {                        __err |= ios_base::eofbit;                        break;                     }                      ++__gc_;                      if (traits_type::eq_int_type(__i, __dlm))                         break;                  }              }              else             {                  while (__gc_ < __n)                 {                      typename traits_type::int_type __i = this->rdbuf()->sbumpc();                      if (traits_type::eq_int_type(__i, traits_type::eof()))                     {                        __err |= ios_base::eofbit;                        break;                     }                      ++__gc_;                      if (traits_type::eq_int_type(__i, __dlm))                         break;                  }              }              this->setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek() {
       __gc_ = 0;
       int_type __r = traits_type::eof();
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)         {              __r = this->rdbuf()->sgetc();              if (traits_type::eq_int_type(__r, traits_type::eof()))                 this->setstate(ios_base::eofbit);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __r;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n) {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)         {              __gc_ = this->rdbuf()->sgetn(__s, __n);              if (__gc_ != __n)                 this->setstate(ios_base::failbit | ios_base::eofbit);          }
           else             this->setstate(ios_base::failbit);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> streamsize basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n) {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)         {              streamsize __c = this->rdbuf()->in_avail();              switch (__c)             {              case -1:                 this->setstate(ios_base::eofbit);                  break;              case 0:                 break;              default:                 read(__s, _VSTD::min(__c, __n));                  break;              }          }
           else             this->setstate(ios_base::failbit);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __gc_;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::putback(char_type __c) {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        this->clear(this->rdstate() & ~ios_base::eofbit);
           sentry __sen(*this, true);
           if (__sen)         {              if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())                 this->setstate(ios_base::badbit);          }
           else             this->setstate(ios_base::failbit);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::unget() {
       __gc_ = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        this->clear(this->rdstate() & ~ios_base::eofbit);
           sentry __sen(*this, true);
           if (__sen)         {              if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())                 this->setstate(ios_base::badbit);          }
           else             this->setstate(ios_base::failbit);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> int basic_istream<_CharT, _Traits>::sync() {
       int __r = 0;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)         {              if (this->rdbuf() == 0)                 return -1;              if (this->rdbuf()->pubsync() == -1)             {                  this->setstate(ios_base::badbit);                  return -1;              }          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __r;
   }
    template<class _CharT, class _Traits> typename basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg() {
       pos_type __r(-1);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __sen(*this, true);
           if (__sen)             __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __r;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template<class _CharT, class _Traits> basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        this->clear(this->rdstate() & ~ios_base::eofbit);
           sentry __sen(*this, true);
           if (__sen)         {              if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))                 this->setstate(ios_base::failbit);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           this->__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return *this;
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& ws(basic_istream<_CharT, _Traits>& __is) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
           if (__sen)         {              const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());              while (true)             {                  typename _Traits::int_type __i = __is.rdbuf()->sgetc();                  if (_Traits::eq_int_type(__i, _Traits::eof()))                 {                     __is.setstate(ios_base::eofbit);                     break;                  }                  if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))                     break;                  __is.rdbuf()->sbumpc();              }          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           __is.__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __is;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Tp> inline _LIBCPP_INLINE_VISIBILITY basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp&& __x) {
       __is >> _VSTD::forward<_Tp>(__x);
       return __is;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits> class _LIBCPP_TEMPLATE_VIS basic_iostream     : public basic_istream<_CharT, _Traits>,       public basic_ostream<_CharT, _Traits> {
   public:     // types:
    typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
        // constructor/destructor
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)       : basic_istream<_CharT, _Traits>(__sb)     {
  }
        virtual ~basic_iostream();
   protected:   
#ifndef _LIBCPP_CXX03_LANG
    inline _LIBCPP_INLINE_VISIBILITY     basic_iostream(basic_iostream&& __rhs);
        // assign/swap
    inline _LIBCPP_INLINE_VISIBILITY     basic_iostream& operator=(basic_iostream&& __rhs);
     
#endif
    inline _LIBCPP_EXTERN_TEMPLATE_INLINE_VISIBILITY     void swap(basic_iostream& __rhs)     {
   basic_istream<char_type, traits_type>::swap(__rhs);
   }
   public: };
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits> basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)     : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)) {
   }
    template <class _CharT, class _Traits> basic_iostream<_CharT, _Traits>& basic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs) {
       swap(__rhs);
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits> basic_iostream<_CharT, _Traits>::~basic_iostream() {
   }
    template<class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            basic_string<_CharT, _Traits, _Allocator>& __str) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
           if (__sen)         {              __str.clear();              streamsize __n = __is.width();              if (__n <= 0)                 __n = __str.max_size();              if (__n <= 0)                 __n = numeric_limits<streamsize>::max();              streamsize __c = 0;              const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());              ios_base::iostate __err = ios_base::goodbit;              while (__c < __n)             {                  typename _Traits::int_type __i = __is.rdbuf()->sgetc();                  if (_Traits::eq_int_type(__i, _Traits::eof()))                 {                     __err |= ios_base::eofbit;                     break;                  }                  _CharT __ch = _Traits::to_char_type(__i);                  if (__ct.is(__ct.space, __ch))                     break;                  __str.push_back(__ch);                  ++__c;                   __is.rdbuf()->sbumpc();              }              __is.width(0);              if (__c == 0)                __err |= ios_base::failbit;              __is.setstate(__err);          }
           else             __is.setstate(ios_base::failbit);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           __is.__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __is;
   }
    template<class _CharT, class _Traits, class _Allocator> basic_istream<_CharT, _Traits>& getline(basic_istream<_CharT, _Traits>& __is,         basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
           if (__sen)         {              __str.clear();              ios_base::iostate __err = ios_base::goodbit;              streamsize __extr = 0;              while (true)             {                  typename _Traits::int_type __i = __is.rdbuf()->sbumpc();                  if (_Traits::eq_int_type(__i, _Traits::eof()))                 {                     __err |= ios_base::eofbit;                     break;                  }                  ++__extr;                  _CharT __ch = _Traits::to_char_type(__i);                  if (_Traits::eq(__ch, __dlm))                     break;                  __str.push_back(__ch);                  if (__str.size() == __str.max_size())                 {                      __err |= ios_base::failbit;                      break;                  }              }              if (__extr == 0)                __err |= ios_base::failbit;              __is.setstate(__err);          }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           __is.__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __is;
   }
    template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_istream<_CharT, _Traits>& getline(basic_istream<_CharT, _Traits>& __is,         basic_string<_CharT, _Traits, _Allocator>& __str) {
       return getline(__is, __str, __is.widen('\n'));
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_istream<_CharT, _Traits>& getline(basic_istream<_CharT, _Traits>&& __is,         basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm) {
       return getline(__is, __str, __dlm);
   }
    template<class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY basic_istream<_CharT, _Traits>& getline(basic_istream<_CharT, _Traits>&& __is,         basic_string<_CharT, _Traits, _Allocator>& __str) {
       return getline(__is, __str, __is.widen('\n'));
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, size_t _Size> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
           if (__sen)         {              basic_string<_CharT, _Traits> __str;              const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());              size_t __c = 0;              ios_base::iostate __err = ios_base::goodbit;              _CharT __zero = __ct.widen('0');              _CharT __one = __ct.widen('1');              while (__c < _Size)             {                  typename _Traits::int_type __i = __is.rdbuf()->sgetc();                  if (_Traits::eq_int_type(__i, _Traits::eof()))                 {                     __err |= ios_base::eofbit;                     break;                  }                  _CharT __ch = _Traits::to_char_type(__i);                  if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))                     break;                  __str.push_back(__ch);                  ++__c;                   __is.rdbuf()->sbumpc();              }              __x = bitset<_Size>(__str);              if (__c == 0)                __err |= ios_base::failbit;              __is.setstate(__err);          }
           else             __is.setstate(ios_base::failbit);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    }
       catch (...)     {
           __is.__set_badbit_and_consider_rethrow();
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __is;
   }
      
#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<char>) _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_istream<wchar_t>) _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_iostream<char>)   
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_ISTREAM
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_STRING
  
#define _LIBCPP_STRING
 /*     string synopsis  namespace std {
    template <class stateT> class fpos {
   private:     stateT st;
   public:     fpos(streamoff = streamoff());
        operator streamoff() const;
        stateT state() const;
       void state(stateT);
  
#endif /* expanded by -frewrite-includes */
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  // basic_stringbuf
 template <class _CharT, class _Traits, class _Allocator> class _LIBCPP_TEMPLATE_VIS basic_stringbuf     : public basic_streambuf<_CharT, _Traits> {
   public:     typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef _Allocator                     allocator_type;
        typedef basic_string<char_type, traits_type, allocator_type> string_type;
    private:      string_type __str_;
       mutable char_type* __hm_;
       ios_base::openmode __mode_;
    public:     // 27.8.1.1 Constructors:
    inline _LIBCPP_INLINE_VISIBILITY     explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);
       inline _LIBCPP_INLINE_VISIBILITY     explicit basic_stringbuf(const string_type& __s,                              ios_base::openmode __wch = ios_base::in | ios_base::out);
     
#ifndef _LIBCPP_CXX03_LANG
    basic_stringbuf(basic_stringbuf&& __rhs);
        // 27.8.1.2 Assign and swap:
    basic_stringbuf& operator=(basic_stringbuf&& __rhs);
     
#endif
    void swap(basic_stringbuf& __rhs);
        // 27.8.1.3 Get and set:
    string_type str() const;
       void str(const string_type& __s);
    protected:     // 27.8.1.4 Overridden virtual functions:
    virtual int_type underflow();
       virtual int_type pbackfail(int_type __c = traits_type::eof());
       virtual int_type overflow (int_type __c = traits_type::eof());
       virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,                              ios_base::openmode __wch = ios_base::in | ios_base::out);
       inline _LIBCPP_INLINE_VISIBILITY     virtual pos_type seekpos(pos_type __sp,                              ios_base::openmode __wch = ios_base::in | ios_base::out);
   };
    template <class _CharT, class _Traits, class _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)     : __hm_(0),       __mode_(__wch) {
       str(string_type());
   }
    template <class _CharT, class _Traits, class _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,                              ios_base::openmode __wch)     : __str_(__s.get_allocator()),       __hm_(0),       __mode_(__wch) {
       str(__s);
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)     : __mode_(__rhs.__mode_) {
       char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
       ptrdiff_t __binp = -1;
       ptrdiff_t __ninp = -1;
       ptrdiff_t __einp = -1;
       if (__rhs.eback() != nullptr)     {          __binp = __rhs.eback() - __p;          __ninp = __rhs.gptr() - __p;          __einp = __rhs.egptr() - __p;      }
       ptrdiff_t __bout = -1;
       ptrdiff_t __nout = -1;
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> void basic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs) {
       char_type* __p = const_cast<char_type*>(__rhs.__str_.data());
       ptrdiff_t __rbinp = -1;
       ptrdiff_t __rninp = -1;
   }
    template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type basic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c) {
       if (__hm_ < this->pptr())         __hm_ = this->pptr();
       if (this->eback() < this->gptr())     {          if (traits_type::eq_int_type(__c, traits_type::eof()))         {              this->setg(this->eback(), this->gptr()-1, __hm_);              return traits_type::not_eof(__c);          }          if ((__mode_ & ios_base::out) ||             traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))         {              this->setg(this->eback(), this->gptr()-1, __hm_);              *this->gptr() = traits_type::to_char_type(__c);              return __c;          }      }
       return traits_type::eof();
   }
    template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type basic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c) {
       if (!traits_type::eq_int_type(__c, traits_type::eof()))     {          ptrdiff_t __ninp = this->gptr()  - this->eback();          if (this->pptr() == this->epptr())         {              if (!(__mode_ & ios_base::out))                 return traits_type::eof();    
        }          __hm_ = _VSTD::max(this->pptr() + 1, __hm_);          if (__mode_ & ios_base::in)         {              char_type* __p = const_cast<char_type*>(__str_.data());              this->setg(__p, __p + __ninp, __hm_);          }          return this->sputc(__c);      }
       return traits_type::not_eof(__c);
   }
    template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type basic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,                                                       ios_base::seekdir __way,                                                       ios_base::openmode __wch) {
       if (__hm_ < this->pptr())         __hm_ = this->pptr();
       if ((__wch & (ios_base::in | ios_base::out)) == 0)         return pos_type(-1);
       if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)         && __way == ios_base::cur)         return pos_type(-1);
       off_type __noff;
   }
    template <class _CharT, class _Traits, class _Allocator> typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type basic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,                                                       ios_base::openmode __wch) {
       return seekoff(__sp, ios_base::beg, __wch);
   }
    // basic_istringstream
 template <class _CharT, class _Traits, class _Allocator> class _LIBCPP_TEMPLATE_VIS basic_istringstream     : public basic_istream<_CharT, _Traits> {
   public:     typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef _Allocator                     allocator_type;
        typedef basic_string<char_type, traits_type, allocator_type> string_type;
    private:     basic_stringbuf<char_type, traits_type, allocator_type> __sb_;
    public:     // 27.8.2.1 Constructors:
    inline _LIBCPP_INLINE_VISIBILITY     explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);
       inline _LIBCPP_INLINE_VISIBILITY     explicit basic_istringstream(const string_type& __s,                                  ios_base::openmode __wch = ios_base::in);
     
#ifndef _LIBCPP_CXX03_LANG
    inline _LIBCPP_INLINE_VISIBILITY     basic_istringstream(basic_istringstream&& __rhs);
        // 27.8.2.2 Assign and swap:
    basic_istringstream& operator=(basic_istringstream&& __rhs);
     
#endif  // _LIBCPP_CXX03_LANG
    inline _LIBCPP_INLINE_VISIBILITY     void swap(basic_istringstream& __rhs);
        // 27.8.2.3 Members:
    inline _LIBCPP_INLINE_VISIBILITY     basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
       inline _LIBCPP_INLINE_VISIBILITY     string_type str() const;
       inline _LIBCPP_INLINE_VISIBILITY     void str(const string_type& __s);
   };
    template <class _CharT, class _Traits, class _Allocator> basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)     : basic_istream<_CharT, _Traits>(&__sb_),       __sb_(__wch | ios_base::in) {
   }
    template <class _CharT, class _Traits, class _Allocator> basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,                                                                       ios_base::openmode __wch)     : basic_istream<_CharT, _Traits>(&__sb_),       __sb_(__s, __wch | ios_base::in) {
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)     : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)),       __sb_(_VSTD::move(__rhs.__sb_)) {
       basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
   }
    template <class _CharT, class _Traits, class _Allocator> basic_istringstream<_CharT, _Traits, _Allocator>& basic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs) {
       basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));
       __sb_ = _VSTD::move(__rhs.__sb_);
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> void basic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs) {
       basic_istream<char_type, traits_type>::swap(__rhs);
       __sb_.swap(__rhs.__sb_);
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,      basic_istringstream<_CharT, _Traits, _Allocator>& __y) {
       __x.swap(__y);
   }
    template <class _CharT, class _Traits, class _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator>* basic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const {
   }
    // basic_ostringstream
 template <class _CharT, class _Traits, class _Allocator> class _LIBCPP_TEMPLATE_VIS basic_ostringstream     : public basic_ostream<_CharT, _Traits> {
   public:     typedef _CharT                         char_type;
       typedef _Traits                        traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef _Allocator                     allocator_type;
        typedef basic_string<char_type, traits_type, allocator_type> string_type;
    private:     basic_stringbuf<char_type, traits_type, allocator_type> __sb_;
    public:     // 27.8.2.1 Constructors:
    inline _LIBCPP_INLINE_VISIBILITY     explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);
       inline _LIBCPP_INLINE_VISIBILITY     explicit basic_ostringstream(const string_type& __s,                                  ios_base::openmode __wch = ios_base::out);
     
#ifndef _LIBCPP_CXX03_LANG
    inline _LIBCPP_INLINE_VISIBILITY     basic_ostringstream(basic_ostringstream&& __rhs);
        // 27.8.2.2 Assign and swap:
    basic_ostringstream& operator=(basic_ostringstream&& __rhs);
     
#endif  // _LIBCPP_CXX03_LANG
    inline _LIBCPP_INLINE_VISIBILITY     void swap(basic_ostringstream& __rhs);
        // 27.8.2.3 Members:
    inline _LIBCPP_INLINE_VISIBILITY     basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;
       inline _LIBCPP_INLINE_VISIBILITY     string_type str() const;
       inline _LIBCPP_INLINE_VISIBILITY     void str(const string_type& __s);
   };
    template <class _CharT, class _Traits, class _Allocator> basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)     : basic_ostream<_CharT, _Traits>(&__sb_),       __sb_(__wch | ios_base::out) {
   }
    template <class _CharT, class _Traits, class _Allocator> basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,                                                                       ios_base::openmode __wch)     : basic_ostream<_CharT, _Traits>(&__sb_),       __sb_(__s, __wch | ios_base::out) {
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)     : basic_ostream<_CharT, _Traits>(_VSTD::move(__rhs)),       __sb_(_VSTD::move(__rhs.__sb_)) {
       basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);
   }
    template <class _CharT, class _Traits, class _Allocator> basic_ostringstream<_CharT, _Traits, _Allocator>& basic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs) {
       basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));
       __sb_ = _VSTD::move(__rhs.__sb_);
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _CharT, class _Traits, class _Allocator> void basic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs) {
       basic_ostream<char_type, traits_type>::swap(__rhs);
       __sb_.swap(__rhs.__sb_);
   }
    template <class _CharT, class _Traits, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,      basic_ostringstream<_CharT, _Traits, _Allocator>& __y) {
       __x.swap(__y);
   }
    template <class _CharT, class _Traits, class _Allocator> basic_stringbuf<_CharT, _Traits, _Allocator>* basic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const {
       return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);
   }
    template <class _CharT, class _Traits, class _Allocator> basic_string<_CharT, _Traits, _Allocator> basic_ostringstream<_CharT, _Traits, _Allocator>::str() const {
       return __sb_.str();
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_SSTREAM
  
#pragma clang module end /*std.sstream*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template<class _Tp> class _LIBCPP_TEMPLATE_VIS complex;
    template<class _Tp> complex<_Tp> operator*(const complex<_Tp>& __z, const complex<_Tp>& __w);
   template<class _Tp> complex<_Tp> operator/(const complex<_Tp>& __x, const complex<_Tp>& __y);
    template<class _Tp> class _LIBCPP_TEMPLATE_VIS complex {
   public:     typedef _Tp value_type;
   private:     value_type __re_;
       value_type __im_;
   public:     _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     complex(const value_type& __re = value_type(), const value_type& __im = value_type())         : __re_(__re), __im_(__im) { }
   };
    template<> class _LIBCPP_TEMPLATE_VIS complex<double>;
   template<> class _LIBCPP_TEMPLATE_VIS complex<long double>;
    template<> class _LIBCPP_TEMPLATE_VIS complex<float> {
       float __re_;
       float __im_;
   public:     typedef float value_type;
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR complex(float __re = 0.0f, float __im = 0.0f)         : __re_(__re), __im_(__im) { }
       _LIBCPP_INLINE_VISIBILITY     explicit _LIBCPP_CONSTEXPR complex(const complex<double>& __c);
       _LIBCPP_INLINE_VISIBILITY     explicit _LIBCPP_CONSTEXPR complex(const complex<long double>& __c);
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR float real() const { return __re_; }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR float imag() const { return __im_; }
        _LIBCPP_INLINE_VISIBILITY void real(value_type __re) { __re_ = __re; }
       _LIBCPP_INLINE_VISIBILITY void imag(value_type __im) { __im_ = __im; }
        _LIBCPP_INLINE_VISIBILITY complex& operator= (float __re)         { __re_ = __re;  __im_ = value_type();  return *this; }
       template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator/=(const complex<_Xp>& __c)         {              *this = *this / complex(__c.real(), __c.imag());              return *this;          }
   };
    template<> class _LIBCPP_TEMPLATE_VIS complex<double> {
       double __re_;
       double __im_;
   public:     typedef double value_type;
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR complex(double __re = 0.0, double __im = 0.0)         : __re_(__re), __im_(__im) { }
       _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR complex(const complex<float>& __c);
       _LIBCPP_INLINE_VISIBILITY     explicit _LIBCPP_CONSTEXPR complex(const complex<long double>& __c);
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR double real() const { return __re_; }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR double imag() const { return __im_; }
        _LIBCPP_INLINE_VISIBILITY void real(value_type __re) { __re_ = __re; }
       _LIBCPP_INLINE_VISIBILITY void imag(value_type __im) { __im_ = __im; }
        _LIBCPP_INLINE_VISIBILITY complex& operator= (double __re)         { __re_ = __re;  __im_ = value_type();  return *this; }
       _LIBCPP_INLINE_VISIBILITY complex& operator+=(double __re) { __re_ += __re;  return *this; }
   };
    template<> class _LIBCPP_TEMPLATE_VIS complex<long double> {
       long double __re_;
       long double __im_;
   public:     typedef long double value_type;
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR complex(long double __re = 0.0L, long double __im = 0.0L)         : __re_(__re), __im_(__im) { }
       _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR complex(const complex<float>& __c);
       _LIBCPP_INLINE_VISIBILITY     _LIBCPP_CONSTEXPR complex(const complex<double>& __c);
        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR long double real() const { return __re_; }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR long double imag() const { return __im_; }
        _LIBCPP_INLINE_VISIBILITY void real(value_type __re) { __re_ = __re; }
       _LIBCPP_INLINE_VISIBILITY void imag(value_type __im) { __im_ = __im; }
        _LIBCPP_INLINE_VISIBILITY complex& operator= (long double __re)         { __re_ = __re;  __im_ = value_type();  return *this; }
       _LIBCPP_INLINE_VISIBILITY complex& operator+=(long double __re) { __re_ += __re;  return *this; }
       _LIBCPP_INLINE_VISIBILITY complex& operator-=(long double __re) { __re_ -= __re;  return *this; }
       _LIBCPP_INLINE_VISIBILITY complex& operator*=(long double __re) { __re_ *= __re;  __im_ *= __re;  return *this; }
       _LIBCPP_INLINE_VISIBILITY complex& operator/=(long double __re) { __re_ /= __re;  __im_ /= __re;  return *this; }
        template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator= (const complex<_Xp>& __c)         {              __re_ = __c.real();              __im_ = __c.imag();              return *this;          }
       template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator+=(const complex<_Xp>& __c)         {              __re_ += __c.real();              __im_ += __c.imag();              return *this;          }
       template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator-=(const complex<_Xp>& __c)         {              __re_ -= __c.real();              __im_ -= __c.imag();              return *this;          }
       template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator*=(const complex<_Xp>& __c)         {              *this = *this * complex(__c.real(), __c.imag());              return *this;          }
       template<class _Xp> _LIBCPP_INLINE_VISIBILITY complex& operator/=(const complex<_Xp>& __c)         {              *this = *this / complex(__c.real(), __c.imag());              return *this;          }
   };
    inline _LIBCPP_CONSTEXPR complex<float>::complex(const complex<double>& __c)     : __re_(__c.real()), __im_(__c.imag()) {
  }
    inline _LIBCPP_CONSTEXPR complex<float>::complex(const complex<long double>& __c)     : __re_(__c.real()), __im_(__c.imag()) {
  }
    inline _LIBCPP_CONSTEXPR complex<double>::complex(const complex<float>& __c)     : __re_(__c.real()), __im_(__c.imag()) {
  }
    inline _LIBCPP_CONSTEXPR complex<double>::complex(const complex<long double>& __c)     : __re_(__c.real()), __im_(__c.imag()) {
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY complex<_Tp> operator*(const _Tp& __x, const complex<_Tp>& __y) {
       complex<_Tp> __t(__y);
       __t *= __x;
       return __t;
   }
    template<class _Tp> complex<_Tp> operator/(const complex<_Tp>& __z, const complex<_Tp>& __w) {
       int __ilogbw = 0;
       _Tp __a = __z.real();
       _Tp __b = __z.imag();
       _Tp __c = __w.real();
       _Tp __d = __w.imag();
       _Tp __logbw = logb(fmax(fabs(__c), fabs(__d)));
       if (__libcpp_isfinite_or_builtin(__logbw))     {          __ilogbw = static_cast<int>(__logbw);          __c = scalbn(__c, -__ilogbw);          __d = scalbn(__d, -__ilogbw);      }
       _Tp __denom = __c * __c + __d * __d;
       _Tp __x = scalbn((__a * __c + __b * __d) / __denom, -__ilogbw);
       _Tp __y = scalbn((__b * __c - __a * __d) / __denom, -__ilogbw);
       if (__libcpp_isnan_or_builtin(__x) && __libcpp_isnan_or_builtin(__y))     {          if ((__denom == _Tp(0)) && (!__libcpp_isnan_or_builtin(__a) || !__libcpp_isnan_or_builtin(__b)))         {              __x = copysign(_Tp(INFINITY), __c) * __a;              __y = copysign(_Tp(INFINITY), __c) * __b;          }          else if ((__libcpp_isinf_or_builtin(__a) || __libcpp_isinf_or_builtin(__b)) && __libcpp_isfinite_or_builtin(__c) && __libcpp_isfinite_or_builtin(__d))         {              __a = copysign(__libcpp_isinf_or_builtin(__a) ? _Tp(1) : _Tp(0), __a);              __b = copysign(__libcpp_isinf_or_builtin(__b) ? _Tp(1) : _Tp(0), __b);              __x = _Tp(INFINITY) * (__a * __c + __b * __d);              __y = _Tp(INFINITY) * (__b * __c - __a * __d);          }          else if (__libcpp_isinf_or_builtin(__logbw) && __logbw > _Tp(0) && __libcpp_isfinite_or_builtin(__a) && __libcpp_isfinite_or_builtin(__b))         {              __c = copysign(__libcpp_isinf_or_builtin(__c) ? _Tp(1) : _Tp(0), __c);              __d = copysign(__libcpp_isinf_or_builtin(__d) ? _Tp(1) : _Tp(0), __d);              __x = _Tp(0) * (__a * __c + __b * __d);              __y = _Tp(0) * (__b * __c - __a * __d);          }      }
       return complex<_Tp>(__x, __y);
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY complex<_Tp> operator/(const complex<_Tp>& __x, const _Tp& __y) {
       return complex<_Tp>(__x.real() / __y, __x.imag() / __y);
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY complex<_Tp> operator-(const complex<_Tp>& __x) {
       return complex<_Tp>(-__x.real(), -__x.imag());
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator==(const complex<_Tp>& __x, const complex<_Tp>& __y) {
       return __x.real() == __y.real() && __x.imag() == __y.imag();
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator==(const complex<_Tp>& __x, const _Tp& __y) {
       return __x.real() == __y && __x.imag() == 0;
       return !(__x == __y);
   }
    template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 bool operator!=(const _Tp& __x, const complex<_Tp>& __y) {
       return !(__x == __y);
   }
    // 26.3.7 values:
 template <class _Tp, bool = is_integral<_Tp>::value,                      bool = is_floating_point<_Tp>::value                      > struct __libcpp_complex_overload_traits {
       typedef _Tp _ValueType;
       typedef complex<_Tp> _ComplexType;
   };
    // real
 template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp real(const complex<_Tp>& __c) {
       return __c.real();
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 typename __libcpp_complex_overload_traits<_Tp>::_ValueType real(_Tp __re) {
       return __re;
   }
    // imag
 template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp imag(const complex<_Tp>& __c) {
       return __c.imag();
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 typename __libcpp_complex_overload_traits<_Tp>::_ValueType imag(_Tp) {
   }
    // log
 template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY complex<_Tp> log(const complex<_Tp>& __x) {
       return complex<_Tp>(log(abs(__x)), arg(__x));
   }
    // log10
 template<class _Tp> inline _LIBCPP_INLINE_VISIBILITY complex<_Tp> log10(const complex<_Tp>& __x) {
       return log(__x) / log(_Tp(10));
   }
    // sqrt
 template<class _Tp> complex<_Tp> sqrt(const complex<_Tp>& __x) {
       if (__libcpp_isinf_or_builtin(__x.imag()))         return complex<_Tp>(_Tp(INFINITY), __x.imag());
       if (__libcpp_isinf_or_builtin(__x.real()))     {          if (__x.real() > _Tp(0))             return complex<_Tp>(__x.real(), __libcpp_isnan_or_builtin(__x.imag()) ? __x.imag() : copysign(_Tp(0), __x.imag()));          return complex<_Tp>(__libcpp_isnan_or_builtin(__x.imag()) ? __x.imag() : _Tp(0), copysign(__x.real(), __x.imag()));      }
       return polar(sqrt(abs(__x)), arg(__x) / _Tp(2));
   }
    template<class _Tp, class _Up> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_arithmetic<_Up>::value,     complex<typename __promote<_Tp, _Up>::type> >::type pow(const complex<_Tp>& __x, const _Up& __y) {
       typedef complex<typename __promote<_Tp, _Up>::type> result_type;
       return _VSTD::pow(result_type(__x), result_type(__y));
   }
    template<class _Tp, class _Up> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     is_arithmetic<_Tp>::value,     complex<typename __promote<_Tp, _Up>::type> >::type pow(const _Tp& __x, const complex<_Up>& __y) {
       typedef complex<typename __promote<_Tp, _Up>::type> result_type;
       return _VSTD::pow(result_type(__x), result_type(__y));
   }
    // tan
 template<class _Tp> complex<_Tp> tan(const complex<_Tp>& __x) {
       complex<_Tp> __z = tanh(complex<_Tp>(-__x.imag(), __x.real()));
       return complex<_Tp>(__z.imag(), -__z.real());
   }
    template<class _Tp, class _CharT, class _Traits> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x) {
       if (__is.good())     {          ws(__is);          if (__is.peek() == _CharT('('))         {              __is.get();              _Tp __r;              __is >> __r;              if (!__is.fail())             {                  ws(__is);                  _CharT __c = __is.peek();                  if (__c == _CharT(','))                 {                      __is.get();                      _Tp __i;                      __is >> __i;                      if (!__is.fail())                     {                         ws(__is);                         __c = __is.peek();                         if (__c == _CharT(')'))                         {                             __is.get();                             __x = complex<_Tp>(__r, __i);                         }                         else                             __is.setstate(ios_base::failbit);                     }                      else                         __is.setstate(ios_base::failbit);                  }                  else if (__c == _CharT(')'))                 {                      __is.get();                      __x = complex<_Tp>(__r, _Tp(0));                  }                  else                     __is.setstate(ios_base::failbit);              }              else                 __is.setstate(ios_base::failbit);          }          else         {              _Tp __r;              __is >> __r;              if (!__is.fail())                 __x = complex<_Tp>(__r, _Tp(0));              else                 __is.setstate(ios_base::failbit);          }      }
       else         __is.setstate(ios_base::failbit);
       return __is;
   }
    template<class _Tp, class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x) {
       basic_ostringstream<_CharT, _Traits> __s;
       __s.flags(__os.flags());
       __s.imbue(__os.getloc());
       __s.precision(__os.precision());
       __s << '(' << __x.real() << ',' << __x.imag() << ')';
       return __os << __s.str();
   }
      
#if _LIBCPP_STD_VER > 11 
// Literal suffix for complex number literals [complex.literals]
inline namespace literals {
      inline namespace complex_literals   {      constexpr complex<long double> operator""il(long double __im)     {          return {  0.0l, __im };      }       constexpr complex<long double> operator""il(unsigned long long __im)     {          return {  0.0l, static_cast<long double>(__im) };      }        constexpr complex<double> operator""i(long double __im)     {          return {  0.0, static_cast<double>(__im) };      }       constexpr complex<double> operator""i(unsigned long long __im)     {          return {  0.0, static_cast<double>(__im) };      }        constexpr complex<float> operator""if(long double __im)     {          return {  0.0f, static_cast<float>(__im) };      }       constexpr complex<float> operator""if(unsigned long long __im)     {          return {  0.0f, static_cast<float>(__im) };      }    }
   }
     
#endif
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_COMPLEX
  
#pragma clang module end /*std.complex*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 // hh 080623 Created
   
#endif  // _LIBCPP_CCOMPLEX
  
#pragma clang module end /*std.compat.ccomplex*/
   
#else  // __cplusplus
   
#if 0 /* expanded by -frewrite-includes */
  
#include_next <complex.h>
  
#endif /* expanded by -frewrite-includes */
   
#endif  // __cplusplus
   
#endif  // _LIBCPP_COMPLEX_H
  
#pragma clang module end /*std.complex_h*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "/aia/r018/scratch/gonzalo/toolchain/llvm/lib/clang/6.0.0/include/tgmath.h"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.tgmath_h
/*===---- tgmath.h - Standard header for type generic math ----------------===*\  *  * Copyright (c) 2009 Howard Hinnant  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN  * THE SOFTWARE.  * \*===----------------------------------------------------------------------===*/
   
#ifndef __CLANG_TGMATH_H
  
#define __CLANG_TGMATH_H
 /* C99 7.22 Type-generic math <tgmath.h>. */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <math.h>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.depr.math_h
// -*- C++ -*-
//===---------------------------- math.h ----------------------------------===//
#ifndef _LIBCPP_MATH_H
  
#define _LIBCPP_MATH_H
 /*     math.h synopsis  Macros:      HUGE_VAL     HUGE_VALF               // C99
    HUGE_VALL               // C99
    INFINITY                // C99
    NAN                     // C99
   long double    truncl(long double x);
    */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
   
#ifdef __cplusplus
 // We support including .h headers inside 'extern "C"' contexts, so switch
// back to C++ linkage before including these C++ headers.
extern "C++" {
      
#if 0 /* expanded by -frewrite-includes */
inline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       { return ::asinf(__lcpp_x); }
   inline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT { return ::asinl(__lcpp_x); }
     
#endif
 template <class _A1> inline _LIBCPP_INLINE_VISIBILITY typename std::enable_if<std::is_integral<_A1>::value, double>::type asin(_A1 __lcpp_x) _NOEXCEPT { return ::asin((double)__lcpp_x); }
    // atan
   
   
#endif // __cplusplus
   
#endif  // _LIBCPP_MATH_H
  
#pragma clang module end /*std.depr.math_h*/
 /*  * Allow additional definitions and implementation-defined values on Apple  * platforms. This is done after   
#include <math.h> to avoid depcycle conflicts
 * between libcxx and darwin in C++ modules builds.  */
  
#if defined(__APPLE__) && __STDC_HOSTED__ && (1)/*__has_include_next(<tgmath.h>)*/
  
#if 0 /* expanded by -frewrite-includes */
  
#  include_next <tgmath.h>
#undef _TG_ATTRSp
  
#undef _TG_ATTRS
   
#endif /* __cplusplus */
  
#endif /* __has_include_next */
  
#endif /* __CLANG_TGMATH_H */
  
#pragma clang module end /*std.tgmath_h*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "ccomplex"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.ccomplex
// -*- C++ -*-
//===--------------------------- ccomplex ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CCOMPLEX
  
#define _LIBCPP_CCOMPLEX
 /*     ccomplex synopsis    
#include <complex>
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <complex>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 // hh 080623 Created
   
#endif  // _LIBCPP_CCOMPLEX
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_CCTYPE
  
#define _LIBCPP_CCTYPE
 /*     cctype synopsis  namespace std {
    int isalnum(int c);
   int isalpha(int c);
   int isblank(int c);
    // C99
int iscntrl(int c);
   int isdigit(int c);
   int isgraph(int c);
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD    
#ifdef isalnum
  
#undef isalnum
  
#endif
   
#ifdef isalpha
  
#undef isalpha
  
#endif
   
#ifdef isblank
  
#undef isblank
  
#endif
   
#ifdef iscntrl
  
#endif
  using ::isalnum;
   using ::isalpha;
   using ::isblank;
   using ::iscntrl;
   using ::isdigit;
   using ::isgraph;
   using ::toupper;
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_CCTYPE
  
#pragma clang module end /*std.compat.cctype*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "cerrno"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.compat.cerrno
// -*- C++ -*-
//===-------------------------- cerrno ------------------------------------===//
#ifndef _LIBCPP_CERRNO
  
#define _LIBCPP_CERRNO
 /*     cerrno synopsis  Macros:      EDOM     EILSEQ  // C99
    ERANGE     errno  */
   
#if 0 /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>  // rest of byte
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
                         // C11
 }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#else
  
#define _LIBCPP_UNREACHABLE() _VSTD::abort()
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  using ::size_t;
   using ::div_t;
           }
       }
   }
    template <class _BidirectionalIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
     
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
       __debug_less<_Compare> __c(__comp);
       return __prev_permutation<_Comp_ref>(__first, __last, __c);
     
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
       return __prev_permutation<_Comp_ref>(__first, __last, __comp);
     
#endif  // _LIBCPP_DEBUG
}
    template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) {
       return _VSTD::prev_permutation(__first, __last,                                   __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_ALGORITHM
  
#pragma clang module end /*std.algorithm*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "any"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.any
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ANY
  
#define _LIBCPP_ANY
 /*    any synopsis  namespace std {
      class bad_any_cast : public bad_cast   {
#endif /* expanded by -frewrite-includes */
// -*- C++ -*-
//===--------------------------- __config ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_CONFIG
  
#define _LIBCPP_EXPERIMENTAL_CONFIG
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#define _LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL namespace std { namespace experimental {
  
#define _LIBCPP_END_NAMESPACE_EXPERIMENTAL  } }
  
#define _VSTD_EXPERIMENTAL std::experimental
   
#define _LIBCPP_BEGIN_NAMESPACE_LFTS _LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL inline namespace fundamentals_v1 {
  
#define _LIBCPP_END_NAMESPACE_LFTS  } } }
  
#define _VSTD_LFTS _VSTD_EXPERIMENTAL::fundamentals_v1
   
#define _LIBCPP_BEGIN_NAMESPACE_LFTS_V2 _LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL inline namespace fundamentals_v2 {
  
#define _LIBCPP_END_NAMESPACE_LFTS_V2  } } }
  
#define _VSTD_LFTS_V2 _VSTD_EXPERIMENTAL::fundamentals_v2
   
#define _LIBCPP_BEGIN_NAMESPACE_LFTS_PMR _LIBCPP_BEGIN_NAMESPACE_LFTS namespace pmr {
  
#define _LIBCPP_END_NAMESPACE_LFTS_PMR _LIBCPP_END_NAMESPACE_LFTS }
  
#define _VSTD_LFTS_PMR _VSTD_LFTS::pmr
   
#define _LIBCPP_BEGIN_NAMESPACE_CHRONO_LFTS _LIBCPP_BEGIN_NAMESPACE_STD        \
  namespace chrono { namespace experimental { inline namespace fundamentals_v1 {
  
#define _LIBCPP_END_NAMESPACE_CHRONO_LFTS _LIBCPP_END_NAMESPACE_STD } } }
   
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.memory
// -*- C++ -*-
//===-------------------------- memory ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_MEMORY
       }
   }
    template <class _RandomAccessIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp) {
     
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
     
#else
    ((void)__msg);
   	  _VSTD::abort();
     
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_out_of_range(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw overflow_error(__msg);
     
#else
    ((void)__msg);
       _VSTD::abort();
     
#endif
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_underflow_error(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw underflow_error(__msg);
     
#else
    ((void)__msg);
       _VSTD::abort();
     
#endif
}
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_STDEXCEPT
  
#pragma clang module end /*std.stdexcept*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Tp, size_t _Size> struct _LIBCPP_TEMPLATE_VIS array {
       // types:
    typedef array __self;
       typedef _Tp                                   value_type;
       typedef value_type&                           reference;
       typedef const value_type&                     const_reference;
       typedef value_type*                           iterator;
       typedef const value_type*                     const_iterator;
       typedef value_type*                           pointer;
       typedef const value_type*                     const_pointer;
       typedef size_t                                size_type;
       typedef ptrdiff_t                             difference_type;
       typedef std::reverse_iterator<iterator>       reverse_iterator;
       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        value_type __elems_[_Size > 0 ? _Size : 1];
        // No explicit construct/copy/destroy for aggregate type
    _LIBCPP_INLINE_VISIBILITY void fill(const value_type& __u)         {
  _VSTD::fill_n(__elems_, _Size, __u);
  }
       _LIBCPP_INLINE_VISIBILITY     void swap(array& __a) _NOEXCEPT_(_Size == 0 || __is_nothrow_swappable<_Tp>::value)         {
   __swap_dispatch((std::integral_constant<bool, _Size == 0>()), __a);
  return iterator(__elems_);
  }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     const_iterator begin() const _NOEXCEPT {
  return const_iterator(__elems_);
  }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     iterator end() _NOEXCEPT {
  return iterator(__elems_ + _Size);
  }
    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     reference operator[](size_type __n)             {
  return __elems_[__n];
  }
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11     const_reference operator[](size_type __n) const {
  return __elems_[__n];
  }
        _LIBCPP_CONSTEXPR_AFTER_CXX14       reference at(size_type __n);
       _LIBCPP_CONSTEXPR_AFTER_CXX11 const_reference at(size_type __n) const;
       _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14     const value_type* data() const _NOEXCEPT {
  return __elems_;
  }
   };
    template <class _Tp, size_t _Size> _LIBCPP_CONSTEXPR_AFTER_CXX14 typename array<_Tp, _Size>::reference array<_Tp, _Size>::at(size_type __n) {
       if (__n >= _Size)         __throw_out_of_range("array::at");
        return __elems_[__n];
   }
    template <class _Tp, size_t _Size> _LIBCPP_CONSTEXPR_AFTER_CXX11 typename array<_Tp, _Size>::const_reference array<_Tp, _Size>::at(size_type __n) const {
       if (__n >= _Size)         __throw_out_of_range("array::at");
       return __elems_[__n];
   }
    template <class _Tp, size_t _Size> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
       return _VSTD::equal(__x.__elems_, __x.__elems_ + _Size, __y.__elems_);
   }
    template <class _Tp, size_t _Size> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
       return !(__x == __y);
   }
    template <class _Tp, size_t _Size> inline _LIBCPP_INLINE_VISIBILITY bool operator<(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
       return _VSTD::lexicographical_compare(__x.__elems_, __x.__elems_ + _Size, __y.__elems_, __y.__elems_ + _Size);
   }
    template <class _Tp, size_t _Size> inline _LIBCPP_INLINE_VISIBILITY bool operator>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
       return __y < __x;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <size_t _Ip, class _Tp, size_t _Size> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 _Tp&& get(array<_Tp, _Size>&& __a) _NOEXCEPT {
       static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
       return _VSTD::move(__a.__elems_[_Ip]);
   }
    template <size_t _Ip, class _Tp, size_t _Size> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 const _Tp&& get(const array<_Tp, _Size>&& __a) _NOEXCEPT {
       static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
       return _VSTD::move(__a.__elems_[_Ip]);
   }
      
#endif  // !_LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_ARRAY
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ATOMIC
  
#define _LIBCPP_ATOMIC
 /*     atomic synopsis  namespace std {
    // feature test macro
   
#define __cpp_lib_atomic_is_always_lock_free // as specified by SG10
 // order and consistency
 typedef enum memory_order {
       memory_order_relaxed,     memory_order_consume,  // load-consume
    memory_order_acquire,  // load-acquire
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_MEMORY
  
#pragma clang module end /*std.memory*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#ifndef _LIBCPP_HAS_NO_THREADS
 _LIBCPP_BEGIN_NAMESPACE_STD  class _LIBCPP_TYPE_VIS condition_variable_any {
       condition_variable __cv_;
       shared_ptr<mutex>  __mut_;
   public:     _LIBCPP_INLINE_VISIBILITY     condition_variable_any();
        _LIBCPP_INLINE_VISIBILITY     void notify_one() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     void notify_all() _NOEXCEPT;
    template <class _Lock, class _Rep, class _Period, class _Predicate> inline bool condition_variable_any::wait_for(_Lock& __lock,                                  const chrono::duration<_Rep, _Period>& __d,                                  _Predicate __pred) {
       return wait_until(__lock, chrono::steady_clock::now() + __d,                       _VSTD::move(__pred));
   }
    _LIBCPP_FUNC_VIS void notify_all_at_thread_exit(condition_variable& cond, unique_lock<mutex> lk);
    _LIBCPP_END_NAMESPACE_STD    
#endif // !_LIBCPP_HAS_NO_THREADS
   
#endif  // _LIBCPP_CONDITION_VARIABLE
  
#pragma clang module end /*std.condition_variable*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "deque"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.deque
// -*- C++ -*-
//===---------------------------- deque -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_DEQUE
  
#define _LIBCPP_DEQUE
  
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__split_buffer>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__split_buffer
// -*- C++ -*-
  
#ifndef _LIBCPP_SPLIT_BUFFER
  
#define _LIBCPP_SPLIT_BUFFER
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TYPE_TRAITS
  
#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {
        // helper class:
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;
   template <class _Tp> class _LIBCPP_TEMPLATE_VIS reference_wrapper;
   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;
       return _VSTD::prev_permutation(__first, __last,                                   __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_ALGORITHM
  
#pragma clang module end /*std.algorithm*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max")   
#else
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template <bool> class __split_buffer_common {
   protected:     void __throw_length_error() const;
       void __throw_out_of_range() const;
   };
    template <class _Tp, class _Allocator = allocator<_Tp> > struct __split_buffer     : private __split_buffer_common<true> {
   private:     __split_buffer(const __split_buffer&);
       __split_buffer& operator=(const __split_buffer&);
   public:     typedef _Tp                                             value_type;
       typedef _Allocator                                      allocator_type;
       typedef typename remove_reference<allocator_type>::type __alloc_rr;
       typedef allocator_traits<__alloc_rr>                    __alloc_traits;
       typedef value_type&                                     reference;
       typedef const value_type&                               const_reference;
       typedef typename __alloc_traits::size_type              size_type;
       typedef typename __alloc_traits::difference_type        difference_type;
       typedef typename __alloc_traits::pointer                pointer;
       typedef typename __alloc_traits::const_pointer          const_pointer;
       typedef pointer                                         iterator;
       typedef const_pointer                                   const_iterator;
        pointer                                         __first_;
       pointer                                         __begin_;
       pointer                                         __end_;
       __compressed_pair<pointer, allocator_type> __end_cap_;
        typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
       typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;
        _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {
  return __end_cap_.second();
  }
       _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {
  return __end_cap_.second();
  }
       _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {
  return __end_cap_.first();
  }
       _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {
  return __end_cap_.first();
  }
        _LIBCPP_INLINE_VISIBILITY     __split_buffer()         _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);
       _LIBCPP_INLINE_VISIBILITY     explicit __split_buffer(__alloc_rr& __a);
       _LIBCPP_INLINE_VISIBILITY     explicit __split_buffer(const __alloc_rr& __a);
       __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);
       ~__split_buffer();
      
#ifndef _LIBCPP_CXX03_LANG
    __split_buffer(__split_buffer&& __c)         _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
       __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);
       __split_buffer& operator=(__split_buffer&& __c)         _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&                 is_nothrow_move_assignable<allocator_type>::value) ||                !__alloc_traits::propagate_on_container_move_assignment::value);
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {
  return __begin_;
  }
       _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {
  return __begin_;
  }
       _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {
  return __end_;
  }
       _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {
  return __end_;
  }
        _LIBCPP_INLINE_VISIBILITY     void clear() _NOEXCEPT         {
  __destruct_at_end(__begin_);
  }
       _LIBCPP_INLINE_VISIBILITY size_type size() const {
  return static_cast<size_type>(__end_ - __begin_);
  }
       _LIBCPP_INLINE_VISIBILITY bool empty()     const {
  return __end_ == __begin_;
  }
       _LIBCPP_INLINE_VISIBILITY size_type capacity() const {
  return static_cast<size_type>(__end_cap() - __first_);
  }
       _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {
  return static_cast<size_type>(__begin_ - __first_);
  }
       _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {
  return static_cast<size_type>(__end_cap() - __end_);
  }
        _LIBCPP_INLINE_VISIBILITY       reference front()       {
  return *__begin_;
  }
       _LIBCPP_INLINE_VISIBILITY const_reference front() const {
  return *__begin_;
  }
       _LIBCPP_INLINE_VISIBILITY       reference back()        {
  return *(__end_ - 1);
  }
       _LIBCPP_INLINE_VISIBILITY const_reference back() const  {
  return *(__end_ - 1);
  }
        void reserve(size_type __n);
       void shrink_to_fit() _NOEXCEPT;
       void push_front(const_reference __x);
       _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);
     
#ifndef _LIBCPP_CXX03_LANG
    void push_front(value_type&& __x);
       void push_back(value_type&& __x);
       template <class... _Args>         void emplace_back(_Args&&... __args);
     
#endif  // !defined(_LIBCPP_CXX03_LANG)
     _LIBCPP_INLINE_VISIBILITY void pop_front() {
  __destruct_at_begin(__begin_+1);
  }
       _LIBCPP_INLINE_VISIBILITY void pop_back() {
  __destruct_at_end(__end_-1);
  }
        void __construct_at_end(size_type __n);
       void __construct_at_end(size_type __n, const_reference __x);
       template <class _InputIter>         typename enable_if         <             __is_input_iterator<_InputIter>::value &&            !__is_forward_iterator<_InputIter>::value,             void         >::type         __construct_at_end(_InputIter __first, _InputIter __last);
       template <class _ForwardIterator>         typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value,             void         >::type         __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
        _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)         {
  __destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());
  }
           _LIBCPP_INLINE_VISIBILITY         void __destruct_at_begin(pointer __new_begin, false_type);
           _LIBCPP_INLINE_VISIBILITY         void __destruct_at_begin(pointer __new_begin, true_type);
        _LIBCPP_INLINE_VISIBILITY     void __destruct_at_end(pointer __new_last) _NOEXCEPT         {
  __destruct_at_end(__new_last, false_type());
  }
       _LIBCPP_INLINE_VISIBILITY         void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY         void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;
        void swap(__split_buffer& __x)         _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||                    __is_nothrow_swappable<__alloc_rr>::value);
        bool __invariants() const;
    private:     _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(__split_buffer& __c, true_type)         _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)         {
               __alloc() = _VSTD::move(__c.__alloc());
           }
        _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT         {
  }
   };
    template <class _Tp, class _Allocator> bool __split_buffer<_Tp, _Allocator>::__invariants() const {
       if (__first_ == nullptr)     {
           if (__begin_ != nullptr)             return false;
           if (__end_ != nullptr)             return false;
           if (__end_cap() != nullptr)             return false;
       }
       else     {
           if (__begin_ < __first_)             return false;
           if (__end_ < __begin_)             return false;
           if (__end_cap() < __end_)             return false;
       }
       return true;
   }
    template <class _Tp, class _Allocator> __split_buffer<_Tp, _Allocator>::~__split_buffer() {
       clear();
       if (__first_)         __alloc_traits::deallocate(__alloc(), __first_, capacity());
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> __split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)     _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)     : __first_(_VSTD::move(__c.__first_)),       __begin_(_VSTD::move(__c.__begin_)),       __end_(_VSTD::move(__c.__end_)),       __end_cap_(_VSTD::move(__c.__end_cap_)) {
       __c.__first_ = nullptr;
       __c.__begin_ = nullptr;
       __c.__end_ = nullptr;
       __c.__end_cap() = nullptr;
   }
    template <class _Tp, class _Allocator> __split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)     : __end_cap_(__second_tag(), __a) {
       if (__a == __c.__alloc())     {
           __first_ = __c.__first_;
           __begin_ = __c.__begin_;
           __end_ = __c.__end_;
           __end_cap() = __c.__end_cap();
           __c.__first_ = nullptr;
           __c.__begin_ = nullptr;
           __c.__end_ = nullptr;
           __c.__end_cap() = nullptr;
       }
       __end_cap() = __c.__end_cap();
       __move_assign_alloc(__c,         integral_constant<bool,                           __alloc_traits::propagate_on_container_move_assignment::value>());
       __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)         _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||                    __is_nothrow_swappable<__alloc_rr>::value) {
   }
    template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT {
       if (capacity() > size())     {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
               __t.__construct_at_end(move_iterator<pointer>(__begin_),                                    move_iterator<pointer>(__end_));
               __t.__end_ = __t.__begin_ + (__end_ - __begin_);
               _VSTD::swap(__first_, __t.__first_);
               _VSTD::swap(__begin_, __t.__begin_);
               _VSTD::swap(__end_, __t.__end_);
               _VSTD::swap(__end_cap(), __t.__end_cap());
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
   }
    template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::push_front(const_reference __x) {
       if (__begin_ == __first_)     {
           if (__end_ < __end_cap())         {
               difference_type __d = __end_cap() - __end_;
               __d = (__d + 1) / 2;
               __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);
               __end_ += __d;
           }
           else         {
               size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
               __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
               __t.__construct_at_end(move_iterator<pointer>(__begin_),                                    move_iterator<pointer>(__end_));
               _VSTD::swap(__first_, __t.__first_);
               _VSTD::swap(__begin_, __t.__begin_);
               _VSTD::swap(__end_, __t.__end_);
               _VSTD::swap(__end_cap(), __t.__end_cap());
           }
       }
       __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);
       --__begin_;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::push_front(value_type&& __x) {
       if (__begin_ == __first_)     {
           if (__end_ < __end_cap())         {
               difference_type __d = __end_cap() - __end_;
               __d = (__d + 1) / 2;
               __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);
               __end_ += __d;
           }
           else         {
               size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
               __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
               __t.__construct_at_end(move_iterator<pointer>(__begin_),                                    move_iterator<pointer>(__end_));
               _VSTD::swap(__first_, __t.__first_);
               _VSTD::swap(__begin_, __t.__begin_);
               _VSTD::swap(__end_, __t.__end_);
               _VSTD::swap(__end_cap(), __t.__end_cap());
           }
       }
       __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),             _VSTD::move(__x));
       --__begin_;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void __split_buffer<_Tp, _Allocator>::push_back(const_reference __x) {
       if (__end_ == __end_cap())     {
           if (__begin_ > __first_)         {
               difference_type __d = __begin_ - __first_;
               __d = (__d + 1) / 2;
               __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);
               __begin_ -= __d;
           }
           else         {
               size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
               __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
               __t.__construct_at_end(move_iterator<pointer>(__begin_),                                    move_iterator<pointer>(__end_));
               _VSTD::swap(__first_, __t.__first_);
               _VSTD::swap(__begin_, __t.__begin_);
               _VSTD::swap(__end_, __t.__end_);
               _VSTD::swap(__end_cap(), __t.__end_cap());
           }
       }
       __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);
       ++__end_;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> void __split_buffer<_Tp, _Allocator>::push_back(value_type&& __x) {
       if (__end_ == __end_cap())     {
           if (__begin_ > __first_)         {
               difference_type __d = __begin_ - __first_;
               __d = (__d + 1) / 2;
               __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);
               __begin_ -= __d;
           }
           else         {
               size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
               __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
               __t.__construct_at_end(move_iterator<pointer>(__begin_),                                    move_iterator<pointer>(__end_));
               _VSTD::swap(__first_, __t.__first_);
               _VSTD::swap(__begin_, __t.__begin_);
               _VSTD::swap(__end_, __t.__end_);
               _VSTD::swap(__end_cap(), __t.__end_cap());
           }
       }
       __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),             _VSTD::move(__x));
       ++__end_;
   }
    template <class _Tp, class _Allocator> template <class... _Args> void __split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args) {
       if (__end_ == __end_cap())     {
           if (__begin_ > __first_)         {
               difference_type __d = __begin_ - __first_;
               __d = (__d + 1) / 2;
               __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);
               __begin_ -= __d;
           }
           else         {
           }
       }
       __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),                               _VSTD::forward<_Args>(__args)...);
       ++__end_;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)         _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_SPLIT_BUFFER
  
#pragma clang module end /*std.__split_buffer*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.type_traits
// -*- C++ -*-
//===------------------------ type_traits ---------------------------------===//
   
#ifndef _LIBCPP_TYPE_TRAITS
  
#define _LIBCPP_TYPE_TRAITS
 /*     type_traits synopsis  namespace std {
        // helper class:
    template <class T, T v> struct integral_constant;
       typedef integral_constant<bool, true>  true_type;
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
   
  };
   template <class _If, class _Then>     struct _LIBCPP_TEMPLATE_VIS conditional<false, _If, _Then> {
  typedef _Then type;
  };
      
#if _LIBCPP_STD_VER > 11
template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;
     
#endif
 template <bool, class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if {
  };
   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS __lazy_enable_if<true, _Tp> {
  typedef typename _Tp::type type;
  };
     
}
    _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_underflow_error(const char*__msg) {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw underflow_error(__msg);
     
#else
    ((void)__msg);
       _VSTD::abort();
     
#endif
}
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_STDEXCEPT
  
#pragma clang module end /*std.stdexcept*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
    
#ifdef min
  
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Tp, class _Allocator> class __deque_base;
   template <class _Tp, class _Allocator = allocator<_Tp> > class _LIBCPP_TEMPLATE_VIS deque;
    template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,           class _DiffType, _DiffType _BlockSize> class _LIBCPP_TEMPLATE_VIS __deque_iterator;
    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,           class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
    template <class _RAIter,           class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(_RAIter __f,               _RAIter __l,               __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,               typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);
    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,           class _OutputIterator> _OutputIterator move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,               __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,               _OutputIterator __r);
    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,           class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,               __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,               __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
    template <class _ValueType, class _DiffType> struct __deque_block_size {
     static const _DiffType value = sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;
   };
    template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,           class _DiffType, _DiffType _BS =   
#ifdef _LIBCPP_ABI_INCOMPLETE_TYPES_IN_DEQUE
// Keep template parameter to avoid changing all template declarations thoughout
// this file.
                               0   
#else
                               __deque_block_size<_ValueType, _DiffType>::value   
#endif
          > class _LIBCPP_TEMPLATE_VIS __deque_iterator {
       typedef _MapPointer __map_iterator;
   public:     typedef _Pointer  pointer;
       typedef _DiffType difference_type;
   private:     __map_iterator __m_iter_;
       pointer        __ptr_;
        static const difference_type __block_size;
   public:     typedef _ValueType                  value_type;
        _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator++()     {
           if (++__ptr_ - *__m_iter_ == __block_size)         {
               ++__m_iter_;
               __ptr_ = *__m_iter_;
           }
           return *this;
       }
        _LIBCPP_INLINE_VISIBILITY __deque_iterator operator++(int)     {
  }
        _LIBCPP_INLINE_VISIBILITY friend         bool operator<(const __deque_iterator& __x, const __deque_iterator& __y)         {
  return __x.__m_iter_ < __y.__m_iter_ ||                (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);
  }
        _LIBCPP_INLINE_VISIBILITY friend         bool operator>(const __deque_iterator& __x, const __deque_iterator& __y)         {
  return __y < __x;
  }
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,               class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>     friend     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>     copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,                   __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,                   __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _RAIter,               class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>     friend     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>     move(_RAIter __f,          _RAIter __l,          __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,          typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,               class _OutputIterator>     friend     _OutputIterator     move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,          __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,          _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,               class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>     friend     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>     move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,          __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,          __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
        template <class _RAIter,               class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>     friend     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>     move_backward(_RAIter __f,                   _RAIter __l,                   __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,                   typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,               class _OutputIterator>     friend     _OutputIterator     move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,                   __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,                   _OutputIterator __r);
        template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,               class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>     friend     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>     move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,                   __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,                   __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
   };
    template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,           class _DiffType, _DiffType _BlockSize> const _DiffType __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer,                                  _DiffType, _BlockSize>::__block_size =     __deque_block_size<_ValueType, _DiffType>::value;
    // copy
 template <class _RAIter,           class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy(_RAIter __f,      _RAIter __l,      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,      typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*) {
       typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;
       typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
       const difference_type __block_size = __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
       while (__f != __l)     {
           pointer __rb = __r.__ptr_;
           pointer __re = *__r.__m_iter_ + __block_size;
           difference_type __bs = __re - __rb;
           difference_type __n = __l - __f;
           _RAIter __m = __l;
           if (__n > __bs)         {
               __n = __bs;
               __m = __f + __n;
           }
           _VSTD::copy(__f, __m, __rb);
           __f = __m;
           __r += __n;
       }
       return __r;
   }
    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,           class _OutputIterator> _OutputIterator copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,      _OutputIterator __r) {
       typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
       typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
       const difference_type __block_size = __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
       difference_type __n = __l - __f;
       while (__n > 0)     {
           pointer __fb = __f.__ptr_;
           pointer __fe = *__f.__m_iter_ + __block_size;
           difference_type __bs = __fe - __fb;
       }
       return __r;
   }
    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,           class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,               __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,               __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r) {
       typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;
       typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
       difference_type __n = __l - __f;
       while (__n > 0)     {
           --__l;
           pointer __lb = *__l.__m_iter_;
           pointer __le = __l.__ptr_ + 1;
           difference_type __bs = __le - __lb;
           if (__bs > __n)         {
               __bs = __n;
               __lb = __le - __bs;
           }
           __r = _VSTD::move_backward(__lb, __le, __r);
           __n -= __bs;
           __l -= __bs - 1;
       }
       return __r;
   }
    template <bool> class __deque_base_common {
   protected:     _LIBCPP_NORETURN void __throw_length_error() const;
       _LIBCPP_NORETURN void __throw_out_of_range() const;
   };
    template <bool __b> void __deque_base_common<__b>::__throw_length_error() const {
       _VSTD::__throw_length_error("deque");
   }
    template <bool __b> void __deque_base_common<__b>::__throw_out_of_range() const {
       _VSTD::__throw_out_of_range("deque");
   }
    template <class _Tp, class _Allocator> class __deque_base     : protected __deque_base_common<true> {
       __deque_base(const __deque_base& __c);
       __deque_base& operator=(const __deque_base& __c);
   protected:     typedef _Tp                                      value_type;
       typedef _Allocator                               allocator_type;
       typedef allocator_traits<allocator_type>         __alloc_traits;
       typedef value_type&                              reference;
       typedef const value_type&                        const_reference;
       typedef typename __alloc_traits::size_type       size_type;
       typedef typename __alloc_traits::difference_type difference_type;
       typedef typename __alloc_traits::pointer         pointer;
       typedef typename __alloc_traits::const_pointer   const_pointer;
        static const difference_type __block_size;
        typedef typename __rebind_alloc_helper<__alloc_traits, pointer>::type __pointer_allocator;
       typedef allocator_traits<__pointer_allocator>        __map_traits;
       typedef typename __map_traits::pointer               __map_pointer;
       typedef typename __rebind_alloc_helper<__alloc_traits, const_pointer>::type __const_pointer_allocator;
       typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;
       typedef __split_buffer<pointer, __pointer_allocator> __map;
        typedef __deque_iterator<value_type, pointer, reference, __map_pointer,                              difference_type>    iterator;
       typedef __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer,                              difference_type>    const_iterator;
        __map __map_;
       size_type __start_;
       __compressed_pair<size_type, allocator_type> __size_;
        iterator       begin() _NOEXCEPT;
       const_iterator begin() const _NOEXCEPT;
       iterator       end() _NOEXCEPT;
       const_iterator end() const _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY size_type&            size()          {
  }
       _LIBCPP_INLINE_VISIBILITY     const allocator_type& __alloc() const _NOEXCEPT {
  return __size_.second();
  }
        _LIBCPP_INLINE_VISIBILITY     __deque_base()         _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);
       _LIBCPP_INLINE_VISIBILITY     explicit __deque_base(const allocator_type& __a);
   public:     ~__deque_base();
      
#ifndef _LIBCPP_CXX03_LANG
    __deque_base(__deque_base&& __c)         _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
       __deque_base(__deque_base&& __c, const allocator_type& __a);
     
#endif  // _LIBCPP_CXX03_LANG
     void swap(__deque_base& __c)   
#if _LIBCPP_STD_VER >= 14
        _NOEXCEPT;
     
#else
        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||                      __is_nothrow_swappable<allocator_type>::value);
     
#endif
protected:     void clear() _NOEXCEPT;
        bool __invariants() const;
   };
    template <class _Tp, class _Allocator> const typename __deque_base<_Tp, _Allocator>::difference_type     __deque_base<_Tp, _Allocator>::__block_size =         __deque_block_size<value_type, difference_type>::value;
    template <class _Tp, class _Allocator> bool __deque_base<_Tp, _Allocator>::__invariants() const {
       if (!__map_.__invariants())         return false;
       if (__map_.size() >= size_type(-1) / __block_size)         return false;
       for (typename __map::const_iterator __i = __map_.begin(), __e = __map_.end();
            __i != __e;
   ++__i)         if (*__i == nullptr)             return false;
   }
    template <class _Tp, class _Allocator> void __deque_base<_Tp, _Allocator>::clear() _NOEXCEPT {
       allocator_type& __a = __alloc();
       for (iterator __i = begin(), __e = end();
   __i != __e;
   ++__i)         __alloc_traits::destroy(__a, _VSTD::addressof(*__i));
       size() = 0;
       while (__map_.size() > 2)     {
           __alloc_traits::deallocate(__a, __map_.front(), __block_size);
           __map_.pop_front();
       }
       switch (__map_.size())     {
       case 1:         __start_ = __block_size / 2;
           break;
       case 2:         __start_ = __block_size;
           break;
       }
   }
    template <class _Tp, class _Allocator /*= allocator<_Tp>*/> class _LIBCPP_TEMPLATE_VIS deque     : private __deque_base<_Tp, _Allocator> {
   public:     // types:
     typedef _Tp value_type;
       typedef _Allocator allocator_type;
        static_assert((is_same<typename allocator_type::value_type, value_type>::value),                   "Allocator::value_type must be same type as value_type");
        typedef __deque_base<value_type, allocator_type> __base;
        typedef typename __base::__alloc_traits        __alloc_traits;
       typedef typename __base::reference             reference;
       typedef typename __base::const_reference       const_reference;
       typedef typename __base::iterator              iterator;
       typedef typename __base::const_iterator        const_iterator;
       typedef typename __base::size_type             size_type;
       typedef typename __base::difference_type       difference_type;
        typedef typename __base::pointer               pointer;
       typedef typename __base::const_pointer         const_pointer;
       typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;
       typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;
        // construct/copy/destroy:
    _LIBCPP_INLINE_VISIBILITY     deque()         _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)         {
  }
       _LIBCPP_INLINE_VISIBILITY explicit deque(const allocator_type& __a) : __base(__a) {
  }
       explicit deque(size_type __n);
     
#if _LIBCPP_STD_VER > 11
    explicit deque(size_type __n, const _Allocator& __a);
     
#endif
    deque(size_type __n, const value_type& __v);
       deque(size_type __n, const value_type& __v, const allocator_type& __a);
       template <class _InputIter>         deque(_InputIter __f, _InputIter __l,               typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);
       template <class _InputIter>         deque(_InputIter __f, _InputIter __l, const allocator_type& __a,               typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);
       deque(const deque& __c);
       deque(const deque& __c, const allocator_type& __a);
        deque& operator=(const deque& __c);
      
#ifndef _LIBCPP_CXX03_LANG
    deque(initializer_list<value_type> __il);
       deque(initializer_list<value_type> __il, const allocator_type& __a);
        _LIBCPP_INLINE_VISIBILITY     deque& operator=(initializer_list<value_type> __il) {
  assign(__il);
   return *this;
  }
        _LIBCPP_INLINE_VISIBILITY     deque(deque&& __c) _NOEXCEPT_(is_nothrow_move_constructible<__base>::value);
       _LIBCPP_INLINE_VISIBILITY     deque(deque&& __c, const allocator_type& __a);
       _LIBCPP_INLINE_VISIBILITY     deque& operator=(deque&& __c)         _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&                    is_nothrow_move_assignable<allocator_type>::value);
        _LIBCPP_INLINE_VISIBILITY     void assign(initializer_list<value_type> __il) {
  assign(__il.begin(), __il.end());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     template <class _InputIter>         void assign(_InputIter __f, _InputIter __l,                     typename enable_if<__is_input_iterator<_InputIter>::value &&                                       !__is_random_access_iterator<_InputIter>::value>::type* = 0);
       template <class _RAIter>         void assign(_RAIter __f, _RAIter __l,                     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);
       void assign(size_type __n, const value_type& __v);
        _LIBCPP_INLINE_VISIBILITY     allocator_type get_allocator() const _NOEXCEPT;
        // iterators:
     _LIBCPP_INLINE_VISIBILITY     iterator       begin() _NOEXCEPT       {
  return __base::begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crend()   const _NOEXCEPT         {
  return const_reverse_iterator(__base::begin());
  }
        // capacity:
    _LIBCPP_INLINE_VISIBILITY     size_type size() const _NOEXCEPT {
  return __base::size();
  }
       _LIBCPP_INLINE_VISIBILITY     size_type max_size() const _NOEXCEPT         {
  return std::min<size_type>(             __alloc_traits::max_size(__base::__alloc()),             numeric_limits<difference_type>::max());
  }
       void resize(size_type __n);
       void resize(size_type __n, const value_type& __v);
       void shrink_to_fit() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     bool empty() const _NOEXCEPT {
  return __base::size() == 0;
  }
        // element access:
    _LIBCPP_INLINE_VISIBILITY     reference operator[](size_type __i);
       _LIBCPP_INLINE_VISIBILITY     const_reference operator[](size_type __i) const;
       _LIBCPP_INLINE_VISIBILITY     reference at(size_type __i);
       _LIBCPP_INLINE_VISIBILITY     const_reference at(size_type __i) const;
       _LIBCPP_INLINE_VISIBILITY     reference front();
       _LIBCPP_INLINE_VISIBILITY     const_reference front() const;
       _LIBCPP_INLINE_VISIBILITY     reference back();
       _LIBCPP_INLINE_VISIBILITY     const_reference back() const;
        // 23.2.2.3 modifiers:
    void push_front(const value_type& __v);
       void push_back(const value_type& __v);
     
#ifndef _LIBCPP_CXX03_LANG
  
#if _LIBCPP_STD_VER > 14
    template <class... _Args> reference emplace_front(_Args&&... __args);
       template <class... _Args> reference emplace_back (_Args&&... __args);
     
#else
    template <class... _Args> void      emplace_front(_Args&&... __args);
       template <class... _Args> void      emplace_back (_Args&&... __args);
     
#endif
    template <class... _Args> iterator emplace(const_iterator __p, _Args&&... __args);
        void push_front(value_type&& __v);
       void push_back(value_type&& __v);
       iterator insert(const_iterator __p, value_type&& __v);
        _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p, initializer_list<value_type> __il)         {
  return insert(__p, __il.begin(), __il.end());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     iterator insert(const_iterator __p, const value_type& __v);
       iterator insert(const_iterator __p, size_type __n, const value_type& __v);
       template <class _InputIter>         iterator insert(const_iterator __p, _InputIter __f, _InputIter __l,                          typename enable_if<__is_input_iterator<_InputIter>::value                                          &&!__is_forward_iterator<_InputIter>::value>::type* = 0);
       template <class _ForwardIterator>         iterator insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value                                          &&!__is_bidirectional_iterator<_ForwardIterator>::value>::type* = 0);
       template <class _BiIter>         iterator insert(const_iterator __p, _BiIter __f, _BiIter __l,                          typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type* = 0);
        void pop_front();
       void pop_back();
       iterator erase(const_iterator __p);
       iterator erase(const_iterator __f, const_iterator __l);
        _LIBCPP_INLINE_VISIBILITY     void swap(deque& __c)   
#if _LIBCPP_STD_VER >= 14
        _NOEXCEPT;
     
#else
        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||                    __is_nothrow_swappable<allocator_type>::value);
     
#endif
    _LIBCPP_INLINE_VISIBILITY     void clear() _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     bool __invariants() const {
  return __base::__invariants();
  }
   private:     typedef typename __base::__map_const_pointer __map_const_pointer;
        _LIBCPP_INLINE_VISIBILITY     static size_type __recommend_blocks(size_type __n)     {
           return __n / __base::__block_size + (__n % __base::__block_size != 0);
       }
       _LIBCPP_INLINE_VISIBILITY     size_type __capacity() const     {
           return __base::__map_.size() == 0 ? 0 : __base::__map_.size() * __base::__block_size - 1;
       }
       _LIBCPP_INLINE_VISIBILITY     size_type __front_spare() const     {
           return __base::__start_;
       }
       _LIBCPP_INLINE_VISIBILITY     size_type __back_spare() const     {
           return __capacity() - (__base::__start_ + __base::size());
       }
        template <class _InpIter>         void __append(_InpIter __f, _InpIter __l,                  typename enable_if<__is_input_iterator<_InpIter>::value &&                                    !__is_forward_iterator<_InpIter>::value>::type* = 0);
       template <class _ForIter>         void __append(_ForIter __f, _ForIter __l,                       typename enable_if<__is_forward_iterator<_ForIter>::value>::type* = 0);
       void __append(size_type __n);
       void __append(size_type __n, const value_type& __v);
       void __erase_to_end(const_iterator __f);
       void __add_front_capacity();
       void __add_front_capacity(size_type __n);
       void __add_back_capacity();
       void __add_back_capacity(size_type __n);
       iterator __move_and_check(iterator __f, iterator __l, iterator __r,                               const_pointer& __vt);
       iterator __move_backward_and_check(iterator __f, iterator __l, iterator __r,                                        const_pointer& __vt);
       void __move_construct_and_check(iterator __f, iterator __l,                                     iterator __r, const_pointer& __vt);
       void __move_construct_backward_and_check(iterator __f, iterator __l,                                              iterator __r, const_pointer& __vt);
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const deque& __c)         {
  __copy_assign_alloc(__c, integral_constant<bool,                       __alloc_traits::propagate_on_container_copy_assignment::value>());
  }
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const deque&, false_type)         {
  }
        void __move_assign(deque& __c, true_type)         _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);
       void __move_assign(deque& __c, false_type);
   };
    template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque(size_type __n) {
       if (__n > 0)         __append(__n);
   }
      
#if _LIBCPP_STD_VER > 11
template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque(size_type __n, const _Allocator& __a)     : __base(__a) {
       if (__n > 0)         __append(__n);
   }
     
#endif
 template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v) {
       if (__n > 0)         __append(__n, __v);
   }
    template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v, const allocator_type& __a)     : __base(__a) {
       if (__n > 0)         __append(__n, __v);
   }
    template <class _Tp, class _Allocator> template <class _InputIter> deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l,               typename enable_if<__is_input_iterator<_InputIter>::value>::type*) {
       __append(__f, __l);
       return *this;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque(initializer_list<value_type> __il) {
       __append(__il.begin(), __il.end());
   }
    template <class _Tp, class _Allocator> deque<_Tp, _Allocator>::deque(initializer_list<value_type> __il, const allocator_type& __a)     : __base(__a) {
       __append(__il.begin(), __il.end());
   }
    template <class _Tp, class _Allocator> inline deque<_Tp, _Allocator>::deque(deque&& __c)     _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)     : __base(_VSTD::move(__c)) {
   }
    template <class _Tp, class _Allocator> inline deque<_Tp, _Allocator>::deque(deque&& __c, const allocator_type& __a)     : __base(_VSTD::move(__c), __a) {
       if (__a != __c.__alloc())     {
           typedef move_iterator<iterator> _Ip;
           assign(_Ip(__c.begin()), _Ip(__c.end()));
       }
   }
    template <class _Tp, class _Allocator> inline deque<_Tp, _Allocator>& deque<_Tp, _Allocator>::operator=(deque&& __c)         _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&                    is_nothrow_move_assignable<allocator_type>::value) {
       __move_assign(__c, integral_constant<bool,           __alloc_traits::propagate_on_container_move_assignment::value>());
       return *this;
   }
    template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__move_assign(deque& __c, false_type) {
       clear();
       shrink_to_fit();
       __base::__move_assign(__c);
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> template <class _InputIter> void deque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l,                                typename enable_if<__is_input_iterator<_InputIter>::value &&                                                  !__is_random_access_iterator<_InputIter>::value>::type*) {
       iterator __i = __base::begin();
       iterator __e = __base::end();
       for (;
   __f != __l && __i != __e;
   ++__f, (void) ++__i)         *__i = *__f;
       if (__f != __l)         __append(__f, __l);
       else         __erase_to_end(__i);
   }
    template <class _Tp, class _Allocator> template <class _RAIter> void deque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l,                                typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*) {
       if (static_cast<size_type>(__l - __f) > __base::size())     {
           _RAIter __m = __f + __base::size();
           _VSTD::copy(__f, __m, __base::begin());
           __append(__m, __l);
       }
       else         __erase_to_end(_VSTD::copy(__f, __l, __base::begin()));
   }
    template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::assign(size_type __n, const value_type& __v) {
       if (__n > __base::size())         __append(__n - __base::size(), __v);
       else if (__n < __base::size())         __erase_to_end(__base::begin() + __n);
   }
    template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT {
       allocator_type& __a = __base::__alloc();
       if (empty())     {
           while (__base::__map_.size() > 0)         {
               __base::__map_.pop_front();
               __base::__start_ -= __base::__block_size;
           }
           if (__back_spare() >= __base::__block_size)         {
               __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
               __base::__map_.pop_back();
           }
       }
       __base::__map_.shrink_to_fit();
   }
    template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::operator[](size_type __i) {
       size_type __p = __base::__start_ + __i;
       return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
   }
    template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::operator[](size_type __i) const {
       size_type __p = __base::__start_ + __i;
       return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
   }
    template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::at(size_type __i) {
       if (__i >= __base::size())         __base::__throw_out_of_range();
       size_type __p = __base::__start_ + __i;
       return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
   }
    template <class _Tp, class _Allocator> inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::back() const {
       size_type __p = __base::size() + __base::__start_ - 1;
       return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
   }
    template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::push_back(const value_type& __v) {
       allocator_type& __a = __base::__alloc();
       if (__back_spare() == 0)         __add_back_capacity();
       // __back_spare() >= 1
    __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), __v);
       --__base::__start_;
       ++__base::size();
   }
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::push_back(value_type&& __v) {
       allocator_type& __a = __base::__alloc();
       if (__back_spare() == 0)         __add_back_capacity();
       // __back_spare() >= 1
    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::move(__v));
       ++__base::size();
   }
    template <class _Tp, class _Allocator> template <class... _Args>   
#if _LIBCPP_STD_VER > 14
typename deque<_Tp, _Allocator>::reference   
#else
void   
#endif
deque<_Tp, _Allocator>::emplace_back(_Args&&... __args) {
       allocator_type& __a = __base::__alloc();
       if (__back_spare() == 0)         __add_back_capacity();
       // __back_spare() >= 1
    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()),                               _VSTD::forward<_Args>(__args)...);
       ++__base::size();
     
#if _LIBCPP_STD_VER > 14
    return *--__base::end();
     
#endif
}
    template <class _Tp, class _Allocator> template <class... _Args> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::emplace(const_iterator __p, _Args&&... __args) {
       size_type __pos = __p - __base::begin();
       size_type __to_end = __base::size() - __pos;
       allocator_type& __a = __base::__alloc();
       if (__pos < __to_end)     {
     // insert by shifting things backward
        if (__front_spare() == 0)             __add_front_capacity();
           // __front_spare() >= 1
        if (__pos == 0)         {
               __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::forward<_Args>(__args)...);
               --__base::__start_;
               ++__base::size();
           }
           else         {
               __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);
           }
       }
       else     {
     // insert by shifting things forward
        if (__back_spare() == 0)             __add_back_capacity();
           // __back_capacity >= 1
        size_type __de = __base::size() - __pos;
           if (__de == 0)         {
               __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::forward<_Args>(__args)...);
               ++__base::size();
           }
           else         {
               __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);
               iterator __e = __base::end();
               iterator __em1 = _VSTD::prev(__e);
               __alloc_traits::construct(__a, _VSTD::addressof(*__e), _VSTD::move(*__em1));
               ++__base::size();
               if (__de > 1)                 __e = _VSTD::move_backward(__e - __de, __em1, __e);
               *--__e = _VSTD::move(__tmp.get());
           }
       }
       return __base::begin() + __pos;
   }
      
#endif  // _LIBCPP_CXX03_LANG
  template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(const_iterator __p, const value_type& __v) {
       size_type __pos = __p - __base::begin();
       size_type __to_end = __base::size() - __pos;
       allocator_type& __a = __base::__alloc();
       if (__pos < __to_end)     {
     // insert by shifting things backward
        if (__front_spare() == 0)             __add_front_capacity();
           // __front_spare() >= 1
        if (__pos == 0)         {
               __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), __v);
               --__base::__start_;
               ++__base::size();
           }
           else         {
               const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
               iterator __b = __base::begin();
               iterator __bm1 = _VSTD::prev(__b);
               if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))                 __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);
               __alloc_traits::construct(__a, _VSTD::addressof(*__bm1), _VSTD::move(*__b));
               --__base::__start_;
               ++__base::size();
               if (__pos > 1)                 __b = __move_and_check(_VSTD::next(__b), __b + __pos, __b, __vt);
               *__b = *__vt;
           }
       }
       else     {
     // insert by shifting things forward
        if (__back_spare() == 0)             __add_back_capacity();
           // __back_capacity >= 1
       }
       return __base::begin() + __pos;
   }
    template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n, const value_type& __v) {
       size_type __pos = __p - __base::begin();
       size_type __to_end = __base::size() - __pos;
       allocator_type& __a = __base::__alloc();
       if (__pos < __to_end)     {
     // insert by shifting things backward
        if (__n > __front_spare())             __add_front_capacity(__n - __front_spare());
           // __n <= __front_spare()
        iterator __old_begin = __base::begin();
           iterator __i = __old_begin;
           if (__n > __pos)         {
               for (size_type __m = __n - __pos;
   __m;
   --__m, --__base::__start_, ++__base::size())                 __alloc_traits::construct(__a, _VSTD::addressof(*--__i), __v);
               __n = __pos;
           }
           if (__n > 0)         {
               const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
               iterator __obn = __old_begin + __n;
               __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);
               if (__n < __pos)                 __old_begin = __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);
               _VSTD::fill_n(__old_begin, __n, *__vt);
           }
       }
       else     {
     // insert by shifting things forward
        size_type __back_capacity = __back_spare();
           if (__n > __back_capacity)             __add_back_capacity(__n - __back_capacity);
           // __n <= __back_capacity
        iterator __old_end = __base::end();
           iterator __i = __old_end;
           size_type __de = __base::size() - __pos;
           if (__n > __de)         {
               for (size_type __m = __n - __de;
   __m;
   --__m, ++__i, ++__base::size())                 __alloc_traits::construct(__a, _VSTD::addressof(*__i), __v);
               __n = __de;
           }
           if (__n > 0)         {
               const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
               iterator __oen = __old_end - __n;
               __move_construct_and_check(__oen, __old_end, __i, __vt);
               if (__n < __de)                 __old_end = __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);
               _VSTD::fill_n(__old_end - __n, __n, *__vt);
           }
       }
       return __base::begin() + __pos;
   }
    template <class _Tp, class _Allocator> template <class _InputIter> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(const_iterator __p, _InputIter __f, _InputIter __l,                                typename enable_if<__is_input_iterator<_InputIter>::value                                                &&!__is_forward_iterator<_InputIter>::value>::type*) {
       __split_buffer<value_type, allocator_type&> __buf(__base::__alloc());
       typedef typename __split_buffer<value_type, allocator_type&>::iterator __fwd;
       return insert(__p, move_iterator<__fwd>(__buf.begin()), move_iterator<__fwd>(__buf.end()));
   }
    template <class _Tp, class _Allocator> template <class _BiIter> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(const_iterator __p, _BiIter __f, _BiIter __l,                                typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type*) {
       size_type __n = _VSTD::distance(__f, __l);
       size_type __pos = __p - __base::begin();
       size_type __to_end = __base::size() - __pos;
       allocator_type& __a = __base::__alloc();
       if (__pos < __to_end)     {
     // insert by shifting things backward
        if (__n > __front_spare())             __add_front_capacity(__n - __front_spare());
           // __n <= __front_spare()
        iterator __old_begin = __base::begin();
           iterator __i = __old_begin;
           _BiIter __m = __f;
           if (__n > __pos)         {
               __m = __pos < __n / 2 ? _VSTD::prev(__l, __pos) : _VSTD::next(__f, __n - __pos);
               for (_BiIter __j = __m;
   __j != __f;
   --__base::__start_, ++__base::size())                 __alloc_traits::construct(__a, _VSTD::addressof(*--__i), *--__j);
               __n = __pos;
           }
           if (__n > 0)         {
               iterator __obn = __old_begin + __n;
               for (iterator __j = __obn;
   __j != __old_begin;
  )             {
                   __alloc_traits::construct(__a, _VSTD::addressof(*--__i), _VSTD::move(*--__j));
                   --__base::__start_;
                   ++__base::size();
               }
               if (__n < __pos)                 __old_begin = _VSTD::move(__obn, __old_begin + __pos, __old_begin);
               _VSTD::copy(__m, __l, __old_begin);
           }
       }
       else     {
     // insert by shifting things forward
        size_type __back_capacity = __back_spare();
           if (__n > __back_capacity)             __add_back_capacity(__n - __back_capacity);
           // __n <= __back_capacity
        iterator __old_end = __base::end();
           iterator __i = __old_end;
           _BiIter __m = __l;
           size_type __de = __base::size() - __pos;
           if (__n > __de)         {
               __m = __de < __n / 2 ? _VSTD::next(__f, __de) : _VSTD::prev(__l, __n - __de);
               for (_BiIter __j = __m;
   __j != __l;
   ++__i, (void) ++__j, ++__base::size())                 __alloc_traits::construct(__a, _VSTD::addressof(*__i), *__j);
               __n = __de;
           }
           if (__n > 0)         {
               iterator __oen = __old_end - __n;
               for (iterator __j = __oen;
   __j != __old_end;
   ++__i, ++__j, ++__base::size())                 __alloc_traits::construct(__a, _VSTD::addressof(*__i), _VSTD::move(*__j));
               if (__n < __de)                 __old_end = _VSTD::move_backward(__old_end - __de, __oen, __old_end);
               _VSTD::copy_backward(__f, __m, __old_end);
           }
       }
       return __base::begin() + __pos;
   }
    template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__append(size_type __n) {
       allocator_type& __a = __base::__alloc();
       size_type __back_capacity = __back_spare();
       if (__n > __back_capacity)         __add_back_capacity(__n - __back_capacity);
       // __n <= __back_capacity
    for (iterator __i = __base::end();
   __n;
   --__n, ++__i, ++__base::size())         __alloc_traits::construct(__a, _VSTD::addressof(*__i));
   }
    template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__append(size_type __n, const value_type& __v) {
       allocator_type& __a = __base::__alloc();
       size_type __back_capacity = __back_spare();
       if (__n > __back_capacity)         __add_back_capacity(__n - __back_capacity);
       // __n <= __back_capacity
    for (iterator __i = __base::end();
   __n;
   --__n, ++__i, ++__base::size())         __alloc_traits::construct(__a, _VSTD::addressof(*__i), __v);
   }
    // Create front capacity for one block of elements.
// Strong guarantee.  Either do it or don't touch anything.
template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__add_front_capacity() {
       allocator_type& __a = __base::__alloc();
       if (__back_spare() >= __base::__block_size)     {
        // until all buffers are allocated.  If we throw, we don't need to fix
        // anything up (any added buffers are undetectible)
        if (__base::__map_.__front_spare() > 0)             __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));
           else         {
               __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
               // Done allocating, reorder capacity
            pointer __pt = __base::__map_.back();
               __base::__map_.pop_back();
               __base::__map_.push_front(__pt);
           }
           __base::__start_ = __base::__map_.size() == 1 ?                                __base::__block_size / 2 :                                __base::__start_ + __base::__block_size;
       }
       // Else need to allocate 1 buffer, *and* we need to reallocate __map_.
    else     {
           __split_buffer<pointer, typename __base::__pointer_allocator&>             __buf(max<size_type>(2 * __base::__map_.capacity(), 1),                   0, __base::__map_.__alloc());
           _VSTD::swap(__base::__map_.__first_, __buf.__first_);
           _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);
           _VSTD::swap(__base::__map_.__end_, __buf.__end_);
           _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());
           __base::__start_ = __base::__map_.size() == 1 ?                                __base::__block_size / 2 :                                __base::__start_ + __base::__block_size;
       }
   }
    // Create front capacity for __n elements.
// Strong guarantee.  Either do it or don't touch anything.
template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__add_front_capacity(size_type __n) {
       allocator_type& __a = __base::__alloc();
       size_type __nb = __recommend_blocks(__n + __base::__map_.empty());
       // Number of unused blocks at back:
    size_type __back_capacity = __back_spare() / __base::__block_size;
       __back_capacity = _VSTD::min(__back_capacity, __nb);
    // don't take more than you need
    __nb -= __back_capacity;
    // number of blocks need to allocate
    // If __nb == 0, then we have sufficient capacity.
    if (__nb == 0)     {
           __base::__start_ += __base::__block_size * __back_capacity;
           for (;
   __back_capacity > 0;
   --__back_capacity)         {
           }
           for (;
   __nb > 0;
   --__nb, ++__back_capacity)             __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));
           // Done allocating, reorder capacity
        __base::__start_ += __back_capacity * __base::__block_size;
           for (;
   __back_capacity > 0;
   --__back_capacity)         {
               pointer __pt = __base::__map_.back();
               __base::__map_.pop_back();
               __base::__map_.push_front(__pt);
           }
       }
       // Else need to allocate __nb buffers, *and* we need to reallocate __map_.
    else     {
           size_type __ds = (__nb + __back_capacity) * __base::__block_size - __base::__map_.empty();
           __split_buffer<pointer, typename __base::__pointer_allocator&>             __buf(max<size_type>(2* __base::__map_.capacity(),                                  __nb + __base::__map_.size()),                   0, __base::__map_.__alloc());
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            for (;
   __nb > 0;
   --__nb)                 __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
               for (typename __base::__map_pointer __i = __buf.begin();
                       __i != __buf.end();
   ++__i)                 __alloc_traits::deallocate(__a, *__i, __base::__block_size);
               throw;
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        for (;
   __back_capacity > 0;
   --__back_capacity)         {
               __buf.push_back(__base::__map_.back());
               __base::__map_.pop_back();
           }
           for (typename __base::__map_pointer __i = __base::__map_.begin();
                   __i != __base::__map_.end();
   ++__i)             __buf.push_back(*__i);
       }
   }
    // Create back capacity for __n elements.
// Strong guarantee.  Either do it or don't touch anything.
template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__add_back_capacity(size_type __n) {
       allocator_type& __a = __base::__alloc();
       size_type __nb = __recommend_blocks(__n + __base::__map_.empty());
       // Number of unused blocks at front:
    size_type __front_capacity = __front_spare() / __base::__block_size;
       __front_capacity = _VSTD::min(__front_capacity, __nb);
    // don't take more than you need
    __nb -= __front_capacity;
    // number of blocks need to allocate
    // If __nb == 0, then we have sufficient capacity.
    if (__nb == 0)     {
           __base::__start_ -= __base::__block_size * __front_capacity;
       }
       // Else need to allocate __nb buffers, *and* we need to reallocate __map_.
    else     {
           size_type __ds = __front_capacity * __base::__block_size;
           __split_buffer<pointer, typename __base::__pointer_allocator&>             __buf(max<size_type>(2* __base::__map_.capacity(),                                  __nb + __base::__map_.size()),                   __base::__map_.size() - __front_capacity,                   __base::__map_.__alloc());
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            for (;
   __nb > 0;
   --__nb)                 __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
               for (typename __base::__map_pointer __i = __buf.begin();
                       __i != __buf.end();
   ++__i)                 __alloc_traits::deallocate(__a, *__i, __base::__block_size);
               throw;
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        for (;
   __front_capacity > 0;
   --__front_capacity)         {
               __buf.push_back(__base::__map_.front());
               __base::__map_.pop_front();
           }
           for (typename __base::__map_pointer __i = __base::__map_.end();
                   __i != __base::__map_.begin();
  )             __buf.push_front(*--__i);
           _VSTD::swap(__base::__map_.__first_, __buf.__first_);
           _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);
           _VSTD::swap(__base::__map_.__end_, __buf.__end_);
           _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());
           __base::__start_ -= __ds;
           __base::__map_.pop_front();
           __base::__start_ -= __base::__block_size;
       }
   }
    template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::pop_back() {
       allocator_type& __a = __base::__alloc();
       size_type __p = __base::size() + __base::__start_ - 1;
       __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +                                                     __p / __base::__block_size) +                                                     __p % __base::__block_size));
       --__base::size();
       if (__back_spare() >= 2 * __base::__block_size)     {
           __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
           __base::__map_.pop_back();
       }
   }
    // move assign [__f, __l) to [__r, __r + (__l-__f)).
// If __vt points into [__f, __l), then subtract (__f - __r) from __vt.
template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l, iterator __r,                                          const_pointer& __vt) {
       // as if
    //   for (; __f != __l; ++__f, ++__r)
    //       *__r = _VSTD::move(*__f);
    difference_type __n = __l - __f;
       while (__n > 0)     {
           pointer __fb = __f.__ptr_;
           pointer __fe = *__f.__m_iter_ + __base::__block_size;
           difference_type __bs = __fe - __fb;
           if (__bs > __n)         {
               __bs = __n;
               __fe = __fb + __bs;
           }
           if (__fb <= __vt && __vt < __fe)             __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;
           __r = _VSTD::move(__fb, __fe, __r);
           __n -= __bs;
           __f += __bs;
       }
       return __r;
   }
    // move assign [__f, __l) to [__r - (__l-__f), __r) backwards.
// If __vt points into [__f, __l), then add (__r - __l) to __vt.
template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l, iterator __r,                                                   const_pointer& __vt) {
       // as if
    //   while (__f != __l)
    //       *--__r = _VSTD::move(*--__l);
    difference_type __n = __l - __f;
       while (__n > 0)     {
           --__l;
           pointer __lb = *__l.__m_iter_;
           pointer __le = __l.__ptr_ + 1;
           difference_type __bs = __le - __lb;
           if (__bs > __n)         {
               __bs = __n;
               __lb = __le - __bs;
           }
           if (__lb <= __vt && __vt < __le)             __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;
           __r = _VSTD::move_backward(__lb, __le, __r);
           __n -= __bs;
           __l -= __bs - 1;
       }
       return __r;
   }
    // move construct [__f, __l) to [__r, __r + (__l-__f)).
// If __vt points into [__f, __l), then add (__r - __f) to __vt.
template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__move_construct_and_check(iterator __f, iterator __l,                                                    iterator __r, const_pointer& __vt) {
       allocator_type& __a = __base::__alloc();
       // as if
    //   for (; __f != __l; ++__r, ++__f, ++__base::size())
    //       __alloc_traits::construct(__a, _VSTD::addressof(*__r), _VSTD::move(*__f));
    difference_type __n = __l - __f;
       while (__n > 0)     {
           pointer __fb = __f.__ptr_;
           pointer __fe = *__f.__m_iter_ + __base::__block_size;
           difference_type __bs = __fe - __fb;
           if (__bs > __n)         {
               __bs = __n;
               __fe = __fb + __bs;
           }
           if (__fb <= __vt && __vt < __fe)             __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;
           for (;
   __fb != __fe;
   ++__fb, ++__r, ++__base::size())             __alloc_traits::construct(__a, _VSTD::addressof(*__r), _VSTD::move(*__fb));
           __n -= __bs;
           __f += __bs;
       }
   }
    // move construct [__f, __l) to [__r - (__l-__f), __r) backwards.
// If __vt points into [__f, __l), then subtract (__l - __r) from __vt.
template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__move_construct_backward_and_check(iterator __f, iterator __l,                                                             iterator __r, const_pointer& __vt) {
       allocator_type& __a = __base::__alloc();
       // as if
    //   for (iterator __j = __l; __j != __f;)
    //   {
    //       __alloc_traitsconstruct(__a, _VSTD::addressof(*--__r), _VSTD::move(*--__j));
    //       --__base::__start_;
    //       ++__base::size();
    //   }
    difference_type __n = __l - __f;
       while (__n > 0)     {
           --__l;
           pointer __lb = *__l.__m_iter_;
           pointer __le = __l.__ptr_ + 1;
           difference_type __bs = __le - __lb;
           if (__bs > __n)         {
               __bs = __n;
               __lb = __le - __bs;
           }
           if (__lb <= __vt && __vt < __le)             __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;
           while (__le != __lb)         {
               __alloc_traits::construct(__a, _VSTD::addressof(*--__r), _VSTD::move(*--__le));
               --__base::__start_;
               ++__base::size();
           }
           __n -= __bs;
           __l -= __bs - 1;
       }
   }
    template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::erase(const_iterator __f) {
       iterator __b = __base::begin();
       difference_type __pos = __f - __b;
       iterator __p = __b + __pos;
       allocator_type& __a = __base::__alloc();
       if (static_cast<size_t>(__pos) <= (__base::size() - 1) / 2)     {
     // erase from front
        _VSTD::move_backward(__b, __p, _VSTD::next(__p));
           __alloc_traits::destroy(__a, _VSTD::addressof(*__b));
           --__base::size();
           ++__base::__start_;
           if (__front_spare() >= 2 * __base::__block_size)         {
               __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
               __base::__map_.pop_front();
               __base::__start_ -= __base::__block_size;
               __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
               __base::__map_.pop_back();
           }
       }
       return __base::begin() + __pos;
   }
    template <class _Tp, class _Allocator> typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l) {
       difference_type __n = __l - __f;
       iterator __b = __base::begin();
       difference_type __pos = __f - __b;
       iterator __p = __b + __pos;
       if (__n > 0)     {
           allocator_type& __a = __base::__alloc();
           if (static_cast<size_t>(__pos) <= (__base::size() - __n) / 2)         {
     // erase from front
            iterator __i = _VSTD::move_backward(__b, __p, __p + __n);
               for (;
   __b != __i;
   ++__b)                 __alloc_traits::destroy(__a, _VSTD::addressof(*__b));
               __base::size() -= __n;
               __base::__start_ += __n;
               while (__front_spare() >= 2 * __base::__block_size)             {
                   __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);
                   __base::__map_.pop_front();
                   __base::__start_ -= __base::__block_size;
               }
           }
           else         {
     // erase from back
            iterator __i = _VSTD::move(__p + __n, __base::end(), __p);
               for (iterator __e = __base::end();
   __i != __e;
   ++__i)                 __alloc_traits::destroy(__a, _VSTD::addressof(*__i));
               __base::size() -= __n;
               while (__back_spare() >= 2 * __base::__block_size)             {
                   __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
                   __base::__map_.pop_back();
               }
           }
       }
       return __base::begin() + __pos;
   }
    template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::__erase_to_end(const_iterator __f) {
       iterator __e = __base::end();
       difference_type __n = __e - __f;
       if (__n > 0)     {
           allocator_type& __a = __base::__alloc();
           iterator __b = __base::begin();
           difference_type __pos = __f - __b;
           for (iterator __p = __b + __pos;
   __p != __e;
   ++__p)             __alloc_traits::destroy(__a, _VSTD::addressof(*__p));
           __base::size() -= __n;
           while (__back_spare() >= 2 * __base::__block_size)         {
               __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);
               __base::__map_.pop_back();
           }
       }
   }
    template <class _Tp, class _Allocator> inline void deque<_Tp, _Allocator>::swap(deque& __c)   
#if _LIBCPP_STD_VER >= 14
        _NOEXCEPT   
#else
        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||                      __is_nothrow_swappable<allocator_type>::value)   
#endif
{
       __base::swap(__c);
   }
    template <class _Tp, class _Allocator> inline void deque<_Tp, _Allocator>::clear() _NOEXCEPT {
       __base::clear();
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
       const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();
       return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
       return !(__x == __y);
       return !(__x < __y);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator<=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
       return !(__y < __x);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(deque<_Tp, _Allocator>& __x, deque<_Tp, _Allocator>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_DEQUE
  
#pragma clang module end /*std.deque*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "exception"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.exception
// -*- C++ -*-
//===-------------------------- exception ---------------------------------===//
//
#ifndef _LIBCPP_EXCEPTION
  
#define _LIBCPP_EXCEPTION
 /*     exception synopsis  namespace std {
    class exception {
   public:     exception() noexcept;
       exception(const exception&) noexcept;
       exception& operator=(const exception&) noexcept;
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
#ifndef _LIBCPP_NO_EXCEPTIONS
    try     {
           throw __e;
       }
       catch (...)     {
           return current_exception();
       }
     
  
#endif
public:     exception_ptr() _NOEXCEPT;
       exception_ptr(nullptr_t) _NOEXCEPT;
       exception_ptr(const exception_ptr& __other) _NOEXCEPT;
       exception_ptr& operator=(const exception_ptr& __other) _NOEXCEPT;
       exception_ptr& operator=(nullptr_t) _NOEXCEPT;
       ~exception_ptr() _NOEXCEPT;
   }
      
#endif // _LIBCPP_ABI_MICROSOFT
// nested_exception
 class _LIBCPP_EXCEPTION_ABI nested_exception {
       exception_ptr __ptr_;
   public:     nested_exception() _NOEXCEPT;
   //     nested_exception(const nested_exception&) noexcept = default;
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_INITIALIZER_LIST
  
#define _LIBCPP_INITIALIZER_LIST
 /*     initializer_list synopsis  namespace std {
};
    template<class E> const E* begin(initializer_list<E> il) noexcept;
   // constexpr in C++14
template<class E> const E* end(initializer_list<E> il) noexcept;
   // constexpr in C++14
 }
    // std
 */
#if 0 /* expanded by -frewrite-includes */
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstring>
  
     
#else
    return *__value;
     
#endif
}
    template <class _ValueType> inline _LIBCPP_ALWAYS_INLINE _ValueType __libcpp_acquire_load(_ValueType const* __value) {
     
       typedef const void        value_type;
        template <class _Up> struct rebind {
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
 template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true> {
     
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;
    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;
     
#else
    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;
     
#endif
};
    template <template <class, class, class, class> class _Sp, class _Tp, class _A0,                                                 class _A1, class _A2, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false> {
       template<class _Yp>         typename enable_if         <             is_convertible<_Yp*, element_type*>::value,             weak_ptr&         >::type         _LIBCPP_INLINE_VISIBILITY         operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;
      
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
     template<class _Yp>         typename enable_if         <             is_convertible<_Yp*, element_type*>::value,             weak_ptr&         >::type         _LIBCPP_INLINE_VISIBILITY         operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     void swap(weak_ptr& __r) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     void reset() _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     long use_count() const _NOEXCEPT         {
  return __cntrl_ ? __cntrl_->use_count() : 0;
       catch (...)     {
       }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    if (__owns_eb_)         delete [] __extbuf_;
       if (__owns_ib_)         delete [] __intbuf_;
   }
    template <class _CharT, class _Traits> void basic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs) {
       return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
   }
    template <class _CharT, class _Traits> inline bool basic_ofstream<_CharT, _Traits>::is_open() const {
       return __sb_.is_open();
   }
      
#ifndef _LIBCPP_HAS_NO_GLOBAL_FILESYSTEM_NAMESPACE
#ifndef _LIBCPP_NO_EXCEPTIONS
    typedef typename decay<_Tp>::type _Up;
       static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
       __throw_with_nested<_Tp, _Up,         is_class<_Up>::value &&         !is_base_of<nested_exception, _Up>::value &&         !__libcpp_is_final<_Up>::value>::             __do_throw(_VSTD::forward<_Tp>(__t));
     
#else
    ((void)__t);
       // FIXME: Make this abort
  
#endif
}
    template <class _From, class _To> struct __can_dynamic_cast : public _LIBCPP_BOOL_CONSTANT(               is_polymorphic<_From>::value &&                  (!is_base_of<_To, _From>::value ||                    is_convertible<const _From*, const _To*>::value)) {
  };
    template <class _Ep> inline _LIBCPP_INLINE_VISIBILITY void rethrow_if_nested(const _Ep& __e,                   typename enable_if< __can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0) {
       const nested_exception* __nep = dynamic_cast<const nested_exception*>(_VSTD::addressof(__e));
       if (__nep)         __nep->rethrow_nested();
   }
    template <class _Ep> inline _LIBCPP_INLINE_VISIBILITY void rethrow_if_nested(const _Ep&,                   typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type* = 0) {
   }
    }
    // std
   
#endif  // _LIBCPP_EXCEPTION
  
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_MUTEX
  
#define _LIBCPP_MUTEX
 /*     mutex synopsis  namespace std {
#endif  // _LIBCPP_CHRONO
  
#pragma clang module end /*std.chrono*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__mutex_base>
  
#if 0 /* expanded by -frewrite-includes */
  
#include <chrono>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
  
#endif /* expanded by -frewrite-includes */
    
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
#  ifdef _LIBCPP_HAS_THREAD_SAFETY_ANNOTATIONS
  
#    define _LIBCPP_THREAD_SAFETY_ANNOTATION(x) __attribute__((x))
  
#  else
  
#    define _LIBCPP_THREAD_SAFETY_ANNOTATION(x)
  
#  endif
  
#endif  // _LIBCPP_THREAD_SAFETY_ANNOTATION
     steady_clock::time_point __c_now = steady_clock::now();
       system_clock::time_point __s_now = system_clock::now();
       if (_Max - __d > __s_now)         __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
       else         __do_timed_wait(__lk, __sys_tpi::max());
       return steady_clock::now() - __c_now < __d ? cv_status::no_timeout :                                                  cv_status::timeout;
  
#define _LIBCPP_TUPLE
 /*     tuple synopsis  namespace std {
    template <class... T> class tuple {
   public:     constexpr tuple();
       explicit tuple(const T&...);
    // constexpr in C++14
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#   include <exception>
  
#endif /* expanded by -frewrite-includes */
  
#endif
  
#ifndef _LIBCPP_DEBUG_MODE
  
#define _LIBCPP_DEBUG_MODE(...) ((void)0)
  
#endif
#if _LIBCPP_DEBUG_LEVEL >= 1 && defined(_LIBCPP_DEBUG_USE_EXCEPTIONS)
  
# if defined(_LIBCPP_NO_EXCEPTIONS)
  
#   error _LIBCPP_DEBUG_USE_EXCEPTIONS cannot be used when exceptions are disabled.
  
# endif
       _PairPtr __pp(new _InvokePair(__f));
       int __ec = __libcpp_thread_create(&__t_, &__thread_proxy_cxx03<_InvokePair>, __pp.get());
       if (__ec == 0)         __pp.release();
       else         __throw_system_error(__ec, "thread constructor failed");
   }
      
#endif  // _LIBCPP_CXX03_LANG
 inline _LIBCPP_INLINE_VISIBILITY void swap(thread& __x, thread& __y) _NOEXCEPT {
       promise& operator=(const promise& __rhs) = delete;
     
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
private:     promise& operator=(const promise& __rhs);
   public:   
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    _LIBCPP_INLINE_VISIBILITY     void swap(promise& __rhs) _NOEXCEPT {
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
       return __quoted_output_proxy<_CharT,             typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>                     ( __s.cbegin(), __s.cend (), __delim, __escape );
   }
    template <class _CharT, class _Traits, class _Allocator> _LIBCPP_INLINE_VISIBILITY __quoted_proxy<_CharT, _Traits, _Allocator> __quoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\')) {
       return __quoted_proxy<_CharT, _Traits, _Allocator>( __s, __delim, __escape );
   }
       
#if _LIBCPP_STD_VER > 11
 template <class _CharT, class _Traits, class _Allocator> _LIBCPP_INLINE_VISIBILITY __quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator> quoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\')) {
     
#endif
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_IOMANIP
  
#pragma clang module end /*std.iomanip*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "ios"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.ios
// -*- C++ -*-
   
#ifndef _LIBCPP_IOS
  
#define _LIBCPP_IOS
 /*     ios synopsis    
#include <iosfwd>
 namespace std {
    typedef OFF_T streamoff;
    storage-class-specifier const error_category& iostream_category() noexcept;
    }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
template <> struct _LIBCPP_TEMPLATE_VIS is_error_code_enum<io_errc::__lx> : public true_type {
   };
     
#endif
 _LIBCPP_FUNC_VIS const error_category& iostream_category() _NOEXCEPT;
    inline _LIBCPP_INLINE_VISIBILITY error_code make_error_code(io_errc __e) _NOEXCEPT {
       return error_code(static_cast<int>(__e), iostream_category());
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_IOS
  
#define _LIBCPP_IOS
 /*     ios synopsis    
#include <iosfwd>
 namespace std {
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__locale>
  
#endif /* expanded by -frewrite-includes */
  
       return __os << __p.get();
   }
    template <class _CharT, class _Traits, size_t _Size> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x) {
       return __os << __x.template to_string<_CharT, _Traits>                         (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),                          use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
   }
      
#ifndef _LIBCPP_AVAILABILITY_NO_STREAMS_EXTERN_TEMPLATE
_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<char>) _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS basic_ostream<wchar_t>)   
#endif
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_OSTREAM
  
#pragma clang module end /*std.ostream*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD    
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_IOSTREAM
  
#pragma clang module end /*std.iostream*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "istream"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.istream
// -*- C++ -*-
//===--------------------------- istream ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ISTREAM
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
    try     {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        sentry __s(*this);
           if (__s)         {
               typedef istreambuf_iterator<char_type, traits_type> _Ip;
               typedef num_get<char_type, _Ip> _Fp;
               ios_base::iostate __err = ios_base::goodbit;
#endif  // _LIBCPP_LOCALE
  
#pragma clang module end /*std.locale*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "map"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.map
// -*- C++ -*-
//===----------------------------- map ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_MAP
  
#define _LIBCPP_MAP
 /*      map synopsis  namespace std {
    template <class Key, class T, class Compare = less<Key>,           class Allocator = allocator<pair<const Key, T>>> class map {
   public:     // types:
    typedef Key                                      key_type;
       typedef T                                        mapped_type;
       typedef pair<const key_type, mapped_type>        value_type;
       typedef Compare                                  key_compare;
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__tree
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP___TREE
  
  
#pragma clang module begin std.iterator
// -*- C++ -*-
//===-------------------------- iterator ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_ITERATOR
  
#define _LIBCPP_ITERATOR
 /*     iterator synopsis  namespace std {
    template<class Iterator> struct iterator_traits {
       typedef typename Iterator::difference_type difference_type;
       typedef typename Iterator::value_type value_type;
       typedef typename Iterator::pointer pointer;
       typedef typename Iterator::reference reference;
       typedef typename Iterator::iterator_category iterator_category;
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <initializer_list>
  
#endif /* expanded by -frewrite-includes */
  
#ifdef __APPLE__
  
#if 0 /* expanded by -frewrite-includes */
  
#include <Availability.h>
  
#endif /* expanded by -frewrite-includes */
  
#endif
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__debug>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
               ++__first1;
           }
       }
       return _VSTD::copy(__first2, __last2, __result);
   }
    template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_union(_InputIterator1 __first1, _InputIterator1 __last1,           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {
     
#ifdef _LIBCPP_DEBUG
     
#endif  // _LIBCPP_DEBUG
}
    template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,                  _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) {
       return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,                                   __less<typename iterator_traits<_InputIterator1>::value_type,                                          typename iterator_traits<_InputIterator2>::value_type>());
   }
    // set_difference
 template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,                  _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {
   }
    template <class _BidirectionalIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
     
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
       __debug_less<_Compare> __c(__comp);
       return __prev_permutation<_Comp_ref>(__first, __last, __c);
     
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
       return __prev_permutation<_Comp_ref>(__first, __last, __comp);
     
#endif  // _LIBCPP_DEBUG
}
    template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) {
       return _VSTD::prev_permutation(__first, __last,                                   __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_ALGORITHM
  
#pragma clang module end /*std.algorithm*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
//
//===----------------------------------------------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max")   
#else
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Tp, class _Compare, class _Allocator> class __tree;
   template <class _Tp, class _NodePtr, class _DiffType>     class _LIBCPP_TEMPLATE_VIS __tree_iterator;
   template <class _Tp, class _ConstNodePtr, class _DiffType>     class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;
    template <class _Pointer> class __tree_end_node;
   template <class _VoidPtr> class __tree_node_base;
   template <class _Tp, class _VoidPtr> class __tree_node;
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Value> union __value_type;
     
#else
template <class _Key, class _Value> struct __value_type;
     
#endif
 template <class _Key, class _CP, class _Compare,     bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value> class __map_value_compare;
    template <class _Allocator> class __map_node_destructor;
   template <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_iterator;
   template <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_const_iterator;
    /*  _NodePtr algorithms  The algorithms taking _NodePtr are red black tree algorithms.  Those algorithms taking a parameter named __root should assume that __root points to a proper red black tree (unless otherwise specified).  Each algorithm herein assumes that __root->__parent_ points to a non-null structure which has a member __left_ which points back to __root.  No other member is read or written to at __root->__parent_.  __root->__parent_ will be referred to below (in comments only) as end_node. end_node->__left_ is an externably accessible lvalue for __root, and can be changed by node insertion and removal (without explicit reference to end_node).  All nodes (with the exception of end_node), even the node referred to as __root, have a non-null __parent_ field.  */
 // Returns:  true if __x is a left child of its parent, else false
// Precondition:  __x != nullptr.
template <class _NodePtr> inline _LIBCPP_INLINE_VISIBILITY bool __tree_is_left_child(_NodePtr __x) _NOEXCEPT {
       return __x == __x->__parent_->__left_;
   }
    // Determines if the subtree rooted at __x is a proper red black subtree.  If
//    __x is a proper subtree, returns the black height (null counts as 1).  If
//    __x is an improper subtree, returns 0.
template <class _NodePtr> unsigned __tree_sub_invariant(_NodePtr __x) {
       if (__x == nullptr)         return 1;
       // If this is red, neither child can be red
    if (!__x->__is_black_)     {
           if (__x->__left_ && !__x->__left_->__is_black_)             return 0;
           if (__x->__right_ && !__x->__right_->__is_black_)             return 0;
       }
       unsigned __h = __tree_sub_invariant(__x->__left_);
       if (__h == 0)         return 0;
    // invalid left subtree
    if (__h != __tree_sub_invariant(__x->__right_))         return 0;
    // invalid or different height right subtree
    return __h + __x->__is_black_;
    // return black height of this node
}
    // Determines if the red black tree rooted at __root is a proper red black tree.
//    __root == nullptr is a proper tree.  Returns true is __root is a proper
//    red black tree, else returns false.
template <class _NodePtr> bool __tree_invariant(_NodePtr __root) {
       if (__root == nullptr)         return true;
       // check __x->__parent_ consistency
    if (__root->__parent_ == nullptr)         return false;
       if (!__tree_is_left_child(__root))         return false;
       // root must be black
    if (!__root->__is_black_)         return false;
       // do normal node checks
   }
    // Returns:  pointer to the right-most node under __x.
// Precondition:  __x != nullptr.
template <class _NodePtr> inline _LIBCPP_INLINE_VISIBILITY _NodePtr __tree_max(_NodePtr __x) _NOEXCEPT {
       while (__x->__right_ != nullptr)         __x = __x->__right_;
       return __x;
   }
    // Returns:  pointer to the next in-order node after __x.
// Precondition:  __x != nullptr.
template <class _NodePtr> _NodePtr __tree_next(_NodePtr __x) _NOEXCEPT {
       if (__x->__right_ != nullptr)         return __tree_min(__x->__right_);
       while (!__tree_is_left_child(__x))         __x = __x->__parent_unsafe();
       return __x->__parent_unsafe();
   }
    template <class _EndNodePtr, class _NodePtr> inline _LIBCPP_INLINE_VISIBILITY _EndNodePtr __tree_next_iter(_NodePtr __x) _NOEXCEPT {
       if (__x->__right_ != nullptr)         return static_cast<_EndNodePtr>(__tree_min(__x->__right_));
       while (true)     {
           if (__x->__left_ != nullptr)         {
               __x = __x->__left_;
               continue;
           }
           if (__x->__right_ != nullptr)         {
               __x = __x->__right_;
               continue;
           }
           break;
       }
       return __x;
   }
    // Effects:  Makes __x->__right_ the subtree root with __x as its left child
//           while preserving in-order order.
// Precondition:  __x->__right_ != nullptr
template <class _NodePtr> void __tree_left_rotate(_NodePtr __x) _NOEXCEPT {
       _NodePtr __y = __x->__right_;
       __x->__right_ = __y->__left_;
       if (__x->__right_ != nullptr)         __x->__right_->__set_parent(__x);
       __y->__parent_ = __x->__parent_;
       if (__tree_is_left_child(__x))         __x->__parent_->__left_ = __y;
       else         __x->__parent_unsafe()->__right_ = __y;
       __y->__left_ = __x;
       __x->__left_ = __y->__right_;
       if (__x->__left_ != nullptr)         __x->__left_->__set_parent(__x);
       __y->__parent_ = __x->__parent_;
       if (__tree_is_left_child(__x))         __x->__parent_->__left_ = __y;
       else         __x->__parent_unsafe()->__right_ = __y;
       __y->__right_ = __x;
       __x->__set_parent(__y);
   }
//                may be different than the value passed in as __root.
template <class _NodePtr> void __tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT {
       __x->__is_black_ = __x == __root;
       while (__x != __root && !__x->__parent_unsafe()->__is_black_)     {
           // __x->__parent_ != __root because __x->__parent_->__is_black == false
        if (__tree_is_left_child(__x->__parent_unsafe()))         {
               _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
               if (__y != nullptr && !__y->__is_black_)             {
                   __x->__is_black_ = true;
                   __x = __x->__parent_unsafe();
                   __x->__is_black_ = __x == __root;
                   __y->__is_black_ = true;
               }
               else             {
                   if (__tree_is_left_child(__x))                 {
                       __x = __x->__parent_unsafe();
                       __tree_right_rotate(__x);
                   }
                   __x = __x->__parent_unsafe();
                   __x->__is_black_ = true;
                   __x = __x->__parent_unsafe();
                   __x->__is_black_ = false;
                   __tree_left_rotate(__x);
                   break;
               }
           }
       }
   }
    // Precondition:  __root != nullptr && __z != nullptr.
//                __tree_invariant(__root) == true.
//                __z == __root or == a direct or indirect child of __root.
// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.
// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_
//                nor any of its children refer to __z.  end_node->__left_
//                may be different than the value passed in as __root.
template <class _NodePtr> void __tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT {
       // __z will be removed from the tree.  Client still needs to destruct/deallocate it
    // __y is either __z, or if __z has two children, __tree_next(__z).
    // __y will have at most one child.
    // __y will be the initial hole in the tree (make the hole at a leaf)
    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?                     __z : __tree_next(__z);
       // __x is __y's possibly null single child
    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;
       // __w is __x's possibly null uncle (will become __x's sibling)
    _NodePtr __w = nullptr;
       // link __x to __y's parent, and find __w
    if (__y != __z)     {
           // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr
        __y->__parent_ = __z->__parent_;
           if (__tree_is_left_child(__z))             __y->__parent_->__left_ = __y;
           else             __y->__parent_unsafe()->__right_ = __y;
           __y->__left_ = __z->__left_;
           __y->__left_->__set_parent(__y);
           __y->__right_ = __z->__right_;
        // Since __y was black and only had one child (which __x points to), __x
        //   is either red with no children, else null, otherwise __y would have
        //   different black heights under left and right pointers.
        // if (__x == __root || __x != nullptr && !__x->__is_black_)
        if (__x != nullptr)             __x->__is_black_ = true;
           else         {
               //  Else __x isn't root, and is "doubly black", even though it may
            //     be null.  __w can not be null here, else the parent would
            //     see a black height >= 2 on the __x side and a black height
            //     of 1 on the __w side (__w must be a non-null black or a red
            //     with a non-null black child).
            while (true)             {
                   if (!__tree_is_left_child(__w))  // if x is left child
                {
                       if (!__w->__is_black_)                     {
                        __w = __tree_is_left_child(__x) ?                                     __x->__parent_unsafe()->__right_ :                                     __x->__parent_->__left_;
                           // continue;
                    }
                       else  // __w has a red child
                    {
                           if (__w->__left_ == nullptr || __w->__left_->__is_black_)                         {
                               // __w right child is non-null and red
                            __w->__right_->__is_black_ = true;
                               __w->__is_black_ = false;
                               __tree_left_rotate(__w);
                               // __w is known not to be root, so root hasn't changed
                            // reset sibling, and it still can't be null
                            __w = __w->__parent_unsafe();
                           }
                           // __w has a left red child, right child may be null
                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                           __w->__parent_unsafe()->__is_black_ = true;
                           __w->__left_->__is_black_ = true;
                           __tree_right_rotate(__w->__parent_unsafe());
                           break;
                       }
                   }
               }
           }
       }
   }
    // node traits
    
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp> struct __is_tree_value_type_imp : false_type {
  };
    template <class _Key, class _Value> struct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {
  };
    template <class ..._Args> struct __is_tree_value_type : false_type {
  };
    template <class _One> struct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {
  };
     
#endif
 template <class _Tp> struct __tree_key_value_types {
     typedef _Tp key_type;
     typedef _Tp __node_value_type;
     typedef _Tp __container_value_type;
     static const bool __is_map = false;
      _LIBCPP_INLINE_VISIBILITY   static key_type const& __get_key(_Tp const& __v) {
       return __v;
     }
     _LIBCPP_INLINE_VISIBILITY   static __container_value_type const& __get_value(__node_value_type const& __v) {
       return __v;
     }
     _LIBCPP_INLINE_VISIBILITY   static __container_value_type* __get_ptr(__node_value_type& __n) {
       return _VSTD::addressof(__n);
     }
      
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_INLINE_VISIBILITY   static  __container_value_type&& __move(__node_value_type& __v) {
       return _VSTD::move(__v);
     }
     
#endif
};
    template <class _Key, class _Tp> struct __tree_key_value_types<__value_type<_Key, _Tp> > {
     typedef _Key                                         key_type;
     typedef _Tp                                          mapped_type;
     typedef __value_type<_Key, _Tp>                      __node_value_type;
     typedef pair<const _Key, _Tp>                        __container_value_type;
     typedef pair<_Key, _Tp>                              __nc_value_type;
     typedef __container_value_type                       __map_value_type;
     static const bool __is_map = true;
      
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_INLINE_VISIBILITY   static  __nc_value_type&& __move(__node_value_type& __v) {
       return _VSTD::move(__v.__nc);
     }
     
#endif
};
    template <class _VoidPtr> struct __tree_node_base_types {
     typedef _VoidPtr                                               __void_pointer;
      typedef __tree_node_base<__void_pointer>                      __node_base_type;
     typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type                                                              __node_base_pointer;
      typedef __tree_end_node<__node_base_pointer>                  __end_node_type;
     typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type                                                              __end_node_pointer;
     
#if defined(_LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB)
  typedef __end_node_pointer __parent_pointer;
     
#else
  typedef typename conditional<       is_pointer<__end_node_pointer>::value,         __end_node_pointer,         __node_base_pointer>::type __parent_pointer;
     
#endif
 private:   static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),                   "_VoidPtr does not point to unqualified void type");
   };
    template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,          bool = _KVTypes::__is_map> struct __tree_map_pointer_types {
  };
    template <class _Tp, class _AllocPtr, class _KVTypes> struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
     typedef typename _KVTypes::__map_value_type   _Mv;
     typedef typename __rebind_pointer<_AllocPtr, _Mv>::type                                                        __map_value_type_pointer;
     typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type                                                  __const_map_value_type_pointer;
   };
    template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type> struct __tree_node_types;
    template <class _NodePtr, class _Tp, class _VoidPtr> struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >     : public __tree_node_base_types<_VoidPtr>,              __tree_key_value_types<_Tp>,              __tree_map_pointer_types<_Tp, _VoidPtr> {
     typedef __tree_node_base_types<_VoidPtr> __base;
     typedef __tree_key_value_types<_Tp>      __key_base;
     typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;
   public:    typedef typename pointer_traits<_NodePtr>::element_type       __node_type;
     typedef _NodePtr                                              __node_pointer;
      typedef _Tp                                                 __node_value_type;
     typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type                                                       __node_value_type_pointer;
     typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type                                                 __const_node_value_type_pointer;
     
#if defined(_LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB)
  typedef typename __base::__end_node_pointer __iter_pointer;
     
#else
  typedef typename conditional<       is_pointer<__node_pointer>::value,         typename __base::__end_node_pointer,         __node_pointer>::type __iter_pointer;
     
#endif
private:     static_assert(!is_const<__node_type>::value,                 "_NodePtr should never be a pointer to const");
       static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,                           _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
   };
    template <class _ValueTp, class _VoidPtr> struct __make_tree_node_types {
     typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type                                                                         _NodePtr;
     typedef __tree_node_types<_NodePtr> type;
   };
    // node
 template <class _Pointer> class __tree_end_node {
   public:     typedef _Pointer pointer;
       pointer __left_;
        _LIBCPP_INLINE_VISIBILITY     __tree_end_node() _NOEXCEPT : __left_() {
  }
   };
    template <class _VoidPtr> class __tree_node_base     : public __tree_node_base_types<_VoidPtr>::__end_node_type {
       typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;
    public:     typedef typename _NodeBaseTypes::__node_base_pointer pointer;
       typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;
        pointer          __right_;
       __parent_pointer __parent_;
     __tree_node_base(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;
     __tree_node_base& operator=(__tree_node_base const&) _LIBCPP_EQUAL_DELETE;
   };
    template <class _Tp, class _VoidPtr> class __tree_node     : public __tree_node_base<_VoidPtr> {
   public:     typedef _Tp __node_value_type;
        __node_value_type __value_;
    private:   ~__tree_node() _LIBCPP_EQUAL_DELETE;
     __tree_node(__tree_node const&) _LIBCPP_EQUAL_DELETE;
     __tree_node& operator=(__tree_node const&) _LIBCPP_EQUAL_DELETE;
   };
     template <class _Allocator> class __tree_node_destructor {
       typedef _Allocator                                      allocator_type;
       typedef allocator_traits<allocator_type>                __alloc_traits;
    public:     typedef typename __alloc_traits::pointer                pointer;
   private:     typedef __tree_node_types<pointer> _NodeTypes;
       allocator_type& __na_;
        __tree_node_destructor& operator=(const __tree_node_destructor&);
    public:     bool __value_constructed;
        _LIBCPP_INLINE_VISIBILITY     explicit __tree_node_destructor(allocator_type& __na, bool __val = false) _NOEXCEPT         : __na_(__na),           __value_constructed(__val)         {
  }
        _LIBCPP_INLINE_VISIBILITY     void operator()(pointer __p) _NOEXCEPT     {
           if (__value_constructed)             __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
           if (__p)             __alloc_traits::deallocate(__na_, __p, 1);
       }
        template <class> friend class __map_node_destructor;
   };
     template <class _Tp, class _NodePtr, class _DiffType> class _LIBCPP_TEMPLATE_VIS __tree_iterator {
       typedef __tree_node_types<_NodePtr>                     _NodeTypes;
       typedef _NodePtr                                        __node_pointer;
       typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;
       typedef typename _NodeTypes::__end_node_pointer         __end_node_pointer;
       typedef typename _NodeTypes::__iter_pointer             __iter_pointer;
       typedef pointer_traits<__node_pointer> __pointer_traits;
        __iter_pointer __ptr_;
    public:     typedef bidirectional_iterator_tag                     iterator_category;
       typedef _Tp                                            value_type;
       typedef _DiffType                                      difference_type;
       typedef value_type&                                    reference;
       typedef typename _NodeTypes::__node_value_type_pointer pointer;
        _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT   
#if _LIBCPP_STD_VER > 11
    : __ptr_(nullptr)   
#endif
    {
  }
        _LIBCPP_INLINE_VISIBILITY reference operator*() const         {
  return __get_np()->__value_;
  }
       _LIBCPP_INLINE_VISIBILITY pointer operator->() const         {
  return pointer_traits<pointer>::pointer_to(__get_np()->__value_);
  }
        _LIBCPP_INLINE_VISIBILITY     __tree_iterator& operator++() {
         __ptr_ = static_cast<__iter_pointer>(           __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
  }
       _LIBCPP_INLINE_VISIBILITY     explicit __tree_iterator(__end_node_pointer __p) _NOEXCEPT : __ptr_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     __node_pointer __get_np() const {
   return static_cast<__node_pointer>(__ptr_);
   }
       template <class, class, class> friend class __tree;
       template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __map_iterator;
       template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;
       template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;
       template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS set;
       template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS multiset;
   };
    template <class _Tp, class _NodePtr, class _DiffType> class _LIBCPP_TEMPLATE_VIS __tree_const_iterator {
       typedef __tree_node_types<_NodePtr>                     _NodeTypes;
       typedef typename _NodeTypes::__node_pointer             __node_pointer;
       typedef typename _NodeTypes::__node_base_pointer        __node_base_pointer;
       typedef typename _NodeTypes::__end_node_pointer         __end_node_pointer;
       typedef typename _NodeTypes::__iter_pointer             __iter_pointer;
       typedef pointer_traits<__node_pointer> __pointer_traits;
        __iter_pointer __ptr_;
    public:     typedef bidirectional_iterator_tag                           iterator_category;
       typedef _Tp                                                  value_type;
       typedef _DiffType                                            difference_type;
       typedef const value_type&                                    reference;
       typedef typename _NodeTypes::__const_node_value_type_pointer pointer;
        _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT   
#if _LIBCPP_STD_VER > 11
    : __ptr_(nullptr)   
#endif
    {
  }
    private:     typedef __tree_iterator<value_type, __node_pointer, difference_type>                                                            __non_const_iterator;
   public:     _LIBCPP_INLINE_VISIBILITY     __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT         : __ptr_(__p.__ptr_) {
  }
        _LIBCPP_INLINE_VISIBILITY reference operator*() const         {
  return __get_np()->__value_;
  }
       _LIBCPP_INLINE_VISIBILITY pointer operator->() const         {
  return pointer_traits<pointer>::pointer_to(__get_np()->__value_);
  }
        _LIBCPP_INLINE_VISIBILITY     __tree_const_iterator& operator++() {
         __ptr_ = static_cast<__iter_pointer>(           __tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
         return *this;
       }
        _LIBCPP_INLINE_VISIBILITY     __tree_const_iterator operator++(int)         {
  }
       _LIBCPP_INLINE_VISIBILITY     __node_pointer __get_np() const {
   return static_cast<__node_pointer>(__ptr_);
   }
        template <class, class, class> friend class __tree;
       template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;
       template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;
       template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS set;
       template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS multiset;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __map_const_iterator;
    };
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp, class _Compare, class _Allocator> struct __diagnose_tree_helper {
     static constexpr bool __trigger_diagnostics()       _LIBCPP_DIAGNOSE_WARNING(!__invokable<_Compare const&, _Tp const&, _Tp const&>::value,             "the specified comparator type does not provide a const call operator")   {
   return true;
   }
   };
    template <class _Key, class _Value, class _KeyComp, class _Alloc> struct __diagnose_tree_helper<     __value_type<_Key, _Value>,     __map_value_compare<_Key, __value_type<_Key, _Value>, _KeyComp>,     _Alloc > : __diagnose_tree_helper<_Key, _KeyComp, _Alloc> {
   };
     
#endif // !_LIBCPP_CXX03_LANG
 template <class _Tp, class _Compare, class _Allocator> class __tree {
   public:     typedef _Tp                                      value_type;
       typedef _Compare                                 value_compare;
       typedef _Allocator                               allocator_type;
    private:     typedef allocator_traits<allocator_type>         __alloc_traits;
       typedef typename __make_tree_node_types<value_type,         typename __alloc_traits::void_pointer>::type                                                     _NodeTypes;
       typedef typename _NodeTypes::key_type           key_type;
   public:     typedef typename _NodeTypes::__node_value_type      __node_value_type;
       typedef typename _NodeTypes::__container_value_type __container_value_type;
        typedef typename __alloc_traits::pointer         pointer;
       typedef typename __alloc_traits::const_pointer   const_pointer;
       typedef typename __alloc_traits::size_type       size_type;
       typedef typename __alloc_traits::difference_type difference_type;
    public:     typedef typename _NodeTypes::__void_pointer        __void_pointer;
        typedef typename _NodeTypes::__node_type           __node;
       typedef typename _NodeTypes::__node_pointer        __node_pointer;
        typedef typename _NodeTypes::__node_base_type      __node_base;
       typedef typename _NodeTypes::__node_base_pointer   __node_base_pointer;
        typedef typename _NodeTypes::__end_node_type       __end_node_t;
       typedef typename _NodeTypes::__end_node_pointer    __end_node_ptr;
        typedef typename _NodeTypes::__parent_pointer      __parent_pointer;
       typedef typename _NodeTypes::__iter_pointer        __iter_pointer;
        typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
       typedef allocator_traits<__node_allocator>         __node_traits;
    private:     // check for sane allocator pointer rebinding semantics. Rebinding the
    // allocator for a new pointer type should be exactly the same as rebinding
    // the pointer using 'pointer_traits'.
    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),                   "Allocator does not rebind pointers in a sane manner.");
       typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type         __node_base_allocator;
       typedef allocator_traits<__node_base_allocator> __node_base_traits;
       static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),                  "Allocator does not rebind pointers in a sane manner.");
    private:     __iter_pointer                                     __begin_node_;
       __compressed_pair<__end_node_t, __node_allocator>  __pair1_;
       __compressed_pair<size_type, value_compare>        __pair3_;
    public:     _LIBCPP_INLINE_VISIBILITY     __iter_pointer __end_node() _NOEXCEPT     {
           return static_cast<__iter_pointer>(                 pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())         );
       }
       _LIBCPP_INLINE_VISIBILITY     __iter_pointer __end_node() const _NOEXCEPT     {
           return static_cast<__iter_pointer>(             pointer_traits<__end_node_ptr>::pointer_to(                 const_cast<__end_node_t&>(__pair1_.first())             )         );
       }
       _LIBCPP_INLINE_VISIBILITY           __node_allocator& __node_alloc() _NOEXCEPT {
  return __pair1_.second();
  }
   private:     _LIBCPP_INLINE_VISIBILITY     const __node_allocator& __node_alloc() const _NOEXCEPT         {
  return __pair1_.second();
  }
       _LIBCPP_INLINE_VISIBILITY           __iter_pointer& __begin_node() _NOEXCEPT {
  }
   private:     _LIBCPP_INLINE_VISIBILITY           size_type& size() _NOEXCEPT {
  return __pair3_.first();
  }
   public:     _LIBCPP_INLINE_VISIBILITY     const size_type& size() const _NOEXCEPT {
  return __pair3_.first();
  }
       _LIBCPP_INLINE_VISIBILITY           value_compare& value_comp() _NOEXCEPT {
  return __pair3_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     const value_compare& value_comp() const _NOEXCEPT         {
  return __pair3_.second();
  }
   public:      _LIBCPP_INLINE_VISIBILITY     __node_pointer __root() const _NOEXCEPT         {
  return static_cast<__node_pointer>(__end_node()->__left_);
  }
        __node_base_pointer* __root_ptr() const _NOEXCEPT {
           return _VSTD::addressof(__end_node()->__left_);
       }
        typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;
       typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;
        explicit __tree(const value_compare& __comp)         _NOEXCEPT_(             is_nothrow_default_constructible<__node_allocator>::value &&             is_nothrow_copy_constructible<value_compare>::value);
       explicit __tree(const allocator_type& __a);
       __tree(const value_compare& __comp, const allocator_type& __a);
       __tree(const __tree& __t);
       __tree& operator=(const __tree& __t);
       template <class _InputIterator>         void __assign_unique(_InputIterator __first, _InputIterator __last);
       template <class _InputIterator>         void __assign_multi(_InputIterator __first, _InputIterator __last);
     
#ifndef _LIBCPP_CXX03_LANG
    __tree(__tree&& __t)         _NOEXCEPT_(             is_nothrow_move_constructible<__node_allocator>::value &&             is_nothrow_move_constructible<value_compare>::value);
       __tree(__tree&& __t, const allocator_type& __a);
       __tree& operator=(__tree&& __t)         _NOEXCEPT_(             __node_traits::propagate_on_container_move_assignment::value &&             is_nothrow_move_assignable<value_compare>::value &&             is_nothrow_move_assignable<__node_allocator>::value);
     
#endif // _LIBCPP_CXX03_LANG
     ~__tree();
        _LIBCPP_INLINE_VISIBILITY           iterator begin()  _NOEXCEPT {
  return       iterator(__begin_node());
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin() const _NOEXCEPT {
  return const_iterator(__begin_node());
  }
       _LIBCPP_INLINE_VISIBILITY           iterator end() _NOEXCEPT {
  return       iterator(__end_node());
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator end() const _NOEXCEPT {
  return const_iterator(__end_node());
  }
        _LIBCPP_INLINE_VISIBILITY     size_type max_size() const _NOEXCEPT         {
  return std::min<size_type>(                 __node_traits::max_size(__node_alloc()),                 numeric_limits<difference_type >::max());
  }
        void clear() _NOEXCEPT;
        void swap(__tree& __t)   
#if _LIBCPP_STD_VER <= 11
        _NOEXCEPT_(             __is_nothrow_swappable<value_compare>::value             && (!__node_traits::propagate_on_container_swap::value ||                  __is_nothrow_swappable<__node_allocator>::value)             );
     
#else
        _NOEXCEPT_(__is_nothrow_swappable<value_compare>::value);
     
#endif
   
#ifndef _LIBCPP_CXX03_LANG
    template <class _Key, class ..._Args>     pair<iterator, bool>     __emplace_unique_key_args(_Key const&, _Args&&... __args);
       template <class _Key, class ..._Args>     iterator     __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);
        template <class... _Args>     pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);
        template <class... _Args>     iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);
        template <class... _Args>     iterator __emplace_multi(_Args&&... __args);
        template <class... _Args>     iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);
        template <class _Pp>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __emplace_unique(_Pp&& __x) {
       }
        template <class _Pp>     _LIBCPP_INLINE_VISIBILITY     iterator     __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {
         return __emplace_hint_unique_key_args(__p, __x.first, _VSTD::forward<_Pp>(__x));
       }
      
#else
    template <class _Key, class _Args>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);
       template <class _Key, class _Args>     _LIBCPP_INLINE_VISIBILITY     iterator __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&);
     
#endif
     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __insert_unique(const __container_value_type& __v) {
           return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
       }
        _LIBCPP_INLINE_VISIBILITY     iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {
           return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);
       }
      
#ifdef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     iterator __insert_multi(const __container_value_type& __v);
       _LIBCPP_INLINE_VISIBILITY     iterator __insert_multi(const_iterator __p, const __container_value_type& __v);
     
#else
    _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __insert_unique(__container_value_type&& __v) {
           return __emplace_unique_key_args(_NodeTypes::__get_key(__v), _VSTD::move(__v));
       }
        _LIBCPP_INLINE_VISIBILITY     iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {
           return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), _VSTD::move(__v));
       }
        template <class _Vp, class = typename enable_if<             !is_same<typename __unconstref<_Vp>::type,                      __container_value_type             >::value         >::type>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __insert_unique(_Vp&& __v) {
           return __emplace_unique(_VSTD::forward<_Vp>(__v));
       }
#endif // !_LIBCPP_CXX03_LANG
     pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
       iterator             __node_insert_unique(const_iterator __p,                                               __node_pointer __nd);
        iterator __node_insert_multi(__node_pointer __nd);
       iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);
        iterator erase(const_iterator __p);
       iterator erase(const_iterator __f, const_iterator __l);
       template <class _Key>         size_type __erase_unique(const _Key& __k);
       template <class _Key>         size_type __erase_multi(const _Key& __k);
        void __insert_node_at(__parent_pointer     __parent,                           __node_base_pointer& __child,                           __node_base_pointer __new_node);
        template <class _Key>         iterator find(const _Key& __v);
       template <class _Key>         const_iterator find(const _Key& __v) const;
        template <class _Key>         size_type __count_unique(const _Key& __k) const;
       template <class _Key>         size_type __count_multi(const _Key& __k) const;
        template <class _Key>         _LIBCPP_INLINE_VISIBILITY         iterator lower_bound(const _Key& __v)             {
  return __lower_bound(__v, __root(), __end_node());
  }
       template <class _Key>         iterator __lower_bound(const _Key& __v,                                __node_pointer __root,                                __iter_pointer __result);
       template <class _Key>         _LIBCPP_INLINE_VISIBILITY         const_iterator lower_bound(const _Key& __v) const             {
  return __lower_bound(__v, __root(), __end_node());
  }
       template <class _Key>         const_iterator __lower_bound(const _Key& __v,                                      __node_pointer __root,                                      __iter_pointer __result) const;
       template <class _Key>         _LIBCPP_INLINE_VISIBILITY         iterator upper_bound(const _Key& __v)             {
  return __upper_bound(__v, __root(), __end_node());
  }
       template <class _Key>         iterator __upper_bound(const _Key& __v,                                __node_pointer __root,                                __iter_pointer __result);
       template <class _Key>         _LIBCPP_INLINE_VISIBILITY         const_iterator upper_bound(const _Key& __v) const             {
  return __upper_bound(__v, __root(), __end_node());
  }
       template <class _Key>         const_iterator __upper_bound(const _Key& __v,                                      __node_pointer __root,                                      __iter_pointer __result) const;
       template <class _Key>         pair<iterator, iterator>         __equal_range_unique(const _Key& __k);
       template <class _Key>         pair<const_iterator, const_iterator>         __equal_range_unique(const _Key& __k) const;
        template <class _Key>         pair<iterator, iterator>         __equal_range_multi(const _Key& __k);
       template <class _Key>         pair<const_iterator, const_iterator>         __equal_range_multi(const _Key& __k) const;
        typedef __tree_node_destructor<__node_allocator> _Dp;
       typedef unique_ptr<__node, _Dp> __node_holder;
        __node_holder remove(const_iterator __p) _NOEXCEPT;
   private:     __node_base_pointer&         __find_leaf_low(__parent_pointer& __parent, const key_type& __v);
       __node_base_pointer&         __find_leaf_high(__parent_pointer& __parent, const key_type& __v);
       __node_base_pointer&         __find_leaf(const_iterator __hint,                     __parent_pointer& __parent, const key_type& __v);
       // FIXME: Make this function const qualified. Unfortunetly doing so
    // breaks existing code which uses non-const callable comparators.
    template <class _Key>     __node_base_pointer&         __find_equal(__parent_pointer& __parent, const _Key& __v);
       template <class _Key>     _LIBCPP_INLINE_VISIBILITY __node_base_pointer&     __find_equal(__parent_pointer& __parent, const _Key& __v) const {
         return const_cast<__tree*>(this)->__find_equal(__parent, __v);
       }
       template <class _Key>     __node_base_pointer&         __find_equal(const_iterator __hint, __parent_pointer& __parent,                      __node_base_pointer& __dummy,                      const _Key& __v);
      
#ifndef _LIBCPP_CXX03_LANG
    template <class ..._Args>     __node_holder __construct_node(_Args&& ...__args);
     
#else
    __node_holder __construct_node(const __container_value_type& __v);
     
#endif
     void destroy(__node_pointer __nd) _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const __tree& __t)         {
  __copy_assign_alloc(__t, integral_constant<bool,              __node_traits::propagate_on_container_copy_assignment::value>());
  }
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const __tree& __t, true_type)         {
           if (__node_alloc() != __t.__node_alloc())         	clear();
  __move_assign_alloc(__t, integral_constant<bool,              __node_traits::propagate_on_container_move_assignment::value>());
  }
        _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(__tree& __t, true_type)         _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)         {
  __node_alloc() = _VSTD::move(__t.__node_alloc());
  }
       _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(__tree&, false_type) _NOEXCEPT {
  }
        __node_pointer __detach();
       static __node_pointer __detach(__node_pointer);
        template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;
       template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;
   };
    template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)         _NOEXCEPT_(             is_nothrow_default_constructible<__node_allocator>::value &&             is_nothrow_copy_constructible<value_compare>::value)     : __pair3_(0, __comp) {
       __begin_node() = __end_node();
   }
    template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)     : __begin_node_(__iter_pointer()),       __pair1_(__second_tag(), __node_allocator(__a)),       __pair3_(0) {
       __begin_node() = __end_node();
   }
    template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,                                            const allocator_type& __a)     : __begin_node_(__iter_pointer()),       __pair1_(__second_tag(), __node_allocator(__a)),       __pair3_(0, __comp) {
       __begin_node() = __end_node();
   }
    // Precondition:  size() != 0
template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_pointer __tree<_Tp, _Compare, _Allocator>::__detach() {
       __node_pointer __cache = static_cast<__node_pointer>(__begin_node());
       __begin_node() = __end_node();
       __end_node()->__left_->__parent_ = nullptr;
       __end_node()->__left_ = nullptr;
       size() = 0;
       // __cache->__left_ == nullptr
    if (__cache->__right_ != nullptr)         __cache = static_cast<__node_pointer>(__cache->__right_);
       // __cache->__left_ == nullptr
    // __cache->__right_ == nullptr
    return __cache;
   }
    // Precondition:  __cache != nullptr
//    __cache->left_ == nullptr
//    __cache->right_ == nullptr
//    This is no longer a red-black tree
template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_pointer __tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache) {
       if (__cache->__parent_ == nullptr)         return nullptr;
       if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))     {
           __cache->__parent_->__left_ = nullptr;
           __cache = static_cast<__node_pointer>(__cache->__parent_);
           if (__cache->__right_ == nullptr)             return __cache;
           return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));
       }
       // __cache is right child
    __cache->__parent_unsafe()->__right_ = nullptr;
       __cache = static_cast<__node_pointer>(__cache->__parent_);
       if (__cache->__left_ == nullptr)         return __cache;
       return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));
   }
    template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>& __tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t) {
       if (this != &__t)     {
           value_comp() = __t.value_comp();
           __copy_assign_alloc(__t);
           __assign_multi(__t.begin(), __t.end());
       }
       return *this;
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _InputIterator> void __tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last) {
       typedef iterator_traits<_InputIterator> _ITraits;
       typedef typename _ITraits::value_type _ItValueType;
       static_assert((is_same<_ItValueType, __container_value_type>::value),                   "__assign_unique may only be called with the containers value type");
        if (size() != 0)     {
           __node_pointer __cache = __detach();
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            for (;
   __cache != nullptr && __first != __last;
   ++__first)             {
                   __cache->__value_ = *__first;
                   __node_pointer __next = __detach(__cache);
                   __node_insert_unique(__cache);
                   __cache = __next;
               }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
               while (__cache->__parent_ != nullptr)                 __cache = static_cast<__node_pointer>(__cache->__parent_);
               destroy(__cache);
               throw;
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        if (__cache != nullptr)         {
               while (__cache->__parent_ != nullptr)                 __cache = static_cast<__node_pointer>(__cache->__parent_);
               destroy(__cache);
           }
       }
       for (;
   __first != __last;
   ++__first)         __insert_unique(*__first);
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _InputIterator> void __tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last) {
       typedef iterator_traits<_InputIterator> _ITraits;
       typedef typename _ITraits::value_type _ItValueType;
       static_assert((is_same<_ItValueType, __container_value_type>::value ||                   is_same<_ItValueType, __node_value_type>::value),                   "__assign_multi may only be called with the containers value type"                   " or the nodes value type");
       if (size() != 0)     {
           __node_pointer __cache = __detach();
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            for (;
   __cache != nullptr && __first != __last;
   ++__first)             {
                   __cache->__value_ = *__first;
                   __node_pointer __next = __detach(__cache);
                   __node_insert_multi(__cache);
                   __cache = __next;
               }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
               while (__cache->__parent_ != nullptr)                 __cache = static_cast<__node_pointer>(__cache->__parent_);
               destroy(__cache);
               throw;
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        if (__cache != nullptr)         {
               while (__cache->__parent_ != nullptr)                 __cache = static_cast<__node_pointer>(__cache->__parent_);
               destroy(__cache);
           }
       }
       for (;
   __first != __last;
   ++__first)         __insert_multi(_NodeTypes::__get_value(*__first));
   }
    template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)     : __begin_node_(__iter_pointer()),       __pair1_(__second_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),       __pair3_(0, __t.value_comp()) {
       __begin_node() = __end_node();
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)     _NOEXCEPT_(         is_nothrow_move_constructible<__node_allocator>::value &&         is_nothrow_move_constructible<value_compare>::value)     : __begin_node_(_VSTD::move(__t.__begin_node_)),       __pair1_(_VSTD::move(__t.__pair1_)),       __pair3_(_VSTD::move(__t.__pair3_)) {
       if (size() == 0)         __begin_node() = __end_node();
       else     {
           __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
           __t.__begin_node() = __t.__end_node();
           value_comp() = _VSTD::move(__t.value_comp());
           const_iterator __e = end();
           if (size() != 0)         {
               __node_pointer __cache = __detach();
     
#ifndef _LIBCPP_NO_EXCEPTIONS
            try             {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
                while (__cache != nullptr && __t.size() != 0)                 {
                       __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);
                       __node_pointer __next = __detach(__cache);
                       __node_insert_multi(__cache);
                       __cache = __next;
                   }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
            }
               catch (...)             {
                   while (__cache->__parent_ != nullptr)                     __cache = static_cast<__node_pointer>(__cache->__parent_);
                   destroy(__cache);
                   throw;
               }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            if (__cache != nullptr)             {
                   while (__cache->__parent_ != nullptr)                     __cache = static_cast<__node_pointer>(__cache->__parent_);
                   destroy(__cache);
               }
           }
           while (__t.size() != 0)             __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));
       }
   }
    template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>& __tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)     _NOEXCEPT_(         __node_traits::propagate_on_container_move_assignment::value &&         is_nothrow_move_assignable<value_compare>::value &&         is_nothrow_move_assignable<__node_allocator>::value)          {
       __move_assign(__t, integral_constant<bool,                   __node_traits::propagate_on_container_move_assignment::value>());
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Compare, class _Allocator> __tree<_Tp, _Compare, _Allocator>::~__tree() {
       static_assert((is_copy_constructible<value_compare>::value),                  "Comparator must be copy-constructible.");
     
#ifndef _LIBCPP_CXX03_LANG
    static_assert((__diagnose_tree_helper<_Tp, _Compare, _Allocator>::                      __trigger_diagnostics()), "");
     
#endif
  destroy(__root());
   }
    template <class _Tp, class _Compare, class _Allocator> void __tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT {
       if (__nd != nullptr)     {
           destroy(static_cast<__node_pointer>(__nd->__left_));
           destroy(static_cast<__node_pointer>(__nd->__right_));
           __node_allocator& __na = __node_alloc();
           __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
           __node_traits::deallocate(__na, __nd, 1);
       }
   }
    template <class _Tp, class _Compare, class _Allocator> void __tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)   
#if _LIBCPP_STD_VER <= 11
        _NOEXCEPT_(             __is_nothrow_swappable<value_compare>::value             && (!__node_traits::propagate_on_container_swap::value ||                  __is_nothrow_swappable<__node_allocator>::value)             )   
#else
        _NOEXCEPT_(__is_nothrow_swappable<value_compare>::value)   
#endif
{
       using _VSTD::swap;
       swap(__begin_node_, __t.__begin_node_);
       swap(__pair1_.first(), __t.__pair1_.first());
       __swap_allocator(__node_alloc(), __t.__node_alloc());
       __pair3_.swap(__t.__pair3_);
       __begin_node() = __end_node();
       __end_node()->__left_ = nullptr;
   }
    // Find lower_bound place to insert
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer& __tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,                                                    const key_type& __v) {
       __node_pointer __nd = __root();
       if (__nd != nullptr)     {
           while (true)         {
               if (value_comp()(__nd->__value_, __v))             {
                   if (__nd->__right_ != nullptr)                     __nd = static_cast<__node_pointer>(__nd->__right_);
                   else                 {
                       __parent = static_cast<__parent_pointer>(__nd);
                       return __nd->__right_;
                   }
               }
               else             {
                   if (__nd->__left_ != nullptr)                     __nd = static_cast<__node_pointer>(__nd->__left_);
                   else                 {
                       __parent = static_cast<__parent_pointer>(__nd);
                       return __parent->__left_;
                   }
               }
           }
       }
       __parent = static_cast<__parent_pointer>(__end_node());
       return __parent->__left_;
   }
    // Find upper_bound place to insert
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer& __tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,                                                     const key_type& __v) {
       __node_pointer __nd = __root();
       if (__nd != nullptr)     {
           while (true)         {
               if (value_comp()(__v, __nd->__value_))             {
                   if (__nd->__left_ != nullptr)                     __nd = static_cast<__node_pointer>(__nd->__left_);
                   else                 {
                       __parent = static_cast<__parent_pointer>(__nd);
                       return __nd->__right_;
                   }
               }
           }
       }
       __parent = static_cast<__parent_pointer>(__end_node());
       return __parent->__left_;
   }
    // Find leaf place to insert closest to __hint
// First check prior to __hint.
// Next check after __hint.
// Next do O(log N) search.
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer& __tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,                                                __parent_pointer& __parent,                                                const key_type& __v) {
       if (__hint == end() || !value_comp()(*__hint, __v))  // check before
    {
           // __v <= *__hint
        const_iterator __prior = __hint;
           if (__prior == begin() || !value_comp()(__v, *--__prior))         {
               // *prev(__hint) <= __v <= *__hint
            if (__hint.__ptr_->__left_ == nullptr)             {
                   __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                   return __parent->__left_;
               }
               else             {
                   __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                   return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
               }
           }
           // __v < *prev(__hint)
        return __find_leaf_high(__parent, __v);
       }
       // else __v > *__hint
    return __find_leaf_low(__parent, __v);
   }
    // Find place to insert if __v doesn't exist
// Set __parent to parent of null leaf
// Return reference to null leaf
// If __v exists, set parent to node of __v and return reference to node of __v
template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer& __tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,                                                 const _Key& __v) {
       __node_pointer __nd = __root();
       __node_base_pointer* __nd_ptr = __root_ptr();
   }
    template <class _Tp, class _Compare, class _Allocator> void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(__parent_pointer     __parent,                                                     __node_base_pointer& __child,                                                     __node_base_pointer  __new_node) {
   }
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp, class _Compare, class _Allocator> template <class _Key, class... _Args> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool> __tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)   
#else
template <class _Tp, class _Compare, class _Allocator> template <class _Key, class _Args> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool> __tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args& __args)   
#endif
{
       __parent_pointer __parent;
       __node_base_pointer& __child = __find_equal(__parent, __k);
       __node_pointer __r = static_cast<__node_pointer>(__child);
       bool __inserted = false;
       if (__child == nullptr)     {
     
#ifndef _LIBCPP_CXX03_LANG
        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);
     
#else
        __node_holder __h = __construct_node(__args);
     
#endif
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
           __r = __h.release();
           __inserted = true;
       }
       return pair<iterator, bool>(iterator(__r), __inserted);
   }
       
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp, class _Compare, class _Allocator> template <class _Key, class... _Args> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(     const_iterator __p, _Key const& __k, _Args&&... __args)   
#else
template <class _Tp, class _Compare, class _Allocator> template <class _Key, class _Args> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(     const_iterator __p, _Key const& __k, _Args& __args)   
#endif
{
       __parent_pointer __parent;
       __node_base_pointer __dummy;
       __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
       __node_pointer __r = static_cast<__node_pointer>(__child);
       if (__child == nullptr)     {
     
#ifndef _LIBCPP_CXX03_LANG
        __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);
     
#else
        __node_holder __h = __construct_node(__args);
     
#endif
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
           __r = __h.release();
       }
       return iterator(__r);
   }
       
#ifndef _LIBCPP_CXX03_LANG
     template <class _Tp, class _Compare, class _Allocator> template <class... _Args> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool> __tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args) {
       __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);
       __parent_pointer __parent;
       __node_base_pointer& __child = __find_equal(__parent, __h->__value_);
       __node_pointer __r = static_cast<__node_pointer>(__child);
       bool __inserted = false;
       if (__child == nullptr)     {
           __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
           __r = __h.release();
           __inserted = true;
       }
       return pair<iterator, bool>(iterator(__r), __inserted);
   }
    template <class _Tp, class _Compare, class _Allocator> template <class... _Args> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args) {
       __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);
       return iterator(static_cast<__node_pointer>(__h.release()));
   }
       
#else  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_holder __tree<_Tp, _Compare, _Allocator>::__construct_node(const __container_value_type& __v) {
       __node_allocator& __na = __node_alloc();
       __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
       __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), __v);
#endif
 template <class _Tp, class _Compare, class _Allocator> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool> __tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd) {
       __parent_pointer __parent;
       __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);
       __node_pointer __r = static_cast<__node_pointer>(__child);
       bool __inserted = false;
       if (__child == nullptr)     {
           __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
           __r = __nd;
           __inserted = true;
       }
       return pair<iterator, bool>(iterator(__r), __inserted);
   }
    template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,                                                         __node_pointer __nd) {
       __parent_pointer __parent;
       return end();
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const {
       const_iterator __p = __lower_bound(__v, __root(), __end_node());
       if (__p != end() && !value_comp()(__v, *__p))         return __p;
       return end();
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::size_type __tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const {
       __node_pointer __rt = __root();
       while (__rt != nullptr)     {
           if (value_comp()(__k, __rt->__value_))         {
               __rt = static_cast<__node_pointer>(__rt->__left_);
           }
           else if (value_comp()(__rt->__value_, __k))             __rt = static_cast<__node_pointer>(__rt->__right_);
           else             return 1;
       }
       return 0;
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::size_type __tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const {
       __iter_pointer __result = __end_node();
       __node_pointer __rt = __root();
       while (__rt != nullptr)     {
           if (value_comp()(__k, __rt->__value_))         {
               __result = static_cast<__iter_pointer>(__rt);
               __rt = static_cast<__node_pointer>(__rt->__left_);
           }
           else if (value_comp()(__rt->__value_, __k))             __rt = static_cast<__node_pointer>(__rt->__right_);
           else             return _VSTD::distance(                 __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)             );
       }
       return 0;
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,                                                  __node_pointer __root,                                                  __iter_pointer __result) {
       while (__root != nullptr)     {
           if (!value_comp()(__root->__value_, __v))         {
               __result = static_cast<__iter_pointer>(__root);
               __root = static_cast<__node_pointer>(__root->__left_);
           }
           else             __root = static_cast<__node_pointer>(__root->__right_);
       }
       return iterator(__result);
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,                                                  __node_pointer __root,                                                  __iter_pointer __result) const {
       while (__root != nullptr)     {
           if (!value_comp()(__root->__value_, __v))         {
               __result = static_cast<__iter_pointer>(__root);
               __root = static_cast<__node_pointer>(__root->__left_);
           }
           else             __root = static_cast<__node_pointer>(__root->__right_);
       }
       return const_iterator(__result);
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,                                                  __node_pointer __root,                                                  __iter_pointer __result) {
       while (__root != nullptr)     {
           if (value_comp()(__v, __root->__value_))         {
               __result = static_cast<__iter_pointer>(__root);
               __root = static_cast<__node_pointer>(__root->__left_);
           }
           else             __root = static_cast<__node_pointer>(__root->__right_);
       }
       return iterator(__result);
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,                                                  __node_pointer __root,                                                  __iter_pointer __result) const {
       while (__root != nullptr)     {
           if (value_comp()(__v, __root->__value_))         {
               __result = static_cast<__iter_pointer>(__root);
               __root = static_cast<__node_pointer>(__root->__left_);
           }
           else             __root = static_cast<__node_pointer>(__root->__right_);
       }
       return const_iterator(__result);
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,      typename __tree<_Tp, _Compare, _Allocator>::iterator> __tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) {
       typedef pair<iterator, iterator> _Pp;
       __iter_pointer __result = __end_node();
       __node_pointer __rt = __root();
       while (__rt != nullptr)     {
           if (value_comp()(__k, __rt->__value_))         {
               __rt = static_cast<__node_pointer>(__rt->__left_);
           }
           else if (value_comp()(__rt->__value_, __k))             __rt = static_cast<__node_pointer>(__rt->__right_);
           else             return _Pp(const_iterator(__rt),                       const_iterator(                           __rt->__right_ != nullptr ?                               static_cast<__iter_pointer>(__tree_min(__rt->__right_))                             : __result));
       }
       return _Pp(const_iterator(__result), const_iterator(__result));
   }
    template <class _Tp, class _Compare, class _Allocator> template <class _Key> pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,      typename __tree<_Tp, _Compare, _Allocator>::iterator> __tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) {
       typedef pair<iterator, iterator> _Pp;
       __iter_pointer __result = __end_node();
       __node_pointer __rt = __root();
       while (__rt != nullptr)     {
           if (value_comp()(__k, __rt->__value_))         {
               __result = static_cast<__iter_pointer>(__rt);
               __rt = static_cast<__node_pointer>(__rt->__left_);
           }
           else             return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),                       __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
       }
       return _Pp(const_iterator(__result), const_iterator(__result));
   }
    template <class _Tp, class _Compare, class _Allocator> typename __tree<_Tp, _Compare, _Allocator>::__node_holder __tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT {
       __node_pointer __np = __p.__get_np();
       if (__begin_node() == __p.__ptr_)     {
           if (__np->__right_ != nullptr)             __begin_node() = static_cast<__iter_pointer>(__np->__right_);
           else             __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
       }
       --size();
       __tree_remove(__end_node()->__left_,                   static_cast<__node_base_pointer>(__np));
       return __node_holder(__np, _Dp(__node_alloc(), true));
   }
    template <class _Tp, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(__tree<_Tp, _Compare, _Allocator>& __x,      __tree<_Tp, _Compare, _Allocator>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP___TREE
  
#pragma clang module end /*std.__tree*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <iterator>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.iterator
// -*- C++ -*-
   
#ifndef _LIBCPP_ITERATOR
  
#define _LIBCPP_ITERATOR
 /*     iterator synopsis  namespace std {
    template<class Iterator> struct iterator_traits {
       typedef typename Iterator::difference_type difference_type;
       typedef typename Iterator::value_type value_type;
#include <initializer_list>
  
#endif /* expanded by -frewrite-includes */
  
#ifdef __APPLE__
  
#if 0 /* expanded by -frewrite-includes */
  
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  struct _LIBCPP_TEMPLATE_VIS input_iterator_tag {
  };
#if 0 /* expanded by -frewrite-includes */
  
#include <stdexcept>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
#endif // __has_feature(is_constructible)
    
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
template <class _Tp, class ..._Args> _LIBCPP_CONSTEXPR bool is_constructible_v     = is_constructible<_Tp, _Args...>::value;
     
#endif
 // is_default_constructible
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_default_constructible     : public is_constructible<_Tp>     {
      
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_move_constructible_v     = is_move_constructible<_Tp>::value;
     
#endif
 // is_trivially_constructible
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
   
#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {
   };
      
#else  // !__has_feature(is_trivially_constructible)
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : false_type {
   };
      
#endif  // !__has_feature(is_trivially_constructible)
   
#endif  // _LIBCPP_HAS_NO_VARIADICS
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
template <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v     = is_trivially_constructible<_Tp, _Args...>::value;
     
      template <class _Integer>   constexpr typename enable_if<is_integral_v<_Integer>, _Integer>::type   to_integer(byte __b) noexcept {
   return _Integer(__b);
   }
    }
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Key, class _CP, class _Compare, bool _IsSmall> class __map_value_compare     : private _Compare {
   public:     _LIBCPP_INLINE_VISIBILITY     __map_value_compare()         _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)         : _Compare() {
  }
       _LIBCPP_INLINE_VISIBILITY     bool operator()(const _CP& __x, const _Key& __y) const         {
  return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);
  }
       _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Key& __x, const _CP& __y) const         {
  return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);
  }
       void swap(__map_value_compare&__y)         _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)     {
         using _VSTD::swap;
         swap(static_cast<_Compare&>(*this), static_cast<_Compare&>(__y));
       }
      
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type     operator () ( const _K2& __x, const _CP& __y ) const         {
  return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);
  }
        template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type     operator () (const _CP& __x, const _K2& __y) const         {
  return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);
  }
     
#endif
};
    template <class _Key, class _CP, class _Compare> class __map_value_compare<_Key, _CP, _Compare, false> {
       _Compare comp;
       void swap(__map_value_compare&__y)         _NOEXCEPT_(__is_nothrow_swappable<_Compare>::value)     {
           using _VSTD::swap;
           swap(comp, __y.comp);
       }
      
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type     operator () ( const _K2& __x, const _CP& __y ) const         {
  return comp (__x, __y.__cc.first);
  }
        template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type     operator () (const _CP& __x, const _K2& __y) const         {
  return comp (__x.__cc.first, __y);
  }
     
#endif
};
    template <class _Key, class _CP, class _Compare, bool __b> inline _LIBCPP_INLINE_VISIBILITY void swap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,      __map_value_compare<_Key, _CP, _Compare, __b>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    template <class _Allocator> class __map_node_destructor {
       typedef _Allocator                          allocator_type;
       typedef allocator_traits<allocator_type>    __alloc_traits;
    public:     typedef typename __alloc_traits::pointer    pointer;
    private:     allocator_type& __na_;
        __map_node_destructor& operator=(const __map_node_destructor&);
    public:     bool __first_constructed;
       bool __second_constructed;
        _LIBCPP_INLINE_VISIBILITY     explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT         : __na_(__na),           __first_constructed(false),           __second_constructed(false)         {
  }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT         : __na_(__x.__na_),           __first_constructed(__x.__value_constructed),           __second_constructed(__x.__value_constructed)         {
               __x.__value_constructed = false;
           }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     void operator()(pointer __p) _NOEXCEPT     {
           if (__second_constructed)             __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));
           if (__first_constructed)             __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));
           if (__p)             __alloc_traits::deallocate(__na_, __p, 1);
       }
   };
    template <class _Key, class _Tp, class _Compare, class _Allocator>     class map;
   template <class _Key, class _Tp, class _Compare, class _Allocator>     class multimap;
   template <class _TreeIterator> class __map_const_iterator;
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Key, class _Tp> union __value_type {
       typedef _Key                                     key_type;
       typedef _Tp                                      mapped_type;
       typedef pair<const key_type, mapped_type>        value_type;
       typedef pair<key_type, mapped_type>              __nc_value_type;
        value_type __cc;
       __nc_value_type __nc;
       __value_type(__value_type&& __v) _LIBCPP_EQUAL_DELETE;
   };
      
#else
 template <class _Key, class _Tp> struct __value_type {
       typedef _Key                                     key_type;
       typedef _Tp                                      mapped_type;
       typedef pair<const key_type, mapped_type>        value_type;
        value_type __cc;
    private:    __value_type();
      __value_type(__value_type const&);
      __value_type& operator=(__value_type const&);
      ~__value_type();
   };
      
#endif // _LIBCPP_CXX03_LANG
 template <class _Tp> struct __extract_key_value_types;
    template <class _Key, class _Tp> struct __extract_key_value_types<__value_type<_Key, _Tp> > {
     typedef _Key const __key_type;
     typedef _Tp        __mapped_type;
   };
    template <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_iterator {
       typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;
       typedef typename _TreeIterator::__pointer_traits             __pointer_traits;
        _TreeIterator __i_;
    public:     typedef bidirectional_iterator_tag                           iterator_category;
       typedef typename _NodeTypes::__map_value_type                value_type;
       typedef typename _TreeIterator::difference_type              difference_type;
       typedef value_type&                                          reference;
       typedef typename _NodeTypes::__map_value_type_pointer        pointer;
        _LIBCPP_INLINE_VISIBILITY     __map_iterator() _NOEXCEPT {
           __map_iterator __t(*this);
           --(*this);
           return __t;
       }
        friend _LIBCPP_INLINE_VISIBILITY     bool operator==(const __map_iterator& __x, const __map_iterator& __y)         {
  return __x.__i_ == __y.__i_;
  }
       friend     _LIBCPP_INLINE_VISIBILITY     bool operator!=(const __map_iterator& __x, const __map_iterator& __y)         {
  return __x.__i_ != __y.__i_;
  }
        template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS map;
       template <class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS multimap;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __map_const_iterator;
   };
    template <class _TreeIterator> class _LIBCPP_TEMPLATE_VIS __map_const_iterator {
       typedef typename _TreeIterator::_NodeTypes                   _NodeTypes;
       typedef typename _TreeIterator::__pointer_traits             __pointer_traits;
        _TreeIterator __i_;
    public:     typedef bidirectional_iterator_tag                           iterator_category;
       typedef typename _NodeTypes::__map_value_type                value_type;
       typedef typename _TreeIterator::difference_type              difference_type;
       typedef const value_type&                                    reference;
       typedef typename _NodeTypes::__const_map_value_type_pointer  pointer;
        _LIBCPP_INLINE_VISIBILITY     __map_const_iterator() _NOEXCEPT {
  }
        _LIBCPP_INLINE_VISIBILITY     __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {
  }
       _LIBCPP_INLINE_VISIBILITY     __map_const_iterator(__map_iterator<         typename _TreeIterator::__non_const_iterator> __i) _NOEXCEPT         : __i_(__i.__i_) {
  }
        _LIBCPP_INLINE_VISIBILITY     reference operator*() const {
  return __i_->__cc;
   return *this;
  }
       _LIBCPP_INLINE_VISIBILITY     __map_const_iterator operator--(int)     {
           __map_const_iterator __t(*this);
           --(*this);
           return __t;
       }
       template <class, class, class> friend class _LIBCPP_TEMPLATE_VIS __tree_const_iterator;
   };
    template <class _Key, class _Tp, class _Compare = less<_Key>,           class _Allocator = allocator<pair<const _Key, _Tp> > > class _LIBCPP_TEMPLATE_VIS map {
   public:     // types:
    typedef _Key                                     key_type;
       typedef _Tp                                      mapped_type;
       typedef pair<const key_type, mapped_type>        value_type;
       typedef pair<key_type, mapped_type>              __nc_value_type;
       typedef _Compare                                 key_compare;
       typedef _Allocator                               allocator_type;
       typedef value_type&                              reference;
       typedef const value_type&                        const_reference;
        static_assert((is_same<typename allocator_type::value_type, value_type>::value),                   "Allocator::value_type must be same type as value_type");
        class _LIBCPP_TEMPLATE_VIS value_compare         : public binary_function<value_type, value_type, bool>     {
           friend class map;
       protected:         key_compare comp;
            _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {
  }
       public:         _LIBCPP_INLINE_VISIBILITY         bool operator()(const value_type& __x, const value_type& __y) const             {
  return comp(__x.first, __y.first);
  }
       };
    private:      typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;
       typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
       typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,                                                  __value_type>::type __allocator_type;
       typedef __tree<__value_type, __vc, __allocator_type>   __base;
       typedef typename __base::__node_traits                 __node_traits;
       typedef allocator_traits<allocator_type>               __alloc_traits;
        __base __tree_;
    public:     typedef typename __alloc_traits::pointer               pointer;
       typedef typename __alloc_traits::const_pointer         const_pointer;
       typedef typename __alloc_traits::size_type             size_type;
       typedef typename __alloc_traits::difference_type       difference_type;
       typedef __map_iterator<typename __base::iterator>             iterator;
       typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
       typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;
       typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;
        _LIBCPP_INLINE_VISIBILITY     map()         _NOEXCEPT_(             is_nothrow_default_constructible<allocator_type>::value &&             is_nothrow_default_constructible<key_compare>::value &&             is_nothrow_copy_constructible<key_compare>::value)         : __tree_(__vc(key_compare())) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit map(const key_compare& __comp)         _NOEXCEPT_(             is_nothrow_default_constructible<allocator_type>::value &&             is_nothrow_copy_constructible<key_compare>::value)         : __tree_(__vc(__comp)) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit map(const key_compare& __comp, const allocator_type& __a)         : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
  }
        template <class _InputIterator>     _LIBCPP_INLINE_VISIBILITY         map(_InputIterator __f, _InputIterator __l,             const key_compare& __comp = key_compare())         : __tree_(__vc(__comp))         {
               insert(__f, __l);
           }
        template <class _InputIterator>     _LIBCPP_INLINE_VISIBILITY         map(_InputIterator __f, _InputIterator __l,             const key_compare& __comp, const allocator_type& __a)         : __tree_(__vc(__comp), typename __base::allocator_type(__a))         {
               insert(__f, __l);
           }
      
#if _LIBCPP_STD_VER > 11
    template <class _InputIterator>     _LIBCPP_INLINE_VISIBILITY     map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)         : map(__f, __l, key_compare(), __a) {
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     map(const map& __m)         : __tree_(__m.__tree_)         {
               insert(__m.begin(), __m.end());
           }
        _LIBCPP_INLINE_VISIBILITY     map& operator=(const map& __m)         {
     
#ifndef _LIBCPP_CXX03_LANG
            __tree_ = __m.__tree_;
           }
        map(map&& __m, const allocator_type& __a);
        _LIBCPP_INLINE_VISIBILITY     map& operator=(map&& __m)         _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)         {
               __tree_ = _VSTD::move(__m.__tree_);
               return *this;
           }
        _LIBCPP_INLINE_VISIBILITY     map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())         : __tree_(__vc(__comp))         {
               insert(__il.begin(), __il.end());
           }
        _LIBCPP_INLINE_VISIBILITY     map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)         : __tree_(__vc(__comp), typename __base::allocator_type(__a))         {
               insert(__il.begin(), __il.end());
           }
      
#if _LIBCPP_STD_VER > 11
    _LIBCPP_INLINE_VISIBILITY     map(initializer_list<value_type> __il, const allocator_type& __a)         : map(__il, key_compare(), __a) {
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     map& operator=(initializer_list<value_type> __il)         {
               __tree_.__assign_unique(__il.begin(), __il.end());
               return *this;
           }
      
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     explicit map(const allocator_type& __a)         : __tree_(typename __base::allocator_type(__a))         {
           }
        _LIBCPP_INLINE_VISIBILITY     map(const map& __m, const allocator_type& __a)         : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))         {
               insert(__m.begin(), __m.end());
           }
        _LIBCPP_INLINE_VISIBILITY           iterator begin() _NOEXCEPT {
  return __tree_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin() const _NOEXCEPT {
  return __tree_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY           iterator end() _NOEXCEPT {
  return __tree_.end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator end() const _NOEXCEPT {
  return __tree_.end();
  }
        _LIBCPP_INLINE_VISIBILITY           reverse_iterator rbegin() _NOEXCEPT {
  return reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rbegin() const _NOEXCEPT         {
  return const_reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY           reverse_iterator rend() _NOEXCEPT             {
  return       reverse_iterator(begin());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rend() const _NOEXCEPT         {
  return const_reverse_iterator(begin());
  }
        _LIBCPP_INLINE_VISIBILITY     const_iterator cbegin() const _NOEXCEPT {
  return begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator cend() const _NOEXCEPT {
  return end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crbegin() const _NOEXCEPT {
  return rbegin();
  return __tree_.size();
  }
       _LIBCPP_INLINE_VISIBILITY     size_type max_size() const _NOEXCEPT {
  return __tree_.max_size();
  }
        mapped_type& operator[](const key_type& __k);
     
#ifndef _LIBCPP_CXX03_LANG
    mapped_type& operator[](key_type&& __k);
     
#endif
           mapped_type& at(const key_type& __k);
       const mapped_type& at(const key_type& __k) const;
        _LIBCPP_INLINE_VISIBILITY     allocator_type get_allocator() const _NOEXCEPT {
  return allocator_type(__tree_.__alloc());
  }
       _LIBCPP_INLINE_VISIBILITY     key_compare    key_comp()      const {
  return __tree_.value_comp().key_comp();
  }
       _LIBCPP_INLINE_VISIBILITY     value_compare  value_comp()    const {
  return value_compare(__tree_.value_comp().key_comp());
  }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool>     insert(value_type&& __v) {
  return __tree_.__insert_unique(_VSTD::move(__v));
  }
        _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p,  value_type&& __v)     {
  return __tree_.__insert_unique(__p.__i_, _VSTD::move(__v));
  }
        _LIBCPP_INLINE_VISIBILITY     void insert(initializer_list<value_type> __il)         {
        }
        template <class _Vp>         _LIBCPP_INLINE_VISIBILITY         iterator insert_or_assign(const_iterator __h, key_type&& __k, _Vp&& __v)      {
           iterator __p = lower_bound(__k);
           if ( __p != end() && !key_comp()(__k, __p->first))         {
               __p->second = _VSTD::forward<_Vp>(__v);
               return __p;
           }
           return emplace_hint(__h, _VSTD::move(__k), _VSTD::forward<_Vp>(__v));
        }
      
#endif // _LIBCPP_STD_VER > 14
     _LIBCPP_INLINE_VISIBILITY     iterator erase(const_iterator __p) {
  return __tree_.erase(__p.__i_);
  }
       _LIBCPP_INLINE_VISIBILITY     iterator erase(iterator __p)       {
  return __tree_.erase(__p.__i_);
  }
       _LIBCPP_INLINE_VISIBILITY     size_type erase(const key_type& __k)         {
  return __tree_.__erase_unique(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     iterator  erase(const_iterator __f, const_iterator __l)         {
  return __tree_.erase(__f.__i_, __l.__i_);
  }
       _LIBCPP_INLINE_VISIBILITY     void clear() _NOEXCEPT {
  __tree_.clear();
  }
        _LIBCPP_INLINE_VISIBILITY     void swap(map& __m)         _NOEXCEPT_(__is_nothrow_swappable<__base>::value)         {
  __tree_.swap(__m.__tree_);
  }
        _LIBCPP_INLINE_VISIBILITY     iterator find(const key_type& __k)             {
  return __tree_.find(__k);
  return __tree_.__count_unique(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type     count(const _K2& __k) const {
  return __tree_.__count_unique(__k);
  }
     
#endif
    _LIBCPP_INLINE_VISIBILITY     iterator lower_bound(const key_type& __k)         {
  return __tree_.lower_bound(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator lower_bound(const key_type& __k) const         {
  return __tree_.lower_bound(__k);
  }
     
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type     equal_range(const _K2& __k)       {
  return __tree_.__equal_range_unique(__k);
  }
       template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type     equal_range(const _K2& __k) const {
  return __tree_.__equal_range_unique(__k);
  }
     
#endif
 private:     typedef typename __base::__node                    __node;
       typedef typename __base::__node_allocator          __node_allocator;
       typedef typename __base::__node_pointer            __node_pointer;
       typedef typename __base::__node_base_pointer       __node_base_pointer;
       typedef typename __base::__parent_pointer          __parent_pointer;
};
       
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Tp, class _Compare, class _Allocator> map<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)     : __tree_(_VSTD::move(__m.__tree_), typename __base::allocator_type(__a)) {
       if (__a != __m.get_allocator())     {
           const_iterator __e = cend();
           while (!__m.empty())             __tree_.__insert_unique(__e.__i_,                     _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));
       }
   }
    template <class _Key, class _Tp, class _Compare, class _Allocator> _Tp& map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k) {
       return __tree_.__emplace_unique_key_args(__k,         _VSTD::piecewise_construct,         _VSTD::forward_as_tuple(__k),         _VSTD::forward_as_tuple()).first->__cc.second;
   }
    template <class _Key, class _Tp, class _Compare, class _Allocator> _Tp& map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k) {
       return __tree_.__emplace_unique_key_args(__k,         _VSTD::piecewise_construct,         _VSTD::forward_as_tuple(_VSTD::move(__k)),         _VSTD::forward_as_tuple()).first->__cc.second;
   }
#endif  // _LIBCPP_CXX03_LANG
 template <class _Key, class _Tp, class _Compare, class _Allocator> _Tp& map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) {
       __parent_pointer __parent;
       __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    if (__child == nullptr)         throw out_of_range("map::at:  key not found");
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return static_cast<__node_pointer>(__child)->__value_.__cc.second;
   }
    template <class _Key, class _Tp, class _Compare, class _Allocator> const _Tp& map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const {
       __parent_pointer __parent;
       __node_base_pointer __child = __tree_.__find_equal(__parent, __k);
     
   }
    template <class _Key, class _Tp, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(map<_Key, _Tp, _Compare, _Allocator>& __x,      map<_Key, _Tp, _Compare, _Allocator>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    template <class _Key, class _Tp, class _Compare = less<_Key>,           class _Allocator = allocator<pair<const _Key, _Tp> > > class _LIBCPP_TEMPLATE_VIS multimap {
   public:     // types:
    typedef _Key                                     key_type;
       typedef _Tp                                      mapped_type;
       typedef pair<const key_type, mapped_type>        value_type;
       typedef pair<key_type, mapped_type>              __nc_value_type;
       typedef _Compare                                 key_compare;
       typedef _Allocator                               allocator_type;
       typedef value_type&                              reference;
       typedef const value_type&                        const_reference;
        static_assert((is_same<typename allocator_type::value_type, value_type>::value),                   "Allocator::value_type must be same type as value_type");
        class _LIBCPP_TEMPLATE_VIS value_compare         : public binary_function<value_type, value_type, bool>     {
           friend class multimap;
       protected:         key_compare comp;
            _LIBCPP_INLINE_VISIBILITY         value_compare(key_compare c) : comp(c) {
  }
       public:         _LIBCPP_INLINE_VISIBILITY         bool operator()(const value_type& __x, const value_type& __y) const             {
  return comp(__x.first, __y.first);
  }
       };
    private:      typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;
       typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
       typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,                                                  __value_type>::type __allocator_type;
       typedef __tree<__value_type, __vc, __allocator_type>            __base;
       typedef typename __base::__node_traits                          __node_traits;
       typedef allocator_traits<allocator_type>                        __alloc_traits;
        __base __tree_;
    public:     typedef typename __alloc_traits::pointer               pointer;
       typedef typename __alloc_traits::const_pointer         const_pointer;
       typedef typename __alloc_traits::size_type             size_type;
       typedef typename __alloc_traits::difference_type       difference_type;
       typedef __map_iterator<typename __base::iterator>      iterator;
       typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
       typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;
       typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;
        _LIBCPP_INLINE_VISIBILITY     multimap()         _NOEXCEPT_(             is_nothrow_default_constructible<allocator_type>::value &&             is_nothrow_default_constructible<key_compare>::value &&             is_nothrow_copy_constructible<key_compare>::value)         : __tree_(__vc(key_compare())) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit multimap(const key_compare& __comp)         _NOEXCEPT_(             is_nothrow_default_constructible<allocator_type>::value &&             is_nothrow_copy_constructible<key_compare>::value)         : __tree_(__vc(__comp)) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit multimap(const key_compare& __comp, const allocator_type& __a)         : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
  }
        template <class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         multimap(_InputIterator __f, _InputIterator __l,             const key_compare& __comp = key_compare())         : __tree_(__vc(__comp))         {
               insert(__f, __l);
           }
        template <class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         multimap(_InputIterator __f, _InputIterator __l,             const key_compare& __comp, const allocator_type& __a)         : __tree_(__vc(__comp), typename __base::allocator_type(__a))         {
               insert(__f, __l);
           }
      
#if _LIBCPP_STD_VER > 11
    template <class _InputIterator>     _LIBCPP_INLINE_VISIBILITY     multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)         : multimap(__f, __l, key_compare(), __a) {
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     multimap(const multimap& __m)         : __tree_(__m.__tree_.value_comp(),           __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))         {
               insert(__m.begin(), __m.end());
           }
        _LIBCPP_INLINE_VISIBILITY     multimap& operator=(const multimap& __m)         {
     
#ifndef _LIBCPP_CXX03_LANG
            __tree_ = __m.__tree_;
     
#else
            if (this != &__m) {
                   __tree_.clear();
                   __tree_.value_comp() = __m.__tree_.value_comp();
                   __tree_.__copy_assign_alloc(__m.__tree_);
                   insert(__m.begin(), __m.end());
               }
     
#endif
            return *this;
           }
      
#ifndef _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     multimap(multimap&& __m)         _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)         : __tree_(_VSTD::move(__m.__tree_))         {
           }
        multimap(multimap&& __m, const allocator_type& __a);
        _LIBCPP_INLINE_VISIBILITY     multimap& operator=(multimap&& __m)         _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)         {
               __tree_ = _VSTD::move(__m.__tree_);
               return *this;
           }
#if _LIBCPP_STD_VER > 11
    _LIBCPP_INLINE_VISIBILITY     multimap(initializer_list<value_type> __il, const allocator_type& __a)         : multimap(__il, key_compare(), __a) {
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     multimap& operator=(initializer_list<value_type> __il)         {
               __tree_.__assign_multi(__il.begin(), __il.end());
               return *this;
           }
      
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     explicit multimap(const allocator_type& __a)         : __tree_(typename __base::allocator_type(__a))         {
           }
        _LIBCPP_INLINE_VISIBILITY     multimap(const multimap& __m, const allocator_type& __a)         : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))         {
               insert(__m.begin(), __m.end());
           }
        _LIBCPP_INLINE_VISIBILITY           iterator begin() _NOEXCEPT {
  return __tree_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin() const _NOEXCEPT {
  return __tree_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY           iterator end() _NOEXCEPT {
  return __tree_.end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator end() const _NOEXCEPT {
  return __tree_.end();
  }
        _LIBCPP_INLINE_VISIBILITY           reverse_iterator rbegin() _NOEXCEPT {
  return reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rbegin() const _NOEXCEPT         {
  return const_reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY           reverse_iterator rend() _NOEXCEPT {
  return reverse_iterator(begin());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rend() const _NOEXCEPT         {
  return const_reverse_iterator(begin());
  }
        _LIBCPP_INLINE_VISIBILITY     const_iterator cbegin()  const _NOEXCEPT {
  return begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator cend() const _NOEXCEPT {
  return end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crbegin() const _NOEXCEPT {
  return rbegin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crend() const _NOEXCEPT {
  return rend();
  }
        _LIBCPP_INLINE_VISIBILITY     bool empty() const _NOEXCEPT {
  return __tree_.size() == 0;
  }
      
#ifndef _LIBCPP_CXX03_LANG
     template <class ..._Args>     _LIBCPP_INLINE_VISIBILITY     iterator emplace(_Args&& ...__args) {
           return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);
       }
        template <class ..._Args>     _LIBCPP_INLINE_VISIBILITY     iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
           return __tree_.__emplace_hint_multi(__p.__i_, _VSTD::forward<_Args>(__args)...);
  }
      
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     iterator insert(const value_type& __v) {
  return __tree_.__insert_multi(__v);
  }
        _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p, const value_type& __v)             {
  return __tree_.__insert_multi(__p.__i_, __v);
  }
        _LIBCPP_INLINE_VISIBILITY     iterator find(const key_type& __k)             {
  return __tree_.find(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator find(const key_type& __k) const {
  return __tree_.find(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type     find(const _K2& __k)                           {
  return __tree_.find(__k);
  }
       template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type     find(const _K2& __k) const                     {
  return __tree_.find(__k);
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     size_type      count(const key_type& __k) const         {
  return __tree_.__count_multi(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type     count(const _K2& __k) const {
  return __tree_.__count_multi(__k);
  }
     
#endif
    _LIBCPP_INLINE_VISIBILITY     iterator lower_bound(const key_type& __k)         {
  return __tree_.lower_bound(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator lower_bound(const key_type& __k) const             {
  return __tree_.lower_bound(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type     lower_bound(const _K2& __k)       {
  return __tree_.lower_bound(__k);
  }
       template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type     upper_bound(const _K2& __k) const {
  return __tree_.upper_bound(__k);
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     pair<iterator,iterator>             equal_range(const key_type& __k)             {
  return __tree_.__equal_range_multi(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     pair<const_iterator,const_iterator> equal_range(const key_type& __k) const             {
  return __tree_.__equal_range_multi(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type     equal_range(const _K2& __k)       {
  return __tree_.__equal_range_multi(__k);
  }
       template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type     equal_range(const _K2& __k) const {
  return __tree_.__equal_range_multi(__k);
  }
     
#endif
 private:     typedef typename __base::__node                    __node;
       typedef typename __base::__node_allocator          __node_allocator;
       typedef typename __base::__node_pointer            __node_pointer;
        typedef __map_node_destructor<__node_allocator> _Dp;
       typedef unique_ptr<__node, _Dp> __node_holder;
   };
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Tp, class _Compare, class _Allocator> multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)     : __tree_(_VSTD::move(__m.__tree_), typename __base::allocator_type(__a)) {
       if (__a != __m.get_allocator())     {
           const_iterator __e = cend();
           while (!__m.empty())             __tree_.__insert_multi(__e.__i_,                     _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));
       }
   }
     
#endif
 template <class _Key, class _Tp, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,            const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
       return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());
   }
    template <class _Key, class _Tp, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,            const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
       return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
   }
    template <class _Key, class _Tp, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,            const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
       return !(__x == __y);
       return !(__y < __x);
   }
    template <class _Key, class _Tp, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,      multimap<_Key, _Tp, _Compare, _Allocator>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_MAP
  
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_MEMORY
  
#define _LIBCPP_MEMORY
 /*     memory synopsis  namespace std {
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <typeinfo>
  
#endif /* expanded by -frewrite-includes */
  }
      
#if _LIBCPP_STD_VER <= 14 || defined(_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR)
template <class _Tp> struct auto_ptr_ref {
       _Tp* __ptr_;
   };
    template<class _Tp> class _LIBCPP_TEMPLATE_VIS auto_ptr {
   private:     _Tp* __ptr_;
#endif
}
      
#ifdef _LIBCPP_BAD_ARRAY_LENGTH_DEFINED
_LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE   
#ifndef _LIBCPP_NO_EXCEPTIONS
_LIBCPP_AVAILABILITY_BAD_ARRAY_LENGTH   
     
#endif
}
     
#endif
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_NEW
  
#pragma clang module end /*std.new*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "numeric"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.numeric
// -*- C++ -*-
//===---------------------------- numeric ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_NUMERIC
  
#define _LIBCPP_NUMERIC
 /*     numeric synopsis  namespace std {
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _InputIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init) {
       for (;
   __first != __last;
   ++__first)         __init = __init + *__first;
       return __init;
   }
    template <class _InputIterator, class _Tp, class _BinaryOperation> inline _LIBCPP_INLINE_VISIBILITY _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op) {
       for (;
   __first != __last;
   ++__first)         __init = __binary_op(__init, *__first);
   }
      
#if _LIBCPP_STD_VER > 14
template <class _InputIterator, class _Tp, class _BinaryOp, class _UnaryOp> inline _LIBCPP_INLINE_VISIBILITY _Tp transform_reduce(_InputIterator __first, _InputIterator __last,             _Tp __init,  _BinaryOp __b, _UnaryOp __u) {
       for (;
   __first != __last;
   ++__first)         __init = __b(__init, __u(*__first));
       return __init;
   }
    template <class _InputIterator1, class _InputIterator2,            class _Tp, class _BinaryOp1, class _BinaryOp2> inline _LIBCPP_INLINE_VISIBILITY _Tp transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,                  _InputIterator2 __first2, _Tp __init,  _BinaryOp1 __b1, _BinaryOp2 __b2) {
       for (;
   __first1 != __last1;
   ++__first1, (void) ++__first2)         __init = __b1(__init, __b2(*__first1, *__first2));
       return __init;
   }
    template <class _InputIterator1, class _InputIterator2, class _Tp> inline _LIBCPP_INLINE_VISIBILITY _Tp transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,                   _InputIterator2 __first2, _Tp __init) {
       return _VSTD::transform_reduce(__first1, __last1, __first2, __init,                                     _VSTD::plus<>(), _VSTD::multiplies<>());
   }
     
#endif
 template <class _InputIterator, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator partial_sum(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
       if (__first != __last)     {
           typename iterator_traits<_InputIterator>::value_type __t(*__first);
           *__result = __t;
           for (++__first, (void) ++__result;
   __first != __last;
   ++__first, (void) ++__result)         {
               __t = __t + *__first;
               *__result = __t;
           }
           for (++__first, (void) ++__result;
   __first != __last;
   ++__first, (void) ++__result)         {
               __t = __binary_op(__t, *__first);
               *__result = __t;
           }
       }
       return __result;
   }
      
#if _LIBCPP_STD_VER > 14
template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator exclusive_scan(_InputIterator __first, _InputIterator __last,                 _OutputIterator __result, _Tp __init, _BinaryOp __b) {
       if (__first != __last)     {
           _Tp __saved = __init;
           do         {
               __init = __b(__init, *__first);
               *__result = __saved;
               __saved = __init;
               ++__result;
           }
   while (++__first != __last);
       }
       return __result;
   }
    template <class _InputIterator, class _OutputIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator exclusive_scan(_InputIterator __first, _InputIterator __last,                 _OutputIterator __result, _Tp __init) {
       return _VSTD::exclusive_scan(__first, __last, __result, __init, _VSTD::plus<>());
   }
    template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp> _OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,                                 _OutputIterator __result, _BinaryOp __b,  _Tp __init) {
       for (;
   __first != __last;
   ++__first, (void) ++__result) {
           *__result++ = __init;
           if (++__first != __last)             return _VSTD::inclusive_scan(__first, __last, __result, __b, __init);
           }
        return __result;
   }
    template <class _InputIterator, class _OutputIterator> _OutputIterator inclusive_scan(_InputIterator __first, _InputIterator __last,                                 _OutputIterator __result) {
       return _VSTD::inclusive_scan(__first, __last, __result, std::plus<>());
   }
    template <class _InputIterator, class _OutputIterator, class _Tp,            class _BinaryOp, class _UnaryOp> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator transform_exclusive_scan(_InputIterator __first, _InputIterator __last,                             _OutputIterator __result, _Tp __init,                            _BinaryOp __b, _UnaryOp __u) {
       if (__first != __last)     {
           _Tp __saved = __init;
           do         {
               __init = __b(__init, __u(*__first));
               *__result = __saved;
               __saved = __init;
               ++__result;
           }
   while (++__first != __last);
       }
       return __result;
   }
    template <class _InputIterator, class _OutputIterator, class _Tp, class _BinaryOp, class _UnaryOp> _OutputIterator transform_inclusive_scan(_InputIterator __first, _InputIterator __last,                             _OutputIterator __result, _BinaryOp __b, _UnaryOp __u, _Tp __init) {
       for (;
   __first != __last;
   ++__first, (void) ++__result) {
           __init = __b(__init, __u(*__first));
           *__result = __init;
           }
        return __result;
   }
    template <class _InputIterator, class _OutputIterator, class _BinaryOp, class _UnaryOp> _OutputIterator transform_inclusive_scan(_InputIterator __first, _InputIterator __last,                                 _OutputIterator __result, _BinaryOp __b, _UnaryOp __u) {
       if (__first != __last) {
           typename std::iterator_traits<_InputIterator>::value_type __init = __u(*__first);
           *__result++ = __init;
           if (++__first != __last)             return _VSTD::transform_inclusive_scan(__first, __last, __result, __b, __u, __init);
           }
            return __result;
   }
     
#endif
 template <class _InputIterator, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
       if (__first != __last)     {
           typename iterator_traits<_InputIterator>::value_type __t1(*__first);
           *__result = __t1;
           for (++__first, (void) ++__result;
   __first != __last;
   ++__first, (void) ++__result)         {
               typename iterator_traits<_InputIterator>::value_type __t2(*__first);
               *__result = __t2 - __t1;
               __t1 = _VSTD::move(__t2);
           }
       }
       return __result;
   }
    template <class _InputIterator, class _OutputIterator, class _BinaryOperation> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator adjacent_difference(_InputIterator __first, _InputIterator __last, _OutputIterator __result,                       _BinaryOperation __binary_op) {
       if (__first != __last)     {
           typename iterator_traits<_InputIterator>::value_type __t1(*__first);
           *__result = __t1;
           for (++__first, (void) ++__result;
   __first != __last;
   ++__first, (void) ++__result)         {
               typename iterator_traits<_InputIterator>::value_type __t2(*__first);
               *__result = __binary_op(__t2, __t1);
               __t1 = _VSTD::move(__t2);
           }
       }
       return __result;
   }
    template <class _ForwardIterator, class _Tp> inline _LIBCPP_INLINE_VISIBILITY void iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value_) {
       for (;
   __first != __last;
   ++__first, (void) ++__value_)         *__first = __value_;
   }
       
#if _LIBCPP_STD_VER > 14
template <typename _Result, typename _Source, bool _IsSigned = is_signed<_Source>::value> struct __abs;
    template <typename _Result, typename _Source> struct __abs<_Result, _Source, true> {
       _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY     _Result operator()(_Source __t) const noexcept {
   return __t;
   }
   };
     template<class _Tp> _LIBCPP_CONSTEXPR _LIBCPP_HIDDEN _Tp __gcd(_Tp __m, _Tp __n) {
       static_assert((!is_signed<_Tp>::value), "");
       return __n == 0 ? __m : _VSTD::__gcd<_Tp>(__n, __m % __n);
   }
     template<class _Tp, class _Up> _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY common_type_t<_Tp,_Up> gcd(_Tp __m, _Up __n) {
       static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to gcd must be integer types");
       static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), "First argument to gcd cannot be bool" );
       static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), "Second argument to gcd cannot be bool" );
       using _Rp = common_type_t<_Tp,_Up>;
       using _Wp = make_unsigned_t<_Rp>;
       return static_cast<_Rp>(_VSTD::__gcd(         static_cast<_Wp>(__abs<_Rp, _Tp>()(__m)),         static_cast<_Wp>(__abs<_Rp, _Up>()(__n))));
   }
    template<class _Tp, class _Up> _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY common_type_t<_Tp,_Up> lcm(_Tp __m, _Up __n) {
       static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to lcm must be integer types");
       static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), "First argument to lcm cannot be bool" );
       static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), "Second argument to lcm cannot be bool" );
       if (__m == 0 || __n == 0)         return 0;
        using _Rp = common_type_t<_Tp,_Up>;
       _Rp __val1 = __abs<_Rp, _Tp>()(__m) / _VSTD::gcd(__m, __n);
       _Rp __val2 = __abs<_Rp, _Up>()(__n);
       _LIBCPP_ASSERT((numeric_limits<_Rp>::max() / __val1 > __val2), "Overflow in lcm");
       return __val1 * __val2;
   }
      
#endif /* _LIBCPP_STD_VER > 14 */
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_NUMERIC
  
#pragma clang module end /*std.numeric*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "optional"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.optional
// -*- C++ -*-
//===-------------------------- optional ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_OPTIONAL
  
#define _LIBCPP_OPTIONAL
 /*     optional synopsis  // C++1z
 namespace std {
     // 23.6.3, optional for object types
  template <class T> class optional;
      // 23.6.4, no-value state indicator
  struct nullopt_t{
  see below };
  
#include <__functional_base>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__functional_base
// -*- C++ -*-
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_FUNCTIONAL_BASE
  
#define _LIBCPP_FUNCTIONAL_BASE
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Arg1, class _Arg2, class _Result> struct _LIBCPP_TEMPLATE_VIS binary_function {
       typedef _Arg1   first_argument_type;
       typedef _Arg2   second_argument_type;
       typedef _Result result_type;
      template<class B>          constexpr bool negation_v = negation<B>::value;
                    // C++17
 }
    */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  };
    template <class _Tp> using __is_inplace_index = __is_inplace_index_imp<__uncvref_t<_Tp>>;
      
#endif // _LIBCPP_STD_VER > 14
 template <class _Arg, class _Result> struct _LIBCPP_TEMPLATE_VIS unary_function {
       typedef _Arg    argument_type;
       typedef _Result result_type;
       }
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<long double>     : public __scalar_hash<long double> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(long double __v) const _NOEXCEPT     {
           // -0.0 and 0.0 should return same hash
        if (__v == 0)             return 0;
     
#if defined(__i386__)
       __enum_hash(__enum_hash const&) = delete;
       __enum_hash& operator=(__enum_hash const&) = delete;
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash : public __enum_hash<_Tp> {
   };
     
#endif
   
   
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Hash> using __check_hash_requirements = integral_constant<bool,     is_copy_constructible<_Hash>::value &&     is_move_constructible<_Hash>::value &&     __invokable_r<size_t, _Hash, _Key const&>::value >;
    template <class _Key, class _Hash = std::hash<_Key> > using __has_enabled_hash = integral_constant<bool,     __check_hash_requirements<_Key, _Hash>::value &&     is_default_constructible<_Hash>::value >;
      
#if _LIBCPP_STD_VER > 14
template <class _Type, class> using __enable_hash_helper_imp = _Type;
    template <class _Type, class ..._Keys> using __enable_hash_helper = __enable_hash_helper_imp<_Type,   typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type >;
     
#else
template <class _Type, class ...> using __enable_hash_helper = _Type;
     
#endif
   
#endif // !_LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_UTILITY
  
#pragma clang module end /*std.utility*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  namespace std  // purposefully not using versioning namespace
{
    class _LIBCPP_EXCEPTION_ABI bad_optional_access     : public exception {
   public:     // Get the key function ~bad_optional_access() into the dylib
    virtual ~bad_optional_access() _NOEXCEPT;
       virtual const char* what() const _NOEXCEPT;
   };
    }
    // std
   
#if _LIBCPP_STD_VER > 14
 _LIBCPP_BEGIN_NAMESPACE_STD  _LIBCPP_NORETURN inline _LIBCPP_INLINE_VISIBILITY void __throw_bad_optional_access() {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        throw bad_optional_access();
     
#else
        _VSTD::abort();
     
#endif
}
    struct nullopt_t {
       struct __secret_tag {
   _LIBCPP_INLINE_VISIBILITY explicit __secret_tag() = default;
   };
       _LIBCPP_INLINE_VISIBILITY constexpr explicit nullopt_t(__secret_tag, __secret_tag) noexcept {
  }
   };
    /* inline */ constexpr nullopt_t nullopt{
  nullopt_t::__secret_tag{
  }
  , nullopt_t::__secret_tag{
  }
  };
    template <class _Tp, bool = is_trivially_destructible<_Tp>::value> struct __optional_destruct_base;
    template <class _Tp> struct __optional_destruct_base<_Tp, false> {
       typedef _Tp value_type;
       static_assert(is_object_v<value_type>,         "instantiation of optional with a non-object type is undefined behavior");
       union     {
           char __null_state_;
           value_type __val_;
       };
       bool __engaged_;
        _LIBCPP_INLINE_VISIBILITY     ~__optional_destruct_base()     {
           if (__engaged_)             __val_.~value_type();
       }
        _LIBCPP_INLINE_VISIBILITY     constexpr __optional_destruct_base() noexcept         :  __null_state_(),            __engaged_(false) {
  }
        template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)         :  __val_(_VSTD::forward<_Args>(__args)...),            __engaged_(true) {
  }
        _LIBCPP_INLINE_VISIBILITY     void reset() noexcept     {
           if (__engaged_)         {
               __val_.~value_type();
               __engaged_ = false;
           }
       }
   };
    template <class _Tp> struct __optional_destruct_base<_Tp, true> {
       typedef _Tp value_type;
       static_assert(is_object_v<value_type>,         "instantiation of optional with a non-object type is undefined behavior");
       union     {
           char __null_state_;
           value_type __val_;
       };
       bool __engaged_;
        _LIBCPP_INLINE_VISIBILITY     constexpr __optional_destruct_base() noexcept         :  __null_state_(),            __engaged_(false) {
  }
        template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)         :  __val_(_VSTD::forward<_Args>(__args)...),            __engaged_(true) {
  }
        _LIBCPP_INLINE_VISIBILITY     void reset() noexcept     {
           if (__engaged_)         {
               __engaged_ = false;
           }
       }
   };
    template <class _Tp, bool = is_reference<_Tp>::value> struct __optional_storage_base : __optional_destruct_base<_Tp> {
       using __base = __optional_destruct_base<_Tp>;
       using value_type = _Tp;
       using __base::__base;
        _LIBCPP_INLINE_VISIBILITY     constexpr bool has_value() const noexcept     {
           return this->__engaged_;
       }
        _LIBCPP_INLINE_VISIBILITY     constexpr value_type& __get() & noexcept     {
           return this->__val_;
           return _VSTD::move(this->__val_);
       }
        template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     void __construct(_Args&&... __args)     {
           _LIBCPP_ASSERT(!has_value(), "__construct called for engaged __optional_storage");
           ::new((void*)_VSTD::addressof(this->__val_)) value_type(_VSTD::forward<_Args>(__args)...);
           this->__engaged_ = true;
       }
        template <class _That>     _LIBCPP_INLINE_VISIBILITY     void __construct_from(_That&& __opt)     {
           if (__opt.has_value())             __construct(_VSTD::forward<_That>(__opt).__get());
       }
        template <class _That>     _LIBCPP_INLINE_VISIBILITY     void __assign_from(_That&& __opt)     {
           if (this->__engaged_ == __opt.has_value())         {
               if (this->__engaged_)                 this->__val_ = _VSTD::forward<_That>(__opt).__get();
           }
           else         {
               if (this->__engaged_)                 this->reset();
               else                 __construct(_VSTD::forward<_That>(__opt).__get());
           }
       }
   };
    // optional<T&> is currently required ill-formed, however it may to be in the
// future. For this reason it has already been implemented to ensure we can
// make the change in an ABI compatible manner.
template <class _Tp> struct __optional_storage_base<_Tp, true> {
       using value_type = _Tp;
       using __raw_type = remove_reference_t<_Tp>;
       __raw_type* __value_;
        template <class _Up>     static constexpr bool __can_bind_reference() {
           using _RawUp = typename remove_reference<_Up>::type;
           using _UpPtr = _RawUp*;
           using _RawTp = typename remove_reference<_Tp>::type;
           using _TpPtr = _RawTp*;
           using _CheckLValueArg = integral_constant<bool,             (is_lvalue_reference<_Up>::value && is_convertible<_UpPtr, _TpPtr>::value)         ||  is_same<_RawUp, reference_wrapper<_RawTp>>::value         ||  is_same<_RawUp, reference_wrapper<typename remove_const<_RawTp>::type>>::value         >;
           return (is_lvalue_reference<_Tp>::value && _CheckLValueArg::value)             || (is_rvalue_reference<_Tp>::value && !is_lvalue_reference<_Up>::value &&                 is_convertible<_UpPtr, _TpPtr>::value);
       }
        _LIBCPP_INLINE_VISIBILITY     constexpr __optional_storage_base() noexcept         :  __value_(nullptr) {
  }
        template <class _UArg>     _LIBCPP_INLINE_VISIBILITY     constexpr explicit __optional_storage_base(in_place_t, _UArg&& __uarg)         :  __value_(_VSTD::addressof(__uarg))     {
         static_assert(__can_bind_reference<_UArg>(),         "Attempted to construct a reference element in tuple from a "         "possible temporary");
       }
        _LIBCPP_INLINE_VISIBILITY     void reset() noexcept {
   __value_ = nullptr;
   }
        _LIBCPP_INLINE_VISIBILITY     constexpr bool has_value() const noexcept       {
   return __value_ != nullptr;
   }
        _LIBCPP_INLINE_VISIBILITY     constexpr value_type& __get() const& noexcept       {
   return *__value_;
   }
        _LIBCPP_INLINE_VISIBILITY     constexpr value_type&& __get() const&& noexcept       {
   return _VSTD::forward<value_type>(*__value_);
   }
        template <class _UArg>     _LIBCPP_INLINE_VISIBILITY     void __construct(_UArg&& __val)     {
           _LIBCPP_ASSERT(!has_value(), "__construct called for engaged __optional_storage");
           static_assert(__can_bind_reference<_UArg>(),             "Attempted to construct a reference element in tuple from a "             "possible temporary");
           __value_ = _VSTD::addressof(__val);
       }
        template <class _That>     _LIBCPP_INLINE_VISIBILITY     void __construct_from(_That&& __opt)     {
           if (__opt.has_value())             __construct(_VSTD::forward<_That>(__opt).__get());
       }
        template <class _That>     _LIBCPP_INLINE_VISIBILITY     void __assign_from(_That&& __opt)     {
           if (has_value() == __opt.has_value())         {
               if (has_value())                 *__value_ = _VSTD::forward<_That>(__opt).__get();
           }
           else         {
               if (has_value())                 reset();
               else                 __construct(_VSTD::forward<_That>(__opt).__get());
           }
       }
   };
    template <class _Tp, bool = is_trivially_copy_constructible<_Tp>::value> struct __optional_copy_base : __optional_storage_base<_Tp> {
       using __optional_storage_base<_Tp>::__optional_storage_base;
   };
    template <class _Tp> struct __optional_copy_base<_Tp, false> : __optional_storage_base<_Tp> {
       using __optional_storage_base<_Tp>::__optional_storage_base;
        _LIBCPP_INLINE_VISIBILITY     __optional_copy_base() = default;
        _LIBCPP_INLINE_VISIBILITY     __optional_copy_base(const __optional_copy_base& __opt)     {
           this->__construct_from(__opt);
       }
        _LIBCPP_INLINE_VISIBILITY     __optional_copy_base(__optional_copy_base&&) = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_copy_base& operator=(const __optional_copy_base&) = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_copy_base& operator=(__optional_copy_base&&) = default;
   };
    template <class _Tp, bool = is_trivially_move_constructible<_Tp>::value> struct __optional_move_base : __optional_copy_base<_Tp> {
       using __optional_copy_base<_Tp>::__optional_copy_base;
   };
    template <class _Tp> struct __optional_move_base<_Tp, false> : __optional_copy_base<_Tp> {
       using value_type = _Tp;
       using __optional_copy_base<_Tp>::__optional_copy_base;
        _LIBCPP_INLINE_VISIBILITY     __optional_move_base() = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_move_base(const __optional_move_base&) = default;
        _LIBCPP_INLINE_VISIBILITY     __optional_move_base(__optional_move_base&& __opt)         noexcept(is_nothrow_move_constructible_v<value_type>)     {
           this->__construct_from(_VSTD::move(__opt));
       }
        _LIBCPP_INLINE_VISIBILITY     __optional_move_base& operator=(const __optional_move_base&) = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_move_base& operator=(__optional_move_base&&) = default;
   };
    template <class _Tp, bool =     is_trivially_destructible<_Tp>::value &&     is_trivially_copy_constructible<_Tp>::value &&     is_trivially_copy_assignable<_Tp>::value> struct __optional_copy_assign_base : __optional_move_base<_Tp> {
       using __optional_move_base<_Tp>::__optional_move_base;
   };
    template <class _Tp> struct __optional_copy_assign_base<_Tp, false> : __optional_move_base<_Tp> {
       using __optional_move_base<_Tp>::__optional_move_base;
        _LIBCPP_INLINE_VISIBILITY     __optional_copy_assign_base() = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_copy_assign_base(const __optional_copy_assign_base&) = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_copy_assign_base(__optional_copy_assign_base&&) = default;
        _LIBCPP_INLINE_VISIBILITY     __optional_copy_assign_base& operator=(const __optional_copy_assign_base& __opt)     {
           this->__assign_from(__opt);
           return *this;
       }
        _LIBCPP_INLINE_VISIBILITY     __optional_copy_assign_base& operator=(__optional_copy_assign_base&&) = default;
   };
    template <class _Tp, bool =     is_trivially_destructible<_Tp>::value &&     is_trivially_move_constructible<_Tp>::value &&     is_trivially_move_assignable<_Tp>::value> struct __optional_move_assign_base : __optional_copy_assign_base<_Tp> {
       using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;
   };
    template <class _Tp> struct __optional_move_assign_base<_Tp, false> : __optional_copy_assign_base<_Tp> {
       using value_type = _Tp;
       using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;
        _LIBCPP_INLINE_VISIBILITY     __optional_move_assign_base() = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_move_assign_base(const __optional_move_assign_base& __opt) = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_move_assign_base(__optional_move_assign_base&&) = default;
       _LIBCPP_INLINE_VISIBILITY     __optional_move_assign_base& operator=(const __optional_move_assign_base&) = default;
        _LIBCPP_INLINE_VISIBILITY     __optional_move_assign_base& operator=(__optional_move_assign_base&& __opt)         noexcept(is_nothrow_move_assignable_v<value_type> &&                  is_nothrow_move_constructible_v<value_type>)     {
           this->__assign_from(_VSTD::move(__opt));
           return *this;
       }
   };
    template <class _Tp> using __optional_sfinae_ctor_base_t = __sfinae_ctor_base<     is_copy_constructible<_Tp>::value,     is_move_constructible<_Tp>::value >;
    template <class _Tp> using __optional_sfinae_assign_base_t = __sfinae_assign_base<     (is_copy_constructible<_Tp>::value && is_copy_assignable<_Tp>::value),     (is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value) >;
    template <class _Tp> class optional     : private __optional_move_assign_base<_Tp>     , private __optional_sfinae_ctor_base_t<_Tp>     , private __optional_sfinae_assign_base_t<_Tp> {
       using __base = __optional_move_assign_base<_Tp>;
   public:     using value_type = _Tp;
    private:      // Disable the reference extension using this static assert.
    static_assert(!is_same_v<value_type, in_place_t>,         "instantiation of optional with in_place_t is ill-formed");
       static_assert(!is_same_v<__uncvref_t<value_type>, nullopt_t>,         "instantiation of optional with nullopt_t is ill-formed");
       static_assert(!is_reference_v<value_type>,         "instantiation of optional with a reference type is ill-formed");
       static_assert(is_destructible_v<value_type>,         "instantiation of optional with a non-destructible type is ill-formed");
        // LWG2756: conditionally explicit conversion from _Up
    struct _CheckOptionalArgsConstructor {
         template <class _Up>       static constexpr bool __enable_implicit() {
             return is_constructible_v<_Tp, _Up&&> &&                  is_convertible_v<_Up&&, _Tp>;
         }
          template <class _Up>       static constexpr bool __enable_explicit() {
             return is_constructible_v<_Tp, _Up&&> &&                  !is_convertible_v<_Up&&, _Tp>;
         }
       };
       template <class _Up>     using _CheckOptionalArgsCtor = conditional_t<         !is_same_v<decay_t<_Up>, in_place_t> &&         !is_same_v<decay_t<_Up>, optional>,         _CheckOptionalArgsConstructor,         __check_tuple_constructor_fail     >;
       template <class _QualUp>     struct _CheckOptionalLikeConstructor {
         template <class _Up, class _Opt = optional<_Up>>       using __check_constructible_from_opt = __lazy_or<           is_constructible<_Tp, _Opt&>,           is_constructible<_Tp, _Opt const&>,           is_constructible<_Tp, _Opt&&>,           is_constructible<_Tp, _Opt const&&>,           is_convertible<_Opt&, _Tp>,           is_convertible<_Opt const&, _Tp>,           is_convertible<_Opt&&, _Tp>,           is_convertible<_Opt const&&, _Tp>       >;
         template <class _Up, class _Opt = optional<_Up>>       using __check_assignable_from_opt = __lazy_or<           is_assignable<_Tp&, _Opt&>,           is_assignable<_Tp&, _Opt const&>,           is_assignable<_Tp&, _Opt&&>,           is_assignable<_Tp&, _Opt const&&>       >;
         template <class _Up, class _QUp = _QualUp>       static constexpr bool __enable_implicit() {
             return is_convertible<_QUp, _Tp>::value &&               !__check_constructible_from_opt<_Up>::value;
         }
         template <class _Up, class _QUp = _QualUp>       static constexpr bool __enable_explicit() {
             return !is_convertible<_QUp, _Tp>::value &&               !__check_constructible_from_opt<_Up>::value;
         }
         template <class _Up, class _QUp = _QualUp>       static constexpr bool __enable_assign() {
             // Construction and assignability of _Qup to _Tp has already been
          // checked.
          return !__check_constructible_from_opt<_Up>::value &&               !__check_assignable_from_opt<_Up>::value;
         }
       };
        _LIBCPP_INLINE_VISIBILITY     optional& operator=(nullopt_t) noexcept     {
           reset();
           return *this;
       }
        _LIBCPP_INLINE_VISIBILITY optional& operator=(const optional&) = default;
       _LIBCPP_INLINE_VISIBILITY optional& operator=(optional&&) = default;
        // LWG2756
    template <class _Up = value_type,               class = enable_if_t                       <__lazy_and<                           integral_constant<bool,                               !is_same_v<decay_t<_Up>, optional> &&                               !(is_same_v<_Up, value_type> && is_scalar_v<value_type>)                           >,                           is_constructible<value_type, _Up>,                           is_assignable<value_type&, _Up>                       >::value>              >     _LIBCPP_INLINE_VISIBILITY     optional&     operator=(_Up&& __v)     {
       }
        _LIBCPP_INLINE_VISIBILITY     void swap(optional& __opt)         noexcept(is_nothrow_move_constructible_v<value_type> &&                  is_nothrow_swappable_v<value_type>)     {
           if (this->has_value() == __opt.has_value())         {
               using _VSTD::swap;
               if (this->has_value())                 swap(this->__get(), __opt.__get());
           }
           else         {
               if (this->has_value())             {
                   __opt.__construct(_VSTD::move(this->__get()));
                   reset();
               }
               else             {
                   this->__construct(_VSTD::move(__opt.__get()));
                   __opt.reset();
               }
           }
       }
        _LIBCPP_INLINE_VISIBILITY     constexpr     add_pointer_t<value_type const>     operator->() const     {
           _LIBCPP_ASSERT(this->has_value(), "optional operator-> called for disengaged value");
     
#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
        return _VSTD::addressof(this->__get());
     
#else
        return __operator_arrow(__has_operator_addressof<value_type>{
  }
  , this->__get());
     
#endif
    }
        _LIBCPP_INLINE_VISIBILITY     constexpr     add_pointer_t<value_type>     operator->()     {
           _LIBCPP_ASSERT(this->has_value(), "optional operator-> called for disengaged value");
     
#ifndef _LIBCPP_HAS_NO_BUILTIN_ADDRESSOF
        return _VSTD::addressof(this->__get());
     
#else
        return __operator_arrow(__has_operator_addressof<value_type>{
  }
  , this->__get());
     
#endif
    }
        _LIBCPP_INLINE_VISIBILITY     constexpr     const value_type&     operator*() const&     {
           _LIBCPP_ASSERT(this->has_value(), "optional operator* called for disengaged value");
       }
        template <class _Up>     _LIBCPP_INLINE_VISIBILITY     constexpr value_type value_or(_Up&& __v) &&     {
           static_assert(is_move_constructible_v<value_type>,                       "optional<T>::value_or: T must be move constructible");
           static_assert(is_convertible_v<_Up, value_type>,                       "optional<T>::value_or: U must be convertible to T");
           return this->has_value() ? _VSTD::move(this->__get()) :                                   static_cast<value_type>(_VSTD::forward<_Up>(__v));
       }
        using __base::reset;
    private:     template <class _Up>     _LIBCPP_INLINE_VISIBILITY     static _Up*     __operator_arrow(true_type, _Up& __x)     {
           return _VSTD::addressof(__x);
       }
        template <class _Up>     _LIBCPP_INLINE_VISIBILITY     static constexpr _Up*     __operator_arrow(false_type, _Up& __x)     {
           return &__x;
       }
   };
    // Comparisons between optionals
template <class _Tp, class _Up> _LIBCPP_INLINE_VISIBILITY constexpr enable_if_t<     is_convertible_v<decltype(_VSTD::declval<const _Tp&>() ==         _VSTD::declval<const _Up&>()), bool>,     bool > operator==(const optional<_Tp>& __x, const optional<_Up>& __y) {
       return true;
   }
    template <class _Tp> _LIBCPP_INLINE_VISIBILITY constexpr bool operator>=(nullopt_t, const optional<_Tp>& __x) noexcept {
       return !static_cast<bool>(__x);
   }
    // Comparisons with T
template <class _Tp, class _Up> _LIBCPP_INLINE_VISIBILITY constexpr enable_if_t<     is_convertible_v<decltype(_VSTD::declval<const _Tp&>() ==         _VSTD::declval<const _Up&>()), bool>,     bool > operator==(const optional<_Tp>& __x, const _Up& __v) {
       return static_cast<bool>(__x) ? *__x == __v : false;
   }
    template <class _Tp, class _Up> _LIBCPP_INLINE_VISIBILITY constexpr enable_if_t<     is_convertible_v<decltype(_VSTD::declval<const _Tp&>() ==         _VSTD::declval<const _Up&>()), bool>,     bool > operator==(const _Tp& __v, const optional<_Up>& __x) {
       return static_cast<bool>(__x) ? __v == *__x : false;
   }
    template <class _Tp, class _Up> _LIBCPP_INLINE_VISIBILITY constexpr enable_if_t<     is_convertible_v<decltype(_VSTD::declval<const _Tp&>() !=         _VSTD::declval<const _Up&>()), bool>,     bool > operator!=(const optional<_Tp>& __x, const _Up& __v) {
       return static_cast<bool>(__x) ? *__x != __v : true;
   }
    template <class _Tp, class _Up> _LIBCPP_INLINE_VISIBILITY constexpr enable_if_t<     is_convertible_v<decltype(_VSTD::declval<const _Tp&>() !=         _VSTD::declval<const _Up&>()), bool>,     bool > operator!=(const _Tp& __v, const optional<_Up>& __x) {
       return static_cast<bool>(__x) ? __v != *__x : true;
   }
    template <class _Tp, class _Up> _LIBCPP_INLINE_VISIBILITY constexpr enable_if_t<     is_convertible_v<decltype(_VSTD::declval<const _Tp&>() <         _VSTD::declval<const _Up&>()), bool>,     bool > operator<(const optional<_Tp>& __x, const _Up& __v) {
       return static_cast<bool>(__x) ? *__x < __v : true;
   }
    template <class _Tp, class _Up> _LIBCPP_INLINE_VISIBILITY constexpr enable_if_t<     is_convertible_v<decltype(_VSTD::declval<const _Tp&>() <         _VSTD::declval<const _Up&>()), bool>,     bool > operator<(const _Tp& __v, const optional<_Up>& __x) {
       return static_cast<bool>(__x) ? __v < *__x : false;
   }
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash<     __enable_hash_helper<optional<_Tp>, remove_const_t<_Tp>> > {
       typedef optional<_Tp> argument_type;
       typedef size_t        result_type;
        _LIBCPP_INLINE_VISIBILITY     result_type operator()(const argument_type& __opt) const     {
           return static_cast<bool>(__opt) ? hash<remove_const_t<_Tp>>()(*__opt) : 0;
       }
   };
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_STD_VER > 14
 _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_OPTIONAL
  
#pragma clang module end /*std.optional*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "ostream"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.ostream
// -*- C++ -*-
   
#ifndef _LIBCPP_OSTREAM
  
#define _LIBCPP_OSTREAM
 /*     ostream synopsis  template <class charT, class traits = char_traits<charT> > class basic_ostream     : virtual public basic_ios<charT,traits> {
   public:     // types (inherited from basic_ios (27.5.4)):
    typedef charT                          char_type;
       typedef traits                         traits_type;
    }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        if (this->rdbuf())         {
               sentry __s(*this);
               if (__s)             {
                   if (this->rdbuf()->pubsync() == -1)                     this->setstate(ios_base::badbit);
               }
           }
       __os.flush();
       return __os;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Stream, class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename enable_if <     !is_lvalue_reference<_Stream>::value &&     is_base_of<ios_base, _Stream>::value,     _Stream&& >::type operator<<(_Stream&& __os, const _Tp& __x) {
       __os << __x;
       return _VSTD::move(__os);
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template<class _CharT, class _Traits, class _Allocator> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const basic_string<_CharT, _Traits, _Allocator>& __str) {
       return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());
   }
    template<class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const basic_string_view<_CharT, _Traits> __sv) {
#endif  // _LIBCPP_OSTREAM
  
#pragma clang module end /*std.ostream*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "queue"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.queue
// -*- C++ -*-
//===--------------------------- queue ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_QUEUE
  
#define _LIBCPP_QUEUE
 /*     queue synopsis  namespace std {
    template <class T, class Container = deque<T>> class queue {
   public:     typedef Container                                container_type;
       typedef typename container_type::value_type      value_type;
       typedef typename container_type::reference       reference;
       typedef typename container_type::const_reference const_reference;
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.deque
// -*- C++ -*-
//===---------------------------- deque -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_DEQUE
  
#define _LIBCPP_DEQUE
 /*     deque synopsis  namespace std {
    template <class T, class Allocator = allocator<T> > class deque {
   public:     // types:
    typedef T value_type;
       typedef Allocator allocator_type;
        typedef typename allocator_type::reference       reference;
       typedef typename allocator_type::const_reference const_reference;
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Tp, class _Allocator> class __deque_base;
   template <class _Tp, class _Allocator = allocator<_Tp> > class _LIBCPP_TEMPLATE_VIS deque;
    template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,           class _DiffType, _DiffType _BlockSize> class _LIBCPP_TEMPLATE_VIS __deque_iterator;
    template <class _RAIter,           class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2> __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy(_RAIter __f,      _RAIter __l,      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,      typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_DEQUE
  
#pragma clang module end /*std.deque*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <vector>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.vector
// -*- C++ -*-
//===------------------------------ vector --------------------------------===//
#ifndef _LIBCPP_VECTOR
  
#define _LIBCPP_VECTOR
 /*     vector synopsis  namespace std {
    template <class T, class Allocator = allocator<T> > class vector {
   public:     typedef T                                        value_type;
       typedef Allocator                                allocator_type;
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  template <bool> class __vector_base_common {
   protected:     _LIBCPP_ALWAYS_INLINE __vector_base_common() {
  }
       _LIBCPP_NORETURN void __throw_length_error() const;
       _LIBCPP_NORETURN void __throw_out_of_range() const;
   };
    template <bool __b> void __vector_base_common<__b>::__throw_length_error() const {
       _VSTD::__throw_length_error("vector");
   }
    template <bool __b> void __vector_base_common<__b>::__throw_out_of_range() const {
       _VSTD::__throw_out_of_range("vector");
   }
    _LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS __vector_base_common<true>)  template <class _Tp, class _Allocator> class __vector_base     : protected __vector_base_common<true> {
   protected:     typedef _Tp                                      value_type;
       typedef _Allocator                               allocator_type;
       typedef allocator_traits<allocator_type>         __alloc_traits;
       typedef value_type&                              reference;
       typedef const value_type&                        const_reference;
       typedef typename __alloc_traits::size_type       size_type;
       typedef typename __alloc_traits::difference_type difference_type;
       typedef typename __alloc_traits::pointer         pointer;
       typedef typename __alloc_traits::const_pointer   const_pointer;
       typedef pointer                                  iterator;
       typedef const_pointer                            const_iterator;
        pointer                                         __begin_;
       pointer                                         __end_;
       __compressed_pair<pointer, allocator_type> __end_cap_;
        _LIBCPP_INLINE_VISIBILITY     allocator_type& __alloc() _NOEXCEPT         {
  return __end_cap_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     const allocator_type& __alloc() const _NOEXCEPT         {
  return __end_cap_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     pointer& __end_cap() _NOEXCEPT         {
  return __end_cap_.first();
  }
       _LIBCPP_INLINE_VISIBILITY     const pointer& __end_cap() const _NOEXCEPT         {
  return __end_cap_.first();
  }
        _LIBCPP_INLINE_VISIBILITY     __vector_base()         _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);
       _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);
       ~__vector_base();
        _LIBCPP_INLINE_VISIBILITY     void clear() _NOEXCEPT {
  __destruct_at_end(__begin_);
  }
       _LIBCPP_INLINE_VISIBILITY     size_type capacity() const _NOEXCEPT         {
  return static_cast<size_type>(__end_cap() - __begin_);
  }
        _LIBCPP_INLINE_VISIBILITY     void __destruct_at_end(pointer __new_last) _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const __vector_base& __c)         {
  __copy_assign_alloc(__c, integral_constant<bool,                       __alloc_traits::propagate_on_container_copy_assignment::value>());
  }
        _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(__vector_base& __c)         _NOEXCEPT_(             !__alloc_traits::propagate_on_container_move_assignment::value ||             is_nothrow_move_assignable<allocator_type>::value)         {
               __alloc() = __c.__alloc();
           }
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const __vector_base&, false_type)         {
  }
        _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(__vector_base& __c, true_type)         _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)         {
               __alloc() = _VSTD::move(__c.__alloc());
           }
        _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(__vector_base&, false_type)         _NOEXCEPT         {
  }
   };
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void __vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT {
       pointer __soon_to_be_end = __end_;
       while (__new_last != __soon_to_be_end)         __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__soon_to_be_end));
       __end_ = __new_last;
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY __vector_base<_Tp, _Allocator>::__vector_base()         _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)     : __begin_(nullptr),       __end_(nullptr),       __end_cap_(nullptr) {
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY __vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)     : __begin_(nullptr),       __end_(nullptr),       __end_cap_(nullptr, __a) {
   }
    template <class _Tp, class _Allocator> __vector_base<_Tp, _Allocator>::~__vector_base() {
       if (__begin_ != nullptr)     {
           clear();
           __alloc_traits::deallocate(__alloc(), __begin_, capacity());
       }
   }
    template <class _Tp, class _Allocator /* = allocator<_Tp> */> class _LIBCPP_TEMPLATE_VIS vector     : private __vector_base<_Tp, _Allocator> {
   private:     typedef __vector_base<_Tp, _Allocator>           __base;
       typedef allocator<_Tp>                           __default_allocator_type;
   public:     typedef vector                                   __self;
       typedef _Tp                                      value_type;
       typedef _Allocator                               allocator_type;
       typedef typename __base::__alloc_traits          __alloc_traits;
       typedef typename __base::reference               reference;
       typedef typename __base::const_reference         const_reference;
       typedef typename __base::size_type               size_type;
       typedef typename __base::difference_type         difference_type;
       typedef typename __base::pointer                 pointer;
       typedef typename __base::const_pointer           const_pointer;
       typedef __wrap_iter<pointer>                     iterator;
       typedef __wrap_iter<const_pointer>               const_iterator;
       typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;
       typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;
        static_assert((is_same<typename allocator_type::value_type, value_type>::value),                   "Allocator::value_type must be same type as value_type");
        _LIBCPP_INLINE_VISIBILITY     vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)         {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
#endif
    }
       explicit vector(size_type __n);
     
#if _LIBCPP_STD_VER > 11
    explicit vector(size_type __n, const allocator_type& __a);
     
#endif
    vector(size_type __n, const_reference __x);
       vector(size_type __n, const_reference __x, const allocator_type& __a);
       template <class _InputIterator>         vector(_InputIterator __first,                typename enable_if<__is_input_iterator  <_InputIterator>::value &&                                  !__is_forward_iterator<_InputIterator>::value &&                                  is_constructible<                                     value_type,                                     typename iterator_traits<_InputIterator>::reference>::value,                                  _InputIterator>::type __last);
       template <class _InputIterator>         vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,                typename enable_if<__is_input_iterator  <_InputIterator>::value &&                                  !__is_forward_iterator<_InputIterator>::value &&                                  is_constructible<                                     value_type,                                     typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);
       template <class _ForwardIterator>         vector(_ForwardIterator __first,                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&                                  is_constructible<                                     value_type,                                     typename iterator_traits<_ForwardIterator>::reference>::value,                                  _ForwardIterator>::type __last);
       template <class _ForwardIterator>         vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&                                  is_constructible<                                     value_type,                                     typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);
      
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     ~vector()     {
           __get_db()->__erase_c(this);
       }
     
#endif
     vector(const vector& __x);
       vector(const vector& __x, const allocator_type& __a);
       _LIBCPP_INLINE_VISIBILITY     vector& operator=(const vector& __x);
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     vector(initializer_list<value_type> __il);
        _LIBCPP_INLINE_VISIBILITY     vector(initializer_list<value_type> __il, const allocator_type& __a);
        _LIBCPP_INLINE_VISIBILITY     vector(vector&& __x)   
#if _LIBCPP_STD_VER > 14
        _NOEXCEPT;
     
#else
        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
     
#endif
     _LIBCPP_INLINE_VISIBILITY     vector(vector&& __x, const allocator_type& __a);
       _LIBCPP_INLINE_VISIBILITY     vector& operator=(vector&& __x)         _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
        _LIBCPP_INLINE_VISIBILITY     vector& operator=(initializer_list<value_type> __il)         {
  assign(__il.begin(), __il.end());
   return *this;
  }
      
#endif  // !_LIBCPP_CXX03_LANG
     template <class _InputIterator>         typename enable_if         <              __is_input_iterator  <_InputIterator>::value &&             !__is_forward_iterator<_InputIterator>::value &&             is_constructible<                  value_type,                  typename iterator_traits<_InputIterator>::reference>::value,             void         >::type         assign(_InputIterator __first, _InputIterator __last);
       template <class _ForwardIterator>         typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value &&             is_constructible<                  value_type,                  typename iterator_traits<_ForwardIterator>::reference>::value,             void         >::type         assign(_ForwardIterator __first, _ForwardIterator __last);
        void assign(size_type __n, const_reference __u);
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     void assign(initializer_list<value_type> __il)         {
  assign(__il.begin(), __il.end());
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     allocator_type get_allocator() const _NOEXCEPT         {
  return this->__alloc();
  }
        _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     reverse_iterator       rbegin() _NOEXCEPT         {
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rend()    const _NOEXCEPT         {
  return const_reverse_iterator(begin());
  }
        _LIBCPP_INLINE_VISIBILITY     const_iterator         cbegin()  const _NOEXCEPT         {
  return begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator         cend()    const _NOEXCEPT         {
  return end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crbegin() const _NOEXCEPT         {
  return rbegin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crend()   const _NOEXCEPT         {
  return rend();
  }
        _LIBCPP_INLINE_VISIBILITY     size_type size() const _NOEXCEPT         {
  return static_cast<size_type>(this->__end_ - this->__begin_);
  }
       _LIBCPP_INLINE_VISIBILITY     size_type capacity() const _NOEXCEPT         {
  return __base::capacity();
  }
       _LIBCPP_INLINE_VISIBILITY     bool empty() const _NOEXCEPT         {
  return this->__begin_ == this->__end_;
  }
       size_type max_size() const _NOEXCEPT;
       void reserve(size_type __n);
       void shrink_to_fit() _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);
       _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;
       reference       at(size_type __n);
       const_reference at(size_type __n) const;
        _LIBCPP_INLINE_VISIBILITY reference       front()     {
           _LIBCPP_ASSERT(!empty(), "front() called for empty vector");
           return *this->__begin_;
       }
       _LIBCPP_INLINE_VISIBILITY const_reference front() const     {
           _LIBCPP_ASSERT(!empty(), "front() called for empty vector");
           return *this->__begin_;
           return *(this->__end_ - 1);
       }
        _LIBCPP_INLINE_VISIBILITY     value_type*       data() _NOEXCEPT         {
  return _VSTD::__to_raw_pointer(this->__begin_);
  }
       _LIBCPP_INLINE_VISIBILITY     const value_type* data() const _NOEXCEPT         {
  return _VSTD::__to_raw_pointer(this->__begin_);
  }
        _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);
        template <class... _Args>         _LIBCPP_INLINE_VISIBILITY   
#if _LIBCPP_STD_VER > 14
        reference emplace_back(_Args&&... __args);
     
#else
        void      emplace_back(_Args&&... __args);
     
#endif
  
#endif // !_LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     void pop_back();
        iterator insert(const_iterator __position, const_reference __x);
      
#ifndef _LIBCPP_CXX03_LANG
    iterator insert(const_iterator __position, value_type&& __x);
       template <class... _Args>         iterator emplace(const_iterator __position, _Args&&... __args);
     
#endif  // !_LIBCPP_CXX03_LANG
     iterator insert(const_iterator __position, size_type __n, const_reference __x);
       template <class _InputIterator>         typename enable_if         <              __is_input_iterator  <_InputIterator>::value &&             !__is_forward_iterator<_InputIterator>::value &&             is_constructible<                  value_type,                  typename iterator_traits<_InputIterator>::reference>::value,             iterator         >::type         insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
       template <class _ForwardIterator>         typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value &&             is_constructible<                  value_type,                  typename iterator_traits<_ForwardIterator>::reference>::value,             iterator         >::type         insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __position, initializer_list<value_type> __il)         {
  return insert(__position, __il.begin(), __il.end());
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);
       iterator erase(const_iterator __first, const_iterator __last);
        _LIBCPP_INLINE_VISIBILITY     void clear() _NOEXCEPT     {
           size_type __old_size = size();
           __base::clear();
           __annotate_shrink(__old_size);
           __invalidate_all_iterators();
       }
        void resize(size_type __sz);
       void resize(size_type __sz, const_reference __x);
        void swap(vector&)   
#if _LIBCPP_STD_VER >= 14
        _NOEXCEPT_DEBUG;
     
#else
        _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||                     __is_nothrow_swappable<allocator_type>::value);
     
#endif
     bool __invariants() const;
      
#if _LIBCPP_DEBUG_LEVEL >= 2
     bool __dereferenceable(const const_iterator* __i) const;
       bool __decrementable(const const_iterator* __i) const;
       bool __addable(const const_iterator* __i, ptrdiff_t __n) const;
       bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;
      
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
 private:     _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();
       _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(pointer __new_last);
       void allocate(size_type __n);
       void deallocate() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;
       void __construct_at_end(size_type __n);
       _LIBCPP_INLINE_VISIBILITY     void __construct_at_end(size_type __n, const_reference __x);
       template <class _ForwardIterator>         typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value,             void         >::type         __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);
       void __append(size_type __n);
       void __append(size_type __n, const_reference __x);
       _LIBCPP_INLINE_VISIBILITY     iterator       __make_iter(pointer __p) _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;
       void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
       pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
       void __move_range(pointer __from_s, pointer __from_e, pointer __to);
       void __move_assign(vector& __c, true_type)         _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);
       void __move_assign(vector& __c, false_type)         _NOEXCEPT_(__alloc_traits::is_always_equal::value);
       _LIBCPP_INLINE_VISIBILITY     void __destruct_at_end(pointer __new_last) _NOEXCEPT     {
           __invalidate_iterators_past(__new_last);
           size_type __old_size = size();
           __base::__destruct_at_end(__new_last);
           __annotate_shrink(__old_size);
       }
      
#ifndef _LIBCPP_CXX03_LANG
    template <class _Up> void __push_back_slow_path(_Up&& __x);
        template <class... _Args>     void __emplace_back_slow_path(_Args&&... __args);
     
#else
    template <class _Up> void __push_back_slow_path(_Up& __x);
     
#endif
     // The following functions are no-ops outside of AddressSanitizer mode.
    // We call annotatations only for the default Allocator because other allocators
    // may not meet the AddressSanitizer alignment constraints.
    // See the documentation for __sanitizer_annotate_contiguous_container for more details.
  
#ifndef _LIBCPP_HAS_NO_ASAN
    void __annotate_contiguous_container(const void *__beg, const void *__end,                                          const void *__old_mid,                                          const void *__new_mid) const     {
          if (__beg && is_same<allocator_type, __default_allocator_type>::value)         __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);
       }
     
#else
    _LIBCPP_INLINE_VISIBILITY     void __annotate_contiguous_container(const void*, const void*, const void*,                                          const void*) const {
  }
     
#endif
    _LIBCPP_INLINE_VISIBILITY     void __annotate_new(size_type __current_size) const {
         __annotate_contiguous_container(data(), data() + capacity(),                                       data() + capacity(), data() + __current_size);
       }
        _LIBCPP_INLINE_VISIBILITY     void __annotate_delete() const {
         __annotate_contiguous_container(data(), data() + capacity(),                                       data() + size(), data() + capacity());
       }
        _LIBCPP_INLINE_VISIBILITY     void __annotate_increase(size_type __n) const     {
         __annotate_contiguous_container(data(), data() + capacity(),                                       data() + size(), data() + size() + __n);
       }
        _LIBCPP_INLINE_VISIBILITY     void __annotate_shrink(size_type __old_size) const     {
         __annotate_contiguous_container(data(), data() + capacity(),                                       data() + __old_size, data() + size());
       }
     
#ifndef _LIBCPP_HAS_NO_ASAN
    // The annotation for size increase should happen before the actual increase,
    // but if an exception is thrown after that the annotation has to be undone.
    struct __RAII_IncreaseAnnotator {
#else
    struct __RAII_IncreaseAnnotator {
         _LIBCPP_INLINE_VISIBILITY       __RAII_IncreaseAnnotator(const vector &, size_type = 1) {
  }
         _LIBCPP_INLINE_VISIBILITY void __done() {
  }
       };
     
#endif
 };
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v) {
       __annotate_delete();
       __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
       _VSTD::swap(this->__begin_, __v.__begin_);
       _VSTD::swap(this->__end_, __v.__end_);
       _VSTD::swap(this->__end_cap(), __v.__end_cap());
       __v.__first_ = __v.__begin_;
       __annotate_new(size());
       __invalidate_all_iterators();
   }
    template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::pointer vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p) {
       __annotate_delete();
       pointer __r = __v.__begin_;
       return __r;
   }
    //  Allocate space for __n objects
//  throws length_error if __n > max_size()
//  throws (probably bad_alloc) if memory run out
//  Precondition:  __begin_ == __end_ == __end_cap() == 0
//  Precondition:  __n > 0
  //  Default constructs __n objects starting at __end_
//  throws if construction throws
//  Postcondition:  size() == size() + __n
//  Exception safety: strong.
template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x) {
       if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)         this->__construct_at_end(__n, __x);
       else     {
           allocator_type& __a = this->__alloc();
           __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
           __v.__construct_at_end(__n, __x);
           __swap_out_circular_buffer(__v);
       }
   }
    template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector(size_type __n) {
     
   }
      
#if _LIBCPP_STD_VER > 11
template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)     : __base(__a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__n);
       }
   }
     
#endif
 template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__n, __x);
       }
   }
    template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)     : __base(__a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__n, __x);
       }
   }
    template <class _Tp, class _Allocator> template <class _InputIterator> vector<_Tp, _Allocator>::vector(_InputIterator __first,        typename enable_if<__is_input_iterator  <_InputIterator>::value &&                          !__is_forward_iterator<_InputIterator>::value &&                          is_constructible<                             value_type,                             typename iterator_traits<_InputIterator>::reference>::value,                           _InputIterator>::type __last) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    for (;
   __first != __last;
   ++__first)         push_back(*__first);
   }
    template <class _Tp, class _Allocator> template <class _InputIterator> vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,        typename enable_if<__is_input_iterator  <_InputIterator>::value &&                          !__is_forward_iterator<_InputIterator>::value &&                          is_constructible<                             value_type,                             typename iterator_traits<_InputIterator>::reference>::value>::type*)     : __base(__a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
    __get_db()->__insert_c(this);
     
#endif
    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));
       if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__first, __last, __n);
       }
       if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__first, __last, __n);
       }
   }
    template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector(const vector& __x)     : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc())) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    size_type __n = __x.size();
       if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__x.__begin_, __x.__end_, __n);
       }
   }
    template <class _Tp, class _Allocator> vector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)     : __base(__a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    size_type __n = __x.size();
       if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__x.__begin_, __x.__end_, __n);
       }
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<_Tp, _Allocator>::vector(vector&& __x)   
#if _LIBCPP_STD_VER > 14
        _NOEXCEPT   
#else
        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)   
#endif
    : __base(_VSTD::move(__x.__alloc())) {
       this->__end_cap() = __x.__end_cap();
       __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)     : __base(__a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    if (__a == __x.__alloc())     {
           this->__begin_ = __x.__begin_;
           this->__end_ = __x.__end_;
           this->__end_cap() = __x.__end_cap();
           __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
     
#if _LIBCPP_DEBUG_LEVEL >= 2
        __get_db()->swap(this, &__x);
     
#endif
    }
       else     {
           typedef move_iterator<iterator> _Ip;
           assign(_Ip(__x.begin()), _Ip(__x.end()));
       }
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<_Tp, _Allocator>& vector<_Tp, _Allocator>::operator=(vector&& __x)     _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {
       __move_assign(__x, integral_constant<bool,           __alloc_traits::propagate_on_container_move_assignment::value>());
       return *this;
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)     _NOEXCEPT_(__alloc_traits::is_always_equal::value) {
       if (__base::__alloc() != __c.__alloc())     {
           typedef move_iterator<iterator> _Ip;
           assign(_Ip(__c.begin()), _Ip(__c.end()));
       }
       else         __move_assign(__c, true_type());
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)     _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value) {
       deallocate();
       __base::__move_assign_alloc(__c);
   // this can throw
    this->__begin_ = __c.__begin_;
       this->__end_ = __c.__end_;
       this->__end_cap() = __c.__end_cap();
       __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->swap(this, &__c);
     
#endif
}
      
#endif  // !_LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<_Tp, _Allocator>& vector<_Tp, _Allocator>::operator=(const vector& __x) {
       if (this != &__x)     {
           __base::__copy_assign_alloc(__x);
           assign(__x.__begin_, __x.__end_);
       }
       return *this;
   }
    template <class _Tp, class _Allocator> template <class _InputIterator> typename enable_if <      __is_input_iterator  <_InputIterator>::value &&     !__is_forward_iterator<_InputIterator>::value &&     is_constructible<        _Tp,        typename iterator_traits<_InputIterator>::reference>::value,     void >::type vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last) {
       clear();
       for (;
   __first != __last;
   ++__first)         push_back(*__first);
   }
    template <class _Tp, class _Allocator> template <class _ForwardIterator> typename enable_if <     __is_forward_iterator<_ForwardIterator>::value &&     is_constructible<        _Tp,        typename iterator_traits<_ForwardIterator>::reference>::value,     void >::type vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last) {
       size_type __new_size = static_cast<size_type>(_VSTD::distance(__first, __last));
       if (__new_size <= capacity())     {
           _ForwardIterator __mid = __last;
           bool __growing = false;
           if (__new_size > size())         {
               __growing = true;
               __mid =  __first;
               _VSTD::advance(__mid, size());
           }
           pointer __m = _VSTD::copy(__first, __mid, this->__begin_);
           if (__growing)             __construct_at_end(__mid, __last, __new_size - size());
           else             this->__destruct_at_end(__m);
       }
       else     {
           deallocate();
           allocate(__recommend(__new_size));
           __construct_at_end(__first, __last, __new_size);
       }
       __invalidate_all_iterators();
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u) {
       if (__n <= capacity())     {
           size_type __s = size();
           _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);
           if (__n > __s)             __construct_at_end(__n - __s, __u);
           else             this->__destruct_at_end(this->__begin_ + __n);
       }
       else     {
           deallocate();
           allocate(__recommend(static_cast<size_type>(__n)));
           __construct_at_end(__n, __u);
       }
       __invalidate_all_iterators();
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    return iterator(this, __p);
     
#else
    return iterator(__p);
     
    return const_iterator(__p);
     
#endif
}
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::begin() _NOEXCEPT {
       return __make_iter(this->__begin_);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<_Tp, _Allocator>::const_iterator vector<_Tp, _Allocator>::begin() const _NOEXCEPT {
       return __make_iter(this->__begin_);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::end() _NOEXCEPT {
       return __make_iter(this->__end_);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<_Tp, _Allocator>::const_iterator vector<_Tp, _Allocator>::end() const _NOEXCEPT {
       return __make_iter(this->__end_);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<_Tp, _Allocator>::reference vector<_Tp, _Allocator>::operator[](size_type __n) {
       _LIBCPP_ASSERT(__n < size(), "vector[] index out of bounds");
       return this->__begin_[__n];
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<_Tp, _Allocator>::const_reference vector<_Tp, _Allocator>::operator[](size_type __n) const {
       _LIBCPP_ASSERT(__n < size(), "vector[] index out of bounds");
       return this->__begin_[__n];
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::reserve(size_type __n) {
       if (__n > capacity())     {
           allocator_type& __a = this->__alloc();
           __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
           __swap_out_circular_buffer(__v);
       }
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT {
       if (capacity() > size())     {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            allocator_type& __a = this->__alloc();
               __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
               __swap_out_circular_buffer(__v);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
   }
    template <class _Tp, class _Allocator> template <class _Up> void   
#ifndef _LIBCPP_CXX03_LANG
vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)   
#else
vector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)   
#endif
{
       allocator_type& __a = this->__alloc();
       __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);
       // __v.push_back(_VSTD::forward<_Up>(__x));
    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));
       __v.__end_++;
       __swap_out_circular_buffer(__v);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void vector<_Tp, _Allocator>::push_back(const_reference __x) {
       if (this->__end_ != this->__end_cap())     {
           __RAII_IncreaseAnnotator __annotator(*this);
           __alloc_traits::construct(this->__alloc(),                                   _VSTD::__to_raw_pointer(this->__end_), __x);
           __annotator.__done();
           ++this->__end_;
       }
       else         __push_back_slow_path(__x);
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void vector<_Tp, _Allocator>::push_back(value_type&& __x) {
       if (this->__end_ < this->__end_cap())     {
           __RAII_IncreaseAnnotator __annotator(*this);
           __alloc_traits::construct(this->__alloc(),                                   _VSTD::__to_raw_pointer(this->__end_),                                   _VSTD::move(__x));
           __annotator.__done();
           ++this->__end_;
       }
       else         __push_back_slow_path(_VSTD::move(__x));
   }
    template <class _Tp, class _Allocator> template <class... _Args> void vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args) {
       allocator_type& __a = this->__alloc();
       __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);
   //    __v.emplace_back(_VSTD::forward<_Args>(__args)...);
    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);
       __v.__end_++;
       __swap_out_circular_buffer(__v);
#if _LIBCPP_STD_VER > 14
    return this->back();
     
#endif
}
      
#endif  // !_LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> inline void vector<_Tp, _Allocator>::pop_back() {
       _LIBCPP_ASSERT(!empty(), "vector::pop_back called for empty vector");
       this->__destruct_at_end(this->__end_ - 1);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::erase(const_iterator __position) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,         "vector::erase(iterator) called with an iterator not"         " referring to this vector");
     
#endif
    _LIBCPP_ASSERT(__position != end(),         "vector::erase(iterator) called with a non-dereferenceable iterator");
       difference_type __ps = __position - cbegin();
       pointer __p = this->__begin_ + __ps;
       this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));
       this->__invalidate_iterators_past(__p-1);
       iterator __r = __make_iter(__p);
       return __r;
   }
    template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,         "vector::erase(iterator,  iterator) called with an iterator not"         " referring to this vector");
       _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,         "vector::erase(iterator,  iterator) called with an iterator not"         " referring to this vector");
     
#endif
    _LIBCPP_ASSERT(__first <= __last, "vector::erase(first, last) called with invalid range");
       pointer __p = this->__begin_ + (__first - begin());
       if (__first != __last) {
           this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));
           this->__invalidate_iterators_past(__p - 1);
       }
       iterator __r = __make_iter(__p);
       return __r;
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to) {
       pointer __old_last = this->__end_;
       difference_type __n = __old_last - __to;
       for (pointer __i = __from_s + __n;
   __i < __from_e;
   ++__i, ++this->__end_)         __alloc_traits::construct(this->__alloc(),                                   _VSTD::__to_raw_pointer(this->__end_),                                   _VSTD::move(*__i));
       _VSTD::move_backward(__from_s, __from_s + __n, __old_last);
   }
    template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,         "vector::insert(iterator, x) called with an iterator not"         " referring to this vector");
     
#endif
    pointer __p = this->__begin_ + (__position - begin());
       if (this->__end_ < this->__end_cap())     {
           __RAII_IncreaseAnnotator __annotator(*this);
           if (__p == this->__end_)         {
               __alloc_traits::construct(this->__alloc(),                                       _VSTD::__to_raw_pointer(this->__end_), __x);
               ++this->__end_;
           }
           else         {
               __move_range(__p, this->__end_, __p + 1);
               const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
               if (__p <= __xr && __xr < this->__end_)                 ++__xr;
               *__p = *__xr;
           }
           __annotator.__done();
       }
       else     {
           allocator_type& __a = this->__alloc();
           __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
           __v.push_back(__x);
           __p = __swap_out_circular_buffer(__v, __p);
       }
       return __make_iter(__p);
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,         "vector::insert(iterator, x) called with an iterator not"         " referring to this vector");
     
#endif
    pointer __p = this->__begin_ + (__position - begin());
       if (this->__end_ < this->__end_cap())     {
           __RAII_IncreaseAnnotator __annotator(*this);
           if (__p == this->__end_)         {
               __alloc_traits::construct(this->__alloc(),                                       _VSTD::__to_raw_pointer(this->__end_),                                       _VSTD::move(__x));
               ++this->__end_;
           }
           else         {
               __move_range(__p, this->__end_, __p + 1);
               *__p = _VSTD::move(__x);
           }
           __annotator.__done();
       }
   }
    template <class _Tp, class _Allocator> template <class... _Args> typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,         "vector::emplace(iterator, x) called with an iterator not"         " referring to this vector");
     
#endif
    pointer __p = this->__begin_ + (__position - begin());
       if (this->__end_ < this->__end_cap())     {
           __RAII_IncreaseAnnotator __annotator(*this);
           if (__p == this->__end_)         {
               __alloc_traits::construct(this->__alloc(),                                       _VSTD::__to_raw_pointer(this->__end_),                                       _VSTD::forward<_Args>(__args)...);
               ++this->__end_;
           }
           else         {
               __temp_value<value_type, _Allocator> __tmp(this->__alloc(), _VSTD::forward<_Args>(__args)...);
               __move_range(__p, this->__end_, __p + 1);
               *__p = _VSTD::move(__tmp.get());
           }
           __annotator.__done();
       }
       else     {
           allocator_type& __a = this->__alloc();
           __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
           __v.emplace_back(_VSTD::forward<_Args>(__args)...);
           __p = __swap_out_circular_buffer(__v, __p);
       }
       return __make_iter(__p);
   }
      
#endif  // !_LIBCPP_CXX03_LANG
 template <class _Tp, class _Allocator> typename vector<_Tp, _Allocator>::iterator vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,         "vector::insert(iterator, n, x) called with an iterator not"         " referring to this vector");
     
#endif
    pointer __p = this->__begin_ + (__position - begin());
       if (__n > 0)     {
           if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))         {
               size_type __old_n = __n;
               pointer __old_last = this->__end_;
               if (__n > static_cast<size_type>(this->__end_ - __p))             {
                   size_type __cx = __n - (this->__end_ - __p);
                   __construct_at_end(__cx, __x);
                   __n -= __cx;
               }
           }
           else         {
               allocator_type& __a = this->__alloc();
               __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
               __v.__construct_at_end(__n, __x);
               __p = __swap_out_circular_buffer(__v, __p);
           }
       }
       return __make_iter(__p);
   }
    template <class _Tp, class _Allocator> template <class _InputIterator> typename enable_if <      __is_input_iterator  <_InputIterator>::value &&     !__is_forward_iterator<_InputIterator>::value &&     is_constructible<        _Tp,        typename iterator_traits<_InputIterator>::reference>::value,     typename vector<_Tp, _Allocator>::iterator >::type vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,         "vector::insert(iterator, range) called with an iterator not"         " referring to this vector");
     
#endif
    difference_type __off = __position - begin();
       pointer __p = this->__begin_ + __off;
       allocator_type& __a = this->__alloc();
       pointer __old_last = this->__end_;
       for (;
   this->__end_ != this->__end_cap() && __first != __last;
   ++__first)     {
           __RAII_IncreaseAnnotator __annotator(*this);
           __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),                                   *__first);
           ++this->__end_;
           __annotator.__done();
       }
       __split_buffer<value_type, allocator_type&> __v(__a);
       if (__first != __last)     {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            __v.__construct_at_end(__first, __last);
               difference_type __old_size = __old_last - this->__begin_;
               difference_type __old_p = __p - this->__begin_;
               reserve(__recommend(size() + __v.size()));
               __p = this->__begin_ + __old_p;
               __old_last = this->__begin_ + __old_size;
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
               erase(__make_iter(__old_last), end());
               throw;
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
       __p = _VSTD::rotate(__p, __old_last, this->__end_);
       insert(__make_iter(__p), make_move_iterator(__v.begin()),                                     make_move_iterator(__v.end()));
       return begin() + __off;
   }
    template <class _Tp, class _Allocator> template <class _ForwardIterator> typename enable_if <     __is_forward_iterator<_ForwardIterator>::value &&     is_constructible<        _Tp,        typename iterator_traits<_ForwardIterator>::reference>::value,     typename vector<_Tp, _Allocator>::iterator >::type vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,         "vector::insert(iterator, range) called with an iterator not"         " referring to this vector");
     
#endif
    pointer __p = this->__begin_ + (__position - begin());
       difference_type __n = _VSTD::distance(__first, __last);
       if (__n > 0)     {
           if (__n <= this->__end_cap() - this->__end_)         {
               size_type __old_n = __n;
               pointer __old_last = this->__end_;
               _ForwardIterator __m = __last;
               allocator_type& __a = this->__alloc();
               __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
               __v.__construct_at_end(__first, __last);
               __p = __swap_out_circular_buffer(__v, __p);
           }
       }
       return __make_iter(__p);
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::resize(size_type __sz) {
       size_type __cs = size();
       if (__cs < __sz)         this->__append(__sz - __cs);
       else if (__cs > __sz)         this->__destruct_at_end(this->__begin_ + __sz);
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x) {
       size_type __cs = size();
       if (__cs < __sz)         this->__append(__sz - __cs, __x);
       else if (__cs > __sz)         this->__destruct_at_end(this->__begin_ + __sz);
   }
    template <class _Tp, class _Allocator> void vector<_Tp, _Allocator>::swap(vector& __x)   
#if _LIBCPP_STD_VER >= 14
    _NOEXCEPT_DEBUG   
#else
    _NOEXCEPT_DEBUG_(!__alloc_traits::propagate_on_container_swap::value ||                 __is_nothrow_swappable<allocator_type>::value)   
#endif
{
       _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||                    this->__alloc() == __x.__alloc(),                    "vector::swap: Either propagate_on_container_swap must be true"                    " or the allocators must compare equal");
       _VSTD::swap(this->__begin_, __x.__begin_);
       _VSTD::swap(this->__end_, __x.__end_);
       _VSTD::swap(this->__end_cap(), __x.__end_cap());
       __swap_allocator(this->__alloc(), __x.__alloc(),         integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->swap(this, &__x);
     
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
}
    template <class _Tp, class _Allocator> bool vector<_Tp, _Allocator>::__invariants() const {
       if (this->__begin_ == nullptr)     {
           if (this->__end_ != nullptr || this->__end_cap() != nullptr)             return false;
       }
       else     {
           if (this->__begin_ > this->__end_)             return false;
           if (this->__begin_ == this->__end_cap())             return false;
           if (this->__end_ > this->__end_cap())             return false;
       }
       return true;
   }
      
#if _LIBCPP_DEBUG_LEVEL >= 2
 template <class _Tp, class _Allocator> bool vector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const {
       return this->__begin_ <= __i->base() && __i->base() < this->__end_;
   }
    template <class _Tp, class _Allocator> bool vector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const {
       return this->__begin_ <= __p && __p < this->__end_;
   }
      
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
 template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void vector<_Tp, _Allocator>::__invalidate_all_iterators() {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__invalidate_all(this);
#endif
}
    // vector<bool>
 template <class _Allocator> class vector<bool, _Allocator>;
    template <class _Allocator> struct hash<vector<bool, _Allocator> >;
    template <class _Allocator> struct __has_storage_type<vector<bool, _Allocator> > {
       static const bool value = true;
   };
    template <class _Allocator> class _LIBCPP_TEMPLATE_VIS vector<bool, _Allocator>     : private __vector_base_common<true> {
   public:     typedef vector                                   __self;
       typedef bool                                     value_type;
       typedef _Allocator                               allocator_type;
       typedef allocator_traits<allocator_type>         __alloc_traits;
       typedef typename __alloc_traits::size_type       size_type;
       typedef typename __alloc_traits::difference_type difference_type;
       typedef size_type __storage_type;
       typedef __bit_iterator<vector, false>            pointer;
       typedef __bit_iterator<vector, true>             const_pointer;
       typedef pointer                                  iterator;
       typedef const_pointer                            const_iterator;
       typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;
       typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;
    private:     typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
       typedef allocator_traits<__storage_allocator>    __storage_traits;
       typedef typename __storage_traits::pointer       __storage_pointer;
       typedef typename __storage_traits::const_pointer __const_storage_pointer;
        __storage_pointer                                      __begin_;
       size_type                                              __size_;
       __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
   public:     typedef __bit_reference<vector>                  reference;
       typedef __bit_const_reference<vector>            const_reference;
   private:     _LIBCPP_INLINE_VISIBILITY     size_type& __cap() _NOEXCEPT         {
  return __cap_alloc_.first();
  }
       _LIBCPP_INLINE_VISIBILITY     const size_type& __cap() const _NOEXCEPT         {
  return __cap_alloc_.first();
  }
       _LIBCPP_INLINE_VISIBILITY     __storage_allocator& __alloc() _NOEXCEPT         {
  return __cap_alloc_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     const __storage_allocator& __alloc() const _NOEXCEPT         {
  return __cap_alloc_.second();
  }
        static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);
        _LIBCPP_INLINE_VISIBILITY     static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT         {
  return __n * __bits_per_word;
  }
       _LIBCPP_INLINE_VISIBILITY     static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT         {
  return (__n - 1) / __bits_per_word + 1;
  }
    public:     _LIBCPP_INLINE_VISIBILITY     vector() _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);
        _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)   
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value);
     
#else
        _NOEXCEPT;
     
#endif
    ~vector();
       explicit vector(size_type __n);
     
#if _LIBCPP_STD_VER > 11
    explicit vector(size_type __n, const allocator_type& __a);
     
#endif
    vector(size_type __n, const value_type& __v);
       vector(size_type __n, const value_type& __v, const allocator_type& __a);
       template <class _InputIterator>         vector(_InputIterator __first, _InputIterator __last,                typename enable_if<__is_input_iterator  <_InputIterator>::value &&                                  !__is_forward_iterator<_InputIterator>::value>::type* = 0);
       template <class _InputIterator>         vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,                typename enable_if<__is_input_iterator  <_InputIterator>::value &&                                  !__is_forward_iterator<_InputIterator>::value>::type* = 0);
       template <class _ForwardIterator>         vector(_ForwardIterator __first, _ForwardIterator __last,                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);
       template <class _ForwardIterator>         vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);
        vector(const vector& __v);
       vector(const vector& __v, const allocator_type& __a);
       vector& operator=(const vector& __v);
      
#ifndef _LIBCPP_CXX03_LANG
    vector(initializer_list<value_type> __il);
       vector(initializer_list<value_type> __il, const allocator_type& __a);
        _LIBCPP_INLINE_VISIBILITY     vector(vector&& __v)   
#if _LIBCPP_STD_VER > 14
        _NOEXCEPT;
     
#else
        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);
     
#endif
    vector(vector&& __v, const allocator_type& __a);
       _LIBCPP_INLINE_VISIBILITY     vector& operator=(vector&& __v)         _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
        _LIBCPP_INLINE_VISIBILITY     vector& operator=(initializer_list<value_type> __il)         {
  assign(__il.begin(), __il.end());
   return *this;
  }
      
#endif  // !_LIBCPP_CXX03_LANG
     template <class _InputIterator>         typename enable_if         <             __is_input_iterator<_InputIterator>::value &&            !__is_forward_iterator<_InputIterator>::value,            void         >::type         assign(_InputIterator __first, _InputIterator __last);
       template <class _ForwardIterator>         typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value,            void         >::type         assign(_ForwardIterator __first, _ForwardIterator __last);
        void assign(size_type __n, const value_type& __x);
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     void assign(initializer_list<value_type> __il)         {
  assign(__il.begin(), __il.end());
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT         {
  return allocator_type(this->__alloc());
  }
        size_type max_size() const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     size_type capacity() const _NOEXCEPT         {
  return __internal_cap_to_external(__cap());
  }
       _LIBCPP_INLINE_VISIBILITY     size_type size() const _NOEXCEPT         {
  return __size_;
  }
       _LIBCPP_INLINE_VISIBILITY     bool empty() const _NOEXCEPT         {
  return __size_ == 0;
  }
       void reserve(size_type __n);
       void shrink_to_fit() _NOEXCEPT;
        _LIBCPP_INLINE_VISIBILITY     iterator begin() _NOEXCEPT         {
  return __make_iter(0);
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin() const _NOEXCEPT         {
  return __make_iter(0);
  }
       _LIBCPP_INLINE_VISIBILITY     iterator end() _NOEXCEPT         {
  return __make_iter(__size_);
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator end()   const _NOEXCEPT         {
  return __make_iter(__size_);
  }
        _LIBCPP_INLINE_VISIBILITY     reverse_iterator rbegin() _NOEXCEPT         {
  return       reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rbegin() const _NOEXCEPT         {
  return const_reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     reverse_iterator rend() _NOEXCEPT         {
  return       reverse_iterator(begin());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rend()   const _NOEXCEPT         {
  return const_reverse_iterator(begin());
  }
        _LIBCPP_INLINE_VISIBILITY     const_iterator         cbegin()  const _NOEXCEPT         {
  return __make_iter(0);
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator         cend()    const _NOEXCEPT         {
  return __make_iter(__size_);
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crbegin() const _NOEXCEPT         {
  return rbegin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crend()   const _NOEXCEPT         {
  return rend();
  }
        _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {
  return __make_ref(__n);
  }
       _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {
  return __make_ref(__n);
  }
       reference       at(size_type __n);
       const_reference at(size_type __n) const;
        _LIBCPP_INLINE_VISIBILITY reference       front()       {
  return __make_ref(0);
  }
       _LIBCPP_INLINE_VISIBILITY const_reference front() const {
  return __make_ref(0);
  }
       _LIBCPP_INLINE_VISIBILITY reference       back()        {
  return __make_ref(__size_ - 1);
  }
       _LIBCPP_INLINE_VISIBILITY const_reference back()  const {
  return __make_ref(__size_ - 1);
  }
        void push_back(const value_type& __x);
     
#if _LIBCPP_STD_VER > 11
    template <class... _Args>   
#if _LIBCPP_STD_VER > 14
    _LIBCPP_INLINE_VISIBILITY reference emplace_back(_Args&&... __args)   
#else
    _LIBCPP_INLINE_VISIBILITY void      emplace_back(_Args&&... __args)   
#endif
    {
           push_back ( value_type ( _VSTD::forward<_Args>(__args)... ));
     
#if _LIBCPP_STD_VER > 14
        return this->back();
     
#endif
    }
     
#endif
     _LIBCPP_INLINE_VISIBILITY void pop_back() {
  --__size_;
  }
      
       iterator insert(const_iterator __position, size_type __n, const_reference __x);
       template <class _InputIterator>         typename enable_if         <              __is_input_iterator  <_InputIterator>::value &&             !__is_forward_iterator<_InputIterator>::value,             iterator         >::type         insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
       template <class _ForwardIterator>         typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value,             iterator         >::type         insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __position, initializer_list<value_type> __il)         {
  return insert(__position, __il.begin(), __il.end());
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);
       iterator erase(const_iterator __first, const_iterator __last);
        _LIBCPP_INLINE_VISIBILITY     void clear() _NOEXCEPT {
  __size_ = 0;
  }
        void swap(vector&)   
#if _LIBCPP_STD_VER >= 14
        _NOEXCEPT;
     
#else
        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||                     __is_nothrow_swappable<allocator_type>::value);
     
#endif
    static void swap(reference __x, reference __y) _NOEXCEPT {
   _VSTD::swap(__x, __y);
   }
        void resize(size_type __sz, value_type __x = false);
       void flip() _NOEXCEPT;
        bool __invariants() const;
    private:     _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();
       void allocate(size_type __n);
       void deallocate() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     static size_type __align_it(size_type __new_size) _NOEXCEPT         {
  return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);
  };
       _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;
       _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);
       template <class _ForwardIterator>         typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value,             void         >::type         __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
       void __append(size_type __n, const_reference __x);
       _LIBCPP_INLINE_VISIBILITY     reference __make_ref(size_type __pos) _NOEXCEPT         {
  return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
       _LIBCPP_INLINE_VISIBILITY     const_reference __make_ref(size_type __pos) const _NOEXCEPT         {
  return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
       _LIBCPP_INLINE_VISIBILITY     iterator __make_iter(size_type __pos) _NOEXCEPT         {
  }
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const vector& __v)         {
  __copy_assign_alloc(__v, integral_constant<bool,                       __storage_traits::propagate_on_container_copy_assignment::value>());
  }
       _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const vector& __c, true_type)         {
               if (__alloc() != __c.__alloc())                 deallocate();
               __alloc() = __c.__alloc();
           }
        _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const vector&, false_type)         {
  }
        void __move_assign(vector& __c, false_type);
       void __move_assign(vector& __c, true_type)         _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);
       _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(vector& __c)         _NOEXCEPT_(             !__storage_traits::propagate_on_container_move_assignment::value ||             is_nothrow_move_assignable<allocator_type>::value)         {
  __move_assign_alloc(__c, integral_constant<bool,                       __storage_traits::propagate_on_container_move_assignment::value>());
  }
       _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(vector& __c, true_type)         _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)         {
               __alloc() = _VSTD::move(__c.__alloc());
           }
        _LIBCPP_INLINE_VISIBILITY     void __move_assign_alloc(vector&, false_type)         _NOEXCEPT         {
  }
        size_t __hash_code() const _NOEXCEPT;
        friend class __bit_reference<vector>;
       friend class __bit_const_reference<vector>;
       friend class __bit_iterator<vector, false>;
       friend class __bit_iterator<vector, true>;
       friend struct __bit_array<vector>;
       friend struct _LIBCPP_TEMPLATE_VIS hash<vector>;
   };
    template <class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void vector<bool, _Allocator>::__invalidate_all_iterators() {
   }
    //  Allocate space for __n objects
//  throws length_error if __n > max_size()
//  throws (probably bad_alloc) if memory run out
//  Precondition:  __begin_ == __end_ == __cap() == 0
//  Precondition:  __n > 0
//  Postcondition:  capacity() == __n
//  Postcondition:  size() == 0
template <class _Allocator> void vector<bool, _Allocator>::allocate(size_type __n) {
       if (__n > max_size())         this->__throw_length_error();
       __n = __external_cap_to_internal(__n);
       this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
       this->__size_ = 0;
       this->__cap() = __n;
   }
    template <class _Allocator> void vector<bool, _Allocator>::deallocate() _NOEXCEPT {
       if (this->__begin_ != nullptr)     {
           __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
           __invalidate_all_iterators();
           this->__begin_ = nullptr;
           this->__size_ = this->__cap() = 0;
       }
   }
    template <class _Allocator> typename vector<bool, _Allocator>::size_type vector<bool, _Allocator>::max_size() const _NOEXCEPT {
       size_type __amax = __storage_traits::max_size(__alloc());
       size_type __nmax = numeric_limits<size_type>::max() / 2;
    // end() >= begin(), always
    if (__nmax / __bits_per_word <= __amax)         return __nmax;
       return __internal_cap_to_external(__amax);
   }
    //  Precondition:  __new_size > capacity()
template <class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<bool, _Allocator>::size_type vector<bool, _Allocator>::__recommend(size_type __new_size) const {
       const size_type __ms = max_size();
       if (__new_size > __ms)         this->__throw_length_error();
       const size_type __cap = capacity();
       if (__cap >= __ms / 2)         return __ms;
       return _VSTD::max(2*__cap, __align_it(__new_size));
   }
    //  Default constructs __n objects starting at __end_
//  Precondition:  __n > 0
//  Precondition:  size() + __n <= capacity()
//  Postcondition:  size() == size() + __n
template <class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x) {
       size_type __old_size = this->__size_;
       this->__size_ += __n;
       _VSTD::fill_n(__make_iter(__old_size), __n, __x);
   }
    template <class _Allocator> template <class _ForwardIterator> typename enable_if <     __is_forward_iterator<_ForwardIterator>::value,     void >::type vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last) {
       size_type __old_size = this->__size_;
       this->__size_ += _VSTD::distance(__first, __last);
       _VSTD::copy(__first, __last, __make_iter(__old_size));
   }
    template <class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<bool, _Allocator>::vector()     _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)     : __begin_(nullptr),       __size_(0),       __cap_alloc_(0) {
   }
    template <class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<bool, _Allocator>::vector(const allocator_type& __a)   
#if _LIBCPP_STD_VER <= 14
        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)   
#else
        _NOEXCEPT   
#endif
    : __begin_(nullptr),       __size_(0),       __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
   }
    template <class _Allocator> vector<bool, _Allocator>::vector(size_type __n)     : __begin_(nullptr),       __size_(0),       __cap_alloc_(0) {
       if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__n, false);
       }
   }
      
#if _LIBCPP_STD_VER > 11
template <class _Allocator> vector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)     : __begin_(nullptr),       __size_(0),       __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
       if (__n > 0)     {
       }
   }
    template <class _Allocator> vector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)     : __begin_(nullptr),       __size_(0),       __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
       size_type __n = static_cast<size_type>(__il.size());
       if (__n > 0)     {
           allocate(__n);
           __construct_at_end(__il.begin(), __il.end());
       }
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Allocator> vector<bool, _Allocator>::~vector() {
       if (__begin_ != nullptr)         __storage_traits::deallocate(__alloc(), __begin_, __cap());
       __invalidate_all_iterators();
   }
    template <class _Allocator> vector<bool, _Allocator>::vector(const vector& __v)     : __begin_(nullptr),       __size_(0),       __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc())) {
       if (__v.size() > 0)     {
           allocate(__v.size());
           __construct_at_end(__v.begin(), __v.end());
       }
   }
    template <class _Allocator> vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)     : __begin_(nullptr),       __size_(0),       __cap_alloc_(0, __a) {
       if (__v.size() > 0)     {
           allocate(__v.size());
           __construct_at_end(__v.begin(), __v.end());
       }
   }
    template <class _Allocator> vector<bool, _Allocator>& vector<bool, _Allocator>::operator=(const vector& __v) {
       if (this != &__v)     {
           __copy_assign_alloc(__v);
       }
       return *this;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<bool, _Allocator>::vector(vector&& __v)   
#if _LIBCPP_STD_VER > 14
        _NOEXCEPT   
#else
        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)   
#endif
    : __begin_(__v.__begin_),       __size_(__v.__size_),       __cap_alloc_(__v.__cap_alloc_) {
       __v.__begin_ = nullptr;
       __v.__size_ = 0;
       __v.__cap() = 0;
   }
    template <class _Allocator> vector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)     : __begin_(nullptr),       __size_(0),       __cap_alloc_(0, __a) {
       if (__a == allocator_type(__v.__alloc()))     {
           this->__begin_ = __v.__begin_;
           this->__size_ = __v.__size_;
           this->__cap() = __v.__cap();
           __v.__begin_ = nullptr;
           __v.__cap() = __v.__size_ = 0;
       }
       else if (__v.size() > 0)     {
           allocate(__v.size());
           __construct_at_end(__v.begin(), __v.end());
       }
   }
    template <class _Allocator> inline _LIBCPP_INLINE_VISIBILITY vector<bool, _Allocator>& vector<bool, _Allocator>::operator=(vector&& __v)     _NOEXCEPT_((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {
   }
      
#endif  // !_LIBCPP_CXX03_LANG
 template <class _Allocator> void vector<bool, _Allocator>::assign(size_type __n, const value_type& __x) {
       __size_ = 0;
       if (__n > 0)     {
           size_type __c = capacity();
           if (__n <= __c)             __size_ = __n;
           else         {
               vector __v(__alloc());
               __v.reserve(__recommend(__n));
               __v.__size_ = __n;
               swap(__v);
           }
           _VSTD::fill_n(begin(), __n, __x);
       }
     __invalidate_all_iterators();
   }
    template <class _Allocator> template <class _InputIterator> typename enable_if <     __is_input_iterator<_InputIterator>::value &&    !__is_forward_iterator<_InputIterator>::value,    void >::type vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last) {
       clear();
       for (;
   __first != __last;
   ++__first)         push_back(*__first);
   }
    template <class _Allocator> template <class _ForwardIterator> typename enable_if <     __is_forward_iterator<_ForwardIterator>::value,    void >::type vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last) {
       clear();
       difference_type __ns = _VSTD::distance(__first, __last);
       _LIBCPP_ASSERT(__ns >= 0, "invalid range specified");
       const size_t __n = static_cast<size_type>(__ns);
       if (__n)     {
           if (__n > capacity())         {
               deallocate();
               allocate(__n);
           }
           __construct_at_end(__first, __last);
       }
   }
    template <class _Allocator> void vector<bool, _Allocator>::reserve(size_type __n) {
       if (__n > capacity())     {
           vector __v(this->__alloc());
           __v.allocate(__n);
           __v.__construct_at_end(this->begin(), this->end());
           swap(__v);
           __invalidate_all_iterators();
       }
   }
    template <class _Allocator> void vector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT {
       if (__external_cap_to_internal(size()) > __cap())     {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            vector(*this, allocator_type(__alloc())).swap(*this);
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    }
   }
    template <class _Allocator> typename vector<bool, _Allocator>::reference vector<bool, _Allocator>::at(size_type __n) {
       if (__n >= size())         this->__throw_out_of_range();
       return (*this)[__n];
   }
    template <class _Allocator> typename vector<bool, _Allocator>::const_reference vector<bool, _Allocator>::at(size_type __n) const {
       if (__n >= size())         this->__throw_out_of_range();
       return (*this)[__n];
   }
    template <class _Allocator> void vector<bool, _Allocator>::push_back(const value_type& __x) {
       if (this->__size_ == this->capacity())         reserve(__recommend(this->__size_ + 1));
   }
    template <class _Allocator> template <class _ForwardIterator> typename enable_if <     __is_forward_iterator<_ForwardIterator>::value,     typename vector<bool, _Allocator>::iterator >::type vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last) {
       const difference_type __n_signed = _VSTD::distance(__first, __last);
       _LIBCPP_ASSERT(__n_signed >= 0, "invalid range specified");
       const size_type __n = static_cast<size_type>(__n_signed);
       iterator __r;
       size_type __c = capacity();
       if (__n <= __c && size() <= __c - __n)     {
           const_iterator __old_end = end();
           __size_ += __n;
           _VSTD::copy_backward(__position, __old_end, end());
           __r = __const_iterator_cast(__position);
       }
       else     {
           vector __v(__alloc());
           __v.reserve(__recommend(__size_ + __n));
           __v.__size_ = __size_ + __n;
           __r = _VSTD::copy(cbegin(), __position, __v.begin());
           _VSTD::copy_backward(__position, cend(), __v.end());
           swap(__v);
       }
       _VSTD::copy(__first, __last, __r);
       return __r;
   }
    template <class _Allocator> inline _LIBCPP_INLINE_VISIBILITY typename vector<bool, _Allocator>::iterator vector<bool, _Allocator>::erase(const_iterator __position) {
       iterator __r = __const_iterator_cast(__position);
       _VSTD::copy(__position + 1, this->cend(), __r);
       --__size_;
       return __r;
   }
    template <class _Allocator> typename vector<bool, _Allocator>::iterator vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last) {
       iterator __r = __const_iterator_cast(__first);
       difference_type __d = __last - __first;
       _VSTD::copy(__last, this->cend(), __r);
       __size_ -= __d;
       return __r;
   }
    template <class _Allocator> void vector<bool, _Allocator>::swap(vector& __x)   
#if _LIBCPP_STD_VER >= 14
    _NOEXCEPT   
#else
    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||                 __is_nothrow_swappable<allocator_type>::value)   
#endif
{
       _VSTD::swap(this->__begin_, __x.__begin_);
       _VSTD::swap(this->__size_, __x.__size_);
       _VSTD::swap(this->__cap(), __x.__cap());
       __swap_allocator(this->__alloc(), __x.__alloc(),         integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
   }
    template <class _Allocator> void vector<bool, _Allocator>::resize(size_type __sz, value_type __x) {
       size_type __cs = size();
       if (__cs < __sz)     {
           iterator __r;
           size_type __c = capacity();
           size_type __n = __sz - __cs;
           if (__n <= __c && __cs <= __c - __n)         {
               __r = end();
           }
           _VSTD::fill_n(__r, __n, __x);
       }
       else         __size_ = __sz;
   }
    template <class _Allocator> void vector<bool, _Allocator>::flip() _NOEXCEPT {
       // do middle whole words
    size_type __n = __size_;
       __storage_pointer __p = __begin_;
       for (;
   __n >= __bits_per_word;
   ++__p, __n -= __bits_per_word)         *__p = ~*__p;
       // do last partial word
    if (__n > 0)     {
           __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
           __storage_type __b = *__p & __m;
           *__p &= ~__m;
           *__p |= ~__b & __m;
       }
   }
    template <class _Allocator> bool vector<bool, _Allocator>::__invariants() const {
       if (this->__begin_ == nullptr)     {
           if (this->__size_ != 0 || this->__cap() != 0)             return false;
       }
       else     {
           if (this->__cap() == 0)             return false;
           if (this->__size_ > this->capacity())             return false;
       }
       return true;
   }
    template <class _Allocator> size_t vector<bool, _Allocator>::__hash_code() const _NOEXCEPT {
       size_t __h = 0;
       // do middle whole words
    size_type __n = __size_;
       __storage_pointer __p = __begin_;
       for (;
   __n >= __bits_per_word;
   ++__p, __n -= __bits_per_word)         __h ^= *__p;
       // do last partial word
    if (__n > 0)     {
           const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
           __h ^= *__p & __m;
       }
       return __h;
   }
    template <class _Allocator> struct _LIBCPP_TEMPLATE_VIS hash<vector<bool, _Allocator> >     : public unary_function<vector<bool, _Allocator>, size_t> {
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT         {
  return __vec.__hash_code();
  }
   };
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
       const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
       return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
       return !(__x == __y);
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
       return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
   }
    template <class _Tp, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
       return __y < __x;
       __x.swap(__y);
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_VECTOR
  
#pragma clang module end /*std.vector*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <functional>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.functional
// -*- C++ -*-
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_FUNCTIONAL
  
#define _LIBCPP_FUNCTIONAL
 /*     functional synopsis  namespace std {
    template <class Arg, class Result> struct unary_function {
       typedef Arg    argument_type;
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <utility> // needed to provide swap_ranges.
  
#endif /* expanded by -frewrite-includes */
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  // __is_seed_sequence
 template <class _Sseq, class _Engine> struct __is_seed_sequence {
       static _LIBCPP_CONSTEXPR const bool value =               !is_convertible<_Sseq, typename _Engine::result_type>::value &&               !is_same<typename remove_cv<_Sseq>::type, _Engine>::value;
   };
    // linear_congruential_engine
 template <unsigned long long __a, unsigned long long __c,           unsigned long long __m, unsigned long long _Mp,           bool _MightOverflow = (__a != 0 && __m != 0 && __m-1 > (_Mp-__c)/__a)> struct __lce_ta;
    // 64
 template <unsigned long long __a, unsigned long long __c, unsigned long long __m> struct __lce_ta<__a, __c, __m, (unsigned long long)(~0), true> {
       typedef unsigned long long result_type;
       _LIBCPP_INLINE_VISIBILITY     static result_type next(result_type __x)     {
           // Schrage's algorithm
        const result_type __q = __m / __a;
           const result_type __r = __m % __a;
           const result_type __t0 = __a * (__x % __q);
           const result_type __t1 = __r * (__x / __q);
           __x = __t0 + (__t0 < __t1) * __m - __t1;
           __x += __c - (__x >= __m - __c) * __m;
           return __x;
       }
   };
    template <unsigned long long __a, unsigned long long __m> struct __lce_ta<__a, 0, __m, (unsigned long long)(~0), true> {
       typedef unsigned long long result_type;
       _LIBCPP_INLINE_VISIBILITY     static result_type next(result_type __x)     {
           // Schrage's algorithm
        const result_type __q = __m / __a;
           const result_type __r = __m % __a;
           const result_type __t0 = __a * (__x % __q);
           const result_type __t1 = __r * (__x / __q);
       }
   };
    template <unsigned long long __a, unsigned long long __c> struct __lce_ta<__a, __c, 0, (unsigned long long)(~0), false> {
       typedef unsigned long long result_type;
       _LIBCPP_INLINE_VISIBILITY     static result_type next(result_type __x)     {
           return __a * __x + __c;
       }
   };
    template <unsigned long long _Ap, unsigned long long _Cp, unsigned long long _Mp> struct __lce_ta<_Ap, _Cp, _Mp, unsigned(~0), false> {
       typedef unsigned result_type;
       _LIBCPP_INLINE_VISIBILITY     static result_type next(result_type __x)     {
           const result_type __a = static_cast<result_type>(_Ap);
           const result_type __c = static_cast<result_type>(_Cp);
           const result_type __m = static_cast<result_type>(_Mp);
           return (__a * __x + __c) % __m;
       }
   };
    template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> class _LIBCPP_TEMPLATE_VIS linear_congruential_engine;
    template <class _CharT, class _Traits,           class _Up, _Up _Ap, _Up _Cp, _Up _Np> _LIBCPP_INLINE_VISIBILITY basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const linear_congruential_engine<_Up, _Ap, _Cp, _Np>&);
    template <class _CharT, class _Traits,           class _Up, _Up _Ap, _Up _Cp, _Up _Np> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            linear_congruential_engine<_Up, _Ap, _Cp, _Np>& __x);
    template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> class _LIBCPP_TEMPLATE_VIS linear_congruential_engine {
   public:     // types
    typedef _UIntType result_type;
    private:     result_type __x_;
        static _LIBCPP_CONSTEXPR const result_type _Mp = result_type(~0);
        static_assert(__m == 0 || __a < __m, "linear_congruential_engine invalid parameters");
       static_assert(__m == 0 || __c < __m, "linear_congruential_engine invalid parameters");
   public:     static _LIBCPP_CONSTEXPR const result_type _Min = __c == 0u ? 1u: 0u;
       static _LIBCPP_CONSTEXPR const result_type _Max = __m - 1u;
       static_assert(_Min < _Max,           "linear_congruential_engine invalid parameters");
        // engine characteristics
    static _LIBCPP_CONSTEXPR const result_type multiplier = __a;
       static _LIBCPP_CONSTEXPR const result_type increment = __c;
       static _LIBCPP_CONSTEXPR const result_type modulus = __m;
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type min() {
  return _Min;
  }
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type max() {
  return _Max;
  }
       static _LIBCPP_CONSTEXPR const result_type default_seed = 1u;
        // constructors and seeding functions
    _LIBCPP_INLINE_VISIBILITY     explicit linear_congruential_engine(result_type __s = default_seed)         {
  seed(__s);
  }
       template<class _Sseq>         _LIBCPP_INLINE_VISIBILITY         explicit linear_congruential_engine(_Sseq& __q,         typename enable_if<__is_seed_sequence<_Sseq, linear_congruential_engine>::value>::type* = 0)         {
  seed(__q);
  }
       _LIBCPP_INLINE_VISIBILITY     void seed(result_type __s = default_seed)         {
  seed(integral_constant<bool, __m == 0>(),               integral_constant<bool, __c == 0>(), __s);
  }
       template<class _Sseq>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             __is_seed_sequence<_Sseq, linear_congruential_engine>::value,             void         >::type         seed(_Sseq& __q)             {
  __seed(__q, integral_constant<unsigned,                 1 + (__m == 0 ? (sizeof(result_type) * __CHAR_BIT__ - 1)/32                              :  (__m > 0x100000000ull))>());
  }
    private:      _LIBCPP_INLINE_VISIBILITY     void seed(true_type, true_type, result_type __s) {
  __x_ = __s == 0 ? 1 : __s;
  }
       _LIBCPP_INLINE_VISIBILITY     void seed(true_type, false_type, result_type __s) {
  __x_ = __s;
  }
       _LIBCPP_INLINE_VISIBILITY     void seed(false_type, true_type, result_type __s) {
  __x_ = __s % __m == 0 ?                                                                  1 : __s % __m;
  }
       _LIBCPP_INLINE_VISIBILITY     void seed(false_type, false_type, result_type __s) {
  __x_ = __s % __m;
  }
        template<class _Sseq>         void __seed(_Sseq& __q, integral_constant<unsigned, 1>);
       template<class _Sseq>         void __seed(_Sseq& __q, integral_constant<unsigned, 2>);
        template <class _CharT, class _Traits,               class _Up, _Up _Ap, _Up _Cp, _Up _Np>     friend     basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>& __os,                const linear_congruential_engine<_Up, _Ap, _Cp, _Np>&);
        template <class _CharT, class _Traits,               class _Up, _Up _Ap, _Up _Cp, _Up _Np>     friend     basic_istream<_CharT, _Traits>&     operator>>(basic_istream<_CharT, _Traits>& __is,                linear_congruential_engine<_Up, _Ap, _Cp, _Np>& __x);
   };
    template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>     _LIBCPP_CONSTEXPR const typename linear_congruential_engine<_UIntType, __a, __c, __m>::result_type     linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;
    template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>     _LIBCPP_CONSTEXPR const typename linear_congruential_engine<_UIntType, __a, __c, __m>::result_type     linear_congruential_engine<_UIntType, __a, __c, __m>::increment;
    template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>     _LIBCPP_CONSTEXPR const typename linear_congruential_engine<_UIntType, __a, __c, __m>::result_type     linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;
    template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>     _LIBCPP_CONSTEXPR const typename linear_congruential_engine<_UIntType, __a, __c, __m>::result_type     linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;
    template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> template<class _Sseq> void linear_congruential_engine<_UIntType, __a, __c, __m>::__seed(_Sseq& __q,                                                  integral_constant<unsigned, 1>) {
       const unsigned __k = 1;
       uint32_t __ar[__k+3];
       __q.generate(__ar, __ar + __k + 3);
       result_type __s = static_cast<result_type>(__ar[3] % __m);
       __x_ = __c == 0 && __s == 0 ? result_type(1) : __s;
   }
    template <class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> template<class _Sseq> void linear_congruential_engine<_UIntType, __a, __c, __m>::__seed(_Sseq& __q,                                                  integral_constant<unsigned, 2>) {
       const unsigned __k = 2;
       uint32_t __ar[__k+3];
       __q.generate(__ar, __ar + __k + 3);
       result_type __s = static_cast<result_type>((__ar[3] +                                               ((uint64_t)__ar[4] << 32)) % __m);
       __x_ = __c == 0 && __s == 0 ? result_type(1) : __s;
   }
    template <class _CharT, class _Traits,           class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> inline _LIBCPP_INLINE_VISIBILITY basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const linear_congruential_engine<_UIntType, __a, __c, __m>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left);
       __os.fill(__os.widen(' '));
       return __os << __x.__x_;
   }
    template <class _CharT, class _Traits,           class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            linear_congruential_engine<_UIntType, __a, __c, __m>& __x) {
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       _UIntType __t;
       __is >> __t;
       if (!__is.fail())         __x.__x_ = __t;
       return __is;
   }
    typedef linear_congruential_engine<uint_fast32_t, 16807, 0, 2147483647>                                                                    minstd_rand0;
   typedef linear_congruential_engine<uint_fast32_t, 48271, 0, 2147483647>                                                                     minstd_rand;
   typedef minstd_rand                                       default_random_engine;
   // mersenne_twister_engine
 template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f> class _LIBCPP_TEMPLATE_VIS mersenne_twister_engine;
    template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,           _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,           _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp> bool operator==(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __x,            const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __y);
    template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,           _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,           _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp> _LIBCPP_INLINE_VISIBILITY bool operator!=(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __x,            const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __y);
    template <class _CharT, class _Traits,           class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,           _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,           _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __x);
    template <class _CharT, class _Traits,           class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,           _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,           _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                    _Bp, _Tp, _Cp, _Lp, _Fp>& __x);
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f> class _LIBCPP_TEMPLATE_VIS mersenne_twister_engine {
   public:     // types
    typedef _UIntType result_type;
    private:     result_type __x_[__n];
       size_t      __i_;
        static_assert(  0 <  __m, "mersenne_twister_engine invalid parameters");
       static_assert(__m <= __n, "mersenne_twister_engine invalid parameters");
       static _LIBCPP_CONSTEXPR const result_type _Dt = numeric_limits<result_type>::digits;
       static_assert(__w <= _Dt, "mersenne_twister_engine invalid parameters");
       static_assert(  2 <= __w, "mersenne_twister_engine invalid parameters");
       static_assert(__r <= __w, "mersenne_twister_engine invalid parameters");
       static_assert(__u <= __w, "mersenne_twister_engine invalid parameters");
       static_assert(__s <= __w, "mersenne_twister_engine invalid parameters");
       static_assert(__t <= __w, "mersenne_twister_engine invalid parameters");
       static_assert(__l <= __w, "mersenne_twister_engine invalid parameters");
   public:     static _LIBCPP_CONSTEXPR const result_type _Min = 0;
       static _LIBCPP_CONSTEXPR const result_type _Max = __w == _Dt ? result_type(~0) :                                                       (result_type(1) << __w) - result_type(1);
       static_assert(_Min < _Max, "mersenne_twister_engine invalid parameters");
       static_assert(__a <= _Max, "mersenne_twister_engine invalid parameters");
       static_assert(__b <= _Max, "mersenne_twister_engine invalid parameters");
       static_assert(__c <= _Max, "mersenne_twister_engine invalid parameters");
       static_assert(__d <= _Max, "mersenne_twister_engine invalid parameters");
       static_assert(__f <= _Max, "mersenne_twister_engine invalid parameters");
        // engine characteristics
    static _LIBCPP_CONSTEXPR const size_t word_size = __w;
       static _LIBCPP_CONSTEXPR const size_t state_size = __n;
       static _LIBCPP_CONSTEXPR const size_t shift_size = __m;
       static _LIBCPP_CONSTEXPR const size_t mask_bits = __r;
       static _LIBCPP_CONSTEXPR const result_type xor_mask = __a;
       static _LIBCPP_CONSTEXPR const size_t tempering_u = __u;
       static _LIBCPP_CONSTEXPR const result_type tempering_d = __d;
       static _LIBCPP_CONSTEXPR const size_t tempering_s = __s;
       static _LIBCPP_CONSTEXPR const result_type tempering_b = __b;
       static _LIBCPP_CONSTEXPR const size_t tempering_t = __t;
       static _LIBCPP_CONSTEXPR const result_type tempering_c = __c;
       static _LIBCPP_CONSTEXPR const size_t tempering_l = __l;
       static _LIBCPP_CONSTEXPR const result_type initialization_multiplier = __f;
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type min() {
   return _Min;
   }
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type max() {
   return _Max;
   }
       static _LIBCPP_CONSTEXPR const result_type default_seed = 5489u;
        // constructors and seeding functions
    _LIBCPP_INLINE_VISIBILITY     explicit mersenne_twister_engine(result_type __sd = default_seed)         {
  seed(__sd);
  }
       template<class _Sseq>         _LIBCPP_INLINE_VISIBILITY         explicit mersenne_twister_engine(_Sseq& __q,         typename enable_if<__is_seed_sequence<_Sseq, mersenne_twister_engine>::value>::type* = 0)         {
  seed(__q);
  }
       void seed(result_type __sd = default_seed);
       template<class _Sseq>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             __is_seed_sequence<_Sseq, mersenne_twister_engine>::value,             void         >::type         seed(_Sseq& __q)             {
  __seed(__q, integral_constant<unsigned, 1 + (__w - 1) / 32>());
  }
        // generating functions
    result_type operator()();
       _LIBCPP_INLINE_VISIBILITY     void discard(unsigned long long __z) {
  for (;
   __z;
   --__z) operator()();
  }
        template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,               _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,               _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>     friend     bool     operator==(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                              _Bp, _Tp, _Cp, _Lp, _Fp>& __x,                const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                              _Bp, _Tp, _Cp, _Lp, _Fp>& __y);
        template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,               _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,               _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>     friend     bool     operator!=(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                              _Bp, _Tp, _Cp, _Lp, _Fp>& __x,                const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                              _Bp, _Tp, _Cp, _Lp, _Fp>& __y);
        template <class _CharT, class _Traits,               class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,               _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,               _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>     friend     basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>& __os,                const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                              _Bp, _Tp, _Cp, _Lp, _Fp>& __x);
        template <class _CharT, class _Traits,               class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,               _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,               _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp>     friend     basic_istream<_CharT, _Traits>&     operator>>(basic_istream<_CharT, _Traits>& __is,                mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                        _Bp, _Tp, _Cp, _Lp, _Fp>& __x);
   private:      template<class _Sseq>         void __seed(_Sseq& __q, integral_constant<unsigned, 1>);
       template<class _Sseq>         void __seed(_Sseq& __q, integral_constant<unsigned, 2>);
        template <size_t __count>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             __count < __w,             result_type         >::type         __lshift(result_type __x) {
  return (__x << __count) & _Max;
  }
        template <size_t __count>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             (__count >= __w),             result_type         >::type         __lshift(result_type) {
  return result_type(0);
  }
        template <size_t __count>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             __count < _Dt,             result_type         >::type         __rshift(result_type __x) {
  return __x >> __count;
  }
        template <size_t __count>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             (__count >= _Dt),             result_type         >::type         __rshift(result_type) {
  return result_type(0);
  }
   };
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>     _LIBCPP_CONSTEXPR const size_t     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::word_size;
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>     _LIBCPP_CONSTEXPR const size_t      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::state_size;
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>     _LIBCPP_CONSTEXPR const size_t      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::shift_size;
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>     _LIBCPP_CONSTEXPR const size_t      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::mask_bits;
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>     _LIBCPP_CONSTEXPR const typename mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::result_type     mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::xor_mask;
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f>     _LIBCPP_CONSTEXPR const size_t      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>::tempering_u;
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f> template<class _Sseq> void mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b,     __t, __c, __l, __f>::__seed(_Sseq& __q, integral_constant<unsigned, 1>) {
       const unsigned __k = 1;
       uint32_t __ar[__n * __k];
       __q.generate(__ar, __ar + __n * __k);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __x_[__i] = static_cast<result_type>(__ar[__i] & _Max);
       const result_type __mask = __r == _Dt ? result_type(~0) :                                        (result_type(1) << __r) - result_type(1);
   }
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f> template<class _Sseq> void mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b,     __t, __c, __l, __f>::__seed(_Sseq& __q, integral_constant<unsigned, 2>) {
       const unsigned __k = 2;
       uint32_t __ar[__n * __k];
       __q.generate(__ar, __ar + __n * __k);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __x_[__i] = static_cast<result_type>(             (__ar[2 * __i] + ((uint64_t)__ar[2 * __i + 1] << 32)) & _Max);
       const result_type __mask = __r == _Dt ? result_type(~0) :                                        (result_type(1) << __r) - result_type(1);
       __i_ = 0;
       if ((__x_[0] & ~__mask) == 0)     {
           for (size_t __i = 1;
   __i < __n;
   ++__i)             if (__x_[__i] != 0)                 return;
           __x_[0] = _Max;
       }
   }
    template <class _UIntType, size_t __w, size_t __n, size_t __m, size_t __r,           _UIntType __a, size_t __u, _UIntType __d, size_t __s,           _UIntType __b, size_t __t, _UIntType __c, size_t __l, _UIntType __f> _UIntType mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d, __s, __b,     __t, __c, __l, __f>::operator()() {
       const size_t __j = (__i_ + 1) % __n;
       const result_type __mask = __r == _Dt ? result_type(~0) :                                        (result_type(1) << __r) - result_type(1);
       const result_type _Yp = (__x_[__i_] & ~__mask) | (__x_[__j] & __mask);
       const size_t __k = (__i_ + __m) % __n;
       __x_[__i_] = __x_[__k] ^ __rshift<1>(_Yp) ^ (__a * (_Yp & 1));
       result_type __z = __x_[__i_] ^ (__rshift<__u>(__x_[__i_]) & __d);
       __i_ = __j;
       __z ^= __lshift<__s>(__z) & __b;
       __z ^= __lshift<__t>(__z) & __c;
       return __z ^ __rshift<__l>(__z);
   }
    template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,           _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,           _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp> bool operator==(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __x,            const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __y) {
       if (__x.__i_ == __y.__i_)         return _VSTD::equal(__x.__x_, __x.__x_ + _Np, __y.__x_);
       if (__x.__i_ == 0 || __y.__i_ == 0)     {
           size_t __j = _VSTD::min(_Np - __x.__i_, _Np - __y.__i_);
           if (!_VSTD::equal(__x.__x_ + __x.__i_, __x.__x_ + __x.__i_ + __j,                          __y.__x_ + __y.__i_))             return false;
           if (__x.__i_ == 0)             return _VSTD::equal(__x.__x_ + __j, __x.__x_ + _Np, __y.__x_);
           return _VSTD::equal(__x.__x_, __x.__x_ + (_Np - __j), __y.__x_ + __j);
       }
       if (__x.__i_ < __y.__i_)     {
           size_t __j = _Np - __y.__i_;
           if (!_VSTD::equal(__x.__x_ + __x.__i_, __x.__x_ + (__x.__i_ + __j),                          __y.__x_ + __y.__i_))             return false;
           if (!_VSTD::equal(__x.__x_ + (__x.__i_ + __j), __x.__x_ + _Np,                          __y.__x_))             return false;
           return _VSTD::equal(__x.__x_, __x.__x_ + __x.__i_,                            __y.__x_ + (_Np - (__x.__i_ + __j)));
       }
       size_t __j = _Np - __x.__i_;
       if (!_VSTD::equal(__y.__x_ + __y.__i_, __y.__x_ + (__y.__i_ + __j),                      __x.__x_ + __x.__i_))         return false;
       if (!_VSTD::equal(__y.__x_ + (__y.__i_ + __j), __y.__x_ + _Np,                      __x.__x_))         return false;
       return _VSTD::equal(__y.__x_, __y.__x_ + __y.__i_,                        __x.__x_ + (_Np - (__y.__i_ + __j)));
   }
    template <class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,           _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,           _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __x,            const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __y) {
       return !(__x == __y);
   }
    template <class _CharT, class _Traits,           class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,           _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,           _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                          _Bp, _Tp, _Cp, _Lp, _Fp>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       __os << __x.__x_[__x.__i_];
       for (size_t __j = __x.__i_ + 1;
   __j < _Np;
   ++__j)         __os << __sp << __x.__x_[__j];
       for (size_t __j = 0;
   __j < __x.__i_;
   ++__j)         __os << __sp << __x.__x_[__j];
       return __os;
   }
    template <class _CharT, class _Traits,           class _UInt, size_t _Wp, size_t _Np, size_t _Mp, size_t _Rp,           _UInt _Ap, size_t _Up, _UInt _Dp, size_t _Sp,           _UInt _Bp, size_t _Tp, _UInt _Cp, size_t _Lp, _UInt _Fp> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            mersenne_twister_engine<_UInt, _Wp, _Np, _Mp, _Rp, _Ap, _Up, _Dp, _Sp,                                    _Bp, _Tp, _Cp, _Lp, _Fp>& __x) {
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       _UInt __t[_Np];
       for (size_t __i = 0;
   __i < _Np;
   ++__i)         __is >> __t[__i];
       if (!__is.fail())     {
           for (size_t __i = 0;
   __i < _Np;
   ++__i)             __x.__x_[__i] = __t[__i];
           __x.__i_ = 0;
       }
       return __is;
   }
    typedef mersenne_twister_engine<uint_fast32_t, 32, 624, 397, 31,                                 0x9908b0df, 11, 0xffffffff,                                 7,  0x9d2c5680,                                 15, 0xefc60000,                                 18, 1812433253>                         mt19937;
   typedef mersenne_twister_engine<uint_fast64_t, 64, 312, 156, 31,                                 0xb5026f5aa96619e9ULL, 29, 0x5555555555555555ULL,                                 17, 0x71d67fffeda60000ULL,                                 37, 0xfff7eee000000000ULL,                                 43, 6364136223846793005ULL>          mt19937_64;
    // subtract_with_carry_engine
 template<class _UIntType, size_t __w, size_t __s, size_t __r> class _LIBCPP_TEMPLATE_VIS subtract_with_carry_engine;
    template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp> bool operator==(     const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,     const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y);
    template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp> _LIBCPP_INLINE_VISIBILITY bool operator!=(     const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,     const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y);
    template <class _CharT, class _Traits,           class _UInt, size_t _Wp, size_t _Sp, size_t _Rp> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x);
    template <class _CharT, class _Traits,           class _UInt, size_t _Wp, size_t _Sp, size_t _Rp> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x);
    template<class _UIntType, size_t __w, size_t __s, size_t __r> class _LIBCPP_TEMPLATE_VIS subtract_with_carry_engine {
   public:     // types
    typedef _UIntType result_type;
    private:     result_type __x_[__r];
       result_type  __c_;
       size_t      __i_;
        static _LIBCPP_CONSTEXPR const result_type _Dt = numeric_limits<result_type>::digits;
       static_assert(  0 <  __w, "subtract_with_carry_engine invalid parameters");
       static_assert(__w <= _Dt, "subtract_with_carry_engine invalid parameters");
       static_assert(  0 <  __s, "subtract_with_carry_engine invalid parameters");
       static_assert(__s <  __r, "subtract_with_carry_engine invalid parameters");
   public:     static _LIBCPP_CONSTEXPR const result_type _Min = 0;
       static _LIBCPP_CONSTEXPR const result_type _Max = __w == _Dt ? result_type(~0) :                                                       (result_type(1) << __w) - result_type(1);
       static_assert(_Min < _Max, "subtract_with_carry_engine invalid parameters");
        // engine characteristics
    static _LIBCPP_CONSTEXPR const size_t word_size = __w;
       static _LIBCPP_CONSTEXPR const size_t short_lag = __s;
       static _LIBCPP_CONSTEXPR const size_t long_lag = __r;
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type min() {
   return _Min;
   }
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type max() {
   return _Max;
   }
       static _LIBCPP_CONSTEXPR const result_type default_seed = 19780503u;
        // constructors and seeding functions
    _LIBCPP_INLINE_VISIBILITY     explicit subtract_with_carry_engine(result_type __sd = default_seed)         {
  }
       template<class _Sseq>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             __is_seed_sequence<_Sseq, subtract_with_carry_engine>::value,             void         >::type         seed(_Sseq& __q)             {
  __seed(__q, integral_constant<unsigned, 1 + (__w - 1) / 32>());
  }
        // generating functions
    result_type operator()();
       _LIBCPP_INLINE_VISIBILITY     void discard(unsigned long long __z) {
  for (;
   __z;
   --__z) operator()();
  }
        template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>     friend     bool     operator==(         const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,         const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y);
        template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>     friend     bool     operator!=(         const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,         const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y);
        template <class _CharT, class _Traits,               class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>     friend     basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>& __os,                const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x);
        template <class _CharT, class _Traits,               class _UInt, size_t _Wp, size_t _Sp, size_t _Rp>     friend     basic_istream<_CharT, _Traits>&     operator>>(basic_istream<_CharT, _Traits>& __is,                subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x);
    private:      void seed(result_type __sd, integral_constant<unsigned, 1>);
       void seed(result_type __sd, integral_constant<unsigned, 2>);
       template<class _Sseq>         void __seed(_Sseq& __q, integral_constant<unsigned, 1>);
       template<class _Sseq>         void __seed(_Sseq& __q, integral_constant<unsigned, 2>);
   };
    template<class _UIntType, size_t __w, size_t __s, size_t __r>     _LIBCPP_CONSTEXPR const size_t subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;
    template<class _UIntType, size_t __w, size_t __s, size_t __r>     _LIBCPP_CONSTEXPR const size_t subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;
    template<class _UIntType, size_t __w, size_t __s, size_t __r>     _LIBCPP_CONSTEXPR const size_t subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;
    template<class _UIntType, size_t __w, size_t __s, size_t __r>     _LIBCPP_CONSTEXPR const typename subtract_with_carry_engine<_UIntType, __w, __s, __r>::result_type     subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;
    template<class _UIntType, size_t __w, size_t __s, size_t __r> void subtract_with_carry_engine<_UIntType, __w, __s, __r>::seed(result_type __sd,         integral_constant<unsigned, 1>) {
       linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>         __e(__sd == 0u ? default_seed : __sd);
       for (size_t __i = 0;
   __i < __r;
   ++__i)         __x_[__i] = static_cast<result_type>(__e() & _Max);
       __c_ = __x_[__r-1] == 0;
       __i_ = 0;
   }
    template<class _UIntType, size_t __w, size_t __s, size_t __r> void subtract_with_carry_engine<_UIntType, __w, __s, __r>::seed(result_type __sd,         integral_constant<unsigned, 2>) {
       linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>         __e(__sd == 0u ? default_seed : __sd);
       for (size_t __i = 0;
   __i < __r;
   ++__i)     {
           result_type __e0 = __e();
           __x_[__i] = static_cast<result_type>(                                     (__e0 + ((uint64_t)__e() << 32)) & _Max);
       }
       __c_ = __x_[__r-1] == 0;
       __i_ = 0;
   }
    template<class _UIntType, size_t __w, size_t __s, size_t __r> template<class _Sseq> void subtract_with_carry_engine<_UIntType, __w, __s, __r>::__seed(_Sseq& __q,         integral_constant<unsigned, 1>) {
       const unsigned __k = 1;
       uint32_t __ar[__r * __k];
       __i_ = 0;
   }
    template<class _UIntType, size_t __w, size_t __s, size_t __r> _UIntType subtract_with_carry_engine<_UIntType, __w, __s, __r>::operator()() {
       const result_type& __xs = __x_[(__i_ + (__r - __s)) % __r];
       result_type& __xr = __x_[__i_];
       result_type __new_c = __c_ == 0 ? __xs < __xr : __xs != 0 ? __xs <= __xr : 1;
       __xr = (__xs - __xr - __c_) & _Max;
       __c_ = __new_c;
       __i_ = (__i_ + 1) % __r;
       return __xr;
   }
    template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp> bool operator==(     const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,     const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y) {
       if (__x.__c_ != __y.__c_)         return false;
       if (__x.__i_ == __y.__i_)         return _VSTD::equal(__x.__x_, __x.__x_ + _Rp, __y.__x_);
       if (__x.__i_ == 0 || __y.__i_ == 0)     {
           size_t __j = _VSTD::min(_Rp - __x.__i_, _Rp - __y.__i_);
           return _VSTD::equal(__x.__x_, __x.__x_ + __x.__i_,                            __y.__x_ + (_Rp - (__x.__i_ + __j)));
       }
       size_t __j = _Rp - __x.__i_;
       if (!_VSTD::equal(__y.__x_ + __y.__i_, __y.__x_ + (__y.__i_ + __j),                      __x.__x_ + __x.__i_))         return false;
       if (!_VSTD::equal(__y.__x_ + (__y.__i_ + __j), __y.__x_ + _Rp,                      __x.__x_))         return false;
       return _VSTD::equal(__y.__x_, __y.__x_ + __y.__i_,                        __x.__x_ + (_Rp - (__y.__i_ + __j)));
   }
    template<class _UInt, size_t _Wp, size_t _Sp, size_t _Rp> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(     const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x,     const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __y) {
       return !(__x == __y);
   }
    template <class _CharT, class _Traits,           class _UInt, size_t _Wp, size_t _Sp, size_t _Rp> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       return __os;
   }
    template <class _CharT, class _Traits,           class _UInt, size_t _Wp, size_t _Sp, size_t _Rp> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            subtract_with_carry_engine<_UInt, _Wp, _Sp, _Rp>& __x) {
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       _UInt __t[_Rp+1];
       for (size_t __i = 0;
   __i < _Rp+1;
   ++__i)         __is >> __t[__i];
       if (!__is.fail())     {
           for (size_t __i = 0;
   __i < _Rp;
   ++__i)             __x.__x_[__i] = __t[__i];
           __x.__c_ = __t[_Rp];
           __x.__i_ = 0;
       }
       return __is;
   }
    typedef subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>     ranlux24_base;
   typedef subtract_with_carry_engine<uint_fast64_t, 48,  5, 12>     ranlux48_base;
    // discard_block_engine
 template<class _Engine, size_t __p, size_t __r> class _LIBCPP_TEMPLATE_VIS discard_block_engine {
       _Engine __e_;
       int     __n_;
        static_assert(  0 <  __r, "discard_block_engine invalid parameters");
       static_assert(__r <= __p, "discard_block_engine invalid parameters");
       static_assert(__r <= INT_MAX, "discard_block_engine invalid parameters");
   public:     // types
    typedef typename _Engine::result_type result_type;
        // engine characteristics
    static _LIBCPP_CONSTEXPR const size_t block_size = __p;
       static _LIBCPP_CONSTEXPR const size_t used_block = __r;
      
#ifdef _LIBCPP_CXX03_LANG
    static const result_type _Min = _Engine::_Min;
       static const result_type _Max = _Engine::_Max;
     
#else
    static _LIBCPP_CONSTEXPR const result_type _Min = _Engine::min();
       static _LIBCPP_CONSTEXPR const result_type _Max = _Engine::max();
     
#endif
     _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type min() {
   return _Engine::min();
   }
       template<class _Sseq>         _LIBCPP_INLINE_VISIBILITY         explicit discard_block_engine(_Sseq& __q,         typename enable_if<__is_seed_sequence<_Sseq, discard_block_engine>::value &&                            !is_convertible<_Sseq, _Engine>::value>::type* = 0)         : __e_(__q), __n_(0) {
  }
       _LIBCPP_INLINE_VISIBILITY     void seed() {
  __e_.seed();
   __n_ = 0;
  }
       _LIBCPP_INLINE_VISIBILITY     void seed(result_type __sd) {
  __e_.seed(__sd);
   __n_ = 0;
  }
       template<class _Sseq>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             __is_seed_sequence<_Sseq, discard_block_engine>::value,             void         >::type         seed(_Sseq& __q) {
  __e_.seed(__q);
   __n_ = 0;
  }
        // generating functions
    result_type operator()();
       _LIBCPP_INLINE_VISIBILITY     void discard(unsigned long long __z) {
  for (;
   __z;
   --__z) operator()();
  }
        // property functions
    _LIBCPP_INLINE_VISIBILITY     const _Engine& base() const _NOEXCEPT {
  return __e_;
  }
        template<class _Eng, size_t _Pp, size_t _Rp>     friend     bool     operator==(         const discard_block_engine<_Eng, _Pp, _Rp>& __x,         const discard_block_engine<_Eng, _Pp, _Rp>& __y);
        template<class _Eng, size_t _Pp, size_t _Rp>     friend     bool     operator!=(         const discard_block_engine<_Eng, _Pp, _Rp>& __x,         const discard_block_engine<_Eng, _Pp, _Rp>& __y);
        template <class _CharT, class _Traits,               class _Eng, size_t _Pp, size_t _Rp>     friend     basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>& __os,                const discard_block_engine<_Eng, _Pp, _Rp>& __x);
        template <class _CharT, class _Traits,               class _Eng, size_t _Pp, size_t _Rp>     friend     basic_istream<_CharT, _Traits>&     operator>>(basic_istream<_CharT, _Traits>& __is,                discard_block_engine<_Eng, _Pp, _Rp>& __x);
   };
    template<class _Engine, size_t __p, size_t __r>     _LIBCPP_CONSTEXPR const size_t discard_block_engine<_Engine, __p, __r>::block_size;
    template<class _Engine, size_t __p, size_t __r>     _LIBCPP_CONSTEXPR const size_t discard_block_engine<_Engine, __p, __r>::used_block;
    template<class _Engine, size_t __p, size_t __r> typename discard_block_engine<_Engine, __p, __r>::result_type discard_block_engine<_Engine, __p, __r>::operator()() {
       if (__n_ >= static_cast<int>(__r))     {
           __e_.discard(__p - __r);
           __n_ = 0;
       }
       ++__n_;
   }
    template <class _CharT, class _Traits,           class _Eng, size_t _Pp, size_t _Rp> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const discard_block_engine<_Eng, _Pp, _Rp>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       return __os << __x.__e_ << __sp << __x.__n_;
   }
    template <class _CharT, class _Traits,           class _Eng, size_t _Pp, size_t _Rp> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            discard_block_engine<_Eng, _Pp, _Rp>& __x) {
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       _Eng __e;
       int __n;
       __is >> __e >> __n;
       if (!__is.fail())     {
           __x.__e_ = __e;
           __x.__n_ = __n;
       }
       return __is;
   }
    typedef discard_block_engine<ranlux24_base, 223, 23> ranlux24;
   typedef discard_block_engine<ranlux48_base, 389, 11> ranlux48;
    // independent_bits_engine
 template<class _Engine, size_t __w, class _UIntType> class _LIBCPP_TEMPLATE_VIS independent_bits_engine {
       template <class _UInt, _UInt _R0, size_t _Wp, size_t _Mp>     class __get_n     {
           static _LIBCPP_CONSTEXPR const size_t _Dt = numeric_limits<_UInt>::digits;
           static _LIBCPP_CONSTEXPR const size_t _Np = _Wp / _Mp + (_Wp % _Mp != 0);
           static _LIBCPP_CONSTEXPR const size_t _W0 = _Wp / _Np;
           static _LIBCPP_CONSTEXPR const _UInt _Y0 = _W0 >= _Dt ? 0 : (_R0 >> _W0) << _W0;
       public:         static _LIBCPP_CONSTEXPR const size_t value = _R0 - _Y0 > _Y0 / _Np ? _Np + 1 : _Np;
       };
   public:     // types
    typedef _UIntType result_type;
    private:     _Engine __e_;
        static _LIBCPP_CONSTEXPR const result_type _Dt = numeric_limits<result_type>::digits;
       static_assert(  0 <  __w, "independent_bits_engine invalid parameters");
       static_assert(__w <= _Dt, "independent_bits_engine invalid parameters");
        typedef typename _Engine::result_type _Engine_result_type;
       typedef typename conditional         <             sizeof(_Engine_result_type) <= sizeof(result_type),                 result_type,                 _Engine_result_type         >::type _Working_result_type;
     
#ifdef _LIBCPP_CXX03_LANG
    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min                                           + _Working_result_type(1);
     
#else
    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()                                                             + _Working_result_type(1);
     
#endif
    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;
       static _LIBCPP_CONSTEXPR const size_t __n = __get_n<_Working_result_type, _Rp, __w, __m>::value;
       static _LIBCPP_CONSTEXPR const size_t __w0 = __w / __n;
       static _LIBCPP_CONSTEXPR const size_t __n0 = __n - __w % __n;
       static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;
       static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;
       static _LIBCPP_CONSTEXPR const _Working_result_type __y0 = __w0 >= _WDt ? 0 :                                                                (_Rp >> __w0) << __w0;
       static _LIBCPP_CONSTEXPR const _Working_result_type __y1 = __w0 >= _WDt - 1 ? 0 :                                                                (_Rp >> (__w0+1)) << (__w0+1);
       static _LIBCPP_CONSTEXPR const _Engine_result_type __mask0 = __w0 > 0 ?                                 _Engine_result_type(~0) >> (_EDt - __w0) :                                 _Engine_result_type(0);
       static _LIBCPP_CONSTEXPR const _Engine_result_type __mask1 = __w0 < _EDt - 1 ?                                 _Engine_result_type(~0) >> (_EDt - (__w0 + 1)) :                                 _Engine_result_type(~0);
   public:     static _LIBCPP_CONSTEXPR const result_type _Min = 0;
       static _LIBCPP_CONSTEXPR const result_type _Max = __w == _Dt ? result_type(~0) :                                                       (result_type(1) << __w) - result_type(1);
       static_assert(_Min < _Max, "independent_bits_engine invalid parameters");
        // engine characteristics
    _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type min() {
   return _Min;
   }
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type max() {
   return _Max;
   }
        // constructors and seeding functions
    _LIBCPP_INLINE_VISIBILITY     independent_bits_engine() {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit independent_bits_engine(const _Engine& __e)         : __e_(__e) {
  }
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     explicit independent_bits_engine(_Engine&& __e)         : __e_(_VSTD::move(__e)) {
  }
     
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     explicit independent_bits_engine(result_type __sd) : __e_(__sd) {
  }
       template<class _Sseq>         _LIBCPP_INLINE_VISIBILITY         explicit independent_bits_engine(_Sseq& __q,         typename enable_if<__is_seed_sequence<_Sseq, independent_bits_engine>::value &&                            !is_convertible<_Sseq, _Engine>::value>::type* = 0)          : __e_(__q) {
  }
       _LIBCPP_INLINE_VISIBILITY     void seed() {
  __e_.seed();
  }
    private:     _LIBCPP_INLINE_VISIBILITY     result_type __eval(false_type);
       result_type __eval(true_type);
        template <size_t __count>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             __count < _Dt,             result_type         >::type         __lshift(result_type __x) {
  return __x << __count;
  }
        template <size_t __count>         _LIBCPP_INLINE_VISIBILITY         static         typename enable_if         <             (__count >= _Dt),             result_type         >::type         __lshift(result_type) {
  return result_type(0);
  }
   };
    template<class _Engine, size_t __w, class _UIntType> inline _UIntType independent_bits_engine<_Engine, __w, _UIntType>::__eval(false_type) {
       return static_cast<result_type>(__e_() & __mask0);
   }
    template<class _Engine, size_t __w, class _UIntType> _UIntType independent_bits_engine<_Engine, __w, _UIntType>::__eval(true_type) {
       result_type _Sp = 0;
       for (size_t __k = 0;
   __k < __n0;
   ++__k)     {
           _Engine_result_type __u;
           do         {
               __u = __e_() - _Engine::min();
           }
   while (__u >= __y0);
           _Sp = static_cast<result_type>(__lshift<__w0>(_Sp) + (__u & __mask0));
   while (__u >= __y1);
           _Sp = static_cast<result_type>(__lshift<__w0+1>(_Sp) + (__u & __mask1));
       }
       return _Sp;
   }
    template<class _Eng, size_t _Wp, class _UInt> inline _LIBCPP_INLINE_VISIBILITY bool operator==(     const independent_bits_engine<_Eng, _Wp, _UInt>& __x,     const independent_bits_engine<_Eng, _Wp, _UInt>& __y) {
       return __x.base() == __y.base();
   }
    template<class _Eng, size_t _Wp, class _UInt> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(     const independent_bits_engine<_Eng, _Wp, _UInt>& __x,     const independent_bits_engine<_Eng, _Wp, _UInt>& __y) {
       return !(__x == __y);
   }
    template <class _CharT, class _Traits,           class _Eng, size_t _Wp, class _UInt> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const independent_bits_engine<_Eng, _Wp, _UInt>& __x) {
       return __os << __x.base();
   }
    template <class _CharT, class _Traits,           class _Eng, size_t _Wp, class _UInt> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            independent_bits_engine<_Eng, _Wp, _UInt>& __x) {
       _Eng __e;
       __is >> __e;
       if (!__is.fail())         __x.__e_ = __e;
       return __is;
   }
    // shuffle_order_engine
 template <uint64_t _Xp, uint64_t _Yp> struct __ugcd {
       static _LIBCPP_CONSTEXPR const uint64_t value = __ugcd<_Yp, _Xp % _Yp>::value;
   };
    template <uint64_t _Xp> struct __ugcd<_Xp, 0> {
       static _LIBCPP_CONSTEXPR const uint64_t value = _Xp;
   };
    template <uint64_t _Np, uint64_t _Dp> class __uratio {
       static_assert(_Dp != 0, "__uratio divide by 0");
       static _LIBCPP_CONSTEXPR const uint64_t __gcd = __ugcd<_Np, _Dp>::value;
   public:     static _LIBCPP_CONSTEXPR const uint64_t num = _Np / __gcd;
       static _LIBCPP_CONSTEXPR const uint64_t den = _Dp / __gcd;
        typedef __uratio<num, den> type;
   };
    template<class _Engine, size_t __k> class _LIBCPP_TEMPLATE_VIS shuffle_order_engine {
       static_assert(0 < __k, "shuffle_order_engine invalid parameters");
   public:     // types
    typedef typename _Engine::result_type result_type;
    private:     _Engine __e_;
       result_type _V_[__k];
       result_type _Y_;
    public:     // engine characteristics
    static _LIBCPP_CONSTEXPR const size_t table_size = __k;
      
#ifdef _LIBCPP_CXX03_LANG
    static const result_type _Min = _Engine::_Min;
       static const result_type _Max = _Engine::_Max;
     
#else
    static _LIBCPP_CONSTEXPR const result_type _Min = _Engine::min();
       static _LIBCPP_CONSTEXPR const result_type _Max = _Engine::max();
     
#endif
    static_assert(_Min < _Max, "shuffle_order_engine invalid parameters");
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type min() {
   return _Min;
   }
       _LIBCPP_INLINE_VISIBILITY     static _LIBCPP_CONSTEXPR result_type max() {
           }
        template <uint64_t __n, uint64_t __d>         _LIBCPP_INLINE_VISIBILITY         result_type __evalf()         {
               const double _Fp = __d == 0 ?                 __n / (2. * 0x8000000000000000ull) :                 __n / (double)__d;
               const size_t __j = static_cast<size_t>(_Fp * (_Y_ - _Min));
               _Y_ = _V_[__j];
               _V_[__j] = __e_();
               return _Y_;
           }
   };
    template<class _Engine, size_t __k>     _LIBCPP_CONSTEXPR const size_t shuffle_order_engine<_Engine, __k>::table_size;
    template<class _Eng, size_t _Kp> bool operator==(     const shuffle_order_engine<_Eng, _Kp>& __x,     const shuffle_order_engine<_Eng, _Kp>& __y) {
   }
    template <class _CharT, class _Traits,           class _Eng, size_t _Kp> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            shuffle_order_engine<_Eng, _Kp>& __x) {
       typedef typename shuffle_order_engine<_Eng, _Kp>::result_type result_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       _Eng __e;
       result_type _Vp[_Kp+1];
       __is >> __e;
       for (size_t __i = 0;
   __i < _Kp+1;
   ++__i)         __is >> _Vp[__i];
       if (!__is.fail())     {
           __x.__e_ = __e;
           for (size_t __i = 0;
   __i < _Kp;
   ++__i)             __x._V_[__i] = _Vp[__i];
           __x._Y_ = _Vp[_Kp];
       }
       return __is;
   }
    typedef shuffle_order_engine<minstd_rand0, 256>                         knuth_b;
    // random_device
 class _LIBCPP_TYPE_VIS random_device {
     
#ifdef _LIBCPP_USING_DEV_RANDOM
    int __f_;
     
#endif // defined(_LIBCPP_USING_DEV_RANDOM)
public:     // types
    typedef unsigned result_type;
    private:     // no copy functions
    random_device(const random_device&);
   // = delete;
    random_device& operator=(const random_device&);
   // = delete;
};
    // seed_seq
 class _LIBCPP_TEMPLATE_VIS seed_seq {
   public:     // types
    typedef uint32_t result_type;
    private:     vector<result_type> __v_;
        template<class _InputIterator>         void init(_InputIterator __first, _InputIterator __last);
   public:     // constructors
    _LIBCPP_INLINE_VISIBILITY     seed_seq() _NOEXCEPT {
  }
     template<class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         seed_seq(_InputIterator __first, _InputIterator __last)              {
  init(__first, __last);
  }
        // generating functions
    template<class _RandomAccessIterator>         void generate(_RandomAccessIterator __first, _RandomAccessIterator __last);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     size_t size() const _NOEXCEPT {
  return __v_.size();
  }
       template<class _OutputIterator>         _LIBCPP_INLINE_VISIBILITY         void param(_OutputIterator __dest) const             {
  _VSTD::copy(__v_.begin(), __v_.end(), __dest);
  }
    private:     // no copy functions
    seed_seq(const seed_seq&);
   // = delete;
    void operator=(const seed_seq&);
   // = delete;
     _LIBCPP_INLINE_VISIBILITY     static result_type _Tp(result_type __x) {
  return __x ^ (__x >> 27);
  }
   };
    template<class _InputIterator> void seed_seq::init(_InputIterator __first, _InputIterator __last) {
       for (_InputIterator __s = __first;
   __s != __last;
   ++__s)         __v_.push_back(*__s & 0xFFFFFFFF);
   }
    template<class _RandomAccessIterator> void seed_seq::generate(_RandomAccessIterator __first, _RandomAccessIterator __last) {
       if (__first != __last)     {
           _VSTD::fill(__first, __last, 0x8b8b8b8b);
           const size_t __n = static_cast<size_t>(__last - __first);
           const size_t __s = __v_.size();
           const size_t __t = (__n >= 623) ? 11                          : (__n >= 68) ? 7                          : (__n >= 39) ? 5                          : (__n >= 7)  ? 3                          : (__n - 1) / 2;
           const size_t __p = (__n - __t) / 2;
           const size_t __q = __p + __t;
           const size_t __m = _VSTD::max(__s + 1, __n);
           // __k = 0;
        {
               result_type __r = 1664525 * _Tp(__first[0] ^ __first[__p]                                                       ^  __first[__n - 1]);
               __first[__p] += __r;
               __r += __s;
               __first[__q] += __r;
               __first[0] = __r;
           }
           for (size_t __k = 1;
   __k <= __s;
   ++__k)         {
               const size_t __kmodn = __k % __n;
               const size_t __kpmodn = (__k + __p) % __n;
               result_type __r = 1664525 * _Tp(__first[__kmodn] ^ __first[__kpmodn]                                            ^ __first[(__k - 1) % __n]);
               __first[__kpmodn] += __r;
               __r +=  __kmodn + __v_[__k-1];
               __first[(__k + __q) % __n] += __r;
               __first[__kmodn] = __r;
           }
           for (size_t __k = __s + 1;
   __k < __m;
   ++__k)         {
               const size_t __kmodn = __k % __n;
               const size_t __kpmodn = (__k + __p) % __n;
               result_type __r = 1664525 * _Tp(__first[__kmodn] ^ __first[__kpmodn]                                            ^ __first[(__k - 1) % __n]);
               __first[__kpmodn] += __r;
               __r +=  __kmodn;
               __first[(__k + __q) % __n] += __r;
               __first[__kmodn] = __r;
           }
           for (size_t __k = __m;
   __k < __m + __n;
   ++__k)         {
               const size_t __kmodn = __k % __n;
               const size_t __kpmodn = (__k + __p) % __n;
               result_type __r = 1566083941 * _Tp(__first[__kmodn] +                                               __first[__kpmodn] +                                               __first[(__k - 1) % __n]);
               __first[__kpmodn] ^= __r;
               __r -= __kmodn;
               __first[(__k + __q) % __n] ^= __r;
               __first[__kmodn] = __r;
           }
       }
   }
    // generate_canonical
 template<class _RealType, size_t __bits, class _URNG> _RealType generate_canonical(_URNG& __g) {
       const size_t _Dt = numeric_limits<_RealType>::digits;
       const size_t __b = _Dt < __bits ? _Dt : __bits;
     
#ifdef _LIBCPP_CXX03_LANG
    const size_t __logR = __log2<uint64_t, _URNG::_Max - _URNG::_Min + uint64_t(1)>::value;
     
#else
    const size_t __logR = __log2<uint64_t, _URNG::max() - _URNG::min() + uint64_t(1)>::value;
     
#endif
    const size_t __k = __b / __logR + (__b % __logR != 0) + (__b == 0);
       const _RealType _Rp = _URNG::max() - _URNG::min() + _RealType(1);
       _RealType __base = _Rp;
       _RealType _Sp = __g() - _URNG::min();
       for (size_t __i = 1;
   __i < __k;
   ++__i, __base *= _Rp)         _Sp += (__g() - _URNG::min()) * __base;
       return _Sp / __base;
   }
    // uniform_int_distribution
 // in <algorithm>
    template <class _CharT, class _Traits, class _IT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            uniform_int_distribution<_IT>& __x) {
       typedef uniform_int_distribution<_IT> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __a;
       result_type __b;
       __is >> __a >> __b;
       if (!__is.fail())         __x.param(param_type(__a, __b));
       return __is;
   }
    // uniform_real_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS uniform_real_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __a_;
           result_type __b_;
       public:         typedef uniform_real_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __a = 0,                             result_type __b = 1)             : __a_(__a), __b_(__b) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type a() const {
  }
           friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructors and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit uniform_real_distribution(result_type __a = 0, result_type __b = 1)         : __p_(param_type(__a, __b)) {
  }
       template<class _URNG> _LIBCPP_INLINE_VISIBILITY result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type a() const {
  return __p_.a();
  }
       _LIBCPP_INLINE_VISIBILITY     result_type b() const {
  return __p_.b();
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const uniform_real_distribution& __x,                         const uniform_real_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template<class _RealType> template<class _URNG> inline typename uniform_real_distribution<_RealType>::result_type uniform_real_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       return (__p.b() - __p.a())         * _VSTD::generate_canonical<_RealType, numeric_limits<_RealType>::digits>(__g)         + __p.a();
   }
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const uniform_real_distribution<_RT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       return __os << __x.a() << __sp << __x.b();
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            uniform_real_distribution<_RT>& __x) {
       typedef uniform_real_distribution<_RT> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __a;
       result_type __b;
       __is >> __a >> __b;
       if (!__is.fail())         __x.param(param_type(__a, __b));
       return __is;
   }
    // bernoulli_distribution
 class _LIBCPP_TEMPLATE_VIS bernoulli_distribution {
   public:     // types
    typedef bool result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           double __p_;
       public:         typedef bernoulli_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(double __p = 0.5) : __p_(__p) {
  }
            _LIBCPP_INLINE_VISIBILITY         double p() const {
  return __p_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__p_ == __y.__p_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructors and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit bernoulli_distribution(double __p = 0.5)         : __p_(param_type(__p)) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit bernoulli_distribution(const param_type& __p) : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> _LIBCPP_INLINE_VISIBILITY result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     double p() const {
  return __p_.p();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  __p_ = __p;
  }
        _LIBCPP_INLINE_VISIBILITY     result_type min() const {
  return false;
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return true;
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const bernoulli_distribution& __x,                         const bernoulli_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const bernoulli_distribution& __x,                         const bernoulli_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template<class _URNG> inline bernoulli_distribution::result_type bernoulli_distribution::operator()(_URNG& __g, const param_type& __p) {
       uniform_real_distribution<double> __gen;
       return __gen(__g) < __p.p();
   }
    template <class _CharT, class _Traits> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, const bernoulli_distribution& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       return __os << __x.p();
   }
    template <class _CharT, class _Traits> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is, bernoulli_distribution& __x) {
       typedef bernoulli_distribution _Eng;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       double __p;
       __is >> __p;
       if (!__is.fail())         __x.param(param_type(__p));
       return __is;
   }
    // binomial_distribution
 template<class _IntType = int> class _LIBCPP_TEMPLATE_VIS binomial_distribution {
   public:     // types
    typedef _IntType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __t_;
           double __p_;
           double __pr_;
           double __odds_ratio_;
           result_type __r0_;
       public:         typedef binomial_distribution distribution_type;
            explicit param_type(result_type __t = 1, double __p = 0.5);
            _LIBCPP_INLINE_VISIBILITY         result_type t() const {
  return __t_;
  }
           _LIBCPP_INLINE_VISIBILITY         double p() const {
  return __p_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__t_ == __y.__t_ && __x.__p_ == __y.__p_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
            friend class binomial_distribution;
       };
    private:     param_type __p_;
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type t() const {
  return __p_.t();
  }
       _LIBCPP_INLINE_VISIBILITY     double p() const {
  return __p_.p();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  __p_ = __p;
  }
        _LIBCPP_INLINE_VISIBILITY     result_type min() const {
  return 0;
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return t();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const binomial_distribution& __x,                         const binomial_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const binomial_distribution& __x,                         const binomial_distribution& __y)         {
  return !(__x == __y);
  }
   };
      
    // Reference: Kemp, C.D. (1986). `A modal method for generating binomial
//           variables', Commun. Statist. - Theor. Meth. 15(3), 805-813.
template<class _IntType> template<class _URNG> _IntType binomial_distribution<_IntType>::operator()(_URNG& __g, const param_type& __pr) {
       if (__pr.__t_ == 0 || __pr.__p_ == 0)         return 0;
       if (__pr.__p_ == 1)         return __pr.__t_;
       uniform_real_distribution<double> __gen;
       double __u = __gen(__g) - __pr.__pr_;
       if (__u < 0)         return __pr.__r0_;
       double __pu = __pr.__pr_;
       double __pd = __pu;
       result_type __ru = __pr.__r0_;
       result_type __rd = __ru;
       while (true)     {
           if (__rd >= 1)         {
               __pd *= __rd / (__pr.__odds_ratio_ * (__pr.__t_ - __rd + 1));
               if (__u < 0)                 return __ru;
           }
       }
   }
    template <class _CharT, class _Traits, class _IntType> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const binomial_distribution<_IntType>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       return __os << __x.t() << __sp << __x.p();
   }
    template <class _CharT, class _Traits, class _IntType> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            binomial_distribution<_IntType>& __x) {
       typedef binomial_distribution<_IntType> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __t;
       double __p;
       __is >> __t >> __p;
       if (!__is.fail())         __x.param(param_type(__t, __p));
       return __is;
   }
    // exponential_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS exponential_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __lambda_;
       public:         typedef exponential_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __lambda = 1) : __lambda_(__lambda) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type lambda() const {
  return __lambda_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__lambda_ == __y.__lambda_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructors and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit exponential_distribution(result_type __lambda = 1)         : __p_(param_type(__lambda)) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit exponential_distribution(const param_type& __p) : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type lambda() const {
  return __p_.lambda();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  return numeric_limits<result_type>::infinity();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const exponential_distribution& __x,                         const exponential_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const exponential_distribution& __x,                         const exponential_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template <class _RealType> template<class _URNG> _RealType exponential_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       return -_VSTD::log                   (                       result_type(1) -                       _VSTD::generate_canonical<result_type,                                        numeric_limits<result_type>::digits>(__g)                   )                   / __p.lambda();
   }
    template <class _CharT, class _Traits, class _RealType> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const exponential_distribution<_RealType>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       return __os << __x.lambda();
   }
    template <class _CharT, class _Traits, class _RealType> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            exponential_distribution<_RealType>& __x) {
       typedef exponential_distribution<_RealType> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __lambda;
       __is >> __lambda;
       if (!__is.fail())         __x.param(param_type(__lambda));
       return __is;
   }
    // normal_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS normal_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __mean_;
           result_type __stddev_;
       public:         typedef normal_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __mean = 0, result_type __stddev = 1)             : __mean_(__mean), __stddev_(__stddev) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type mean() const {
  return __mean_;
  }
           _LIBCPP_INLINE_VISIBILITY         result_type stddev() const {
  return __stddev_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__mean_ == __y.__mean_ && __x.__stddev_ == __y.__stddev_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
       result_type _V_;
       bool _V_hot_;
    public:     // constructors and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit normal_distribution(result_type __mean = 0, result_type __stddev = 1)         : __p_(param_type(__mean, __stddev)), _V_hot_(false) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit normal_distribution(const param_type& __p)         : __p_(__p), _V_hot_(false) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  _V_hot_ = false;
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type mean() const {
  return numeric_limits<result_type>::infinity();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const normal_distribution& __x,                         const normal_distribution& __y)         {
  return __x.__p_ == __y.__p_ && __x._V_hot_ == __y._V_hot_ &&                 (!__x._V_hot_ || __x._V_ == __y._V_);
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const normal_distribution& __x,                         const normal_distribution& __y)         {
  return !(__x == __y);
  }
        template <class _CharT, class _Traits, class _RT>     friend     basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>& __os,                const normal_distribution<_RT>& __x);
        template <class _CharT, class _Traits, class _RT>     friend     basic_istream<_CharT, _Traits>&     operator>>(basic_istream<_CharT, _Traits>& __is,                normal_distribution<_RT>& __x);
   };
    template <class _RealType> template<class _URNG> _RealType normal_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       result_type _Up;
       if (_V_hot_)     {
           _V_hot_ = false;
           _Up = _V_;
       }
       else     {
           uniform_real_distribution<result_type> _Uni(-1, 1);
           result_type __u;
           result_type __v;
           result_type __s;
           do         {
               __u = _Uni(__g);
               __v = _Uni(__g);
               __s = __u * __u + __v * __v;
           }
   while (__s > 1 || __s == 0);
           result_type _Fp = _VSTD::sqrt(-2 * _VSTD::log(__s) / __s);
           _V_ = __v * _Fp;
           _V_hot_ = true;
           _Up = __u * _Fp;
       }
       return _Up * __p.stddev() + __p.mean();
   }
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const normal_distribution<_RT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
   }
    // lognormal_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS lognormal_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           normal_distribution<result_type> __nd_;
       public:         typedef lognormal_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __m = 0, result_type __s = 1)             : __nd_(__m, __s) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type m() const {
  return __nd_.mean();
  }
           _LIBCPP_INLINE_VISIBILITY         result_type s() const {
  return __nd_.stddev();
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__nd_ == __y.__nd_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
           friend class lognormal_distribution;
            template <class _CharT, class _Traits, class _RT>         friend         basic_ostream<_CharT, _Traits>&         operator<<(basic_ostream<_CharT, _Traits>& __os,                    const lognormal_distribution<_RT>& __x);
            template <class _CharT, class _Traits, class _RT>         friend         basic_istream<_CharT, _Traits>&         operator>>(basic_istream<_CharT, _Traits>& __is,                    lognormal_distribution<_RT>& __x);
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit lognormal_distribution(result_type __m = 0, result_type __s = 1)         : __p_(param_type(__m, __s)) {
  }
        template <class _CharT, class _Traits, class _RT>     friend     basic_istream<_CharT, _Traits>&     operator>>(basic_istream<_CharT, _Traits>& __is,                lognormal_distribution<_RT>& __x);
   };
    template <class _CharT, class _Traits, class _RT> inline _LIBCPP_INLINE_VISIBILITY basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const lognormal_distribution<_RT>& __x) {
       return __os << __x.__p_.__nd_;
   }
    template <class _CharT, class _Traits, class _RT> inline _LIBCPP_INLINE_VISIBILITY basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            lognormal_distribution<_RT>& __x) {
       return __is >> __x.__p_.__nd_;
   }
    // poisson_distribution
 template<class _IntType = int> class _LIBCPP_TEMPLATE_VIS poisson_distribution {
   public:     // types
    typedef _IntType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           double __mean_;
           double __s_;
           double __d_;
           double __l_;
           double __omega_;
           double __c0_;
           double __c1_;
           double __c2_;
           double __c3_;
           double __c_;
        public:         typedef poisson_distribution distribution_type;
            explicit param_type(double __mean = 1.0);
            _LIBCPP_INLINE_VISIBILITY         double mean() const {
  return __mean_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__mean_ == __y.__mean_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
            friend class poisson_distribution;
       };
    private:     param_type __p_;
    public:     // constructors and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit poisson_distribution(double __mean = 1.0) : __p_(__mean) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit poisson_distribution(const param_type& __p) : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     double mean() const {
  return __p_.mean();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return numeric_limits<result_type>::max();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const poisson_distribution& __x,                         const poisson_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const poisson_distribution& __x,                         const poisson_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template<class _IntType> poisson_distribution<_IntType>::param_type::param_type(double __mean)     : __mean_(__mean) {
       if (__mean_ < 10)     {
           __s_ = 0;
           __d_ = 0;
           __l_ = _VSTD::exp(-__mean_);
           __omega_ = 0;
           __c3_ = 0;
           __c2_ = 0;
           __c1_ = 0;
           __c0_ = 0;
           __c_ = 0;
       }
       else     {
           __s_ = _VSTD::sqrt(__mean_);
           __d_ = 6 * __mean_ * __mean_;
           __l_ = static_cast<result_type>(__mean_ - 1.1484);
           __omega_ = .3989423 / __s_;
           double __b1_ = .4166667E-1 / __mean_;
           double __b2_ = .3 * __b1_ * __b1_;
           __c3_ = .1428571 * __b1_ * __b2_;
           __c2_ = __b2_ - 15. * __c3_;
           __c1_ = __b1_ - 6. * __b2_ + 45. * __c3_;
           __c0_ = 1. - __b1_ + 3. * __b2_ - 15. * __c3_;
           __c_ = .1069 / __mean_;
       }
   }
    template <class _IntType> template<class _URNG> _IntType poisson_distribution<_IntType>::operator()(_URNG& __urng, const param_type& __pr) {
       result_type __x;
       uniform_real_distribution<double> __urd;
       if (__pr.__mean_ < 10)     {
            __x = 0;
           for (double __p = __urd(__urng);
   __p > __pr.__l_;
   ++__x)             __p *= __urd(__urng);
       }
       else     {
           double __difmuk;
           double __g = __pr.__mean_ + __pr.__s_ * normal_distribution<double>()(__urng);
           double __u;
           if (__g > 0)         {
               __x = static_cast<result_type>(__g);
               if (__x >= __pr.__l_)                 return __x;
               __difmuk = __pr.__mean_ - __x;
               __u = __urd(__urng);
               if (__pr.__d_ * __u >= __difmuk * __difmuk * __difmuk)                 return __x;
           }
           exponential_distribution<double> __edist;
           for (bool __using_exp_dist = false;
   true;
   __using_exp_dist = true)         {
               double __e;
               if (__using_exp_dist || __g < 0)             {
                   double __t;
                   do                 {
                       __e = __edist(__urng);
                       __u = __urd(__urng);
                       __u += __u - 1;
                       __t = 1.8 + (__u < 0 ? -__e : __e);
                   }
   while (__t <= -.6744);
                   __x = __pr.__mean_ + __pr.__s_ * __t;
                   __difmuk = __pr.__mean_ - __x;
                   __using_exp_dist = true;
               }
               double __px;
               double __py;
               if (__x < 10)             {
                   const result_type __fac[] = {
  1, 1, 2, 6, 24, 120, 720, 5040,                                              40320, 362880};
                   __px = -__pr.__mean_;
                   __py = _VSTD::pow(__pr.__mean_, (double)__x) / __fac[__x];
               }
               else             {
                   double __del = .8333333E-1 / __x;
                   __del -= 4.8 * __del * __del * __del;
                   double __v = __difmuk / __x;
                   if (_VSTD::abs(__v) > 0.25)                     __px = __x * _VSTD::log(1 + __v) - __difmuk - __del;
                   else                     __px = __x * __v * __v * (((((((.1250060 * __v + -.1384794) *                            __v + .1421878) * __v + -.1661269) * __v + .2000118) *                            __v + -.2500068) * __v + .3333333) * __v + -.5) - __del;
                   __py = .3989423 / _VSTD::sqrt(__x);
               }
               double __r = (0.5 - __difmuk) / __pr.__s_;
               double __r2 = __r * __r;
           }
       }
       return __x;
   }
    template <class _CharT, class _Traits, class _IntType> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const poisson_distribution<_IntType>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       return __os << __x.mean();
   }
    template <class _CharT, class _Traits, class _IntType> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            poisson_distribution<_IntType>& __x) {
       typedef poisson_distribution<_IntType> _Eng;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       double __mean;
       __is >> __mean;
       if (!__is.fail())         __x.param(param_type(__mean));
       return __is;
   }
    // weibull_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS weibull_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __a_;
           result_type __b_;
       public:         typedef weibull_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __a = 1, result_type __b = 1)             : __a_(__a), __b_(__b) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type a() const {
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit weibull_distribution(result_type __a = 1, result_type __b = 1)         : __p_(param_type(__a, __b)) {
  }
       template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g, const param_type& __p)         {
  return __p.b() *             _VSTD::pow(exponential_distribution<result_type>()(__g), 1/__p.a());
  }
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type a() const {
  return __p_.a();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const weibull_distribution& __x,                         const weibull_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const weibull_distribution& __x,                         const weibull_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const weibull_distribution<_RT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       __os << __x.a() << __sp << __x.b();
       return __os;
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            weibull_distribution<_RT>& __x) {
       typedef weibull_distribution<_RT> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __a;
       result_type __b;
       __is >> __a >> __b;
       if (!__is.fail())         __x.param(param_type(__a, __b));
       return __is;
   }
    template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS extreme_value_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __a_;
           result_type __b_;
       public:         typedef extreme_value_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __a = 0, result_type __b = 1)             : __a_(__a), __b_(__b) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type a() const {
  return __a_;
  }
           _LIBCPP_INLINE_VISIBILITY         result_type b() const {
  return __b_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit extreme_value_distribution(result_type __a = 0, result_type __b = 1)         : __p_(param_type(__a, __b)) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit extreme_value_distribution(const param_type& __p)         : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  __p_ = __p;
  }
        _LIBCPP_INLINE_VISIBILITY     result_type min() const {
  return -numeric_limits<result_type>::infinity();
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return numeric_limits<result_type>::infinity();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const extreme_value_distribution& __x,                         const extreme_value_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const extreme_value_distribution& __x,                         const extreme_value_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template<class _RealType> template<class _URNG> _RealType extreme_value_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       return __p.a() - __p.b() *          _VSTD::log(-_VSTD::log(1-uniform_real_distribution<result_type>()(__g)));
   }
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const extreme_value_distribution<_RT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       __os << __x.a() << __sp << __x.b();
       return __os;
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            extreme_value_distribution<_RT>& __x) {
       typedef extreme_value_distribution<_RT> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __a;
       result_type __b;
       __is >> __a >> __b;
       if (!__is.fail())         __x.param(param_type(__a, __b));
       return __is;
   }
    // gamma_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS gamma_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __alpha_;
           result_type __beta_;
       public:         typedef gamma_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __alpha = 1, result_type __beta = 1)             : __alpha_(__alpha), __beta_(__beta) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type alpha() const {
  return __alpha_;
  }
           _LIBCPP_INLINE_VISIBILITY         result_type beta() const {
  return __beta_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__alpha_ == __y.__alpha_ && __x.__beta_ == __y.__beta_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructors and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit gamma_distribution(result_type __alpha = 1, result_type __beta = 1)         : __p_(param_type(__alpha, __beta)) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit gamma_distribution(const param_type& __p)         : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type alpha() const {
  return __p_.alpha();
  }
       _LIBCPP_INLINE_VISIBILITY     result_type beta() const {
  return __p_.beta();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  __p_ = __p;
  }
        _LIBCPP_INLINE_VISIBILITY     result_type min() const {
  return 0;
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return numeric_limits<result_type>::infinity();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const gamma_distribution& __x,                         const gamma_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const gamma_distribution& __x,                         const gamma_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template <class _RealType> template<class _URNG> _RealType gamma_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       result_type __a = __p.alpha();
       uniform_real_distribution<result_type> __gen(0, 1);
       exponential_distribution<result_type> __egen;
       result_type __x;
       if (__a == 1)         __x = __egen(__g);
       else if (__a > 1)     {
           const result_type __b = __a - 1;
           const result_type __c = 3 * __a - result_type(0.75);
           while (true)         {
               const result_type __u = __gen(__g);
               const result_type __v = __gen(__g);
               const result_type __w = __u * (1 - __u);
               if (__w != 0)             {
                   const result_type __y = _VSTD::sqrt(__c / __w) *                                         (__u - result_type(0.5));
                   __x = __b + __y;
                   if (__x >= 0)                 {
                       const result_type __z = 64 * __w * __w * __w * __v * __v;
                       if (__z <= 1 - 2 * __y * __y / __x)                         break;
                       if (_VSTD::log(__z) <= 2 * (__b * _VSTD::log(__x / __b) - __y))                         break;
                   }
               }
           }
       }
       else  // __a < 1
    {
           while (true)         {
               const result_type __u = __gen(__g);
               const result_type __es = __egen(__g);
               if (__u <= 1 - __a)             {
                   __x = _VSTD::pow(__u, 1 / __a);
                   if (__x <= __es)                     break;
               }
               else             {
                   const result_type __e = -_VSTD::log((1-__u)/__a);
                   __x = _VSTD::pow(1 - __a + __a * __e, 1 / __a);
                   if (__x <= __e + __es)                     break;
               }
           }
       }
       return __x * __p.beta();
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            gamma_distribution<_RT>& __x) {
       typedef gamma_distribution<_RT> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __alpha;
       result_type __beta;
       __is >> __alpha >> __beta;
       if (!__is.fail())         __x.param(param_type(__alpha, __beta));
       return __is;
   }
    // negative_binomial_distribution
 template<class _IntType = int> class _LIBCPP_TEMPLATE_VIS negative_binomial_distribution {
   public:     // types
    typedef _IntType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __k_;
           double __p_;
       public:         typedef negative_binomial_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __k = 1, double __p = 0.5)             : __k_(__k), __p_(__p) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type k() const {
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit negative_binomial_distribution(result_type __k = 1, double __p = 0.5)         : __p_(__k, __p) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit negative_binomial_distribution(const param_type& __p) : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type k() const {
  return __p_.k();
  }
       _LIBCPP_INLINE_VISIBILITY     double p() const {
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const negative_binomial_distribution& __x,                         const negative_binomial_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template <class _IntType> template<class _URNG> _IntType negative_binomial_distribution<_IntType>::operator()(_URNG& __urng, const param_type& __pr) {
       result_type __k = __pr.k();
       double __p = __pr.p();
       if (__k <= 21 * __p)     {
           bernoulli_distribution __gen(__p);
           result_type __f = 0;
           result_type __s = 0;
           while (__s < __k)         {
               if (__gen(__urng))                 ++__s;
               else                 ++__f;
           }
           return __f;
       }
       return poisson_distribution<result_type>(gamma_distribution<double>                                             (__k, (1-__p)/__p)(__urng))(__urng);
   }
    template <class _CharT, class _Traits, class _IntType> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const negative_binomial_distribution<_IntType>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       return __os << __x.k() << __sp << __x.p();
   }
    template <class _CharT, class _Traits, class _IntType> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            negative_binomial_distribution<_IntType>& __x) {
       typedef negative_binomial_distribution<_IntType> _Eng;
       typedef typename _Eng::result_type result_type;
       return __is;
   }
    // geometric_distribution
 template<class _IntType = int> class _LIBCPP_TEMPLATE_VIS geometric_distribution {
   public:     // types
    typedef _IntType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           double __p_;
       public:         typedef geometric_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(double __p = 0.5) : __p_(__p) {
  }
            _LIBCPP_INLINE_VISIBILITY         double p() const {
  return __p_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__p_ == __y.__p_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructors and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit geometric_distribution(double __p = 0.5) : __p_(__p) {
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  __p_ = __p;
  }
        _LIBCPP_INLINE_VISIBILITY     result_type min() const {
  return 0;
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return numeric_limits<result_type>::max();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const geometric_distribution& __x,                         const geometric_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const geometric_distribution& __x,                         const geometric_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template <class _CharT, class _Traits, class _IntType> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const geometric_distribution<_IntType>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       return __os << __x.p();
   }
    template <class _CharT, class _Traits, class _IntType> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            geometric_distribution<_IntType>& __x) {
       typedef geometric_distribution<_IntType> _Eng;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       double __p;
       __is >> __p;
       if (!__is.fail())         __x.param(param_type(__p));
       return __is;
   }
    // chi_squared_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS chi_squared_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __n_;
       public:         typedef chi_squared_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __n = 1) : __n_(__n) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type n() const {
  return __n_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__n_ == __y.__n_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit chi_squared_distribution(result_type __n = 1)         : __p_(param_type(__n)) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit chi_squared_distribution(const param_type& __p)         : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type n() const {
  return __p_.n();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const chi_squared_distribution& __x,                         const chi_squared_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const chi_squared_distribution& __x,                         const chi_squared_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const chi_squared_distribution<_RT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       __os << __x.n();
       return __os;
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            chi_squared_distribution<_RT>& __x) {
       typedef chi_squared_distribution<_RT> _Eng;
   }
    // cauchy_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS cauchy_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __a_;
           result_type __b_;
       public:         typedef cauchy_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __a = 0, result_type __b = 1)             : __a_(__a), __b_(__b) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type a() const {
  return __a_;
  }
           _LIBCPP_INLINE_VISIBILITY         result_type b() const {
  }
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit cauchy_distribution(result_type __a = 0, result_type __b = 1)         : __p_(param_type(__a, __b)) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit cauchy_distribution(const param_type& __p)         : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> _LIBCPP_INLINE_VISIBILITY result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type a() const {
  return __p_.a();
  }
       _LIBCPP_INLINE_VISIBILITY     result_type b() const {
  return __p_.b();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  }
   };
    template <class _RealType> template<class _URNG> inline _RealType cauchy_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       uniform_real_distribution<result_type> __gen;
       // purposefully let tan arg get as close to pi/2 as it wants, tan will return a finite
    return __p.a() + __p.b() * _VSTD::tan(3.1415926535897932384626433832795 * __gen(__g));
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            cauchy_distribution<_RT>& __x) {
       typedef cauchy_distribution<_RT> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __a;
       result_type __b;
       __is >> __a >> __b;
       if (!__is.fail())         __x.param(param_type(__a, __b));
       return __is;
   }
    // fisher_f_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS fisher_f_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __m_;
           result_type __n_;
       public:         typedef fisher_f_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __m = 1, result_type __n = 1)             : __m_(__m), __n_(__n) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type m() const {
  return __m_;
  }
           _LIBCPP_INLINE_VISIBILITY         result_type n() const {
  return __n_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__m_ == __y.__m_ && __x.__n_ == __y.__n_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit fisher_f_distribution(result_type __m = 1, result_type __n = 1)         : __p_(param_type(__m, __n)) {
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type m() const {
  return __p_.m();
  }
       _LIBCPP_INLINE_VISIBILITY     result_type n() const {
  return __p_.n();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  __p_ = __p;
  }
        _LIBCPP_INLINE_VISIBILITY     result_type min() const {
  return 0;
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return numeric_limits<result_type>::infinity();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const fisher_f_distribution& __x,                         const fisher_f_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const fisher_f_distribution& __x,                         const fisher_f_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template <class _RealType> template<class _URNG> _RealType fisher_f_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       gamma_distribution<result_type> __gdm(__p.m() * result_type(.5));
       gamma_distribution<result_type> __gdn(__p.n() * result_type(.5));
       return __p.n() * __gdm(__g) / (__p.m() * __gdn(__g));
   }
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const fisher_f_distribution<_RT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       __os << __x.m() << __sp << __x.n();
       return __os;
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            fisher_f_distribution<_RT>& __x) {
       typedef fisher_f_distribution<_RT> _Eng;
       typedef typename _Eng::result_type result_type;
       typedef typename _Eng::param_type param_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       result_type __m;
       result_type __n;
       __is >> __m >> __n;
       if (!__is.fail())         __x.param(param_type(__m, __n));
       return __is;
   }
    // student_t_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS student_t_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           result_type __n_;
       public:         typedef student_t_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         explicit param_type(result_type __n = 1) : __n_(__n) {
  }
            _LIBCPP_INLINE_VISIBILITY         result_type n() const {
  return __n_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__n_ == __y.__n_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
       };
    private:     param_type __p_;
       normal_distribution<result_type> __nd_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     explicit student_t_distribution(result_type __n = 1)         : __p_(param_type(__n)) {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit student_t_distribution(const param_type& __p)         : __p_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     void reset() {
  __nd_.reset();
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     result_type n() const {
  return __p_.n();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return numeric_limits<result_type>::infinity();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const student_t_distribution& __x,                         const student_t_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const student_t_distribution& __x,                         const student_t_distribution& __y)         {
  return !(__x == __y);
  }
   };
    template <class _RealType> template<class _URNG> _RealType student_t_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       gamma_distribution<result_type> __gd(__p.n() * .5, 2);
       return __nd_(__g) * _VSTD::sqrt(__p.n()/__gd(__g));
   }
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const student_t_distribution<_RT>& __x) {
   }
    // discrete_distribution
 template<class _IntType = int> class _LIBCPP_TEMPLATE_VIS discrete_distribution {
   public:     // types
    typedef _IntType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           vector<double> __p_;
       public:         typedef discrete_distribution distribution_type;
            _LIBCPP_INLINE_VISIBILITY         param_type() {
  }
           template<class _InputIterator>             _LIBCPP_INLINE_VISIBILITY             param_type(_InputIterator __f, _InputIterator __l)             : __p_(__f, __l) {
  __init();
  }
     
#ifndef _LIBCPP_CXX03_LANG
        _LIBCPP_INLINE_VISIBILITY         param_type(initializer_list<double> __wl)             : __p_(__wl.begin(), __wl.end()) {
  __init();
  }
     
#endif  // _LIBCPP_CXX03_LANG
        template<class _UnaryOperation>             param_type(size_t __nw, double __xmin, double __xmax,                        _UnaryOperation __fw);
            vector<double> probabilities() const;
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__p_ == __y.__p_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
        private:         void __init();
            friend class discrete_distribution;
            template <class _CharT, class _Traits, class _IT>         friend         basic_ostream<_CharT, _Traits>&         operator<<(basic_ostream<_CharT, _Traits>& __os,                    const discrete_distribution<_IT>& __x);
            template <class _CharT, class _Traits, class _IT>         friend         basic_istream<_CharT, _Traits>&         operator>>(basic_istream<_CharT, _Traits>& __is,                    discrete_distribution<_IT>& __x);
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     discrete_distribution() {
  }
       template<class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         discrete_distribution(_InputIterator __f, _InputIterator __l)             : __p_(__f, __l) {
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     vector<double> probabilities() const {
  return __p_.probabilities();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  __p_ = __p;
  }
        _LIBCPP_INLINE_VISIBILITY     result_type min() const {
  return 0;
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return __p_.__p_.size();
  }
        friend _LIBCPP_INLINE_VISIBILITY         bool operator==(const discrete_distribution& __x,                         const discrete_distribution& __y)         {
  return __x.__p_ == __y.__p_;
  }
       friend _LIBCPP_INLINE_VISIBILITY         bool operator!=(const discrete_distribution& __x,                         const discrete_distribution& __y)         {
  return !(__x == __y);
  }
        template <class _CharT, class _Traits, class _IT>     friend     basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>& __os,                const discrete_distribution<_IT>& __x);
        template <class _CharT, class _Traits, class _IT>     friend     basic_istream<_CharT, _Traits>&     operator>>(basic_istream<_CharT, _Traits>& __is,                discrete_distribution<_IT>& __x);
   };
    template<class _IntType> template<class _UnaryOperation> discrete_distribution<_IntType>::param_type::param_type(size_t __nw,                                                         double __xmin,                                                         double __xmax,                                                         _UnaryOperation __fw) {
       if (__nw > 1)     {
           __p_.reserve(__nw - 1);
           double __d = (__xmax - __xmin) / __nw;
           double __d2 = __d / 2;
           for (size_t __k = 0;
   __k < __nw;
   ++__k)             __p_.push_back(__fw(__xmin + __k * __d + __d2));
           __init();
       }
   }
    template<class _IntType> void discrete_distribution<_IntType>::param_type::__init() {
       if (!__p_.empty())     {
           if (__p_.size() > 1)         {
               double __s = _VSTD::accumulate(__p_.begin(), __p_.end(), 0.0);
               for (_VSTD::vector<double>::iterator __i = __p_.begin(), __e = __p_.end();
                                                                          __i < __e;
   ++__i)                 *__i /= __s;
               vector<double> __t(__p_.size() - 1);
               _VSTD::partial_sum(__p_.begin(), __p_.end() - 1, __t.begin());
               swap(__p_, __t);
           }
           else         {
               __p_.clear();
               __p_.shrink_to_fit();
           }
       }
   }
    template<class _IntType> vector<double> discrete_distribution<_IntType>::param_type::probabilities() const {
       size_t __n = __p_.size();
       _VSTD::vector<double> __p(__n+1);
       _VSTD::adjacent_difference(__p_.begin(), __p_.end(), __p.begin());
       if (__n > 0)         __p[__n] = 1 - __p_[__n-1];
       else         __p[0] = 1;
       return __p;
   }
    template<class _IntType> template<class _URNG> _IntType discrete_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p) {
       uniform_real_distribution<double> __gen;
       return static_cast<_IntType>(            _VSTD::upper_bound(__p.__p_.begin(), __p.__p_.end(), __gen(__g)) -                                                               __p.__p_.begin());
   }
    template <class _CharT, class _Traits, class _IT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const discrete_distribution<_IT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       size_t __n = __x.__p_.__p_.size();
       __os << __n;
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __os << __sp << __x.__p_.__p_[__i];
       return __os;
   }
    template <class _CharT, class _Traits, class _IT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            discrete_distribution<_IT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       size_t __n;
       __is >> __n;
       vector<double> __p(__n);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __is >> __p[__i];
       if (!__is.fail())         swap(__x.__p_.__p_, __p);
       return __is;
   }
    // piecewise_constant_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS piecewise_constant_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           vector<result_type> __b_;
           vector<result_type> __densities_;
           vector<result_type> __areas_;
       public:         typedef piecewise_constant_distribution distribution_type;
            param_type();
           template<class _InputIteratorB, class _InputIteratorW>             param_type(_InputIteratorB __fB, _InputIteratorB __lB,                        _InputIteratorW __fW);
     
#ifndef _LIBCPP_CXX03_LANG
        template<class _UnaryOperation>             param_type(initializer_list<result_type> __bl, _UnaryOperation __fw);
     
#endif  // _LIBCPP_CXX03_LANG
        template<class _UnaryOperation>             param_type(size_t __nw, result_type __xmin, result_type __xmax,                        _UnaryOperation __fw);
           param_type & operator=(const param_type& __rhs);
            _LIBCPP_INLINE_VISIBILITY         vector<result_type> intervals() const {
  return __b_;
  }
           _LIBCPP_INLINE_VISIBILITY         vector<result_type> densities() const {
  return __densities_;
  }
            friend _LIBCPP_INLINE_VISIBILITY             bool operator==(const param_type& __x, const param_type& __y)             {
  return __x.__densities_ == __y.__densities_ && __x.__b_ == __y.__b_;
  }
           friend _LIBCPP_INLINE_VISIBILITY             bool operator!=(const param_type& __x, const param_type& __y)             {
  return !(__x == __y);
  }
        private:         void __init();
            friend class piecewise_constant_distribution;
            template <class _CharT, class _Traits, class _RT>         friend         basic_ostream<_CharT, _Traits>&         operator<<(basic_ostream<_CharT, _Traits>& __os,                    const piecewise_constant_distribution<_RT>& __x);
            template <class _CharT, class _Traits, class _RT>         friend         basic_istream<_CharT, _Traits>&         operator>>(basic_istream<_CharT, _Traits>& __is,                    piecewise_constant_distribution<_RT>& __x);
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     piecewise_constant_distribution() {
  }
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     vector<result_type> intervals() const {
  return __p_.intervals();
  }
   };
    template<class _RealType> typename piecewise_constant_distribution<_RealType>::param_type & piecewise_constant_distribution<_RealType>::param_type::operator=                                                        (const param_type& __rhs) {
   //  These can throw
    __b_.reserve        (__rhs.__b_.size ());
       __densities_.reserve(__rhs.__densities_.size());
       __areas_.reserve    (__rhs.__areas_.size());
    //  These can not throw
    __b_         = __rhs.__b_;
       __b_[1] = 1;
   }
    template<class _RealType> template<class _InputIteratorB, class _InputIteratorW> piecewise_constant_distribution<_RealType>::param_type::param_type(         _InputIteratorB __fB, _InputIteratorB __lB, _InputIteratorW __fW)     : __b_(__fB, __lB) {
       if (__b_.size() < 2)     {
           __b_.resize(2);
           __b_[0] = 0;
           __b_[1] = 1;
           __densities_.assign(1, 1.0);
           __init();
       }
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template<class _RealType> template<class _UnaryOperation> piecewise_constant_distribution<_RealType>::param_type::param_type(         initializer_list<result_type> __bl, _UnaryOperation __fw)     : __b_(__bl.begin(), __bl.end()) {
       if (__b_.size() < 2)     {
           __b_.resize(2);
           __b_[0] = 0;
           __b_[1] = 1;
           __densities_.assign(1, 1.0);
           __areas_.assign(1, 0.0);
       }
       else     {
           __densities_.reserve(__b_.size() - 1);
           for (size_t __i = 0;
   __i < __b_.size() - 1;
   ++__i)             __densities_.push_back(__fw((__b_[__i+1] + __b_[__i])*.5));
           __init();
       }
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template<class _RealType> template<class _UnaryOperation> piecewise_constant_distribution<_RealType>::param_type::param_type(         size_t __nw, result_type __xmin, result_type __xmax, _UnaryOperation __fw)     : __b_(__nw == 0 ? 2 : __nw + 1) {
       size_t __n = __b_.size() - 1;
       result_type __d = (__xmax - __xmin) / __n;
       __densities_.reserve(__n);
       for (size_t __i = 0;
   __i < __n;
   ++__i)     {
           __b_[__i] = __xmin + __i * __d;
           __densities_.push_back(__fw(__b_[__i] + __d*.5));
       }
       __b_[__n] = __xmax;
       __init();
   }
    template<class _RealType> template<class _URNG> _RealType piecewise_constant_distribution<_RealType>::operator()(_URNG& __g, const param_type& __p) {
       typedef uniform_real_distribution<result_type> _Gen;
       result_type __u = _Gen()(__g);
       ptrdiff_t __k = _VSTD::upper_bound(__p.__areas_.begin(), __p.__areas_.end(),                                       __u) - __p.__areas_.begin() - 1;
       return (__u - __p.__areas_[__k]) / __p.__densities_[__k] + __p.__b_[__k];
   }
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const piecewise_constant_distribution<_RT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       size_t __n = __x.__p_.__b_.size();
       __os << __n;
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __os << __sp << __x.__p_.__b_[__i];
       __n = __x.__p_.__densities_.size();
       __os << __sp << __n;
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __os << __sp << __x.__p_.__densities_[__i];
       __n = __x.__p_.__areas_.size();
       __os << __sp << __n;
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __os << __sp << __x.__p_.__areas_[__i];
       return __os;
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            piecewise_constant_distribution<_RT>& __x) {
       typedef piecewise_constant_distribution<_RT> _Eng;
       typedef typename _Eng::result_type result_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       size_t __n;
       __is >> __n;
       vector<result_type> __b(__n);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __is >> __b[__i];
       __is >> __n;
       vector<result_type> __densities(__n);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __is >> __densities[__i];
       __is >> __n;
       vector<result_type> __areas(__n);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __is >> __areas[__i];
       if (!__is.fail())     {
           swap(__x.__p_.__b_, __b);
           swap(__x.__p_.__densities_, __densities);
           swap(__x.__p_.__areas_, __areas);
       }
       return __is;
   }
    // piecewise_linear_distribution
 template<class _RealType = double> class _LIBCPP_TEMPLATE_VIS piecewise_linear_distribution {
   public:     // types
    typedef _RealType result_type;
        class _LIBCPP_TEMPLATE_VIS param_type     {
           vector<result_type> __b_;
           vector<result_type> __densities_;
           vector<result_type> __areas_;
        template<class _UnaryOperation>             param_type(size_t __nw, result_type __xmin, result_type __xmax,                        _UnaryOperation __fw);
           param_type & operator=(const param_type& __rhs);
                    _LIBCPP_INLINE_VISIBILITY         vector<result_type> intervals() const {
  return __b_;
  }
           _LIBCPP_INLINE_VISIBILITY         vector<result_type> densities() const {
  return __densities_;
  }
            friend class piecewise_linear_distribution;
            template <class _CharT, class _Traits, class _RT>         friend         basic_ostream<_CharT, _Traits>&         operator<<(basic_ostream<_CharT, _Traits>& __os,                    const piecewise_linear_distribution<_RT>& __x);
            template <class _CharT, class _Traits, class _RT>         friend         basic_istream<_CharT, _Traits>&         operator>>(basic_istream<_CharT, _Traits>& __is,                    piecewise_linear_distribution<_RT>& __x);
       };
    private:     param_type __p_;
    public:     // constructor and reset functions
    _LIBCPP_INLINE_VISIBILITY     piecewise_linear_distribution() {
  }
     template<class _UnaryOperation>         _LIBCPP_INLINE_VISIBILITY         piecewise_linear_distribution(size_t __nw, result_type __xmin,                                       result_type __xmax, _UnaryOperation __fw)         : __p_(__nw, __xmin, __xmax, __fw) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit piecewise_linear_distribution(const param_type& __p)         : __p_(__p) {
  }
        _LIBCPP_INLINE_VISIBILITY     void reset() {
  }
        // generating functions
    template<class _URNG>         _LIBCPP_INLINE_VISIBILITY         result_type operator()(_URNG& __g)         {
  return (*this)(__g, __p_);
  }
       template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
        // property functions
    _LIBCPP_INLINE_VISIBILITY     vector<result_type> intervals() const {
  return __p_.intervals();
  }
       _LIBCPP_INLINE_VISIBILITY     vector<result_type> densities() const {
  return __p_.densities();
  }
        _LIBCPP_INLINE_VISIBILITY     param_type param() const {
  return __p_;
  }
       _LIBCPP_INLINE_VISIBILITY     void param(const param_type& __p) {
  __p_ = __p;
  }
        _LIBCPP_INLINE_VISIBILITY     result_type min() const {
  return __p_.__b_.front();
  }
       _LIBCPP_INLINE_VISIBILITY     result_type max() const {
  return __p_.__b_.back();
  }
   };
    template<class _RealType> typename piecewise_linear_distribution<_RealType>::param_type & piecewise_linear_distribution<_RealType>::param_type::operator=                                                        (const param_type& __rhs) {
   //  These can throw
    __b_.reserve        (__rhs.__b_.size ());
       __densities_.reserve(__rhs.__densities_.size());
       __areas_.reserve    (__rhs.__areas_.size());
    //  These can not throw
   }
    template <class _CharT, class _Traits, class _RT> basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os,            const piecewise_linear_distribution<_RT>& __x) {
       __save_flags<_CharT, _Traits> __lx(__os);
       __os.flags(ios_base::dec | ios_base::left | ios_base::fixed |                ios_base::scientific);
       _CharT __sp = __os.widen(' ');
       __os.fill(__sp);
       size_t __n = __x.__p_.__b_.size();
       __os << __n;
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __os << __sp << __x.__p_.__b_[__i];
       __n = __x.__p_.__densities_.size();
       __os << __sp << __n;
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __os << __sp << __x.__p_.__densities_[__i];
       __n = __x.__p_.__areas_.size();
       __os << __sp << __n;
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __os << __sp << __x.__p_.__areas_[__i];
       return __os;
   }
    template <class _CharT, class _Traits, class _RT> basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is,            piecewise_linear_distribution<_RT>& __x) {
       typedef piecewise_linear_distribution<_RT> _Eng;
       typedef typename _Eng::result_type result_type;
       __save_flags<_CharT, _Traits> __lx(__is);
       __is.flags(ios_base::dec | ios_base::skipws);
       size_t __n;
       __is >> __n;
       vector<result_type> __b(__n);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __is >> __b[__i];
       __is >> __n;
       vector<result_type> __densities(__n);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __is >> __densities[__i];
       __is >> __n;
       vector<result_type> __areas(__n);
       for (size_t __i = 0;
   __i < __n;
   ++__i)         __is >> __areas[__i];
       if (!__is.fail())     {
           swap(__x.__p_.__b_, __b);
           swap(__x.__p_.__densities_, __densities);
           swap(__x.__p_.__areas_, __areas);
       }
       return __is;
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_RANDOM
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_RATIO
  
#define _LIBCPP_RATIO
 /*     ratio synopsis  namespace std {
    template <intmax_t N, intmax_t D = 1> class ratio {
   public:     static constexpr intmax_t num;
       static constexpr intmax_t den;
       typedef ratio<num, den> type;
   };
    // ratio arithmetic
template <class R1, class R2> using ratio_add = ...;
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
    
#endif  // _LIBCPP_CXX03_LANG
 template <class _R1, class _R2> struct __ratio_divide {
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_RATIO
  
#pragma clang module end /*std.ratio*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "regex"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.regex
// -*- C++ -*-
//===--------------------------- regex ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_REGEX
  
#define _LIBCPP_REGEX
 /*     regex synopsis    
#include <initializer_list>
 namespace std {
    namespace regex_constants {
    emum syntax_option_type {
       icase      = unspecified,     nosubs     = unspecified,     optimize   = unspecified,     collate    = unspecified,     ECMAScript = unspecified,     basic      = unspecified,     extended   = unspecified,     awk        = unspecified,     grep       = unspecified,     egrep      = unspecified };
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD  namespace regex_constants {
    // syntax_option_type
 enum syntax_option_type {
       icase      = 1 << 0,     nosubs     = 1 << 1,     optimize   = 1 << 2,     collate    = 1 << 3,     ECMAScript = 0,     basic      = 1 << 4,     extended   = 1 << 5,     awk        = 1 << 6,     grep       = 1 << 7,     egrep      = 1 << 8 };
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR syntax_option_type operator~(syntax_option_type __x) {
       return syntax_option_type(~int(__x) & 0x1FF);
   }
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR syntax_option_type operator&(syntax_option_type __x, syntax_option_type __y) {
       return syntax_option_type(int(__x) & int(__y));
   }
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR syntax_option_type operator|(syntax_option_type __x, syntax_option_type __y) {
       return syntax_option_type(int(__x) | int(__y));
   }
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR syntax_option_type operator^(syntax_option_type __x, syntax_option_type __y) {
       __x = __x | __y;
       return __x;
   }
    inline _LIBCPP_INLINE_VISIBILITY syntax_option_type& operator^=(syntax_option_type& __x, syntax_option_type __y) {
       __x = __x ^ __y;
       return __x;
   }
    // match_flag_type
 enum match_flag_type {
       match_default     = 0,     match_not_bol     = 1 << 0,     match_not_eol     = 1 << 1,     match_not_bow     = 1 << 2,     match_not_eow     = 1 << 3,     match_any         = 1 << 4,     match_not_null    = 1 << 5,     match_continuous  = 1 << 6,     match_prev_avail  = 1 << 7,     format_default    = 0,     format_sed        = 1 << 8,     format_no_copy    = 1 << 9,     format_first_only = 1 << 10,     __no_update_pos   = 1 << 11,     __full_match      = 1 << 12 };
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR match_flag_type operator~(match_flag_type __x) {
       return match_flag_type(~int(__x) & 0x0FFF);
   }
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR match_flag_type operator&(match_flag_type __x, match_flag_type __y) {
       return match_flag_type(int(__x) & int(__y));
   }
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR match_flag_type operator|(match_flag_type __x, match_flag_type __y) {
       return match_flag_type(int(__x) | int(__y));
   }
    inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR match_flag_type operator^(match_flag_type __x, match_flag_type __y) {
       return match_flag_type(int(__x) ^ int(__y));
   }
    inline _LIBCPP_INLINE_VISIBILITY match_flag_type& operator&=(match_flag_type& __x, match_flag_type __y) {
       __x = __x & __y;
       return __x;
   }
    inline _LIBCPP_INLINE_VISIBILITY match_flag_type& operator|=(match_flag_type& __x, match_flag_type __y) {
       __x = __x | __y;
       return __x;
   }
    inline _LIBCPP_INLINE_VISIBILITY match_flag_type& operator^=(match_flag_type& __x, match_flag_type __y) {
       __x = __x ^ __y;
       return __x;
   }
    enum error_type {
       error_collate = 1,     error_ctype,     error_escape,     error_backref,     error_brack,     error_paren,     error_brace,     error_badbrace,     error_range,     error_space,     error_badrepeat,     error_complexity,     error_stack,     __re_err_grammar,     __re_err_empty,     __re_err_unknown };
    }
    // regex_constants
 class _LIBCPP_EXCEPTION_ABI regex_error     : public runtime_error {
       regex_constants::error_type __code_;
   public:     explicit regex_error(regex_constants::error_type __ecode);
       virtual ~regex_error() throw();
        _LIBCPP_INLINE_VISIBILITY     regex_constants::error_type code() const {
  return __code_;
  }
   };
    template <regex_constants::error_type _Ev> _LIBCPP_NORETURN inline _LIBCPP_ALWAYS_INLINE void __throw_regex_error() {
     
#ifndef _LIBCPP_NO_EXCEPTIONS
    throw regex_error(_Ev);
     
#else
    _VSTD::abort();
     
#endif
}
    template <class _CharT> struct _LIBCPP_TEMPLATE_VIS regex_traits {
   public:     typedef _CharT                  char_type;
       typedef basic_string<char_type> string_type;
       typedef locale                  locale_type;
       typedef ctype_base::mask        char_class_type;
      
#if defined(__mips__) && defined(__GLIBC__)
    static const char_class_type __regex_word = static_cast<char_class_type>(_ISbit(15));
     
#else
    static const char_class_type __regex_word = 0x80;
     
#endif
 private:     locale __loc_;
       const ctype<char_type>* __ct_;
       const collate<char_type>* __col_;
    public:     regex_traits();
        _LIBCPP_INLINE_VISIBILITY     static size_t length(const char_type* __p)         {
  return char_traits<char_type>::length(__p);
  }
       template <class _ForwardIterator>         _LIBCPP_INLINE_VISIBILITY         string_type         lookup_collatename(_ForwardIterator __f, _ForwardIterator __l) const             {
  return __lookup_collatename(__f, __l, char_type());
  }
       template <class _ForwardIterator>         _LIBCPP_INLINE_VISIBILITY         char_class_type         lookup_classname(_ForwardIterator __f, _ForwardIterator __l,                          bool __icase = false) const             {
  return __lookup_classname(__f, __l, __icase, char_type());
  }
       bool isctype(char_type __c, char_class_type __m) const;
       _LIBCPP_INLINE_VISIBILITY     int value(char_type __ch, int __radix) const         {
  return __regex_traits_value(__ch, __radix);
  }
       locale_type imbue(locale_type __l);
       _LIBCPP_INLINE_VISIBILITY     locale_type getloc()const {
  return __loc_;
  }
    private:     void __init();
        template <class _ForwardIterator>         string_type         __transform_primary(_ForwardIterator __f, _ForwardIterator __l, char) const;
       template <class _ForwardIterator>         string_type         __transform_primary(_ForwardIterator __f, _ForwardIterator __l, wchar_t) const;
        template <class _ForwardIterator>         string_type         __lookup_collatename(_ForwardIterator __f, _ForwardIterator __l, char) const;
       template <class _ForwardIterator>         string_type         __lookup_collatename(_ForwardIterator __f, _ForwardIterator __l, wchar_t) const;
        template <class _ForwardIterator>         char_class_type         __lookup_classname(_ForwardIterator __f, _ForwardIterator __l,                            bool __icase, char) const;
       template <class _ForwardIterator>         char_class_type         __lookup_classname(_ForwardIterator __f, _ForwardIterator __l,                            bool __icase, wchar_t) const;
        static int __regex_traits_value(unsigned char __ch, int __radix);
       _LIBCPP_INLINE_VISIBILITY     int __regex_traits_value(char __ch, int __radix) const         {
  return __regex_traits_value(static_cast<unsigned char>(__ch), __radix);
  }
       _LIBCPP_INLINE_VISIBILITY     int __regex_traits_value(wchar_t __ch, int __radix) const;
   };
    template <class _CharT> const typename regex_traits<_CharT>::char_class_type regex_traits<_CharT>::__regex_word;
    template <class _CharT> regex_traits<_CharT>::regex_traits() {
       __init();
   }
    template <class _CharT> void regex_traits<_CharT>::__init() {
       __ct_ = &use_facet<ctype<char_type> >(__loc_);
       __col_ = &use_facet<collate<char_type> >(__loc_);
   }
    template <class _CharT> typename regex_traits<_CharT>::locale_type regex_traits<_CharT>::imbue(locale_type __l) {
       locale __r = __loc_;
       __loc_ = __l;
       __init();
       return __r;
   }
    // transform_primary is very FreeBSD-specific
 template <class _CharT> template <class _ForwardIterator> typename regex_traits<_CharT>::string_type regex_traits<_CharT>::__transform_primary(_ForwardIterator __f,                                           _ForwardIterator __l, char) const {
       const string_type __s(__f, __l);
       string_type __d = __col_->transform(__s.data(), __s.data() + __s.size());
       switch (__d.size())     {
       case 1:         break;
       case 12:         __d[11] = __d[3];
           break;
       default:         __d.clear();
           break;
       }
       return __d;
   }
    template <class _CharT> template <class _ForwardIterator> typename regex_traits<_CharT>::string_type regex_traits<_CharT>::__transform_primary(_ForwardIterator __f,                                           _ForwardIterator __l, wchar_t) const {
       const string_type __s(__f, __l);
       string_type __d = __col_->transform(__s.data(), __s.data() + __s.size());
       switch (__d.size())     {
       case 1:         break;
       case 3:         __d[2] = __d[0];
           break;
       default:         __d.clear();
           break;
       }
       return __d;
   }
    // lookup_collatename is very FreeBSD-specific
 _LIBCPP_FUNC_VIS string __get_collation_name(const char* __s);
    template <class _CharT> template <class _ForwardIterator> typename regex_traits<_CharT>::string_type regex_traits<_CharT>::__lookup_collatename(_ForwardIterator __f,                                            _ForwardIterator __l, char) const {
       string_type __s(__f, __l);
       string_type __r;
       if (!__s.empty())     {
           __r = __get_collation_name(__s.c_str());
           if (__r.empty() && __s.size() <= 2)         {
               __r = __col_->transform(__s.data(), __s.data() + __s.size());
               if (__r.size() == 1 || __r.size() == 12)                 __r = __s;
               else                 __r.clear();
           }
       }
       return __r;
   }
    template <class _CharT> template <class _ForwardIterator> typename regex_traits<_CharT>::string_type regex_traits<_CharT>::__lookup_collatename(_ForwardIterator __f,                                            _ForwardIterator __l, wchar_t) const {
       string_type __s(__f, __l);
       string __n;
       __n.reserve(__s.size());
       for (typename string_type::const_iterator __i = __s.begin(), __e = __s.end();
                                                                 __i != __e;
   ++__i)     {
           if (static_cast<unsigned>(*__i) >= 127)             return string_type();
           __n.push_back(char(*__i));
       }
       string_type __r;
       if (!__s.empty())     {
           __n = __get_collation_name(__n.c_str());
           if (!__n.empty())             __r.assign(__n.begin(), __n.end());
           else if (__s.size() <= 2)         {
               __r = __col_->transform(__s.data(), __s.data() + __s.size());
               if (__r.size() == 1 || __r.size() == 3)                 __r = __s;
               else                 __r.clear();
           }
       }
       return __r;
   }
    // lookup_classname
 regex_traits<char>::char_class_type _LIBCPP_FUNC_VIS __get_classname(const char* __s, bool __icase);
    template <class _CharT> template <class _ForwardIterator> typename regex_traits<_CharT>::char_class_type regex_traits<_CharT>::__lookup_classname(_ForwardIterator __f,                                          _ForwardIterator __l,                                          bool __icase, char) const {
       string_type __s(__f, __l);
       __ct_->tolower(&__s[0], &__s[0] + __s.size());
       return __get_classname(__s.c_str(), __icase);
   }
    template <class _CharT> template <class _ForwardIterator> typename regex_traits<_CharT>::char_class_type regex_traits<_CharT>::__lookup_classname(_ForwardIterator __f,                                          _ForwardIterator __l,                                          bool __icase, wchar_t) const {
       string_type __s(__f, __l);
       __ct_->tolower(&__s[0], &__s[0] + __s.size());
       string __n;
       __n.reserve(__s.size());
       for (typename string_type::const_iterator __i = __s.begin(), __e = __s.end();
                                                                 __i != __e;
   ++__i)     {
           if (static_cast<unsigned>(*__i) >= 127)             return char_class_type();
           __n.push_back(char(*__i));
       }
       return __get_classname(__n.c_str(), __icase);
   }
    template <class _CharT> bool regex_traits<_CharT>::isctype(char_type __c, char_class_type __m) const {
       if (__ct_->is(__m, __c))         return true;
       return (__c == '_' && (__m & __regex_word));
   }
    template <class _CharT> int regex_traits<_CharT>::__regex_traits_value(unsigned char __ch, int __radix) {
       if ((__ch & 0xF8u) == 0x30)  // '0' <= __ch && __ch <= '7'
        return __ch - '0';
       if (__radix != 8)     {
           if ((__ch & 0xFEu) == 0x38)  // '8' <= __ch && __ch <= '9'
            return __ch - '0';
           if (__radix == 16)         {
               __ch |= 0x20;
    // tolower
            if ('a' <= __ch && __ch <= 'f')                 return __ch - ('a' - 10);
           }
       }
       return -1;
   }
    template <class _CharT> inline int regex_traits<_CharT>::__regex_traits_value(wchar_t __ch, int __radix) const {
       return __regex_traits_value(static_cast<unsigned char>(__ct_->narrow(__ch, char_type())), __radix);
   }
    template <class _CharT> class __node;
    template <class _BidirectionalIterator> class _LIBCPP_TEMPLATE_VIS sub_match;
    template <class _BidirectionalIterator,           class _Allocator = allocator<sub_match<_BidirectionalIterator> > > class _LIBCPP_TEMPLATE_VIS match_results;
    template <class _CharT> struct __state {
       enum     {
           __end_state = -1000,         __consume_input,  // -999
        __begin_marked_expr, // -998
        __end_marked_expr,   // -997
        __pop_state,           // -996
        __accept_and_consume,  // -995
        __accept_but_not_consume,  // -994
        __reject,                  // -993
        __split,         __repeat     };
        int __do_;
       const _CharT* __first_;
       const _CharT* __current_;
       const _CharT* __last_;
       vector<sub_match<const _CharT*> > __sub_matches_;
       vector<pair<size_t, const _CharT*> > __loop_data_;
       const __node<_CharT>* __node_;
       regex_constants::match_flag_type __flags_;
       bool __at_first_;
        _LIBCPP_INLINE_VISIBILITY     __state()         : __do_(0), __first_(nullptr), __current_(nullptr), __last_(nullptr),           __node_(nullptr), __flags_() {
  }
   };
    // __node
 template <class _CharT> class __node {
       __node(const __node&);
       __node& operator=(const __node&);
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __node() {
  }
       _LIBCPP_INLINE_VISIBILITY     virtual ~__node() {
  }
        _LIBCPP_INLINE_VISIBILITY     virtual void __exec(__state&) const {
  };
       _LIBCPP_INLINE_VISIBILITY     virtual void __exec_split(bool, __state&) const {
  };
   };
    // __end_state
 template <class _CharT> class __end_state     : public __node<_CharT> {
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __end_state() {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __end_state<_CharT>::__exec(__state& __s) const {
       __s.__do_ = __state::__end_state;
   }
    // __has_one_state
 template <class _CharT> class __has_one_state     : public __node<_CharT> {
       __node<_CharT>* __first_;
    public:     _LIBCPP_INLINE_VISIBILITY     explicit __has_one_state(__node<_CharT>* __s)         : __first_(__s) {
  }
        _LIBCPP_INLINE_VISIBILITY     __node<_CharT>*  first() const {
  return __first_;
  }
       _LIBCPP_INLINE_VISIBILITY     __node<_CharT>*& first()       {
  return __first_;
  }
   };
    // __owns_one_state
 template <class _CharT> class __owns_one_state     : public __has_one_state<_CharT> {
       typedef __has_one_state<_CharT> base;
    public:     _LIBCPP_INLINE_VISIBILITY     explicit __owns_one_state(__node<_CharT>* __s)         : base(__s) {
  }
        virtual ~__owns_one_state();
   };
    template <class _CharT> __owns_one_state<_CharT>::~__owns_one_state() {
       delete this->first();
   }
    // __empty_state
 template <class _CharT> class __empty_state     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
    public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     explicit __empty_state(__node<_CharT>* __s)         : base(__s) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __empty_state<_CharT>::__exec(__state& __s) const {
       __s.__do_ = __state::__accept_but_not_consume;
       __s.__node_ = this->first();
   }
    // __empty_non_own_state
 template <class _CharT> class __empty_non_own_state     : public __has_one_state<_CharT> {
       typedef __has_one_state<_CharT> base;
    public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     explicit __empty_non_own_state(__node<_CharT>* __s)         : base(__s) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __empty_non_own_state<_CharT>::__exec(__state& __s) const {
       __s.__do_ = __state::__accept_but_not_consume;
       __s.__node_ = this->first();
   }
    // __repeat_one_loop
 template <class _CharT> class __repeat_one_loop     : public __has_one_state<_CharT> {
       typedef __has_one_state<_CharT> base;
    public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     explicit __repeat_one_loop(__node<_CharT>* __s)         : base(__s) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __repeat_one_loop<_CharT>::__exec(__state& __s) const {
       __s.__do_ = __state::__repeat;
       __s.__node_ = this->first();
   }
    // __owns_two_states
 template <class _CharT> class __owns_two_states     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        base* __second_;
    public:     _LIBCPP_INLINE_VISIBILITY     explicit __owns_two_states(__node<_CharT>* __s1, base* __s2)         : base(__s1), __second_(__s2) {
  }
        virtual ~__owns_two_states();
        _LIBCPP_INLINE_VISIBILITY     base*  second() const {
  return __second_;
  }
       _LIBCPP_INLINE_VISIBILITY     base*& second()       {
  return __second_;
  }
   };
    template <class _CharT> __owns_two_states<_CharT>::~__owns_two_states() {
       delete __second_;
   }
    // __loop
 template <class _CharT> class __loop     : public __owns_two_states<_CharT> {
       typedef __owns_two_states<_CharT> base;
        size_t __min_;
       size_t __max_;
       unsigned __loop_id_;
       unsigned __mexp_begin_;
       unsigned __mexp_end_;
       bool __greedy_;
    public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     explicit __loop(unsigned __loop_id,                           __node<_CharT>* __s1, __owns_one_state<_CharT>* __s2,                           unsigned __mexp_begin, unsigned __mexp_end,                           bool __greedy = true,                           size_t __min = 0,                           size_t __max = numeric_limits<size_t>::max())         : base(__s1, __s2), __min_(__min), __max_(__max), __loop_id_(__loop_id),           __mexp_begin_(__mexp_begin), __mexp_end_(__mexp_end),           __greedy_(__greedy) {
  }
        virtual void __exec(__state& __s) const;
       virtual void __exec_split(bool __second, __state& __s) const;
    private:     _LIBCPP_INLINE_VISIBILITY     void __init_repeat(__state& __s) const     {
           __s.__loop_data_[__loop_id_].second = __s.__current_;
           for (size_t __i = __mexp_begin_-1;
   __i != __mexp_end_-1;
   ++__i)         {
               __s.__sub_matches_[__i].first = __s.__last_;
               __s.__sub_matches_[__i].second = __s.__last_;
               __s.__sub_matches_[__i].matched = false;
           }
       }
   };
    template <class _CharT> void __loop<_CharT>::__exec(__state& __s) const {
       if (__s.__do_ == __state::__repeat)     {
           bool __do_repeat = ++__s.__loop_data_[__loop_id_].first < __max_;
           bool __do_alt = __s.__loop_data_[__loop_id_].first >= __min_;
           if (__do_repeat && __do_alt &&                                __s.__loop_data_[__loop_id_].second == __s.__current_)             __do_repeat = false;
           if (__do_repeat && __do_alt)             __s.__do_ = __state::__split;
           else if (__do_repeat)         {
               __s.__node_ = this->first();
               __init_repeat(__s);
           }
           else         {
               __s.__do_ = __state::__accept_but_not_consume;
               __s.__node_ = this->second();
           }
       }
   }
    template <class _CharT> void __loop<_CharT>::__exec_split(bool __second, __state& __s) const {
       __s.__do_ = __state::__accept_but_not_consume;
       if (__greedy_ != __second)     {
           __s.__node_ = this->first();
           __init_repeat(__s);
       }
   }
    // __back_ref
 template <class _CharT> class __back_ref     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        unsigned __mexp_;
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     explicit __back_ref(unsigned __mexp, __node<_CharT>* __s)         : base(__s), __mexp_(__mexp) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __back_ref<_CharT>::__exec(__state& __s) const {
       if (__mexp_ > __s.__sub_matches_.size())         __throw_regex_error<regex_constants::error_backref>();
       sub_match<const _CharT*>& __sm = __s.__sub_matches_[__mexp_-1];
       if (__sm.matched)     {
           ptrdiff_t __len = __sm.second - __sm.first;
           if (__s.__last_ - __s.__current_ >= __len &&             _VSTD::equal(__sm.first, __sm.second, __s.__current_))         {
               __s.__do_ = __state::__accept_but_not_consume;
               __s.__current_ += __len;
               __s.__node_ = this->first();
           }
           else         {
               __s.__do_ = __state::__reject;
               __s.__node_ = nullptr;
           }
       }
       else     {
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __back_ref_icase
 template <class _CharT, class _Traits> class __back_ref_icase     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        _Traits __traits_;
       unsigned __mexp_;
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     explicit __back_ref_icase(const _Traits& __traits, unsigned __mexp,                               __node<_CharT>* __s)         : base(__s), __traits_(__traits), __mexp_(__mexp) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT, class _Traits> void __back_ref_icase<_CharT, _Traits>::__exec(__state& __s) const {
       sub_match<const _CharT*>& __sm = __s.__sub_matches_[__mexp_-1];
       if (__sm.matched)     {
           ptrdiff_t __len = __sm.second - __sm.first;
           if (__s.__last_ - __s.__current_ >= __len)         {
           }
           else         {
               __s.__do_ = __state::__reject;
               __s.__node_ = nullptr;
           }
       }
       else     {
   __not_equal:         __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __back_ref_collate
 template <class _CharT, class _Traits> class __back_ref_collate     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        _Traits __traits_;
       unsigned __mexp_;
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     explicit __back_ref_collate(const _Traits& __traits, unsigned __mexp,                               __node<_CharT>* __s)         : base(__s), __traits_(__traits), __mexp_(__mexp) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT, class _Traits> void __back_ref_collate<_CharT, _Traits>::__exec(__state& __s) const {
       sub_match<const _CharT*>& __sm = __s.__sub_matches_[__mexp_-1];
       if (__sm.matched)     {
           ptrdiff_t __len = __sm.second - __sm.first;
           if (__s.__last_ - __s.__current_ >= __len)         {
               for (ptrdiff_t __i = 0;
   __i < __len;
   ++__i)             {
                   if (__traits_.translate(__sm.first[__i]) !=                                        __traits_.translate(__s.__current_[__i]))                     goto __not_equal;
               }
               __s.__do_ = __state::__accept_but_not_consume;
               __s.__current_ += __len;
               __s.__node_ = this->first();
           }
           else         {
               __s.__do_ = __state::__reject;
               __s.__node_ = nullptr;
           }
       }
       else     {
   __not_equal:         __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __word_boundary
 template <class _CharT, class _Traits> class __word_boundary     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        _Traits __traits_;
       bool __invert_;
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     explicit __word_boundary(const _Traits& __traits, bool __invert,                              __node<_CharT>* __s)         : base(__s), __traits_(__traits), __invert_(__invert) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT, class _Traits> void __word_boundary<_CharT, _Traits>::__exec(__state& __s) const {
       bool __is_word_b = false;
       if (__s.__first_ != __s.__last_)     {
           if (__s.__current_ == __s.__last_)         {
               if (!(__s.__flags_ & regex_constants::match_not_eow))             {
                   _CharT __c = __s.__current_[-1];
                   __is_word_b = __c == '_' ||                               __traits_.isctype(__c, ctype_base::alnum);
               }
           }
           else if (__s.__current_ == __s.__first_ &&                 !(__s.__flags_ & regex_constants::match_prev_avail))         {
               if (!(__s.__flags_ & regex_constants::match_not_bow))             {
                   _CharT __c = *__s.__current_;
                   __is_word_b = __c == '_' ||                               __traits_.isctype(__c, ctype_base::alnum);
               }
           }
       }
       if (__is_word_b != __invert_)     {
           __s.__do_ = __state::__accept_but_not_consume;
           __s.__node_ = this->first();
       }
       else     {
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __l_anchor
 template <class _CharT> class __l_anchor     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
    public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __l_anchor(__node<_CharT>* __s)         : base(__s) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __l_anchor<_CharT>::__exec(__state& __s) const {
       if (__s.__at_first_ && __s.__current_ == __s.__first_ &&         !(__s.__flags_ & regex_constants::match_not_bol))     {
           __s.__do_ = __state::__accept_but_not_consume;
           __s.__node_ = this->first();
       }
       else     {
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __r_anchor
 template <class _CharT> class __r_anchor     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
    public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __r_anchor(__node<_CharT>* __s)         : base(__s) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __r_anchor<_CharT>::__exec(__state& __s) const {
   }
    // __match_any
 template <class _CharT> class __match_any     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
    public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __match_any(__node<_CharT>* __s)         : base(__s) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __match_any<_CharT>::__exec(__state& __s) const {
       if (__s.__current_ != __s.__last_ && *__s.__current_ != 0)     {
           __s.__do_ = __state::__accept_and_consume;
           ++__s.__current_;
           __s.__node_ = this->first();
       }
       else     {
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __match_any_but_newline
 template <class _CharT> class __match_any_but_newline     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
    public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __match_any_but_newline(__node<_CharT>* __s)         : base(__s) {
  }
        virtual void __exec(__state&) const;
   };
    template <> _LIBCPP_FUNC_VIS void __match_any_but_newline<char>::__exec(__state&) const;
   template <> _LIBCPP_FUNC_VIS void __match_any_but_newline<wchar_t>::__exec(__state&) const;
    // __match_char
 template <class _CharT> class __match_char     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        _CharT __c_;
        __match_char(const __match_char&);
       __match_char& operator=(const __match_char&);
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __match_char(_CharT __c, __node<_CharT>* __s)         : base(__s), __c_(__c) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT> void __match_char<_CharT>::__exec(__state& __s) const {
       if (__s.__current_ != __s.__last_ && *__s.__current_ == __c_)     {
           __s.__do_ = __state::__accept_and_consume;
           ++__s.__current_;
           __s.__node_ = this->first();
       }
       else     {
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __match_char_icase
 template <class _CharT, class _Traits> class __match_char_icase     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        _Traits __traits_;
       _CharT __c_;
        __match_char_icase(const __match_char_icase&);
       __match_char_icase& operator=(const __match_char_icase&);
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __match_char_icase(const _Traits& __traits, _CharT __c, __node<_CharT>* __s)         : base(__s), __traits_(__traits), __c_(__traits.translate_nocase(__c)) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT, class _Traits> void __match_char_icase<_CharT, _Traits>::__exec(__state& __s) const {
       if (__s.__current_ != __s.__last_ &&         __traits_.translate_nocase(*__s.__current_) == __c_)     {
           __s.__do_ = __state::__accept_and_consume;
           ++__s.__current_;
           __s.__node_ = this->first();
       }
       else     {
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __match_char_collate
 template <class _CharT, class _Traits> class __match_char_collate     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        _Traits __traits_;
       _CharT __c_;
        __match_char_collate(const __match_char_collate&);
       __match_char_collate& operator=(const __match_char_collate&);
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __match_char_collate(const _Traits& __traits, _CharT __c, __node<_CharT>* __s)         : base(__s), __traits_(__traits), __c_(__traits.translate(__c)) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT, class _Traits> void __match_char_collate<_CharT, _Traits>::__exec(__state& __s) const {
       if (__s.__current_ != __s.__last_ &&         __traits_.translate(*__s.__current_) == __c_)     {
           __s.__do_ = __state::__accept_and_consume;
           ++__s.__current_;
           __s.__node_ = this->first();
       }
       else     {
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    // __bracket_expression
 template <class _CharT, class _Traits> class __bracket_expression     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
       typedef typename _Traits::string_type string_type;
        _Traits __traits_;
       vector<_CharT> __chars_;
       vector<_CharT> __neg_chars_;
       vector<pair<string_type, string_type> > __ranges_;
       vector<pair<_CharT, _CharT> > __digraphs_;
       vector<string_type> __equivalences_;
       typename regex_traits<_CharT>::char_class_type __mask_;
       typename regex_traits<_CharT>::char_class_type __neg_mask_;
       bool __negate_;
       bool __icase_;
       bool __collate_;
       bool __might_have_digraph_;
        __bracket_expression(const __bracket_expression&);
       __bracket_expression& operator=(const __bracket_expression&);
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __bracket_expression(const _Traits& __traits, __node<_CharT>* __s,                                  bool __negate, bool __icase, bool __collate)         : base(__s), __traits_(__traits), __mask_(), __neg_mask_(),           __negate_(__negate), __icase_(__icase), __collate_(__collate),           __might_have_digraph_(__traits_.getloc().name() != "C") {
  }
        virtual void __exec(__state&) const;
        _LIBCPP_INLINE_VISIBILITY     bool __negated() const {
  return __negate_;
  }
        _LIBCPP_INLINE_VISIBILITY     void __add_char(_CharT __c)         {
               if (__icase_)                 __chars_.push_back(__traits_.translate_nocase(__c));
               else if (__collate_)                 __chars_.push_back(__traits_.translate(__c));
               else                 __chars_.push_back(__c);
           }
       _LIBCPP_INLINE_VISIBILITY     void __add_neg_char(_CharT __c)         {
               if (__icase_)                 __neg_chars_.push_back(__traits_.translate_nocase(__c));
               else if (__collate_)                 __neg_chars_.push_back(__traits_.translate(__c));
           }
       _LIBCPP_INLINE_VISIBILITY     void __add_digraph(_CharT __c1, _CharT __c2)         {
               if (__icase_)                 __digraphs_.push_back(make_pair(__traits_.translate_nocase(__c1),                                                 __traits_.translate_nocase(__c2)));
               else if (__collate_)                 __digraphs_.push_back(make_pair(__traits_.translate(__c1),                                                 __traits_.translate(__c2)));
               else                 __digraphs_.push_back(make_pair(__c1, __c2));
           }
       _LIBCPP_INLINE_VISIBILITY     void __add_equivalence(const string_type& __s)         {
  __equivalences_.push_back(__s);
  }
       _LIBCPP_INLINE_VISIBILITY     void __add_class(typename regex_traits<_CharT>::char_class_type __mask)         {
  __mask_ |= __mask;
  }
       _LIBCPP_INLINE_VISIBILITY     void __add_neg_class(typename regex_traits<_CharT>::char_class_type __mask)         {
  __neg_mask_ |= __mask;
  }
   };
    template <class _CharT, class _Traits> void __bracket_expression<_CharT, _Traits>::__exec(__state& __s) const {
       bool __found = false;
       unsigned __consumed = 0;
       if (__s.__current_ != __s.__last_)     {
           ++__consumed;
           if (__might_have_digraph_)         {
               const _CharT* __next = _VSTD::next(__s.__current_);
               if (__next != __s.__last_)             {
                   pair<_CharT, _CharT> __ch2(*__s.__current_, *__next);
                   if (__icase_)                 {
                       __ch2.first = __traits_.translate_nocase(__ch2.first);
                       __ch2.second = __traits_.translate_nocase(__ch2.second);
                   }
                   else if (__collate_)                 {
                       __ch2.first = __traits_.translate(__ch2.first);
                       __ch2.second = __traits_.translate(__ch2.second);
                   }
                   if (!__traits_.lookup_collatename(&__ch2.first, &__ch2.first+2).empty())                 {
                       // __ch2 is a digraph in this locale
                    ++__consumed;
                       for (size_t __i = 0;
   __i < __digraphs_.size();
   ++__i)                     {
                           if (__ch2 == __digraphs_[__i])                         {
                               __found = true;
                               goto __exit;
                           }
                       }
                       if (__collate_ && !__ranges_.empty())                     {
                           string_type __s2 = __traits_.transform(&__ch2.first,                                                                &__ch2.first + 2);
                           for (size_t __i = 0;
   __i < __ranges_.size();
   ++__i)                         {
                               if (__ranges_[__i].first <= __s2 &&                                 __s2 <= __ranges_[__i].second)                             {
                                   __found = true;
                                   goto __exit;
                               }
                           }
                       }
                       if (!__equivalences_.empty())                     {
                           string_type __s2 = __traits_.transform_primary(&__ch2.first,                                                                        &__ch2.first + 2);
                           for (size_t __i = 0;
   __i < __equivalences_.size();
   ++__i)                         {
                               if (__s2 == __equivalences_[__i])                             {
                                   __found = true;
                                   goto __exit;
                               }
                           }
                       }
                       if (__traits_.isctype(__ch2.first, __mask_) &&                         __traits_.isctype(__ch2.second, __mask_))                     {
                           __found = true;
                           goto __exit;
                       }
                       if (!__traits_.isctype(__ch2.first, __neg_mask_) &&                         !__traits_.isctype(__ch2.second, __neg_mask_))                     {
                           __found = true;
                           goto __exit;
                       }
                       goto __exit;
                   }
               }
           }
           // test *__s.__current_ as not a digraph
        _CharT __ch = *__s.__current_;
           if (__icase_)             __ch = __traits_.translate_nocase(__ch);
           else if (__collate_)             __ch = __traits_.translate(__ch);
           for (size_t __i = 0;
   __i < __chars_.size();
   ++__i)         {
               if (__ch == __chars_[__i])             {
                   __found = true;
                   goto __exit;
               }
           }
           if (!__neg_chars_.empty())         {
               for (size_t __i = 0;
   __i < __neg_chars_.size();
   ++__i)             {
                   if (__ch == __neg_chars_[__i])                     goto __is_neg_char;
               }
               __found = true;
               goto __exit;
           }
   __is_neg_char:         if (!__ranges_.empty())         {
               string_type __s2 = __collate_ ?                                    __traits_.transform(&__ch, &__ch + 1) :                                    string_type(1, __ch);
               for (size_t __i = 0;
   __i < __ranges_.size();
   ++__i)             {
                   if (__ranges_[__i].first <= __s2 && __s2 <= __ranges_[__i].second)                 {
                       __found = true;
                       goto __exit;
                   }
               }
           }
           if (!__equivalences_.empty())         {
               string_type __s2 = __traits_.transform_primary(&__ch, &__ch + 1);
               for (size_t __i = 0;
   __i < __equivalences_.size();
   ++__i)             {
                   if (__s2 == __equivalences_[__i])                 {
                       __found = true;
                       goto __exit;
                   }
               }
           }
           if (__traits_.isctype(__ch, __mask_))         {
               __found = true;
               goto __exit;
           }
           if (__neg_mask_ && !__traits_.isctype(__ch, __neg_mask_))         {
               __found = true;
               goto __exit;
           }
       }
       else         __found = __negate_;
    // force reject
__exit:     if (__found != __negate_)     {
           __s.__do_ = __state::__accept_and_consume;
           __s.__current_ += __consumed;
           __s.__node_ = this->first();
       }
       else     {
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    template <class _CharT, class _Traits> class __lookahead;
    template <class _CharT, class _Traits = regex_traits<_CharT> > class _LIBCPP_TEMPLATE_VIS basic_regex {
   public:     // types:
    typedef _CharT                              value_type;
       typedef _Traits                             traits_type;
       typedef typename _Traits::string_type       string_type;
       typedef regex_constants::syntax_option_type flag_type;
       typedef typename _Traits::locale_type       locale_type;
    private:     _Traits   __traits_;
       flag_type __flags_;
       unsigned __marked_count_;
       unsigned __loop_count_;
       int __open_count_;
       shared_ptr<__empty_state<_CharT> > __start_;
       __owns_one_state<_CharT>* __end_;
        typedef _VSTD::__state<_CharT> __state;
       typedef _VSTD::__node<_CharT> __node;
    public:     // constants:
    static const regex_constants::syntax_option_type icase = regex_constants::icase;
       static const regex_constants::syntax_option_type nosubs = regex_constants::nosubs;
       static const regex_constants::syntax_option_type optimize = regex_constants::optimize;
       static const regex_constants::syntax_option_type collate = regex_constants::collate;
       static const regex_constants::syntax_option_type ECMAScript = regex_constants::ECMAScript;
       static const regex_constants::syntax_option_type basic = regex_constants::basic;
       static const regex_constants::syntax_option_type extended = regex_constants::extended;
       static const regex_constants::syntax_option_type awk = regex_constants::awk;
       static const regex_constants::syntax_option_type grep = regex_constants::grep;
       static const regex_constants::syntax_option_type egrep = regex_constants::egrep;
        // construct/copy/destroy:
    _LIBCPP_INLINE_VISIBILITY     basic_regex()         : __flags_(), __marked_count_(0), __loop_count_(0), __open_count_(0),           __end_(0)         {
  }
       _LIBCPP_INLINE_VISIBILITY     explicit basic_regex(const value_type* __p, flag_type __f = regex_constants::ECMAScript)         : __flags_(__f), __marked_count_(0), __loop_count_(0), __open_count_(0),           __end_(0)         {
  __parse(__p, __p + __traits_.length(__p));
  }
        template <class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <              __is_input_iterator  <_InputIterator>::value &&             !__is_forward_iterator<_InputIterator>::value,             basic_regex&         >::type         assign(_InputIterator __first, _InputIterator __last,                             flag_type __f = regex_constants::ECMAScript)         {
               basic_string<_CharT> __t(__first, __last);
               return assign(__t.begin(), __t.end(), __f);
           }
    private:     _LIBCPP_INLINE_VISIBILITY     void __member_init(flag_type __f)     {
           __flags_ = __f;
           __marked_count_ = 0;
           __loop_count_ = 0;
           __open_count_ = 0;
           __end_ = nullptr;
       }
   public:      template <class _ForwardIterator>         _LIBCPP_INLINE_VISIBILITY         typename enable_if         <             __is_forward_iterator<_ForwardIterator>::value,             basic_regex&         >::type         assign(_ForwardIterator __first, _ForwardIterator __last,                             flag_type __f = regex_constants::ECMAScript)         {
               return assign(basic_regex(__first, __last, __f));
           }
      
    _LIBCPP_INLINE_VISIBILITY     unsigned mark_count() const {
  return __marked_count_;
  }
       _LIBCPP_INLINE_VISIBILITY     flag_type flags() const {
  return __flags_;
  }
        // locale:
    _LIBCPP_INLINE_VISIBILITY     locale_type imbue(locale_type __loc)     {
           __member_init(ECMAScript);
           __start_.reset();
           return __traits_.imbue(__loc);
       }
       _LIBCPP_INLINE_VISIBILITY     locale_type getloc() const {
  return __traits_.getloc();
  }
        // swap:
    void swap(basic_regex& __r);
    private:     _LIBCPP_INLINE_VISIBILITY     unsigned __loop_count() const {
  return __loop_count_;
  }
        template <class _ForwardIterator>         _ForwardIterator         __parse(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_basic_reg_exp(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_RE_expression(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_simple_RE(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_nondupl_RE(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_one_char_or_coll_elem_RE(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_Back_open_paren(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_Back_close_paren(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_Back_open_brace(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_Back_close_brace(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_BACKREF(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_ORD_CHAR(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_QUOTED_CHAR(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_RE_dupl_symbol(_ForwardIterator __first, _ForwardIterator __last,                                __owns_one_state<_CharT>* __s,                                unsigned __mexp_begin, unsigned __mexp_end);
       template <class _ForwardIterator>         _ForwardIterator         __parse_ERE_dupl_symbol(_ForwardIterator __first, _ForwardIterator __last,                                 __owns_one_state<_CharT>* __s,                                 unsigned __mexp_begin, unsigned __mexp_end);
       template <class _ForwardIterator>         _ForwardIterator         __parse_bracket_expression(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_follow_list(_ForwardIterator __first, _ForwardIterator __last,                             __bracket_expression<_CharT, _Traits>* __ml);
       template <class _ForwardIterator>         _ForwardIterator         __parse_expression_term(_ForwardIterator __first, _ForwardIterator __last,                                 __bracket_expression<_CharT, _Traits>* __ml);
       template <class _ForwardIterator>         _ForwardIterator         __parse_equivalence_class(_ForwardIterator __first, _ForwardIterator __last,                                   __bracket_expression<_CharT, _Traits>* __ml);
       template <class _ForwardIterator>         _ForwardIterator         __parse_character_class(_ForwardIterator __first, _ForwardIterator __last,                                 __bracket_expression<_CharT, _Traits>* __ml);
       template <class _ForwardIterator>         _ForwardIterator         __parse_collating_symbol(_ForwardIterator __first, _ForwardIterator __last,                                  basic_string<_CharT>& __col_sym);
       template <class _ForwardIterator>         _ForwardIterator         __parse_DUP_COUNT(_ForwardIterator __first, _ForwardIterator __last, int& __c);
       template <class _ForwardIterator>         _ForwardIterator         __parse_extended_reg_exp(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_ERE_branch(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_ERE_expression(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_one_char_or_coll_elem_ERE(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_ORD_CHAR_ERE(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_QUOTED_CHAR_ERE(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_ecma_exp(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_alternative(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_term(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_assertion(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_atom(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_atom_escape(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_decimal_escape(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_character_class_escape(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_character_escape(_ForwardIterator __first, _ForwardIterator __last,                                  basic_string<_CharT>* __str = nullptr);
       template <class _ForwardIterator>         _ForwardIterator         __parse_pattern_character(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_grep(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_egrep(_ForwardIterator __first, _ForwardIterator __last);
       template <class _ForwardIterator>         _ForwardIterator         __parse_class_escape(_ForwardIterator __first, _ForwardIterator __last,                           basic_string<_CharT>& __str,                           __bracket_expression<_CharT, _Traits>* __ml);
       template <class _ForwardIterator>         _ForwardIterator         __parse_awk_escape(_ForwardIterator __first, _ForwardIterator __last,                           basic_string<_CharT>* __str = nullptr);
        _LIBCPP_INLINE_VISIBILITY     void __push_l_anchor();
       void __push_r_anchor();
       void __push_match_any();
       void __push_match_any_but_newline();
       _LIBCPP_INLINE_VISIBILITY     void __push_greedy_inf_repeat(size_t __min, __owns_one_state<_CharT>* __s,                                   unsigned __mexp_begin = 0, unsigned __mexp_end = 0)         {
  __push_loop(__min, numeric_limits<size_t>::max(), __s,                      __mexp_begin, __mexp_end);
  }
       _LIBCPP_INLINE_VISIBILITY     void __push_nongreedy_inf_repeat(size_t __min, __owns_one_state<_CharT>* __s,                                   unsigned __mexp_begin = 0, unsigned __mexp_end = 0)         {
  __push_loop(__min, numeric_limits<size_t>::max(), __s,                      __mexp_begin, __mexp_end, false);
  }
       void __push_loop(size_t __min, size_t __max, __owns_one_state<_CharT>* __s,                      size_t __mexp_begin = 0, size_t __mexp_end = 0,                      bool __greedy = true);
       __bracket_expression<_CharT, _Traits>* __start_matching_list(bool __negate);
       void __push_char(value_type __c);
       void __push_back_ref(int __i);
       void __push_alternation(__owns_one_state<_CharT>* __sa,                             __owns_one_state<_CharT>* __sb);
       void __push_begin_marked_subexpression();
       void __push_end_marked_subexpression(unsigned);
       void __push_empty();
       void __push_word_boundary(bool);
       void __push_lookahead(const basic_regex&, bool, unsigned);
        template <class _Allocator>         bool         __search(const _CharT* __first, const _CharT* __last,                  match_results<const _CharT*, _Allocator>& __m,                  regex_constants::match_flag_type __flags) const;
        template <class _Allocator>         bool         __match_at_start(const _CharT* __first, const _CharT* __last,                  match_results<const _CharT*, _Allocator>& __m,                  regex_constants::match_flag_type __flags, bool) const;
       template <class _Allocator>         bool         __match_at_start_ecma(const _CharT* __first, const _CharT* __last,                  match_results<const _CharT*, _Allocator>& __m,                  regex_constants::match_flag_type __flags, bool) const;
       template <class _Allocator>         bool         __match_at_start_posix_nosubs(const _CharT* __first, const _CharT* __last,                  match_results<const _CharT*, _Allocator>& __m,                  regex_constants::match_flag_type __flags, bool) const;
       template <class _Allocator>         bool         __match_at_start_posix_subs(const _CharT* __first, const _CharT* __last,                  match_results<const _CharT*, _Allocator>& __m,                  regex_constants::match_flag_type __flags, bool) const;
        template <class _Bp, class _Ap, class _Cp, class _Tp>     friend     bool     regex_search(_Bp, _Bp, match_results<_Bp, _Ap>&, const basic_regex<_Cp, _Tp>&,                  regex_constants::match_flag_type);
        template <class _Ap, class _Cp, class _Tp>     friend     bool     regex_search(const _Cp*, const _Cp*, match_results<const _Cp*, _Ap>&,                  const basic_regex<_Cp, _Tp>&, regex_constants::match_flag_type);
        template <class _Bp, class _Cp, class _Tp>     friend     bool     regex_search(_Bp, _Bp, const basic_regex<_Cp, _Tp>&,                  regex_constants::match_flag_type);
        template <class _Cp, class _Tp>     friend     bool     regex_search(const _Cp*, const _Cp*,                  const basic_regex<_Cp, _Tp>&, regex_constants::match_flag_type);
        template <class _Cp, class _Ap, class _Tp>     friend     bool     regex_search(const _Cp*, match_results<const _Cp*, _Ap>&, const basic_regex<_Cp, _Tp>&,                  regex_constants::match_flag_type);
        template <class _ST, class _SA, class _Cp, class _Tp>     friend     bool     regex_search(const basic_string<_Cp, _ST, _SA>& __s,                  const basic_regex<_Cp, _Tp>& __e,                  regex_constants::match_flag_type __flags);
        template <class _ST, class _SA, class _Ap, class _Cp, class _Tp>     friend     bool     regex_search(const basic_string<_Cp, _ST, _SA>& __s,                  match_results<typename basic_string<_Cp, _ST, _SA>::const_iterator, _Ap>&,                  const basic_regex<_Cp, _Tp>& __e,                  regex_constants::match_flag_type __flags);
        template <class _Iter, class _Ap, class _Cp, class _Tp>     friend     bool     regex_search(__wrap_iter<_Iter> __first,                  __wrap_iter<_Iter> __last,                  match_results<__wrap_iter<_Iter>, _Ap>& __m,                  const basic_regex<_Cp, _Tp>& __e,                  regex_constants::match_flag_type __flags);
        template <class, class> friend class __lookahead;
   };
    template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::icase;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::nosubs;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::optimize;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::collate;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::ECMAScript;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::basic;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::extended;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::awk;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::grep;
   template <class _CharT, class _Traits>     const regex_constants::syntax_option_type basic_regex<_CharT, _Traits>::egrep;
    template <class _CharT, class _Traits> void basic_regex<_CharT, _Traits>::swap(basic_regex& __r) {
   }
    template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY void swap(basic_regex<_CharT, _Traits>& __x, basic_regex<_CharT, _Traits>& __y) {
       return __x.swap(__y);
   }
    // __lookahead
 template <class _CharT, class _Traits> class __lookahead     : public __owns_one_state<_CharT> {
       typedef __owns_one_state<_CharT> base;
        basic_regex<_CharT, _Traits> __exp_;
       unsigned __mexp_;
       bool __invert_;
        __lookahead(const __lookahead&);
       __lookahead& operator=(const __lookahead&);
   public:     typedef _VSTD::__state<_CharT> __state;
        _LIBCPP_INLINE_VISIBILITY     __lookahead(const basic_regex<_CharT, _Traits>& __exp, bool __invert, __node<_CharT>* __s, unsigned __mexp)         : base(__s), __exp_(__exp), __mexp_(__mexp), __invert_(__invert) {
  }
        virtual void __exec(__state&) const;
   };
    template <class _CharT, class _Traits> void __lookahead<_CharT, _Traits>::__exec(__state& __s) const {
       match_results<const _CharT*> __m;
       __m.__init(1 + __exp_.mark_count(), __s.__current_, __s.__last_);
       bool __matched = __exp_.__match_at_start_ecma(         __s.__current_, __s.__last_,         __m,         (__s.__flags_ | regex_constants::match_continuous) &         ~regex_constants::__full_match,         __s.__at_first_ && __s.__current_ == __s.__first_);
       if (__matched != __invert_)     {
           __s.__do_ = __state::__accept_but_not_consume;
           __s.__do_ = __state::__reject;
           __s.__node_ = nullptr;
       }
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse(_ForwardIterator __first,                                       _ForwardIterator __last) {
       {
           unique_ptr<__node> __h(new __end_state<_CharT>);
           __start_.reset(new __empty_state<_CharT>(__h.get()));
           __h.release();
           __end_ = __start_.get();
       }
       switch (__flags_ & 0x1F0)     {
       case ECMAScript:         __first = __parse_ecma_exp(__first, __last);
           break;
       case basic:         __first = __parse_basic_reg_exp(__first, __last);
       default:         __throw_regex_error<regex_constants::__re_err_grammar>();
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_basic_reg_exp(_ForwardIterator __first,                                                     _ForwardIterator __last) {
       if (__first != __last)     {
           if (*__first == '^')         {
               __push_l_anchor();
               ++__first;
           }
           if (__first != __last)         {
               __first = __parse_RE_expression(__first, __last);
               if (__first != __last)             {
                   _ForwardIterator __temp = _VSTD::next(__first);
                   if (__temp == __last && *__first == '$')                 {
                       __push_r_anchor();
                       ++__first;
                   }
               }
           }
           if (__first != __last)             __throw_regex_error<regex_constants::__re_err_empty>();
       }
       return __first;
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_ERE_expression(_ForwardIterator __first,                                                      _ForwardIterator __last) {
       __owns_one_state<_CharT>* __e = __end_;
       unsigned __mexp_begin = __marked_count_;
       _ForwardIterator __temp = __parse_one_char_or_coll_elem_ERE(__first, __last);
       if (__temp == __first && __temp != __last)     {
           switch (*__temp)         {
               if (*__first == '\\' && *__temp == ')')                 __first = ++__temp;
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_Back_open_brace(_ForwardIterator __first,                                                       _ForwardIterator __last) {
       if (__first != __last)     {
           _ForwardIterator __temp = _VSTD::next(__first);
           if (__temp != __last)         {
               if (*__first == '\\' && *__temp == '{')                 __first = ++__temp;
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_Back_close_brace(_ForwardIterator __first,                                                        _ForwardIterator __last) {
       if (__first != __last)     {
           _ForwardIterator __temp = _VSTD::next(__first);
           if (__temp != __last)         {
               if (*__first == '\\' && *__temp == '}')                 __first = ++__temp;
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_BACKREF(_ForwardIterator __first,                                               _ForwardIterator __last) {
       if (__first != __last)     {
           _ForwardIterator __temp = _VSTD::next(__first);
           if (__temp != __last)         {
               if (*__first == '\\')             {
                    int __val = __traits_.value(*__temp, 10);
                   if (__val >= 1 && __val <= 9)                 {
                       __push_back_ref(__val);
                       __first = ++__temp;
                   }
               }
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_ORD_CHAR(_ForwardIterator __first,                                                _ForwardIterator __last) {
       if (__first != __last)     {
           _ForwardIterator __temp = _VSTD::next(__first);
           if (__temp == __last && *__first == '$')             return __first;
           // Not called inside a bracket
        if (*__first == '.' || *__first == '\\' || *__first == '[')             return __first;
           __push_char(*__first);
           ++__first;
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_ORD_CHAR_ERE(_ForwardIterator __first,                                                    _ForwardIterator __last) {
       if (__first != __last)     {
           switch (*__first)         {
           case '^':         case '.':         case '[':         case '$':         case '(':         case '|':         case '*':         case '+':         case '?':         case '{':         case '\\':             break;
           case ')':             if (__open_count_ == 0)             {
                   __push_char(*__first);
                   ++__first;
               }
               break;
           default:             __push_char(*__first);
               ++__first;
               break;
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_QUOTED_CHAR(_ForwardIterator __first,                                                   _ForwardIterator __last) {
       if (__first != __last)     {
           _ForwardIterator __temp = _VSTD::next(__first);
           if (__temp != __last)         {
               if (*__first == '\\')             {
               }
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_RE_dupl_symbol(_ForwardIterator __first,                                                      _ForwardIterator __last,                                                      __owns_one_state<_CharT>* __s,                                                      unsigned __mexp_begin,                                                      unsigned __mexp_end) {
       if (__first != __last)     {
           if (*__first == '*')         {
               __push_greedy_inf_repeat(0, __s, __mexp_begin, __mexp_end);
               ++__first;
           }
           else         {
               _ForwardIterator __temp = __parse_Back_open_brace(__first, __last);
               if (__temp != __first)             {
                   int __min = 0;
                   __first = __temp;
                   __temp = __parse_DUP_COUNT(__first, __last, __min);
                   if (__temp == __first)                     __throw_regex_error<regex_constants::error_badbrace>();
                   __first = __temp;
                   if (__first == __last)                     __throw_regex_error<regex_constants::error_brace>();
                   if (*__first != ',')                 {
                       __temp = __parse_Back_close_brace(__first, __last);
                       if (__temp == __first)                         __throw_regex_error<regex_constants::error_brace>();
                   }
               }
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_ERE_dupl_symbol(_ForwardIterator __first,                                                       _ForwardIterator __last,                                                       __owns_one_state<_CharT>* __s,                                                       unsigned __mexp_begin,                                                       unsigned __mexp_end) {
       if (__first != __last)     {
           unsigned __grammar = __flags_ & 0x1F0;
           switch (*__first)         {
           case '*':             ++__first;
               if (__grammar == ECMAScript && __first != __last && *__first == '?')             {
                   ++__first;
                   __push_nongreedy_inf_repeat(0, __s, __mexp_begin, __mexp_end);
               }
               break;
           case '{':             {
                   int __min;
                   _ForwardIterator __temp = __parse_DUP_COUNT(++__first, __last, __min);
                   if (__temp == __first)                     __throw_regex_error<regex_constants::error_badbrace>();
                   __first = __temp;
                   if (__first == __last)                     __throw_regex_error<regex_constants::error_brace>();
                   switch (*__first)                 {
                   case '}':                     ++__first;
                       if (__grammar == ECMAScript && __first != __last && *__first == '?')                     {
                           ++__first;
                           __push_loop(__min, __min, __s, __mexp_begin, __mexp_end, false);
                       }
                       else                         __push_loop(__min, __min, __s, __mexp_begin, __mexp_end);
                       break;
                   case ',':                     ++__first;
                       if (__first == __last)                         __throw_regex_error<regex_constants::error_badbrace>();
                       if (*__first == '}')                     {
                           ++__first;
                           if (__grammar == ECMAScript && __first != __last && *__first == '?')                         {
                               ++__first;
                               __push_nongreedy_inf_repeat(__min, __s, __mexp_begin, __mexp_end);
                           }
                       }
                       break;
                   default:                     __throw_regex_error<regex_constants::error_badbrace>();
                   }
               }
               break;
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_bracket_expression(_ForwardIterator __first,                                                          _ForwardIterator __last) {
       if (__first != __last && *__first == '[')     {
           ++__first;
           if (__first == __last)             __throw_regex_error<regex_constants::error_brack>();
           bool __negate = false;
           if (*__first == '^')         {
               ++__first;
               __negate = true;
           }
           __bracket_expression<_CharT, _Traits>* __ml = __start_matching_list(__negate);
           // __ml owned by *this
        if (__first == __last)             __throw_regex_error<regex_constants::error_brack>();
           if ((__flags_ & 0x1F0) != ECMAScript && *__first == ']')         {
               ++__first;
           }
           if (__first == __last || *__first != ']')             __throw_regex_error<regex_constants::error_brack>();
           ++__first;
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_follow_list(_ForwardIterator __first,                                     _ForwardIterator __last,                                     __bracket_expression<_CharT, _Traits>* __ml) {
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_expression_term(_ForwardIterator __first,                                     _ForwardIterator __last,                                     __bracket_expression<_CharT, _Traits>* __ml) {
       if (__first != __last && *__first != ']')     {
           _ForwardIterator __temp = _VSTD::next(__first);
           basic_string<_CharT> __start_range;
           if (__temp != __last && *__first == '[')         {
               if (*__temp == '=')                 return __parse_equivalence_class(++__temp, __last, __ml);
               else if (*__temp == ':')                 return __parse_character_class(++__temp, __last, __ml);
               else if (*__temp == '.')                 __first = __parse_collating_symbol(++__temp, __last, __start_range);
           }
           unsigned __grammar = __flags_ & 0x1F0;
           if (__start_range.empty())         {
               if ((__grammar == ECMAScript || __grammar == awk) && *__first == '\\')             {
                   if (__grammar == ECMAScript)                     __first = __parse_class_escape(++__first, __last, __start_range, __ml);
                   else                     __first = __parse_awk_escape(++__first, __last, &__start_range);
               }
               else             {
                   __start_range = *__first;
                   ++__first;
               }
           }
           if (__first != __last && *__first != ']')         {
               __temp = _VSTD::next(__first);
               if (__temp != __last && *__first == '-' && *__temp != ']')             {
                   // parse a range
                basic_string<_CharT> __end_range;
                   __first = __temp;
                   ++__temp;
                   if (__temp != __last && *__first == '[' && *__temp == '.')                     __first = __parse_collating_symbol(++__temp, __last, __end_range);
                   else                 {
                       if ((__grammar == ECMAScript || __grammar == awk) && *__first == '\\')                     {
                           if (__grammar == ECMAScript)                             __first = __parse_class_escape(++__first, __last,                                                            __end_range, __ml);
                           else                             __first = __parse_awk_escape(++__first, __last,                                                          &__end_range);
                       }
                       else                     {
                           __end_range = *__first;
                           ++__first;
                       }
                   }
                   __ml->__add_range(_VSTD::move(__start_range), _VSTD::move(__end_range));
               }
               else if (!__start_range.empty())             {
                   if (__start_range.size() == 1)                     __ml->__add_char(__start_range[0]);
                   else                     __ml->__add_digraph(__start_range[0], __start_range[1]);
               }
           }
           else if (!__start_range.empty())         {
               if (__start_range.size() == 1)                 __ml->__add_char(__start_range[0]);
               else                 __ml->__add_digraph(__start_range[0], __start_range[1]);
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_class_escape(_ForwardIterator __first,                           _ForwardIterator __last,                           basic_string<_CharT>& __str,                           __bracket_expression<_CharT, _Traits>* __ml) {
       if (__first == __last)         __throw_regex_error<regex_constants::error_escape>();
       switch (*__first)     {
       case 0:         __str = *__first;
           return ++__first;
       case 'b':         __str = _CharT(8);
           return ++__first;
       case 'd':         __ml->__add_class(ctype_base::digit);
           return ++__first;
           return ++__first;
       case 'W':         __ml->__add_neg_class(ctype_base::alnum);
           __ml->__add_neg_char('_');
           return ++__first;
       }
       __first = __parse_character_escape(__first, __last, &__str);
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_awk_escape(_ForwardIterator __first,                           _ForwardIterator __last,                           basic_string<_CharT>* __str) {
       if (__first == __last)         __throw_regex_error<regex_constants::error_escape>();
       switch (*__first)     {
       case '\\':     case '"':     case '/':         if (__str)             *__str = *__first;
           else             __push_char(*__first);
           return ++__first;
       case 'a':         if (__str)             *__str = _CharT(7);
           else             __push_char(_CharT(0x9));
           return ++__first;
       case 'v':         if (__str)             *__str = _CharT(0xB);
           else             __push_char(_CharT(0xB));
           return ++__first;
       }
       if ('0' <= *__first && *__first <= '7')     {
           unsigned __val = *__first - '0';
           if (++__first != __last && ('0' <= *__first && *__first <= '7'))         {
               __val = 8 * __val + *__first - '0';
               if (++__first != __last && ('0' <= *__first && *__first <= '7'))                 __val = 8 * __val + *__first++ - '0';
           }
           if (__str)             *__str = _CharT(__val);
           else             __push_char(_CharT(__val));
       }
       else         __throw_regex_error<regex_constants::error_escape>();
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_equivalence_class(_ForwardIterator __first,                                     _ForwardIterator __last,                                     __bracket_expression<_CharT, _Traits>* __ml) {
       // Found [=
    //   This means =] must exist
    value_type _Equal_close[2] = {
  '=', ']'};
       _ForwardIterator __temp = _VSTD::search(__first, __last, _Equal_close,                                                             _Equal_close+2);
       if (__temp == __last)         __throw_regex_error<regex_constants::error_brack>();
       // [__first, __temp) contains all text in [= ... =]
    string_type __collate_name =         __traits_.lookup_collatename(__first, __temp);
       if (__collate_name.empty())         __throw_regex_error<regex_constants::error_collate>();
       string_type __equiv_name =         __traits_.transform_primary(__collate_name.begin(),                                     __collate_name.end());
       if (!__equiv_name.empty())         __ml->__add_equivalence(__equiv_name);
       else     {
       }
       __first = _VSTD::next(__temp, 2);
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_character_class(_ForwardIterator __first,                                     _ForwardIterator __last,                                     __bracket_expression<_CharT, _Traits>* __ml) {
       // Found [:
    //   This means :] must exist
    value_type _Colon_close[2] = {
  ':', ']'};
       _ForwardIterator __temp = _VSTD::search(__first, __last, _Colon_close,                                                             _Colon_close+2);
       if (__temp == __last)         __throw_regex_error<regex_constants::error_brack>();
       // [__first, __temp) contains all text in [: ... :]
    typedef typename _Traits::char_class_type char_class_type;
       char_class_type __class_type =         __traits_.lookup_classname(__first, __temp, __flags_ & icase);
       if (__class_type == 0)         __throw_regex_error<regex_constants::error_brack>();
       __ml->__add_class(__class_type);
       __first = _VSTD::next(__temp, 2);
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_collating_symbol(_ForwardIterator __first,                                                 _ForwardIterator __last,                                                 basic_string<_CharT>& __col_sym) {
       // Found [.
    //   This means .] must exist
    value_type _Dot_close[2] = {
  '.', ']'};
       _ForwardIterator __temp = _VSTD::search(__first, __last, _Dot_close,                                                             _Dot_close+2);
       if (__temp == __last)         __throw_regex_error<regex_constants::error_brack>();
       // [__first, __temp) contains all text in [. ... .]
    __col_sym = __traits_.lookup_collatename(__first, __temp);
       switch (__col_sym.size())     {
       case 1:     case 2:         break;
       default:         __throw_regex_error<regex_constants::error_collate>();
       }
       __first = _VSTD::next(__temp, 2);
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_DUP_COUNT(_ForwardIterator __first,                                                 _ForwardIterator __last,                                                 int& __c) {
       if (__first != __last )     {
           int __val = __traits_.value(*__first, 10);
           if ( __val != -1 )         {
               __c = __val;
               for (++__first;
                     __first != __last && ( __val = __traits_.value(*__first, 10)) != -1;
                    ++__first)             {
                   __c *= 10;
                   __c += __val;
               }
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_ecma_exp(_ForwardIterator __first,                                                _ForwardIterator __last) {
       __owns_one_state<_CharT>* __sa = __end_;
       _ForwardIterator __temp = __parse_alternative(__first, __last);
       if (__temp == __first)         __push_empty();
       if (__first != __last)     {
           switch (*__first)         {
           case '^':             __push_l_anchor();
               ++__first;
               break;
           case '$':             __push_r_anchor();
               ++__first;
               break;
           case '\\':             {
                   _ForwardIterator __temp = _VSTD::next(__first);
                   if (__temp != __last)                 {
                       if (*__temp == 'b')                     {
                           __push_word_boundary(false);
                           __first = ++__temp;
                       }
                       else if (*__temp == 'B')                     {
                           __push_word_boundary(true);
                           __first = ++__temp;
                       }
                   }
               }
               break;
           case '(':             {
                   _ForwardIterator __temp = _VSTD::next(__first);
                   if (__temp != __last && *__temp == '?')                 {
                       if (++__temp != __last)                     {
                           switch (*__temp)                         {
                           case '=':                             {
                                   basic_regex __exp;
                                   __exp.__flags_ = __flags_;
                                   __temp = __exp.__parse(++__temp, __last);
                                   __first = ++__temp;
                               }
                               break;
                           }
                       }
                   }
               }
               break;
               unsigned __v = *__first - '0';
               for (++__first;
                       __first != __last && '0' <= *__first && *__first <= '9';
   ++__first)                 __v = 10 * __v + *__first - '0';
               if (__v > mark_count())                 __throw_regex_error<regex_constants::error_backref>();
               __push_back_ref(__v);
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_character_class_escape(_ForwardIterator __first,                                                              _ForwardIterator __last) {
       if (__first != __last)     {
           __bracket_expression<_CharT, _Traits>* __ml;
           switch (*__first)         {
           case 'd':             __ml = __start_matching_list(false);
               ++__first;
               break;
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_character_escape(_ForwardIterator __first,                                                     _ForwardIterator __last,                                                     basic_string<_CharT>* __str) {
       if (__first != __last)     {
           _ForwardIterator __t;
           unsigned __sum = 0;
           int __hd;
           switch (*__first)         {
           case 'f':             if (__str)                 *__str = _CharT(0xC);
               else                 __push_char(_CharT(0xC));
               ++__first;
               ++__first;
               break;
           default:             if (*__first != '_' && !__traits_.isctype(*__first, ctype_base::alnum))             {
                   if (__str)                     *__str = *__first;
                   else                     __push_char(*__first);
                   ++__first;
               }
               else                 __throw_regex_error<regex_constants::error_escape>();
               break;
           }
       }
       return __first;
   }
    template <class _CharT, class _Traits> template <class _ForwardIterator> _ForwardIterator basic_regex<_CharT, _Traits>::__parse_pattern_character(_ForwardIterator __first,                                                         _ForwardIterator __last) {
       if (__first != __last)     {
           switch (*__first)         {
           case '^':         case '$':         case '\\':         case '.':         case '*':         case '+':         case '?':         case '(':         case ')':         case '[':         case ']':         case '{':         case '}':         case '|':             break;
           default:             __push_char(*__first);
               ++__first;
               break;
           }
       }
   }
    // regex_search
 template <class _CharT, class _Traits> template <class _Allocator> bool basic_regex<_CharT, _Traits>::__match_at_start_ecma(         const _CharT* __first, const _CharT* __last,         match_results<const _CharT*, _Allocator>& __m,         regex_constants::match_flag_type __flags, bool __at_first) const {
       vector<__state> __states;
       __node* __st = __start_.get();
       if (__st)     {
           sub_match<const _CharT*> __unmatched;
           __states.back().__sub_matches_.resize(mark_count(), __unmatched);
           __states.back().__loop_data_.resize(__loop_count());
           __states.back().__node_ = __st;
           __states.back().__flags_ = __flags;
           __states.back().__at_first_ = __at_first;
           do         {
               __state& __s = __states.back();
               if (__s.__node_)                 __s.__node_->__exec(__s);
               switch (__s.__do_)             {
               case __state::__end_state:                 if ((__flags & regex_constants::match_not_null) &&                     __s.__current_ == __first)                 {
                     __states.pop_back();
                     break;
                   }
                   if ((__flags & regex_constants::__full_match) &&                     __s.__current_ != __last)                 {
                     __states.pop_back();
                     break;
                   }
                   __m.__matches_[0].first = __first;
                   __m.__matches_[0].second = _VSTD::next(__first, __s.__current_ - __first);
                   __m.__matches_[0].matched = true;
                   for (unsigned __i = 0;
   __i < __s.__sub_matches_.size();
   ++__i)                     __m.__matches_[__i+1] = __s.__sub_matches_[__i];
                   break;
               case __state::__reject:                 __states.pop_back();
                   break;
               default:                 __throw_regex_error<regex_constants::__re_err_unknown>();
                   break;
                }
           }
   while (!__states.empty());
       }
       return false;
   }
    template <class _CharT, class _Traits> template <class _Allocator> bool basic_regex<_CharT, _Traits>::__match_at_start_posix_nosubs(         const _CharT* __first, const _CharT* __last,         match_results<const _CharT*, _Allocator>& __m,         regex_constants::match_flag_type __flags, bool __at_first) const {
       deque<__state> __states;
       ptrdiff_t __highest_j = 0;
       ptrdiff_t _Np = _VSTD::distance(__first, __last);
       __node* __st = __start_.get();
       if (__st)     {
           __states.push_back(__state());
           __states.back().__do_ = 0;
           __states.back().__first_ = __first;
           __states.back().__current_ = __first;
           __states.back().__last_ = __last;
           __states.back().__loop_data_.resize(__loop_count());
           __states.back().__node_ = __st;
           __states.back().__flags_ = __flags;
           __states.back().__at_first_ = __at_first;
           bool __matched = false;
           do         {
               __state& __s = __states.back();
               if (__s.__node_)                 __s.__node_->__exec(__s);
           }
   while (!__states.empty());
           if (__matched)         {
               __m.__matches_[0].first = __first;
               __m.__matches_[0].second = _VSTD::next(__first, __highest_j);
               __m.__matches_[0].matched = true;
               return true;
           }
       }
       return false;
   }
    template <class _CharT, class _Traits> template <class _Allocator> bool basic_regex<_CharT, _Traits>::__match_at_start_posix_subs(         const _CharT* __first, const _CharT* __last,         match_results<const _CharT*, _Allocator>& __m,         regex_constants::match_flag_type __flags, bool __at_first) const {
       vector<__state> __states;
       __state __best_state;
       ptrdiff_t __j = 0;
       ptrdiff_t __highest_j = 0;
       ptrdiff_t _Np = _VSTD::distance(__first, __last);
       __node* __st = __start_.get();
       if (__st)     {
           sub_match<const _CharT*> __unmatched;
           __unmatched.first   = __last;
           __unmatched.second  = __last;
           __states.back().__node_ = __st;
           __states.back().__flags_ = __flags;
           __states.back().__at_first_ = __at_first;
           const _CharT* __current = __first;
           bool __matched = false;
           do         {
               __state& __s = __states.back();
               if (__s.__node_)                 __s.__node_->__exec(__s);
               switch (__s.__do_)             {
               case __state::__end_state:                 if ((__flags & regex_constants::match_not_null) &&                     __s.__current_ == __first)                 {
                     __states.pop_back();
                     break;
                   }
                   if ((__flags & regex_constants::__full_match) &&                     __s.__current_ != __last)                 {
                     __states.pop_back();
                     break;
                   }
                   if (!__matched || __highest_j < __s.__current_ - __s.__first_)                 {
                       __highest_j = __s.__current_ - __s.__first_;
                       __best_state = __s;
                   }
                   __matched = true;
                   if (__highest_j == _Np)                     __states.clear();
                   else                     __states.pop_back();
                   break;
               case __state::__accept_and_consume:                 __j += __s.__current_ - __current;
                   __current = __s.__current_;
                   break;
               case __state::__repeat:             case __state::__accept_but_not_consume:                 break;
               case __state::__split:                 {
                   __state __snext = __s;
                   __s.__node_->__exec_split(true, __s);
                   __snext.__node_->__exec_split(false, __snext);
                   __states.push_back(_VSTD::move(__snext));
                   }
                   break;
               case __state::__reject:                 __states.pop_back();
                   break;
               default:                 __throw_regex_error<regex_constants::__re_err_unknown>();
                   break;
               }
           }
   while (!__states.empty());
           if (__matched)         {
               __m.__matches_[0].first = __first;
               __m.__matches_[0].second = _VSTD::next(__first, __highest_j);
               __m.__matches_[0].matched = true;
               for (unsigned __i = 0;
   __i < __best_state.__sub_matches_.size();
   ++__i)                 __m.__matches_[__i+1] = __best_state.__sub_matches_[__i];
               return true;
           }
       }
       return false;
       if (__first != __last && !(__flags & regex_constants::match_continuous))     {
           __flags |= regex_constants::match_prev_avail;
           for (++__first;
   __first != __last;
   ++__first)         {
               __m.__matches_.assign(__m.size(), __m.__unmatched_);
               if (__match_at_start(__first, __last, __m, __flags, false))             {
                   __m.__prefix_.second = __m[0].first;
                   __m.__prefix_.matched = __m.__prefix_.first != __m.__prefix_.second;
                   __m.__suffix_.first = __m[0].second;
                   __m.__suffix_.matched = __m.__suffix_.first != __m.__suffix_.second;
                   return true;
               }
               __m.__matches_.assign(__m.size(), __m.__unmatched_);
           }
       }
       __m.__matches_.clear();
       return false;
   }
    template <class _BidirectionalIterator, class _Allocator, class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY bool regex_search(_BidirectionalIterator __first, _BidirectionalIterator __last,              match_results<_BidirectionalIterator, _Allocator>& __m,              const basic_regex<_CharT, _Traits>& __e,              regex_constants::match_flag_type __flags = regex_constants::match_default) {
       int __offset = (__flags & regex_constants::match_prev_avail) ? 1 : 0;
       basic_string<_CharT> __s(_VSTD::prev(__first, __offset), __last);
       match_results<const _CharT*> __mc;
       bool __r = __e.__search(__s.data() + __offset, __s.data() + __s.size(), __mc, __flags);
   }
      
#if _LIBCPP_STD_VER > 11
template <class _ST, class _SA, class _Allocator, class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY bool regex_match(const basic_string<_CharT, _ST, _SA>&& __s,             match_results<typename basic_string<_CharT, _ST, _SA>::const_iterator, _Allocator>& __m,             const basic_regex<_CharT, _Traits>& __e,             regex_constants::match_flag_type __flags = regex_constants::match_default) = delete;
      
#endif
 template <class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY bool regex_match(const _CharT* __str, const basic_regex<_CharT, _Traits>& __e,             regex_constants::match_flag_type __flags = regex_constants::match_default) {
       return _VSTD::regex_match(__str, __str + _Traits::length(__str), __e, __flags);
   }
    template <class _ST, class _SA, class _CharT, class _Traits> inline _LIBCPP_INLINE_VISIBILITY bool regex_match(const basic_string<_CharT, _ST, _SA>& __s,             const basic_regex<_CharT, _Traits>& __e,             regex_constants::match_flag_type __flags = regex_constants::match_default) {
       return _VSTD::regex_match(__s.begin(), __s.end(), __e, __flags);
   }
    // regex_iterator
 template <class _BidirectionalIterator,           class _CharT = typename iterator_traits<_BidirectionalIterator>::value_type,           class _Traits = regex_traits<_CharT> > class _LIBCPP_TEMPLATE_VIS regex_iterator {
   public:     typedef basic_regex<_CharT, _Traits>          regex_type;
       typedef match_results<_BidirectionalIterator> value_type;
       typedef ptrdiff_t                             difference_type;
       typedef const value_type*                     pointer;
       typedef const value_type&                     reference;
       typedef forward_iterator_tag                  iterator_category;
    private:     _BidirectionalIterator           __begin_;
       _BidirectionalIterator           __end_;
       const regex_type*                __pregex_;
       regex_constants::match_flag_type __flags_;
       value_type                       __match_;
    public:     regex_iterator();
       regex_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                    const regex_type& __re,                    regex_constants::match_flag_type __m                                               = regex_constants::match_default);
     
#if _LIBCPP_STD_VER > 11
    regex_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                    const regex_type&& __re,                    regex_constants::match_flag_type __m                                       = regex_constants::match_default) = delete;
     
#endif
     bool operator==(const regex_iterator& __x) const;
       _LIBCPP_INLINE_VISIBILITY     bool operator!=(const regex_iterator& __x) const {
  return !(*this == __x);
  }
        _LIBCPP_INLINE_VISIBILITY     reference operator*() const {
  return  __match_;
  }
       _LIBCPP_INLINE_VISIBILITY     pointer operator->() const  {
  return &__match_;
  }
        regex_iterator& operator++();
       _LIBCPP_INLINE_VISIBILITY     regex_iterator operator++(int)     {
           regex_iterator __t(*this);
           ++(*this);
           return __t;
       }
   };
    template <class _BidirectionalIterator, class _CharT, class _Traits> regex_iterator<_BidirectionalIterator, _CharT, _Traits>::regex_iterator()     : __begin_(), __end_(), __pregex_(nullptr), __flags_(), __match_() {
   }
    template <class _BidirectionalIterator, class _CharT, class _Traits> regex_iterator<_BidirectionalIterator, _CharT, _Traits>::     regex_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                    const regex_type& __re, regex_constants::match_flag_type __m)     : __begin_(__a),       __end_(__b),       __pregex_(&__re),       __flags_(__m) {
       _VSTD::regex_search(__begin_, __end_, __match_, *__pregex_, __flags_);
       _BidirectionalIterator __start = __match_[0].second;
       if (__match_[0].first == __match_[0].second)     {
           if (__start == __end_)         {
               __match_ = value_type();
               return *this;
           }
           else if (_VSTD::regex_search(__start, __end_, __match_, *__pregex_,                                     __flags_ | regex_constants::match_not_null |                                     regex_constants::match_continuous))             return *this;
           else             ++__start;
       }
       __flags_ |= regex_constants::match_prev_avail;
       if (!_VSTD::regex_search(__start, __end_, __match_, *__pregex_, __flags_))         __match_ = value_type();
       return *this;
   }
    typedef regex_iterator<const char*>             cregex_iterator;
   typedef regex_iterator<const wchar_t*>          wcregex_iterator;
   typedef regex_iterator<string::const_iterator>  sregex_iterator;
   typedef regex_iterator<wstring::const_iterator> wsregex_iterator;
    // regex_token_iterator
 template <class _BidirectionalIterator,           class _CharT = typename iterator_traits<_BidirectionalIterator>::value_type,           class _Traits = regex_traits<_CharT> > class _LIBCPP_TEMPLATE_VIS regex_token_iterator {
   public:     typedef basic_regex<_CharT, _Traits>      regex_type;
       typedef sub_match<_BidirectionalIterator> value_type;
       typedef ptrdiff_t                         difference_type;
       typedef const value_type*                 pointer;
       typedef const value_type&                 reference;
       typedef forward_iterator_tag              iterator_category;
    private:     typedef regex_iterator<_BidirectionalIterator, _CharT, _Traits> _Position;
        _Position         __position_;
       const value_type* __result_;
       value_type        __suffix_;
       ptrdiff_t         __n_;
       vector<int>       __subs_;
    public:     regex_token_iterator();
       regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type& __re, int __submatch = 0,                          regex_constants::match_flag_type __m =                                                 regex_constants::match_default);
     
#if _LIBCPP_STD_VER > 11
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type&& __re, int __submatch = 0,                          regex_constants::match_flag_type __m =                                        regex_constants::match_default) = delete;
     
#endif
     regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type& __re, const vector<int>& __submatches,                          regex_constants::match_flag_type __m =                                                 regex_constants::match_default);
     
#if _LIBCPP_STD_VER > 11
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type&& __re, const vector<int>& __submatches,                          regex_constants::match_flag_type __m =                                      regex_constants::match_default) = delete;
     
#endif
   
#ifndef _LIBCPP_CXX03_LANG
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type& __re,                          initializer_list<int> __submatches,                          regex_constants::match_flag_type __m =                                                 regex_constants::match_default);
      
#if _LIBCPP_STD_VER > 11
    regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type&& __re,                          initializer_list<int> __submatches,                          regex_constants::match_flag_type __m =                                        regex_constants::match_default) = delete;
     
#endif
  
#endif  // _LIBCPP_CXX03_LANG
    template <size_t _Np>         regex_token_iterator(_BidirectionalIterator __a,                              _BidirectionalIterator __b,                              const regex_type& __re,                              const int (&__submatches)[_Np],                              regex_constants::match_flag_type __m =                                                 regex_constants::match_default);
     
#if _LIBCPP_STD_VER > 11
    template <std::size_t _Np>         regex_token_iterator(_BidirectionalIterator __a,                              _BidirectionalIterator __b,                              const regex_type&& __re,                              const int (&__submatches)[_Np],                              regex_constants::match_flag_type __m =                                       regex_constants::match_default) = delete;
     
#endif
     regex_token_iterator(const regex_token_iterator&);
       regex_token_iterator& operator=(const regex_token_iterator&);
        bool operator==(const regex_token_iterator& __x) const;
       _LIBCPP_INLINE_VISIBILITY     bool operator!=(const regex_token_iterator& __x) const {
  return !(*this == __x);
  }
        _LIBCPP_INLINE_VISIBILITY     const value_type& operator*() const {
  return *__result_;
  }
       _LIBCPP_INLINE_VISIBILITY     const value_type* operator->() const {
  return __result_;
  }
        regex_token_iterator& operator++();
       _LIBCPP_INLINE_VISIBILITY     regex_token_iterator operator++(int)     {
           regex_token_iterator __t(*this);
           ++(*this);
           return __t;
       }
    private:     void __init(_BidirectionalIterator __a, _BidirectionalIterator __b);
       void __establish_result () {
           if (__subs_[__n_] == -1)             __result_ = &__position_->prefix();
           else             __result_ = &(*__position_)[__subs_[__n_]];
           }
          };
    template <class _BidirectionalIterator, class _CharT, class _Traits> regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     regex_token_iterator()     : __result_(nullptr),       __suffix_(),       __n_(0) {
   }
    template <class _BidirectionalIterator, class _CharT, class _Traits> void regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     __init(_BidirectionalIterator __a, _BidirectionalIterator __b) {
       if (__position_ != _Position())         __establish_result ();
       else if (__subs_[__n_] == -1)     {
           __suffix_.matched = true;
           __suffix_.first = __a;
           __suffix_.second = __b;
           __result_ = &__suffix_;
       }
       else         __result_ = nullptr;
   }
    template <class _BidirectionalIterator, class _CharT, class _Traits> regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type& __re, int __submatch,                          regex_constants::match_flag_type __m)     : __position_(__a, __b, __re, __m),       __n_(0),       __subs_(1, __submatch) {
       __init(__a, __b);
   }
    template <class _BidirectionalIterator, class _CharT, class _Traits> regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type& __re, const vector<int>& __submatches,                          regex_constants::match_flag_type __m)     : __position_(__a, __b, __re, __m),       __n_(0),       __subs_(__submatches) {
       __init(__a, __b);
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _BidirectionalIterator, class _CharT, class _Traits> regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                          const regex_type& __re,                          initializer_list<int> __submatches,                          regex_constants::match_flag_type __m)     : __position_(__a, __b, __re, __m),       __n_(0),       __subs_(__submatches) {
       __init(__a, __b);
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _BidirectionalIterator, class _CharT, class _Traits> template <size_t _Np> regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     regex_token_iterator(_BidirectionalIterator __a, _BidirectionalIterator __b,                              const regex_type& __re,                              const int (&__submatches)[_Np],                              regex_constants::match_flag_type __m)     : __position_(__a, __b, __re, __m),       __n_(0),       __subs_(__submatches, __submatches + _Np) {
       __init(__a, __b);
   }
    template <class _BidirectionalIterator, class _CharT, class _Traits> regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     regex_token_iterator(const regex_token_iterator& __x)     : __position_(__x.__position_),       __result_(__x.__result_),       __suffix_(__x.__suffix_),       __n_(__x.__n_),       __subs_(__x.__subs_) {
       if (__x.__result_ == &__x.__suffix_)         __result_ = &__suffix_;
       else if ( __result_ != nullptr )         __establish_result ();
   }
    template <class _BidirectionalIterator, class _CharT, class _Traits> regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>& regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     operator=(const regex_token_iterator& __x) {
       if (this != &__x)     {
           __position_ = __x.__position_;
           if (__x.__result_ == &__x.__suffix_)             __result_ = &__suffix_;
           else             __result_ = __x.__result_;
           __suffix_ = __x.__suffix_;
           __n_ = __x.__n_;
           __subs_ = __x.__subs_;
            if ( __result_ != nullptr && __result_ != &__suffix_ )             __establish_result();
       }
       return *this;
   }
    template <class _BidirectionalIterator, class _CharT, class _Traits> bool regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::     operator==(const regex_token_iterator& __x) const {
       if (__result_ == nullptr && __x.__result_ == nullptr)         return true;
       if (__result_ == &__suffix_ && __x.__result_ == &__x.__suffix_ &&             __suffix_ == __x.__suffix_)         return true;
       if (__result_ == nullptr || __x.__result_ == nullptr)         return false;
       if (__result_ == &__suffix_ || __x.__result_ == &__x.__suffix_)         return false;
       return __position_ == __x.__position_ && __n_ == __x.__n_ &&            __subs_ == __x.__subs_;
   }
    template <class _BidirectionalIterator, class _CharT, class _Traits> regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>& regex_token_iterator<_BidirectionalIterator, _CharT, _Traits>::operator++() {
       _Position __prev = __position_;
       if (__result_ == &__suffix_)         __result_ = nullptr;
       else if (static_cast<size_t>(__n_ + 1) < __subs_.size())     {
           ++__n_;
           __establish_result();
       }
       else     {
           __n_ = 0;
           ++__position_;
           if (__position_ != _Position())             __establish_result();
           else         {
               if (_VSTD::find(__subs_.begin(), __subs_.end(), -1) != __subs_.end()                 && __prev->suffix().length() != 0)             {
                   __suffix_.matched = true;
                   __suffix_.first = __prev->suffix().first;
                   __suffix_.second = __prev->suffix().second;
                   __result_ = &__suffix_;
               }
               else                 __result_ = nullptr;
           }
       }
       return *this;
   }
    typedef regex_token_iterator<const char*>             cregex_token_iterator;
   typedef regex_token_iterator<const wchar_t*>          wcregex_token_iterator;
   typedef regex_token_iterator<string::const_iterator>  sregex_token_iterator;
   typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;
    // regex_replace
 template <class _OutputIterator, class _BidirectionalIterator,           class _Traits, class _CharT> _OutputIterator regex_replace(_OutputIterator __output,               _BidirectionalIterator __first, _BidirectionalIterator __last,               const basic_regex<_CharT, _Traits>& __e, const _CharT* __fmt,               regex_constants::match_flag_type __flags = regex_constants::match_default) {
       typedef regex_iterator<_BidirectionalIterator, _CharT, _Traits> _Iter;
       _Iter __i(__first, __last, __e, __flags);
       _Iter __eof;
       if (__i == __eof)     {
           if (!(__flags & regex_constants::format_no_copy))             __output = _VSTD::copy(__first, __last, __output);
       }
       else     {
           sub_match<_BidirectionalIterator> __lm;
           for (size_t __len = char_traits<_CharT>::length(__fmt);
   __i != __eof;
   ++__i)         {
               if (!(__flags & regex_constants::format_no_copy))                 __output = _VSTD::copy(__i->prefix().first, __i->prefix().second, __output);
               __output = __i->format(__output, __fmt, __fmt + __len, __flags);
               __lm = __i->suffix();
               if (__flags & regex_constants::format_first_only)                 break;
           }
           if (!(__flags & regex_constants::format_no_copy))             __output = _VSTD::copy(__lm.first, __lm.second, __output);
       }
       return __output;
   }
    template <class _OutputIterator, class _BidirectionalIterator,           class _Traits, class _CharT, class _ST, class _SA> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator regex_replace(_OutputIterator __output,               _BidirectionalIterator __first, _BidirectionalIterator __last,               const basic_regex<_CharT, _Traits>& __e,               const basic_string<_CharT, _ST, _SA>& __fmt,               regex_constants::match_flag_type __flags = regex_constants::match_default) {
       return _VSTD::regex_replace(__output, __first, __last, __e, __fmt.c_str(), __flags);
   }
    template <class _Traits, class _CharT, class _ST, class _SA, class _FST,           class _FSA> inline _LIBCPP_INLINE_VISIBILITY basic_string<_CharT, _ST, _SA> regex_replace(const basic_string<_CharT, _ST, _SA>& __s,               const basic_regex<_CharT, _Traits>& __e,               const basic_string<_CharT, _FST, _FSA>& __fmt,               regex_constants::match_flag_type __flags = regex_constants::match_default) {
       basic_string<_CharT, _ST, _SA> __r;
       _VSTD::regex_replace(back_inserter(__r), __s.begin(), __s.end(), __e,                         __fmt.c_str(), __flags);
       return __r;
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_REGEX
  
#pragma clang module end /*std.regex*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "scoped_allocator"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.scoped_allocator
// -*- C++ -*-
//===-------------------------- scoped_allocator --------------------------===//
#ifndef _LIBCPP_SCOPED_ALLOCATOR
  
#define _LIBCPP_SCOPED_ALLOCATOR
 /*     scoped_allocator synopsis  namespace std {
    template <class OuterAlloc, class... InnerAllocs> class scoped_allocator_adaptor : public OuterAlloc {
       typedef allocator_traits<OuterAlloc> OuterTraits;
   // exposition only
    scoped_allocator_adaptor<InnerAllocs...> inner;
 // struct hash<T*> in <memory>
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_FUNCTIONAL
  
#pragma clang module end /*std.functional*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Key, class _Compare = less<_Key>,           class _Allocator = allocator<_Key> > class _LIBCPP_TEMPLATE_VIS set {
   public:     // types:
    typedef _Key                                     key_type;
       typedef key_type                                 value_type;
       typedef _Compare                                 key_compare;
       typedef key_compare                              value_compare;
       typedef _Allocator                               allocator_type;
       typedef value_type&                              reference;
       typedef const value_type&                        const_reference;
        static_assert((is_same<typename allocator_type::value_type, value_type>::value),                   "Allocator::value_type must be same type as value_type");
    private:     typedef __tree<value_type, value_compare, allocator_type> __base;
       typedef allocator_traits<allocator_type>                  __alloc_traits;
       typedef typename __base::__node_holder                    __node_holder;
        __base __tree_;
    public:     typedef typename __base::pointer               pointer;
       typedef typename __base::const_pointer         const_pointer;
       typedef typename __base::size_type             size_type;
       typedef typename __base::difference_type       difference_type;
       typedef typename __base::const_iterator        iterator;
       typedef typename __base::const_iterator        const_iterator;
       typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;
       typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;
        _LIBCPP_INLINE_VISIBILITY     set()         _NOEXCEPT_(             is_nothrow_default_constructible<allocator_type>::value &&             is_nothrow_default_constructible<key_compare>::value &&             is_nothrow_copy_constructible<key_compare>::value)         : __tree_(value_compare()) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit set(const value_compare& __comp)         _NOEXCEPT_(             is_nothrow_default_constructible<allocator_type>::value &&             is_nothrow_copy_constructible<key_compare>::value)         : __tree_(__comp) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit set(const value_compare& __comp, const allocator_type& __a)         : __tree_(__comp, __a) {
  }
       template <class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         set(_InputIterator __f, _InputIterator __l,             const value_compare& __comp = value_compare())         : __tree_(__comp)         {
               insert(__f, __l);
           }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     set(set&& __s)         _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)         : __tree_(_VSTD::move(__s.__tree_)) {
  }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     explicit set(const allocator_type& __a)         : __tree_(__a) {
  }
        _LIBCPP_INLINE_VISIBILITY     set(const set& __s, const allocator_type& __a)         : __tree_(__s.__tree_.value_comp(), __a)         {
               insert(__s.begin(), __s.end());
           }
      
#ifndef _LIBCPP_CXX03_LANG
    set(set&& __s, const allocator_type& __a);
        _LIBCPP_INLINE_VISIBILITY     set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())         : __tree_(__comp)         {
               insert(__il.begin(), __il.end());
           }
        _LIBCPP_INLINE_VISIBILITY     set(initializer_list<value_type> __il, const value_compare& __comp,         const allocator_type& __a)         : __tree_(__comp, __a)         {
               insert(__il.begin(), __il.end());
           }
      
#if _LIBCPP_STD_VER > 11
    _LIBCPP_INLINE_VISIBILITY      set(initializer_list<value_type> __il, const allocator_type& __a)         : set(__il, key_compare(), __a) {
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     set& operator=(initializer_list<value_type> __il)         {
               __tree_.__assign_unique(__il.begin(), __il.end());
               return *this;
           }
        _LIBCPP_INLINE_VISIBILITY     set& operator=(set&& __s)         _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)         {
               __tree_ = _VSTD::move(__s.__tree_);
               return *this;
           }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY           iterator begin() _NOEXCEPT       {
  return __tree_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin() const _NOEXCEPT {
  return __tree_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY           iterator end() _NOEXCEPT         {
  return __tree_.end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator end()   const _NOEXCEPT {
  return __tree_.end();
  }
        _LIBCPP_INLINE_VISIBILITY           reverse_iterator rbegin() _NOEXCEPT             {
  return reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rbegin() const _NOEXCEPT         {
  return const_reverse_iterator(end());
  return begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator cend() const _NOEXCEPT {
  return end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crbegin() const _NOEXCEPT {
  return rbegin();
  return __tree_.size();
  }
       _LIBCPP_INLINE_VISIBILITY     size_type max_size() const _NOEXCEPT {
  return __tree_.max_size();
  }
        // modifiers:
  
#ifndef _LIBCPP_CXX03_LANG
    template <class... _Args>         _LIBCPP_INLINE_VISIBILITY         pair<iterator, bool> emplace(_Args&&... __args)             {
  return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);
  }
       template <class... _Args>         _LIBCPP_INLINE_VISIBILITY         iterator emplace_hint(const_iterator __p, _Args&&... __args)             {
  return __tree_.__emplace_hint_unique(__p, _VSTD::forward<_Args>(__args)...);
  }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     pair<iterator,bool> insert(const value_type& __v)         {
  return __tree_.__insert_unique(__v);
  }
       _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p, const value_type& __v)         {
  return __tree_.__insert_unique(__p, __v);
  }
        template <class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         void insert(_InputIterator __f, _InputIterator __l)         {
               for (const_iterator __e = cend();
   __f != __l;
   ++__f)                 __tree_.__insert_unique(__e, *__f);
           }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     pair<iterator,bool> insert(value_type&& __v)         {
  return __tree_.__insert_unique(_VSTD::move(__v));
  }
        _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p, value_type&& __v)         {
  return __tree_.__insert_unique(__p, _VSTD::move(__v));
  }
        _LIBCPP_INLINE_VISIBILITY     void insert(initializer_list<value_type> __il)         {
  insert(__il.begin(), __il.end());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     iterator  erase(const_iterator __p) {
  return __tree_.erase(__p);
  }
       _LIBCPP_INLINE_VISIBILITY     size_type erase(const key_type& __k)         {
  return __tree_.__erase_unique(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     iterator  erase(const_iterator __f, const_iterator __l)         {
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type     find(const _K2& __k)                           {
  return __tree_.find(__k);
  }
       template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type     find(const _K2& __k) const                     {
  return __tree_.find(__k);
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     size_type      count(const key_type& __k) const         {
  return __tree_.__count_unique(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type     count(const _K2& __k) const                    {
  return __tree_.__count_unique(__k);
  }
     
#endif
    _LIBCPP_INLINE_VISIBILITY     iterator lower_bound(const key_type& __k)         {
  return __tree_.lower_bound(__k);
  return __tree_.upper_bound(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator upper_bound(const key_type& __k) const         {
  return __tree_.upper_bound(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type     upper_bound(const _K2& __k)       {
  return __tree_.upper_bound(__k);
  }
       template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type     upper_bound(const _K2& __k) const {
  return __tree_.upper_bound(__k);
  }
     
#endif
};
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Key, class _Compare, class _Allocator> set<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)     : __tree_(_VSTD::move(__s.__tree_), __a) {
       if (__a != __s.get_allocator())     {
           const_iterator __e = cend();
           while (!__s.empty())             insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));
       }
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Key, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator==(const set<_Key, _Compare, _Allocator>& __x,            const set<_Key, _Compare, _Allocator>& __y) {
       return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());
   }
    template <class _Key, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator< (const set<_Key, _Compare, _Allocator>& __x,            const set<_Key, _Compare, _Allocator>& __y) {
       __x.swap(__y);
   }
    template <class _Key, class _Compare = less<_Key>,           class _Allocator = allocator<_Key> > class _LIBCPP_TEMPLATE_VIS multiset {
   public:     // types:
    typedef _Key                                      key_type;
       typedef key_type                                 value_type;
       typedef _Compare                                  key_compare;
       typedef key_compare                              value_compare;
       typedef _Allocator                                allocator_type;
       typedef value_type&                              reference;
       typedef const value_type&                        const_reference;
        static_assert((is_same<typename allocator_type::value_type, value_type>::value),                   "Allocator::value_type must be same type as value_type");
    private:     typedef __tree<value_type, value_compare, allocator_type> __base;
       typedef allocator_traits<allocator_type>                  __alloc_traits;
       typedef typename __base::__node_holder                    __node_holder;
        __base __tree_;
    public:     typedef typename __base::pointer               pointer;
       typedef typename __base::const_pointer         const_pointer;
       typedef typename __base::size_type             size_type;
       typedef typename __base::difference_type       difference_type;
       typedef typename __base::const_iterator        iterator;
       typedef typename __base::const_iterator        const_iterator;
       typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;
       typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;
        // construct/copy/destroy:
    _LIBCPP_INLINE_VISIBILITY     multiset()         _NOEXCEPT_(             is_nothrow_default_constructible<allocator_type>::value &&             is_nothrow_default_constructible<key_compare>::value &&             is_nothrow_copy_constructible<key_compare>::value)         : __tree_(value_compare()) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit multiset(const value_compare& __comp)         _NOEXCEPT_(             is_nothrow_default_constructible<allocator_type>::value &&             is_nothrow_copy_constructible<key_compare>::value)         : __tree_(__comp) {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit multiset(const value_compare& __comp, const allocator_type& __a)         : __tree_(__comp, __a) {
  }
        _LIBCPP_INLINE_VISIBILITY     multiset& operator=(const multiset& __s)         {
               __tree_ = __s.__tree_;
               return *this;
           }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     multiset(multiset&& __s)         _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)         : __tree_(_VSTD::move(__s.__tree_)) {
  }
        multiset(multiset&& __s, const allocator_type& __a);
     
#endif  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     explicit multiset(const allocator_type& __a)         : __tree_(__a) {
  }
       _LIBCPP_INLINE_VISIBILITY     multiset(const multiset& __s, const allocator_type& __a)         : __tree_(__s.__tree_.value_comp(), __a)         {
               insert(__s.begin(), __s.end());
           }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())         : __tree_(__comp)         {
               insert(__il.begin(), __il.end());
           }
        _LIBCPP_INLINE_VISIBILITY     multiset(initializer_list<value_type> __il, const value_compare& __comp,         const allocator_type& __a)         : __tree_(__comp, __a)         {
               insert(__il.begin(), __il.end());
           }
      
#if _LIBCPP_STD_VER > 11
    _LIBCPP_INLINE_VISIBILITY      multiset(initializer_list<value_type> __il, const allocator_type& __a)         : multiset(__il, key_compare(), __a) {
  }
     
#endif
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY           iterator begin() _NOEXCEPT       {
  return __tree_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin() const _NOEXCEPT {
  return __tree_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY           iterator end() _NOEXCEPT         {
  return __tree_.end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator end()   const _NOEXCEPT {
  return __tree_.end();
  }
        _LIBCPP_INLINE_VISIBILITY           reverse_iterator rbegin() _NOEXCEPT             {
  return reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rbegin() const _NOEXCEPT         {
  return const_reverse_iterator(end());
  }
       _LIBCPP_INLINE_VISIBILITY           reverse_iterator rend() _NOEXCEPT             {
  return       reverse_iterator(begin());
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator rend() const _NOEXCEPT         {
  return const_reverse_iterator(begin());
  }
        _LIBCPP_INLINE_VISIBILITY     const_iterator cbegin()  const _NOEXCEPT {
  return begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator cend() const _NOEXCEPT {
  return end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crbegin() const _NOEXCEPT {
  return rbegin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_reverse_iterator crend() const _NOEXCEPT {
  return rend();
  }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     iterator insert(value_type&& __v)         {
  return __tree_.__insert_multi(_VSTD::move(__v));
  }
        _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p, value_type&& __v)         {
  return __tree_.__insert_multi(__p, _VSTD::move(__v));
  }
        _LIBCPP_INLINE_VISIBILITY     void insert(initializer_list<value_type> __il)         {
  insert(__il.begin(), __il.end());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     iterator  erase(const_iterator __p) {
  return __tree_.erase(__p);
  }
       _LIBCPP_INLINE_VISIBILITY     key_compare    key_comp()      const {
  return __tree_.value_comp();
  }
       _LIBCPP_INLINE_VISIBILITY     value_compare  value_comp()    const {
  return __tree_.value_comp();
  }
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type     find(const _K2& __k)                           {
  return __tree_.find(__k);
  }
       template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type     find(const _K2& __k) const                     {
  return __tree_.find(__k);
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     size_type      count(const key_type& __k) const         {
  return __tree_.__count_multi(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type     count(const _K2& __k)                  {
  return __tree_.__count_multi(__k);
  return __tree_.upper_bound(__k);
  }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     pair<iterator,iterator>             equal_range(const key_type& __k)             {
  return __tree_.__equal_range_multi(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     pair<const_iterator,const_iterator> equal_range(const key_type& __k) const             {
  return __tree_.__equal_range_multi(__k);
  }
     
#if _LIBCPP_STD_VER > 11
    template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type     equal_range(const _K2& __k)       {
  return __tree_.__equal_range_multi(__k);
  }
       template <typename _K2>     _LIBCPP_INLINE_VISIBILITY     typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type     equal_range(const _K2& __k) const {
  return __tree_.__equal_range_multi(__k);
  }
     
#endif
};
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Key, class _Compare, class _Allocator> multiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)     : __tree_(_VSTD::move(__s.__tree_), __a) {
       if (__a != __s.get_allocator())     {
           const_iterator __e = cend();
           while (!__s.empty())             insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));
       }
   }
      
#endif  // _LIBCPP_CXX03_LANG
    template <class _Key, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY bool operator<=(const multiset<_Key, _Compare, _Allocator>& __x,            const multiset<_Key, _Compare, _Allocator>& __y) {
       return !(__y < __x);
   }
    template <class _Key, class _Compare, class _Allocator> inline _LIBCPP_INLINE_VISIBILITY void swap(multiset<_Key, _Compare, _Allocator>& __x,      multiset<_Key, _Compare, _Allocator>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_SET
  
#pragma clang module end /*std.set*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "sstream"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.sstream
// -*- C++ -*-
//===--------------------------- sstream ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_SSTREAM
  
#define _LIBCPP_SSTREAM
 /*     sstream synopsis  template <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> > class basic_stringbuf     : public basic_streambuf<charT, traits> {
   public:     typedef charT                          char_type;
       typedef traits                         traits_type;
       typedef typename traits_type::int_type int_type;
       typedef typename traits_type::pos_type pos_type;
       typedef typename traits_type::off_type off_type;
       typedef Allocator                      allocator_type;
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
  
   
#ifndef _LIBCPP_DEQUE
  
#define _LIBCPP_DEQUE
 /*     deque synopsis  namespace std {
    template <class T, class Allocator = allocator<T> > class deque {
   public:     // types:
    typedef T value_type;
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <exception>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <new>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <utility>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Arg1, class _Arg2, class _Result> struct _LIBCPP_TEMPLATE_VIS binary_function {
   };
    template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>     : public binary_function<volatile _Cp*, _A1, _Rp> {
   };
    template <class _Rp, class _Cp, class _A1> struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>     : public binary_function<const volatile _Cp*, _A1, _Rp> {
   };
       
#ifndef _LIBCPP_CXX03_LANG
// 3 or more arguments
   return reinterpret_cast<size_t>(__type_name);
   }
        _LIBCPP_INLINE_VISIBILITY     bool operator==(const type_info& __arg) const _NOEXCEPT     {
   return __type_name == __arg.__type_name;
   }
     
#endif
#else
	_VSTD::abort();
     
#endif
}
   _LIBCPP_END_NAMESPACE_STD    
#endif  // __LIBCPP_TYPEINFO
  
#pragma clang module end /*std.typeinfo*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "unordered_map"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.unordered_map
// -*- C++ -*-
//===-------------------------- unordered_map -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_UNORDERED_MAP
  
#define _LIBCPP_UNORDERED_MAP
 /*      unordered_map synopsis    
       void insert(initializer_list<value_type>);
        template <class... Args>         pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
    
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module import std_config /* clang -frewrite-includes: implicit import */
#pragma clang module begin std.__hash_table
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP__HASH_TABLE
  
#define _LIBCPP__HASH_TABLE
   
#if 0 /* expanded by -frewrite-includes */
  
#include <initializer_list>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.initializer_list
// -*- C++ -*-
   
#ifndef _LIBCPP_INITIALIZER_LIST
  
#define _LIBCPP_INITIALIZER_LIST
 /*     initializer_list synopsis  namespace std {
    template<class E> class initializer_list {
   public:     typedef E        value_type;
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
#if 0 /* expanded by -frewrite-includes */
  
#include <iosfwd>
  
#endif /* expanded by -frewrite-includes */
  template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value> struct __pointer_traits_rebind {
     
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Tp::template rebind<_Up> type;
     
#else
    typedef typename _Tp::template rebind<_Up>::other type;
     
#endif
};
      
#ifndef _LIBCPP_HAS_NO_VARIADICS
 template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true> {
     
#ifndef _LIBCPP_CXX03_LANG
    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;
     
#else
    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;
     
#endif
};
    template <template <class> class _Sp, class _Tp, class _Up> struct __pointer_traits_rebind<_Sp<_Tp>, _Up, false> {
       typedef _Sp<_Up> type;
   };
    template <template <class, class> class _Sp, class _Tp, class _A0, class _Up> struct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true> {
#endif
  
#ifndef _LIBCPP_DEBUG_MODE
  
#define _LIBCPP_DEBUG_MODE(...) ((void)0)
  
#endif
///   an instance of __libcpp_debug_exception when called.
 _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __libcpp_throw_debug_function(__libcpp_debug_info const&);
    /// __libcpp_set_debug_function - Set the debug handler to the specified
///    function.
_LIBCPP_FUNC_VIS bool __libcpp_set_debug_function(__libcpp_debug_function_type __func);
    // Setup the throwing debug handler during dynamic initialization.
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max")   
#else
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
  _LIBCPP_BEGIN_NAMESPACE_STD    
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Tp> union __hash_value_type;
     
#else
template <class _Key, class _Tp> struct __hash_value_type;
     
#endif
 template <class _Key, class _Cp, class _Hash,           bool =  is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value> class __unordered_map_hasher;
    template <class _Key, class _Cp, class _Pred,           bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value          > class __unordered_map_equal;
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp> struct __is_hash_value_type_imp : false_type {
  };
    template <class _Key, class _Value> struct __is_hash_value_type_imp<__hash_value_type<_Key, _Value>> : true_type {
  };
    template <class ..._Args> struct __is_hash_value_type : false_type {
  };
    template <class _One> struct __is_hash_value_type<_One> : __is_hash_value_type_imp<typename __uncvref<_One>::type> {
  };
     
#endif
 _LIBCPP_FUNC_VIS size_t __next_prime(size_t __n);
    template <class _NodePtr> struct __hash_node_base {
       typedef typename pointer_traits<_NodePtr>::element_type __node_type;
       typedef __hash_node_base __first_node;
       typedef typename __rebind_pointer<_NodePtr, __first_node>::type __node_base_pointer;
       typedef _NodePtr __node_pointer;
      
#if defined(_LIBCPP_ABI_FIX_UNORDERED_NODE_POINTER_UB)
  typedef __node_base_pointer __next_pointer;
     
#else
  typedef typename conditional<       is_pointer<__node_pointer>::value,       __node_base_pointer,       __node_pointer>::type   __next_pointer;
     
#endif
     __next_pointer    __next_;
        _LIBCPP_INLINE_VISIBILITY     __next_pointer __ptr() _NOEXCEPT {
           return static_cast<__next_pointer>(             pointer_traits<__node_base_pointer>::pointer_to(*this));
       }
   };
    template <class _Tp, class _VoidPtr> struct __hash_node     : public __hash_node_base              <                  typename __rebind_pointer<_VoidPtr, __hash_node<_Tp, _VoidPtr> >::type              > {
       typedef _Tp __node_value_type;
        size_t            __hash_;
       __node_value_type __value_;
   };
    inline _LIBCPP_INLINE_VISIBILITY bool __is_hash_power2(size_t __bc) {
       return __bc > 2 && !(__bc & (__bc - 1));
   }
    inline _LIBCPP_INLINE_VISIBILITY size_t __constrain_hash(size_t __h, size_t __bc) {
       return !(__bc & (__bc - 1)) ? __h & (__bc - 1) :         (__h < __bc ? __h : __h % __bc);
   }
    inline _LIBCPP_INLINE_VISIBILITY size_t __next_hash_pow2(size_t __n) {
       return __n < 2 ? __n : (size_t(1) << (std::numeric_limits<size_t>::digits - __clz(__n-1)));
   }
     template <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;
    template <class _NodePtr>      class _LIBCPP_TEMPLATE_VIS __hash_iterator;
   template <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;
   template <class _NodePtr>      class _LIBCPP_TEMPLATE_VIS __hash_local_iterator;
   template <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;
   template <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;
   template <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;
    template <class _Tp> struct __hash_key_value_types {
     static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, "");
     typedef _Tp key_type;
     typedef _Tp __node_value_type;
     typedef _Tp __container_value_type;
     static const bool __is_map = false;
      _LIBCPP_INLINE_VISIBILITY   static key_type const& __get_key(_Tp const& __v) {
       return __v;
     }
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_INLINE_VISIBILITY   static  __container_value_type&& __move(__node_value_type& __v) {
       return _VSTD::move(__v);
     }
     
#endif
};
    template <class _Key, class _Tp> struct __hash_key_value_types<__hash_value_type<_Key, _Tp> > {
     typedef _Key                                         key_type;
     typedef _Tp                                          mapped_type;
     typedef __hash_value_type<_Key, _Tp>                 __node_value_type;
     typedef pair<const _Key, _Tp>                        __container_value_type;
     typedef pair<_Key, _Tp>                              __nc_value_type;
     typedef __container_value_type                       __map_value_type;
     static const bool __is_map = true;
      _LIBCPP_INLINE_VISIBILITY   static key_type const& __get_key(__container_value_type const& __v) {
       return __v.first;
     }
      template <class _Up>   _LIBCPP_INLINE_VISIBILITY   static typename enable_if<__is_same_uncvref<_Up, __node_value_type>::value,       __container_value_type const&>::type   __get_value(_Up& __t) {
       return __t.__cc;
     }
      template <class _Up>   _LIBCPP_INLINE_VISIBILITY   static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,       __container_value_type const&>::type   __get_value(_Up& __t) {
       return __t;
     }
      _LIBCPP_INLINE_VISIBILITY   static __container_value_type* __get_ptr(__node_value_type& __n) {
       return _VSTD::addressof(__n.__cc);
     }
     
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_INLINE_VISIBILITY   static __nc_value_type&& __move(__node_value_type& __v) {
       return _VSTD::move(__v.__nc);
     }
     
#endif
 };
    template <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>,           bool = _KVTypes::__is_map> struct __hash_map_pointer_types {
  };
    template <class _Tp, class _AllocPtr, class _KVTypes> struct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
     typedef typename _KVTypes::__map_value_type   _Mv;
     typedef typename __rebind_pointer<_AllocPtr, _Mv>::type                                                        __map_value_type_pointer;
     typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type                                                  __const_map_value_type_pointer;
   };
    template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type> struct __hash_node_types;
    template <class _NodePtr, class _Tp, class _VoidPtr> struct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr> >     : public __hash_key_value_types<_Tp>, __hash_map_pointer_types<_Tp, _VoidPtr>  {
     typedef __hash_key_value_types<_Tp>           __base;
    public:   typedef ptrdiff_t difference_type;
     typedef size_t size_type;
      typedef typename __rebind_pointer<_NodePtr, void>::type       __void_pointer;
      typedef typename pointer_traits<_NodePtr>::element_type       __node_type;
     typedef _NodePtr                                              __node_pointer;
      typedef __hash_node_base<__node_pointer>                      __node_base_type;
     typedef typename __rebind_pointer<_NodePtr, __node_base_type>::type                                                              __node_base_pointer;
      typedef typename __node_base_type::__next_pointer          __next_pointer;
      typedef _Tp                                                 __node_value_type;
     typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type                                                       __node_value_type_pointer;
     typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type                                                 __const_node_value_type_pointer;
    private:     static_assert(!is_const<__node_type>::value,                 "_NodePtr should never be a pointer to const");
       static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),                   "_VoidPtr does not point to unqualified void type");
       static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,                           _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
   };
    template <class _HashIterator> struct __hash_node_types_from_iterator;
     template <class _NodeValueTp, class _VoidPtr> struct __make_hash_node_types {
     typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;
     typedef typename __rebind_pointer<_VoidPtr, _NodeTp>::type _NodePtr;
     typedef __hash_node_types<_NodePtr> type;
   };
    template <class _NodePtr> class _LIBCPP_TEMPLATE_VIS __hash_iterator {
       typedef __hash_node_types<_NodePtr> _NodeTypes;
       typedef _NodePtr                            __node_pointer;
       typedef typename _NodeTypes::__next_pointer __next_pointer;
        __next_pointer            __node_;
    public:     typedef forward_iterator_tag                           iterator_category;
       typedef typename _NodeTypes::__node_value_type         value_type;
       typedef typename _NodeTypes::difference_type           difference_type;
       typedef value_type&                                    reference;
       typedef typename _NodeTypes::__node_value_type_pointer pointer;
        _LIBCPP_INLINE_VISIBILITY __hash_iterator() _NOEXCEPT : __node_(nullptr) {
           _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));
       }
      
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     __hash_iterator(const __hash_iterator& __i)         : __node_(__i.__node_)     {
           __get_db()->__iterator_copy(this, &__i);
       }
     
#endif
    template <class, class, class, class> friend class __hash_table;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;
       template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;
       template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;
   };
    template <class _NodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_iterator {
       static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, "");
       typedef __hash_node_types<_NodePtr> _NodeTypes;
       typedef _NodePtr                            __node_pointer;
       typedef typename _NodeTypes::__next_pointer __next_pointer;
        __next_pointer __node_;
    public:     typedef __hash_iterator<_NodePtr> __non_const_iterator;
        typedef forward_iterator_tag                                 iterator_category;
       typedef typename _NodeTypes::__node_value_type               value_type;
       typedef typename _NodeTypes::difference_type                 difference_type;
       typedef const value_type&                                    reference;
       typedef typename _NodeTypes::__const_node_value_type_pointer pointer;
         _LIBCPP_INLINE_VISIBILITY __hash_const_iterator() _NOEXCEPT : __node_(nullptr) {
           _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));
       }
        _LIBCPP_INLINE_VISIBILITY      __hash_const_iterator(const __non_const_iterator& __x) _NOEXCEPT         : __node_(__x.__node_)     {
       }
        _LIBCPP_INLINE_VISIBILITY     __hash_const_iterator operator++(int)     {
           __hash_const_iterator __t(*this);
           ++(*this);
           return __t;
       }
        friend _LIBCPP_INLINE_VISIBILITY     bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)     {
           return __x.__node_ == __y.__node_;
       }
       friend _LIBCPP_INLINE_VISIBILITY     bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)         {
  return !(__x == __y);
  }
    private:   
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     __hash_const_iterator(__next_pointer __node, const void* __c) _NOEXCEPT         : __node_(__node)         {
               __get_db()->__insert_ic(this, __c);
           }
     
#else
    _LIBCPP_INLINE_VISIBILITY     __hash_const_iterator(__next_pointer __node) _NOEXCEPT         : __node_(__node)         {
  }
     
#endif
    template <class, class, class, class> friend class __hash_table;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;
       template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;
       template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;
   };
    template <class _NodePtr> class _LIBCPP_TEMPLATE_VIS __hash_local_iterator {
       typedef __hash_node_types<_NodePtr> _NodeTypes;
       typedef _NodePtr                            __node_pointer;
       typedef typename _NodeTypes::__next_pointer __next_pointer;
        __next_pointer         __node_;
       size_t                 __bucket_;
       size_t                 __bucket_count_;
    public:     typedef forward_iterator_tag                                iterator_category;
       typedef typename _NodeTypes::__node_value_type              value_type;
       typedef typename _NodeTypes::difference_type                difference_type;
       typedef value_type&                                         reference;
       typedef typename _NodeTypes::__node_value_type_pointer      pointer;
        _LIBCPP_INLINE_VISIBILITY __hash_local_iterator() _NOEXCEPT : __node_(nullptr) {
           _LIBCPP_DEBUG_MODE(__get_db()->__insert_i(this));
       }
      
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     __hash_local_iterator(const __hash_local_iterator& __i)         : __node_(__i.__node_),           __bucket_(__i.__bucket_),           __bucket_count_(__i.__bucket_count_)     {
#endif
    template <class, class, class, class> friend class __hash_table;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_iterator;
   };
    template <class _ConstNodePtr> class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator {
       typedef __hash_node_types<_ConstNodePtr> _NodeTypes;
       typedef _ConstNodePtr                       __node_pointer;
       typedef typename _NodeTypes::__next_pointer __next_pointer;
        __next_pointer         __node_;
       size_t                 __bucket_;
       size_t                 __bucket_count_;
        typedef pointer_traits<__node_pointer>          __pointer_traits;
       typedef typename __pointer_traits::element_type __node;
       typedef typename remove_const<__node>::type     __non_const_node;
       typedef typename __rebind_pointer<__node_pointer, __non_const_node>::type         __non_const_node_pointer;
   public:     typedef __hash_local_iterator<__non_const_node_pointer>                                                     __non_const_iterator;
        typedef forward_iterator_tag                                 iterator_category;
       typedef typename _NodeTypes::__node_value_type               value_type;
       typedef typename _NodeTypes::difference_type                 difference_type;
       typedef const value_type&                                    reference;
       typedef typename _NodeTypes::__const_node_value_type_pointer pointer;
         _LIBCPP_INLINE_VISIBILITY __hash_const_local_iterator() _NOEXCEPT : __node_(nullptr) {
       }
        _LIBCPP_INLINE_VISIBILITY     __hash_const_local_iterator& operator++() {
           _LIBCPP_DEBUG_ASSERT(__get_const_db()->__dereferenceable(this),                        "Attempted to increment non-incrementable unordered container const_local_iterator");
           __node_ = __node_->__next_;
           if (__node_ != nullptr && __constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)             __node_ = nullptr;
           return *this;
       }
       friend _LIBCPP_INLINE_VISIBILITY     bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)         {
  return !(__x == __y);
  }
    private:   
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_INLINE_VISIBILITY     __hash_const_local_iterator(__next_pointer __node, size_t __bucket,                                 size_t __bucket_count, const void* __c) _NOEXCEPT         : __node_(__node),           __bucket_(__bucket),           __bucket_count_(__bucket_count)         {
               __get_db()->__insert_ic(this, __c);
#endif
    template <class, class, class, class> friend class __hash_table;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_map_const_iterator;
   };
    template <class _Alloc> class __bucket_list_deallocator {
       typedef _Alloc                                          allocator_type;
       typedef allocator_traits<allocator_type>                __alloc_traits;
       typedef typename __alloc_traits::size_type              size_type;
        __compressed_pair<size_type, allocator_type> __data_;
   public:     typedef typename __alloc_traits::pointer pointer;
        _LIBCPP_INLINE_VISIBILITY     __bucket_list_deallocator()         _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)         : __data_(0) {
  }
        _LIBCPP_INLINE_VISIBILITY     __bucket_list_deallocator(const allocator_type& __a, size_type __size)         _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)         : __data_(__size, __a) {
  }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     __bucket_list_deallocator(__bucket_list_deallocator&& __x)         _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)         : __data_(_VSTD::move(__x.__data_))     {
           __x.size() = 0;
       }
     
#endif
     _LIBCPP_INLINE_VISIBILITY     size_type& size() _NOEXCEPT {
  return __data_.first();
  }
       _LIBCPP_INLINE_VISIBILITY     size_type  size() const _NOEXCEPT {
  return __data_.first();
  }
        _LIBCPP_INLINE_VISIBILITY     allocator_type& __alloc() _NOEXCEPT {
  return __data_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     const allocator_type& __alloc() const _NOEXCEPT {
  return __data_.second();
  }
        _LIBCPP_INLINE_VISIBILITY     void operator()(pointer __p) _NOEXCEPT     {
           __alloc_traits::deallocate(__alloc(), __p, size());
       }
   };
    template <class _Alloc> class __hash_map_node_destructor;
    template <class _Alloc> class __hash_node_destructor {
       typedef _Alloc                                          allocator_type;
       typedef allocator_traits<allocator_type>                __alloc_traits;
    public:     typedef typename __alloc_traits::pointer                pointer;
   private:     typedef __hash_node_types<pointer> _NodeTypes;
        allocator_type& __na_;
        __hash_node_destructor& operator=(const __hash_node_destructor&);
    public:     bool __value_constructed;
        _LIBCPP_INLINE_VISIBILITY     explicit __hash_node_destructor(allocator_type& __na,                                     bool __constructed = false) _NOEXCEPT         : __na_(__na),           __value_constructed(__constructed)         {
  }
        _LIBCPP_INLINE_VISIBILITY     void operator()(pointer __p) _NOEXCEPT     {
           if (__value_constructed)             __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
           if (__p)             __alloc_traits::deallocate(__na_, __p, 1);
       }
        template <class> friend class __hash_map_node_destructor;
   };
       
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Hash, class _Equal, class _Alloc> struct __diagnose_hash_table_helper {
     static constexpr bool __trigger_diagnostics()     _LIBCPP_DIAGNOSE_WARNING(__check_hash_requirements<_Key, _Hash>::value                          && !__invokable<_Hash const&, _Key const&>::value,       "the specified hash functor does not provide a const call operator")     _LIBCPP_DIAGNOSE_WARNING(is_copy_constructible<_Equal>::value                           && !__invokable<_Equal const&, _Key const&, _Key const&>::value,       "the specified comparator type does not provide a const call operator")   {
       static_assert(__check_hash_requirements<_Key, _Hash>::value,       "the specified hash does not meet the Hash requirements");
       static_assert(is_copy_constructible<_Equal>::value,       "the specified comparator is required to be copy constructible");
       return true;
     }
   };
    template <class _Key, class _Value, class _Hash, class _Equal, class _Alloc> struct __diagnose_hash_table_helper<   __hash_value_type<_Key, _Value>,   __unordered_map_hasher<_Key, __hash_value_type<_Key, _Value>, _Hash>,   __unordered_map_equal<_Key, __hash_value_type<_Key, _Value>, _Equal>,   _Alloc> : __diagnose_hash_table_helper<_Key, _Hash, _Equal, _Alloc> {
   };
     
#endif // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table {
   public:     typedef _Tp    value_type;
       typedef _Hash  hasher;
       typedef _Equal key_equal;
       typedef _Alloc allocator_type;
    private:     typedef allocator_traits<allocator_type> __alloc_traits;
       typedef typename       __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type                                                                      _NodeTypes;
   public:      typedef typename _NodeTypes::__node_value_type           __node_value_type;
       typedef typename _NodeTypes::__container_value_type      __container_value_type;
       typedef typename _NodeTypes::key_type                    key_type;
       typedef value_type&                              reference;
       typedef const value_type&                        const_reference;
       typedef typename __alloc_traits::pointer         pointer;
       typedef typename __alloc_traits::const_pointer   const_pointer;
     
#ifndef _LIBCPP_ABI_FIX_UNORDERED_CONTAINER_SIZE_TYPE
    typedef typename __alloc_traits::size_type       size_type;
     
#else
    typedef typename _NodeTypes::size_type           size_type;
     
#endif
    typedef typename _NodeTypes::difference_type     difference_type;
   public:     // Create __node
     typedef typename _NodeTypes::__node_type __node;
       typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
       typedef allocator_traits<__node_allocator>       __node_traits;
       typedef typename _NodeTypes::__void_pointer      __void_pointer;
       typedef typename _NodeTypes::__node_pointer      __node_pointer;
       typedef typename _NodeTypes::__node_pointer      __node_const_pointer;
       typedef typename _NodeTypes::__node_base_type    __first_node;
       typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
       typedef typename _NodeTypes::__next_pointer      __next_pointer;
    private:     // check for sane allocator pointer rebinding semantics. Rebinding the
    // allocator for a new pointer type should be exactly the same as rebinding
    // the pointer using 'pointer_traits'.
    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),                   "Allocator does not rebind pointers in a sane manner.");
       typedef typename __rebind_alloc_helper<__node_traits, __first_node>::type         __node_base_allocator;
       typedef allocator_traits<__node_base_allocator> __node_base_traits;
       static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),                  "Allocator does not rebind pointers in a sane manner.");
    private:      typedef typename __rebind_alloc_helper<__node_traits, __next_pointer>::type __pointer_allocator;
       typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;
       typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;
       typedef allocator_traits<__pointer_allocator>          __pointer_alloc_traits;
       typedef typename __bucket_list_deleter::pointer       __node_pointer_pointer;
      
#ifndef _LIBCPP_CXX03_LANG
    static_assert(__diagnose_hash_table_helper<_Tp, _Hash, _Equal, _Alloc>::__trigger_diagnostics(), "");
     
#endif
     // --- Member data begin ---
    __bucket_list                                         __bucket_list_;
       __compressed_pair<__first_node, __node_allocator>     __p1_;
       __compressed_pair<size_type, hasher>                  __p2_;
       __compressed_pair<float, key_equal>                   __p3_;
       // --- Member data end ---
     _LIBCPP_INLINE_VISIBILITY     size_type& size() _NOEXCEPT {
  return __p2_.first();
  }
   public:     _LIBCPP_INLINE_VISIBILITY     size_type  size() const _NOEXCEPT {
  return __p2_.first();
  }
        _LIBCPP_INLINE_VISIBILITY     hasher& hash_function() _NOEXCEPT {
  return __p2_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     const hasher& hash_function() const _NOEXCEPT {
  return __p2_.second();
  }
        _LIBCPP_INLINE_VISIBILITY     float& max_load_factor() _NOEXCEPT {
  return __p3_.first();
  }
       _LIBCPP_INLINE_VISIBILITY     float  max_load_factor() const _NOEXCEPT {
  return __p3_.first();
  }
        _LIBCPP_INLINE_VISIBILITY     key_equal& key_eq() _NOEXCEPT {
  return __p3_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     const key_equal& key_eq() const _NOEXCEPT {
  return __p3_.second();
  }
        _LIBCPP_INLINE_VISIBILITY     __node_allocator& __node_alloc() _NOEXCEPT {
  return __p1_.second();
  }
       _LIBCPP_INLINE_VISIBILITY     const __node_allocator& __node_alloc() const _NOEXCEPT         {
  return __p1_.second();
  }
    public:     typedef __hash_iterator<__node_pointer>                   iterator;
       typedef __hash_const_iterator<__node_pointer>             const_iterator;
       typedef __hash_local_iterator<__node_pointer>             local_iterator;
       typedef __hash_const_local_iterator<__node_pointer>       const_local_iterator;
        _LIBCPP_INLINE_VISIBILITY     __hash_table()         _NOEXCEPT_(             is_nothrow_default_constructible<__bucket_list>::value &&             is_nothrow_default_constructible<__first_node>::value &&             is_nothrow_default_constructible<__node_allocator>::value &&             is_nothrow_default_constructible<hasher>::value &&             is_nothrow_default_constructible<key_equal>::value);
       _LIBCPP_INLINE_VISIBILITY     __hash_table(const hasher& __hf, const key_equal& __eql);
       __hash_table(const hasher& __hf, const key_equal& __eql,                  const allocator_type& __a);
       explicit __hash_table(const allocator_type& __a);
       __hash_table(const __hash_table& __u);
       __hash_table(const __hash_table& __u, const allocator_type& __a);
     
#ifndef _LIBCPP_CXX03_LANG
    __hash_table(__hash_table&& __u)         _NOEXCEPT_(             is_nothrow_move_constructible<__bucket_list>::value &&             is_nothrow_move_constructible<__first_node>::value &&             is_nothrow_move_constructible<__node_allocator>::value &&             is_nothrow_move_constructible<hasher>::value &&             is_nothrow_move_constructible<key_equal>::value);
       __hash_table(__hash_table&& __u, const allocator_type& __a);
     
#endif  // _LIBCPP_CXX03_LANG
    ~__hash_table();
        __hash_table& operator=(const __hash_table& __u);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     __hash_table& operator=(__hash_table&& __u)         _NOEXCEPT_(             __node_traits::propagate_on_container_move_assignment::value &&             is_nothrow_move_assignable<__node_allocator>::value &&             is_nothrow_move_assignable<hasher>::value &&             is_nothrow_move_assignable<key_equal>::value);
     
#endif
    template <class _InputIterator>         void __assign_unique(_InputIterator __first, _InputIterator __last);
       template <class _InputIterator>         void __assign_multi(_InputIterator __first, _InputIterator __last);
        _LIBCPP_INLINE_VISIBILITY     size_type max_size() const _NOEXCEPT     {
           return std::min<size_type>(             __node_traits::max_size(__node_alloc()),             numeric_limits<difference_type >::max()         );
       }
        pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
       iterator             __node_insert_multi(__node_pointer __nd);
       iterator             __node_insert_multi(const_iterator __p,                                              __node_pointer __nd);
      
#ifndef _LIBCPP_CXX03_LANG
    template <class _Key, class ..._Args>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __emplace_unique_key_args(_Key const& __k, _Args&&... __args);
        template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);
        template <class _Pp>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __emplace_unique(_Pp&& __x) {
         return __emplace_unique_extract_key(_VSTD::forward<_Pp>(__x),                                           __can_extract_key<_Pp, key_type>());
       }
        template <class _First, class _Second>     _LIBCPP_INLINE_VISIBILITY     typename enable_if<         __can_extract_map_key<_First, key_type, __container_value_type>::value,         pair<iterator, bool>     >::type __emplace_unique(_First&& __f, _Second&& __s) {
           return __emplace_unique_key_args(__f, _VSTD::forward<_First>(__f),                                               _VSTD::forward<_Second>(__s));
       }
        template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __emplace_unique(_Args&&... __args) {
         return __emplace_unique_impl(_VSTD::forward<_Args>(__args)...);
       }
        template <class _Pp>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool>     __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
         return __emplace_unique_impl(_VSTD::forward<_Pp>(__x));
       }
       template <class _Pp>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool>     __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
         return __emplace_unique_key_args(__x, _VSTD::forward<_Pp>(__x));
       }
       template <class _Pp>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool>     __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
         return __emplace_unique_key_args(__x.first, _VSTD::forward<_Pp>(__x));
       }
        template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     iterator __emplace_multi(_Args&&... __args);
       template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);
         _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool>     __insert_unique(__container_value_type&& __x) {
         return __emplace_unique_key_args(_NodeTypes::__get_key(__x), _VSTD::move(__x));
       }
        template <class _Pp, class = typename enable_if<             !__is_same_uncvref<_Pp, __container_value_type>::value         >::type>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __insert_unique(_Pp&& __x) {
         return __emplace_unique(_VSTD::forward<_Pp>(__x));
       }
        template <class _Pp>     _LIBCPP_INLINE_VISIBILITY     iterator __insert_multi(_Pp&& __x) {
         return __emplace_multi(_VSTD::forward<_Pp>(__x));
       }
        template <class _Pp>     _LIBCPP_INLINE_VISIBILITY     iterator __insert_multi(const_iterator __p, _Pp&& __x) {
           return __emplace_hint_multi(__p, _VSTD::forward<_Pp>(__x));
       }
      
#else  // !defined(_LIBCPP_CXX03_LANG)
    template <class _Key, class _Args>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args& __args);
        iterator __insert_multi(const __container_value_type& __x);
       iterator __insert_multi(const_iterator __p, const __container_value_type& __x);
     
#endif
     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> __insert_unique(const __container_value_type& __x) {
           return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);
       }
        void clear() _NOEXCEPT;
       void rehash(size_type __n);
       _LIBCPP_INLINE_VISIBILITY void reserve(size_type __n)         {
  rehash(static_cast<size_type>(ceil(__n / max_load_factor())));
  }
        _LIBCPP_INLINE_VISIBILITY     size_type bucket_count() const _NOEXCEPT     {
           return __bucket_list_.get_deleter().size();
       }
        _LIBCPP_INLINE_VISIBILITY     iterator       begin() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     iterator       end() _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin() const _NOEXCEPT;
       _LIBCPP_INLINE_VISIBILITY     const_iterator end() const _NOEXCEPT;
        template <class _Key>         _LIBCPP_INLINE_VISIBILITY         size_type bucket(const _Key& __k) const         {
               _LIBCPP_ASSERT(bucket_count() > 0,                 "unordered container::bucket(key) called when bucket_count() == 0");
               return __constrain_hash(hash_function()(__k), bucket_count());
           }
        template <class _Key>         iterator       find(const _Key& __x);
       template <class _Key>         const_iterator find(const _Key& __x) const;
        typedef __hash_node_destructor<__node_allocator> _Dp;
       typedef unique_ptr<__node, _Dp> __node_holder;
        iterator erase(const_iterator __p);
       iterator erase(const_iterator __first, const_iterator __last);
       template <class _Key>         size_type __erase_unique(const _Key& __k);
       template <class _Key>         size_type __erase_multi(const _Key& __k);
       __node_holder remove(const_iterator __p) _NOEXCEPT;
        template <class _Key>         _LIBCPP_INLINE_VISIBILITY         size_type __count_unique(const _Key& __k) const;
       template <class _Key>         size_type __count_multi(const _Key& __k) const;
        template <class _Key>         pair<iterator, iterator>         __equal_range_unique(const _Key& __k);
       template <class _Key>         pair<const_iterator, const_iterator>         __equal_range_unique(const _Key& __k) const;
        template <class _Key>         pair<iterator, iterator>         __equal_range_multi(const _Key& __k);
       template <class _Key>         pair<const_iterator, const_iterator>         __equal_range_multi(const _Key& __k) const;
     _LIBCPP_INLINE_VISIBILITY     size_type max_bucket_count() const _NOEXCEPT         {
  return max_size();
   }
       size_type bucket_size(size_type __n) const;
       _LIBCPP_INLINE_VISIBILITY float load_factor() const _NOEXCEPT     {
           size_type __bc = bucket_count();
           return __bc != 0 ? (float)size() / __bc : 0.f;
       }
        _LIBCPP_INLINE_VISIBILITY     local_iterator     end(size_type __n)     {
           _LIBCPP_ASSERT(__n < bucket_count(),             "unordered container::end(n) called with n >= bucket_count()");
     
#if _LIBCPP_DEBUG_LEVEL >= 2
        return local_iterator(nullptr, __n, bucket_count(), this);
     
#else
        return local_iterator(nullptr, __n, bucket_count());
#endif
    }
      
#if _LIBCPP_DEBUG_LEVEL >= 2
     bool __dereferenceable(const const_iterator* __i) const;
       bool __decrementable(const const_iterator* __i) const;
       bool __addable(const const_iterator* __i, ptrdiff_t __n) const;
       bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;
      
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
 private:     void __rehash(size_type __n);
      
#ifndef _LIBCPP_CXX03_LANG
    template <class ..._Args>     __node_holder __construct_node(_Args&& ...__args);
        template <class _First, class ..._Rest>     __node_holder __construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest);
     
#else // _LIBCPP_CXX03_LANG
    __node_holder __construct_node(const __container_value_type& __v);
       __node_holder __construct_node_hash(size_t __hash, const __container_value_type& __v);
     
#endif
      _LIBCPP_INLINE_VISIBILITY     void __copy_assign_alloc(const __hash_table& __u)         {
  __copy_assign_alloc(__u, integral_constant<bool,              __node_traits::propagate_on_container_copy_assignment::value>());
  }
       void __copy_assign_alloc(const __hash_table& __u, true_type);
       _LIBCPP_INLINE_VISIBILITY         void __copy_assign_alloc(const __hash_table&, false_type) {
  }
      
#ifndef _LIBCPP_CXX03_LANG
    void __move_assign(__hash_table& __u, false_type);
       void __move_assign(__hash_table& __u, true_type)         _NOEXCEPT_(             is_nothrow_move_assignable<__node_allocator>::value &&             is_nothrow_move_assignable<hasher>::value &&             is_nothrow_move_assignable<key_equal>::value);
       _LIBCPP_INLINE_VISIBILITY         void __move_assign_alloc(__hash_table&, false_type) _NOEXCEPT {
  }
     
#endif // _LIBCPP_CXX03_LANG
     void __deallocate_node(__next_pointer __np) _NOEXCEPT;
       __next_pointer __detach() _NOEXCEPT;
        template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_map;
       template <class, class, class, class, class> friend class _LIBCPP_TEMPLATE_VIS unordered_multimap;
   };
    template <class _Tp, class _Hash, class _Equal, class _Alloc> inline __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()     _NOEXCEPT_(         is_nothrow_default_constructible<__bucket_list>::value &&         is_nothrow_default_constructible<__first_node>::value &&         is_nothrow_default_constructible<__node_allocator>::value &&         is_nothrow_default_constructible<hasher>::value &&         is_nothrow_default_constructible<key_equal>::value)     : __p2_(0),       __p3_(1.0f) {
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> inline __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,                                                        const key_equal& __eql)     : __bucket_list_(nullptr, __bucket_list_deleter()),       __p1_(),       __p2_(0, __hf),       __p3_(1.0f, __eql) {
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,                                                        const key_equal& __eql,                                                        const allocator_type& __a)     : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),       __p1_(__second_tag(), __node_allocator(__a)),       __p2_(0, __hf),       __p3_(1.0f, __eql) {
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)     : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),       __p1_(__second_tag(), __node_allocator(__a)),       __p2_(0),       __p3_(1.0f) {
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)     : __bucket_list_(nullptr,           __bucket_list_deleter(allocator_traits<__pointer_allocator>::               select_on_container_copy_construction(                   __u.__bucket_list_.get_deleter().__alloc()), 0)),       __p1_(__second_tag(), allocator_traits<__node_allocator>::           select_on_container_copy_construction(__u.__node_alloc())),       __p2_(0, __u.hash_function()),       __p3_(__u.__p3_) {
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,                                                        const allocator_type& __a)     : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),       __p1_(__second_tag(), __node_allocator(__a)),       __p2_(0, __u.hash_function()),       __p3_(__u.__p3_) {
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)         _NOEXCEPT_(             is_nothrow_move_constructible<__bucket_list>::value &&             is_nothrow_move_constructible<__first_node>::value &&             is_nothrow_move_constructible<__node_allocator>::value &&             is_nothrow_move_constructible<hasher>::value &&             is_nothrow_move_constructible<key_equal>::value)     : __bucket_list_(_VSTD::move(__u.__bucket_list_)),       __p1_(_VSTD::move(__u.__p1_)),       __p2_(_VSTD::move(__u.__p2_)),       __p3_(_VSTD::move(__u.__p3_)) {
       if (size() > 0)     {
           __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =             __p1_.first().__ptr();
           __u.__p1_.first().__next_ = nullptr;
           __u.size() = 0;
       }
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,                                                        const allocator_type& __a)     : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),       __p1_(__second_tag(), __node_allocator(__a)),       __p2_(0, _VSTD::move(__u.hash_function())),       __p3_(_VSTD::move(__u.__p3_)) {
       if (__a == allocator_type(__u.__node_alloc()))     {
           __bucket_list_.reset(__u.__bucket_list_.release());
           __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
           __u.__bucket_list_.get_deleter().size() = 0;
           if (__u.size() > 0)         {
               __p1_.first().__next_ = __u.__p1_.first().__next_;
               __u.__p1_.first().__next_ = nullptr;
               __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =                 __p1_.first().__ptr();
               size() = __u.size();
               __u.size() = 0;
           }
       }
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> __hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table() {
     
#if defined(_LIBCPP_CXX03_LANG)
    static_assert((is_copy_constructible<key_equal>::value),                  "Predicate must be copy-constructible.");
       static_assert((is_copy_constructible<hasher>::value),                  "Hasher must be copy-constructible.");
     
#endif
     __deallocate_node(__p1_.first().__next_);
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__erase_c(this);
     
#endif
}
    template <class _Tp, class _Hash, class _Equal, class _Alloc> void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(         const __hash_table& __u, true_type) {
       if (__node_alloc() != __u.__node_alloc())     {
           clear();
           __bucket_list_.reset();
           __bucket_list_.get_deleter().size() = 0;
       }
       __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();
       __node_alloc() = __u.__node_alloc();
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> __hash_table<_Tp, _Hash, _Equal, _Alloc>& __hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u) {
       if (this != &__u)     {
           __copy_assign_alloc(__u);
           hash_function() = __u.hash_function();
           key_eq() = __u.key_eq();
           max_load_factor() = __u.max_load_factor();
           __assign_multi(__u.begin(), __u.end());
       }
       return *this;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np)     _NOEXCEPT {
       __node_allocator& __na = __node_alloc();
       while (__np != nullptr)     {
           __next_pointer __next = __np->__next_;
     
#if _LIBCPP_DEBUG_LEVEL >= 2
        __c_node* __c = __get_db()->__find_c_and_lock(this);
           for (__i_node** __p = __c->end_;
   __p != __c->beg_;
   )         {
               --__p;
               iterator* __i = static_cast<iterator*>((*__p)->__i_);
               if (__i->__node_ == __np)             {
                   (*__p)->__c_ = nullptr;
                   if (--__c->end_ != __p)                     memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));
               }
           }
           __get_db()->unlock();
     
#endif
        __node_pointer __real_np = __np->__upcast();
           __node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__value_));
           __node_traits::deallocate(__na, __real_np, 1);
           __np = __next;
       }
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer __hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() _NOEXCEPT {
       size_type __bc = bucket_count();
       for (size_type __i = 0;
   __i < __bc;
   ++__i)         __bucket_list_[__i] = nullptr;
       size() = 0;
       __next_pointer __cache = __p1_.first().__next_;
       __p1_.first().__next_ = nullptr;
       return __cache;
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(         __hash_table& __u, true_type)     _NOEXCEPT_(         is_nothrow_move_assignable<__node_allocator>::value &&         is_nothrow_move_assignable<hasher>::value &&         is_nothrow_move_assignable<key_equal>::value) {
       clear();
       __bucket_list_.reset(__u.__bucket_list_.release());
       __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
       __u.__bucket_list_.get_deleter().size() = 0;
       __move_assign_alloc(__u);
       size() = __u.size();
       hash_function() = _VSTD::move(__u.hash_function());
       max_load_factor() = __u.max_load_factor();
       key_eq() = _VSTD::move(__u.key_eq());
       __p1_.first().__next_ = __u.__p1_.first().__next_;
       if (size() > 0)     {
           __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] =             __p1_.first().__ptr();
           if (bucket_count() != 0)         {
               __next_pointer __cache = __detach();
     
#ifndef _LIBCPP_NO_EXCEPTIONS
            try             {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
                const_iterator __i = __u.begin();
                   while (__cache != nullptr && __u.size() != 0)                 {
                       __cache->__upcast()->__value_ =                         _VSTD::move(__u.remove(__i++)->__value_);
                       __next_pointer __next = __cache->__next_;
                       __node_insert_multi(__cache->__upcast());
                       __cache = __next;
                   }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
            }
               catch (...)             {
                   __deallocate_node(__cache);
                   throw;
               }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            __deallocate_node(__cache);
           }
           const_iterator __i = __u.begin();
           while (__u.size() != 0)         {
               __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__value_));
               __node_insert_multi(__h.get());
               __h.release();
           }
       }
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> inline __hash_table<_Tp, _Hash, _Equal, _Alloc>& __hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)     _NOEXCEPT_(         __node_traits::propagate_on_container_move_assignment::value &&         is_nothrow_move_assignable<__node_allocator>::value &&         is_nothrow_move_assignable<hasher>::value &&         is_nothrow_move_assignable<key_equal>::value) {
       __move_assign(__u, integral_constant<bool,                   __node_traits::propagate_on_container_move_assignment::value>());
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _InputIterator> void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,                                                           _InputIterator __last) {
       typedef iterator_traits<_InputIterator> _ITraits;
       typedef typename _ITraits::value_type _ItValueType;
       static_assert((is_same<_ItValueType, __container_value_type>::value),                   "__assign_unique may only be called with the containers value type");
        if (bucket_count() != 0)     {
           __next_pointer __cache = __detach();
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            for (;
   __cache != nullptr && __first != __last;
   ++__first)             {
                   __cache->__upcast()->__value_ = *__first;
                   __next_pointer __next = __cache->__next_;
                   __node_insert_unique(__cache->__upcast());
                   __cache = __next;
               }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
               __deallocate_node(__cache);
               throw;
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        __deallocate_node(__cache);
       }
       for (;
   __first != __last;
   ++__first)         __insert_unique(*__first);
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _InputIterator> void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,                                                          _InputIterator __last) {
       typedef iterator_traits<_InputIterator> _ITraits;
       typedef typename _ITraits::value_type _ItValueType;
       static_assert((is_same<_ItValueType, __container_value_type>::value ||                   is_same<_ItValueType, __node_value_type>::value),                   "__assign_multi may only be called with the containers value type"                   " or the nodes value type");
       if (bucket_count() != 0)     {
           __next_pointer __cache = __detach();
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        try         {
     
#endif  // _LIBCPP_NO_EXCEPTIONS
            for (;
   __cache != nullptr && __first != __last;
   ++__first)             {
                   __cache->__upcast()->__value_ = *__first;
                   __next_pointer __next = __cache->__next_;
                   __node_insert_multi(__cache->__upcast());
                   __cache = __next;
               }
     
#ifndef _LIBCPP_NO_EXCEPTIONS
        }
           catch (...)         {
               __deallocate_node(__cache);
               throw;
           }
     
#endif  // _LIBCPP_NO_EXCEPTIONS
        __deallocate_node(__cache);
       }
       for (;
   __first != __last;
   ++__first)         __insert_multi(_NodeTypes::__get_value(*__first));
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> inline typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() _NOEXCEPT {
}
    template <class _Tp, class _Hash, class _Equal, class _Alloc> void __hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() _NOEXCEPT {
       if (size() > 0)     {
           __deallocate_node(__p1_.first().__next_);
           __p1_.first().__next_ = nullptr;
           size_type __bc = bucket_count();
           for (size_type __i = 0;
   __i < __bc;
   ++__i)             __bucket_list_[__i] = nullptr;
           size() = 0;
       }
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd) {
       __nd->__hash_ = hash_function()(__nd->__value_);
       size_type __bc = bucket_count();
       bool __inserted = false;
       __next_pointer __ndptr;
       size_t __chash;
       if (__bc != 0)     {
           __chash = __constrain_hash(__nd->__hash_, __bc);
           __ndptr = __bucket_list_[__chash];
           if (__ndptr != nullptr)         {
               for (__ndptr = __ndptr->__next_;
   __ndptr != nullptr &&                                              __constrain_hash(__ndptr->__hash(), __bc) == __chash;
                                                        __ndptr = __ndptr->__next_)             {
                   if (key_eq()(__ndptr->__upcast()->__value_, __nd->__value_))                     goto __done;
               }
           }
       }
       {
           if (size()+1 > __bc * max_load_factor() || __bc == 0)         {
               rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),                            size_type(ceil(float(size() + 1) / max_load_factor()))));
               __bc = bucket_count();
               __chash = __constrain_hash(__nd->__hash_, __bc);
           }
           // insert_after __bucket_list_[__chash], or __first_node if bucket is null
        __next_pointer __pn = __bucket_list_[__chash];
           if (__pn == nullptr)         {
               __nd->__next_ = __pn->__next_;
               __pn->__next_ = __nd->__ptr();
           }
           __ndptr = __nd->__ptr();
           // increment size
        ++size();
           __inserted = true;
       }
   __done:   
#if _LIBCPP_DEBUG_LEVEL >= 2
    return pair<iterator, bool>(iterator(__ndptr, this), __inserted);
     
#else
    return pair<iterator, bool>(iterator(__ndptr), __inserted);
     
#endif
}
    template <class _Tp, class _Hash, class _Equal, class _Alloc> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp) {
       __cp->__hash_ = hash_function()(__cp->__value_);
       size_type __bc = bucket_count();
       if (size()+1 > __bc * max_load_factor() || __bc == 0)     {
           rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),                        size_type(ceil(float(size() + 1) / max_load_factor()))));
           __bc = bucket_count();
       }
       size_t __chash = __constrain_hash(__cp->__hash_, __bc);
       __next_pointer __pn = __bucket_list_[__chash];
       if (__pn == nullptr)     {
           __pn =__p1_.first().__ptr();
           __cp->__next_ = __pn->__next_;
           __pn->__next_ = __cp->__ptr();
           // fix up __bucket_list_
        __bucket_list_[__chash] = __pn;
           if (__cp->__next_ != nullptr)             __bucket_list_[__constrain_hash(__cp->__next_->__hash(), __bc)]                 = __cp->__ptr();
       }
       else     {
           for (bool __found = false;
   __pn->__next_ != nullptr &&                                    __constrain_hash(__pn->__next_->__hash(), __bc) == __chash;
                                                              __pn = __pn->__next_)         {
           }
       }
       ++size();
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    return iterator(__cp->__ptr(), this);
     
#else
    return iterator(__cp->__ptr());
     
#endif
}
    template <class _Tp, class _Hash, class _Equal, class _Alloc> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(         const_iterator __p, __node_pointer __cp) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,         "unordered container::emplace_hint(const_iterator, args...) called with an iterator not"         " referring to this unordered container");
     
#endif
    if (__p != end() && key_eq()(*__p, __cp->__value_))     {
           __next_pointer __np = __p.__node_;
           __cp->__hash_ = __np->__hash();
           size_type __bc = bucket_count();
           if (size()+1 > __bc * max_load_factor() || __bc == 0)         {
               rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),                            size_type(ceil(float(size() + 1) / max_load_factor()))));
               __bc = bucket_count();
           }
           size_t __chash = __constrain_hash(__cp->__hash_, __bc);
           __next_pointer __pp = __bucket_list_[__chash];
           while (__pp->__next_ != __np)             __pp = __pp->__next_;
           __cp->__next_ = __np;
           __pp->__next_ = static_cast<__next_pointer>(__cp);
           ++size();
     
#if _LIBCPP_DEBUG_LEVEL >= 2
        return iterator(static_cast<__next_pointer>(__cp), this);
     
#else
        return iterator(static_cast<__next_pointer>(__cp));
     
#endif
    }
       return __node_insert_multi(__cp);
   }
        
#ifndef _LIBCPP_CXX03_LANG
template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key, class ..._Args> pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)   
#else
template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key, class _Args> pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args& __args)   
#endif
{
        size_t __hash = hash_function()(__k);
       size_type __bc = bucket_count();
       bool __inserted = false;
       __next_pointer __nd;
       size_t __chash;
       if (__bc != 0)     {
           __chash = __constrain_hash(__hash, __bc);
           __nd = __bucket_list_[__chash];
           if (__nd != nullptr)         {
               for (__nd = __nd->__next_;
   __nd != nullptr &&                 (__nd->__hash() == __hash || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                              __nd = __nd->__next_)             {
                   if (key_eq()(__nd->__upcast()->__value_, __k))                     goto __done;
               }
           }
       }
       {
     
#ifndef _LIBCPP_CXX03_LANG
        __node_holder __h = __construct_node_hash(__hash, _VSTD::forward<_Args>(__args)...);
     
#else
        __node_holder __h = __construct_node_hash(__hash, __args);
     
#endif
        if (size()+1 > __bc * max_load_factor() || __bc == 0)         {
               rehash(_VSTD::max<size_type>(2 * __bc + !__is_hash_power2(__bc),                            size_type(ceil(float(size() + 1) / max_load_factor()))));
               __bc = bucket_count();
           }
           __nd = static_cast<__next_pointer>(__h.release());
           // increment size
        ++size();
           __inserted = true;
       }
   __done:   
#if _LIBCPP_DEBUG_LEVEL >= 2
    return pair<iterator, bool>(iterator(__nd, this), __inserted);
     
#else
    return pair<iterator, bool>(iterator(__nd), __inserted);
     
#endif
}
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class... _Args> pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args&&... __args) {
       __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);
       pair<iterator, bool> __r = __node_insert_unique(__h.get());
       if (__r.second)         __h.release();
       return __r;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class... _Args> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args) {
       __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);
       iterator __r = __node_insert_multi(__h.get());
       __h.release();
       return __r;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class... _Args> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(         const_iterator __p, _Args&&... __args) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,         "unordered container::emplace_hint(const_iterator, args...) called with an iterator not"         " referring to this unordered container");
     
#endif
    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);
       iterator __r = __node_insert_multi(__p, __h.get());
       __h.release();
       return __r;
   }
      
#else // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const __container_value_type& __x) {
       __node_holder __h = __construct_node(__x);
       iterator __r = __node_insert_multi(__h.get());
       __h.release();
       return __r;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,                                                          const __container_value_type& __x) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,         "unordered container::insert(const_iterator, lvalue) called with an iterator not"         " referring to this unordered container");
     
#endif
    __node_holder __h = __construct_node(__x);
       iterator __r = __node_insert_multi(__p, __h.get());
       __h.release();
       return __r;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> void __hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n) {
       if (__n == 1)         __n = 2;
       else if (__n & (__n - 1))         __n = __next_prime(__n);
       size_type __bc = bucket_count();
       if (__n > __bc)         __rehash(__n);
       else if (__n < __bc)     {
           __n = _VSTD::max<size_type>               (                   __n,                   __is_hash_power2(__bc) ? __next_hash_pow2(size_t(ceil(float(size()) / max_load_factor()))) :                                            __next_prime(size_t(ceil(float(size()) / max_load_factor())))               );
           if (__n < __bc)             __rehash(__n);
       }
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__invalidate_all(this);
     
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();
       __bucket_list_.reset(__nbc > 0 ?                       __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);
       __bucket_list_.get_deleter().size() = __nbc;
       if (__nbc > 0)     {
           for (size_type __i = 0;
   __i < __nbc;
   ++__i)             __bucket_list_[__i] = nullptr;
           __next_pointer __pp = __p1_.first().__ptr();
           __next_pointer __cp = __pp->__next_;
           if (__cp != nullptr)         {
               size_type __chash = __constrain_hash(__cp->__hash(), __nbc);
               __bucket_list_[__chash] = __pp;
               size_type __phash = __chash;
               for (__pp = __cp, __cp = __cp->__next_;
   __cp != nullptr;
                                                              __cp = __pp->__next_)             {
                   __chash = __constrain_hash(__cp->__hash(), __nbc);
                   if (__chash == __phash)                     __pp = __cp;
                   else                 {
                       if (__bucket_list_[__chash] == nullptr)                     {
                           __bucket_list_[__chash] = __pp;
                           __pp = __cp;
                           __phash = __chash;
                       }
                       else                     {
                           __next_pointer __np = __cp;
                           for (;
   __np->__next_ != nullptr &&                                key_eq()(__cp->__upcast()->__value_,                                         __np->__next_->__upcast()->__value_);
                                                              __np = __np->__next_)                             ;
                           __pp->__next_ = __np->__next_;
                           __np->__next_ = __bucket_list_[__chash]->__next_;
                           __bucket_list_[__chash]->__next_ = __cp;
                        }
                   }
               }
           }
       }
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) {
       size_t __hash = hash_function()(__k);
       size_type __bc = bucket_count();
       if (__bc != 0)     {
           size_t __chash = __constrain_hash(__hash, __bc);
           __next_pointer __nd = __bucket_list_[__chash];
           if (__nd != nullptr)         {
               for (__nd = __nd->__next_;
   __nd != nullptr &&                 (__nd->__hash() == __hash                   || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                              __nd = __nd->__next_)             {
                   if ((__nd->__hash() == __hash)                     && key_eq()(__nd->__upcast()->__value_, __k))   
#if _LIBCPP_DEBUG_LEVEL >= 2
                    return iterator(__nd, this);
     
#else
                    return iterator(__nd);
     
#endif
            }
           }
       }
       return end();
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const {
       size_t __hash = hash_function()(__k);
       size_type __bc = bucket_count();
       if (__bc != 0)     {
           size_t __chash = __constrain_hash(__hash, __bc);
           __next_pointer __nd = __bucket_list_[__chash];
           if (__nd != nullptr)         {
               for (__nd = __nd->__next_;
   __nd != nullptr &&                 (__hash == __nd->__hash()                     || __constrain_hash(__nd->__hash(), __bc) == __chash);
                                                              __nd = __nd->__next_)             {
                   if ((__nd->__hash() == __hash)                     && key_eq()(__nd->__upcast()->__value_, __k))   
#if _LIBCPP_DEBUG_LEVEL >= 2
                    return const_iterator(__nd, this);
     
#else
                    return const_iterator(__nd);
     
#endif
            }
           }
        }
       return end();
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class ..._Args> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder __hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args) {
       static_assert(!__is_hash_value_type<_Args...>::value,                   "Construct cannot be called with a hash value type");
       __node_allocator& __na = __node_alloc();
       __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
       __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), _VSTD::forward<_Args>(__args)...);
       __h.get_deleter().__value_constructed = true;
       __h->__hash_ = hash_function()(__h->__value_);
       __h->__next_ = nullptr;
       return __h;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _First, class ..._Rest> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder __hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(     size_t __hash, _First&& __f, _Rest&& ...__rest) {
       static_assert(!__is_hash_value_type<_First, _Rest...>::value,                   "Construct cannot be called with a hash value type");
       __node_allocator& __na = __node_alloc();
       __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
       __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),                              _VSTD::forward<_First>(__f),                              _VSTD::forward<_Rest>(__rest)...);
       __h.get_deleter().__value_constructed = true;
       __h->__hash_ = __hash;
       __h->__next_ = nullptr;
       return __h;
   }
#endif  // _LIBCPP_CXX03_LANG
 template <class _Tp, class _Hash, class _Equal, class _Alloc> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator __hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p) {
       __next_pointer __np = __p.__node_;
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,         "unordered container erase(iterator) called with an iterator not"         " referring to this container");
       _LIBCPP_ASSERT(__p != end(),         "unordered container erase(iterator) called with a non-dereferenceable iterator");
       iterator __r(__np, this);
     
#else
    iterator __r(__np);
     
#endif
    ++__r;
       remove(__p);
       return __r;
}
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type __hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k) {
       iterator __i = find(__k);
       if (__i == end())         return 0;
       erase(__i);
       return 1;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type __hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k) {
       size_type __r = 0;
       iterator __i = find(__k);
       if (__i != end())     {
           iterator __e = end();
           do         {
               erase(__i++);
               ++__r;
           }
   while (__i != __e && key_eq()(*__i, __k));
       }
       return __r;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder __hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) _NOEXCEPT {
       // current node
    __next_pointer __cn = __p.__node_;
       size_type __bc = bucket_count();
       size_t __chash = __constrain_hash(__cn->__hash(), __bc);
       // find previous node
    __next_pointer __pn = __bucket_list_[__chash];
       for (;
   __pn->__next_ != __cn;
   __pn = __pn->__next_)         ;
    return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> inline typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type __hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const {
       return static_cast<size_type>(find(__k) != end());
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type __hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const {
       size_type __r = 0;
       const_iterator __i = find(__k);
       if (__i != end())     {
           const_iterator __e = end();
           do         {
               ++__i;
               ++__r;
           }
   while (__i != __e && key_eq()(*__i, __k));
       }
       return __r;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,      typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(         const _Key& __k) {
       iterator __i = find(__k);
       iterator __j = __i;
       if (__i != end())         ++__j;
       return pair<iterator, iterator>(__i, __j);
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,      typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(         const _Key& __k) const {
       const_iterator __i = find(__k);
       const_iterator __j = __i;
       if (__i != end())         ++__j;
       return pair<const_iterator, const_iterator>(__i, __j);
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,      typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(         const _Key& __k) {
       iterator __i = find(__k);
       iterator __j = __i;
       if (__i != end())     {
           iterator __e = end();
           do         {
               ++__j;
           }
   while (__j != __e && key_eq()(*__j, __k));
       }
       return pair<iterator, iterator>(__i, __j);
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> template <class _Key> pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,      typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator> __hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(         const _Key& __k) const {
       const_iterator __i = find(__k);
       const_iterator __j = __i;
       if (__i != end())     {
           const_iterator __e = end();
           do         {
               ++__j;
           }
   while (__j != __e && key_eq()(*__j, __k));
       }
       return pair<const_iterator, const_iterator>(__i, __j);
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->swap(this, &__u);
     
#endif
}
    template <class _Tp, class _Hash, class _Equal, class _Alloc> typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type __hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const {
       _LIBCPP_ASSERT(__n < bucket_count(),         "unordered container::bucket_size(n) called with n >= bucket_count()");
       __next_pointer __np = __bucket_list_[__n];
       size_type __bc = bucket_count();
       size_type __r = 0;
       if (__np != nullptr)     {
           for (__np = __np->__next_;
   __np != nullptr &&                                    __constrain_hash(__np->__hash(), __bc) == __n;
                                                       __np = __np->__next_, ++__r)             ;
       }
       return __r;
   }
    template <class _Tp, class _Hash, class _Equal, class _Alloc> inline _LIBCPP_INLINE_VISIBILITY void swap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,      __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
      
#if _LIBCPP_DEBUG_LEVEL >= 2
 template <class _Tp, class _Hash, class _Equal, class _Alloc> bool __hash_table<_Tp, _Hash, _Equal, _Alloc>::__dereferenceable(const const_iterator* __i) const {
   private:     _LIBCPP_HIDDEN     __i_node* __insert_iterator(void* __i);
       _LIBCPP_HIDDEN     __i_node* __find_iterator(const void* __i) const;
        friend _LIBCPP_FUNC_VIS __libcpp_db* __get_db();
   };
    _LIBCPP_FUNC_VIS __libcpp_db* __get_db();
   _LIBCPP_FUNC_VIS const __libcpp_db* __get_const_db();
       
#endif // _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Key, class _Cp, class _Hash, bool _IsEmpty> class __unordered_map_hasher     : private _Hash {
   public:     _LIBCPP_INLINE_VISIBILITY     __unordered_map_hasher()         _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)         : _Hash() {
  }
       _LIBCPP_INLINE_VISIBILITY     __unordered_map_hasher(const _Hash& __h)         _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)         : _Hash(__h) {
  }
       _LIBCPP_INLINE_VISIBILITY     const _Hash& hash_function() const _NOEXCEPT {
  return *this;
  }
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(const _Cp& __x) const         {
       }
   };
    template <class _Key, class _Cp, class _Hash> class __unordered_map_hasher<_Key, _Cp, _Hash, false> {
       _Hash __hash_;
   public:     _LIBCPP_INLINE_VISIBILITY     __unordered_map_hasher()         _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)         : __hash_() {
  }
       _LIBCPP_INLINE_VISIBILITY     __unordered_map_hasher(const _Hash& __h)         _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)         : __hash_(__h) {
  }
       _LIBCPP_INLINE_VISIBILITY     const _Hash& hash_function() const _NOEXCEPT {
  return __hash_;
  }
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(const _Cp& __x) const         {
  return __hash_(__x.__cc.first);
  }
       _LIBCPP_INLINE_VISIBILITY     size_t operator()(const _Key& __x) const         {
  return __hash_(__x);
  }
       void swap(__unordered_map_hasher&__y)         _NOEXCEPT_(__is_nothrow_swappable<_Hash>::value)     {
           using _VSTD::swap;
           swap(__hash_, __y.__hash_);
       }
   };
    template <class _Key, class _Cp, class _Hash, bool __b> inline _LIBCPP_INLINE_VISIBILITY void swap(__unordered_map_hasher<_Key, _Cp, _Hash, __b>& __x,      __unordered_map_hasher<_Key, _Cp, _Hash, __b>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    template <class _Key, class _Cp, class _Pred, bool _IsEmpty> class __unordered_map_equal     : private _Pred {
   public:     _LIBCPP_INLINE_VISIBILITY     __unordered_map_equal()         _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)         : _Pred() {
  }
       _LIBCPP_INLINE_VISIBILITY     __unordered_map_equal(const _Pred& __p)         _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)         : _Pred(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     const _Pred& key_eq() const _NOEXCEPT {
  return *this;
  }
       _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Cp& __x, const _Cp& __y) const         {
  return static_cast<const _Pred&>(*this)(__x.__cc.first, __y.__cc.first);
  }
       _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Cp& __x, const _Key& __y) const         {
       }
   };
    template <class _Key, class _Cp, class _Pred> class __unordered_map_equal<_Key, _Cp, _Pred, false> {
       _Pred __pred_;
   public:     _LIBCPP_INLINE_VISIBILITY     __unordered_map_equal()         _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)         : __pred_() {
  }
       _LIBCPP_INLINE_VISIBILITY     __unordered_map_equal(const _Pred& __p)         _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)         : __pred_(__p) {
  }
       _LIBCPP_INLINE_VISIBILITY     const _Pred& key_eq() const _NOEXCEPT {
  return __pred_;
  }
       _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Cp& __x, const _Cp& __y) const         {
  return __pred_(__x.__cc.first, __y.__cc.first);
  }
       _LIBCPP_INLINE_VISIBILITY     bool operator()(const _Cp& __x, const _Key& __y) const         {
  return __pred_(__x.__cc.first, __y);
       }
   };
    template <class _Key, class _Cp, class _Pred, bool __b> inline _LIBCPP_INLINE_VISIBILITY void swap(__unordered_map_equal<_Key, _Cp, _Pred, __b>& __x,      __unordered_map_equal<_Key, _Cp, _Pred, __b>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    template <class _Alloc> class __hash_map_node_destructor {
       typedef _Alloc                              allocator_type;
       typedef allocator_traits<allocator_type>    __alloc_traits;
    public:      typedef typename __alloc_traits::pointer       pointer;
   private:      allocator_type& __na_;
        __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);
    public:     bool __first_constructed;
       bool __second_constructed;
        _LIBCPP_INLINE_VISIBILITY     explicit __hash_map_node_destructor(allocator_type& __na) _NOEXCEPT         : __na_(__na),           __first_constructed(false),           __second_constructed(false)         {
  }
      
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)         _NOEXCEPT         : __na_(__x.__na_),           __first_constructed(__x.__value_constructed),           __second_constructed(__x.__value_constructed)         {
               __x.__value_constructed = false;
           }
     
#else  // _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)         : __na_(__x.__na_),           __first_constructed(__x.__value_constructed),           __second_constructed(__x.__value_constructed)         {
               const_cast<bool&>(__x.__value_constructed) = false;
           }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     void operator()(pointer __p) _NOEXCEPT     {
           if (__second_constructed)             __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));
           if (__first_constructed)             __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));
           if (__p)             __alloc_traits::deallocate(__na_, __p, 1);
       }
   };
      
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Tp> union __hash_value_type {
       typedef _Key                                     key_type;
       typedef _Tp                                      mapped_type;
    private:     __hash_value_type(const __hash_value_type& __v) = delete;
       __hash_value_type(__hash_value_type&& __v) = delete;
       template <class ..._Args>     explicit __hash_value_type(_Args&& ...__args) = delete;
        ~__hash_value_type() = delete;
   };
      
#else
#endif
 template <class _HashIterator> class _LIBCPP_TEMPLATE_VIS __hash_map_iterator {
       _HashIterator __i_;
        typedef  __hash_node_types_from_iterator<_HashIterator> _NodeTypes;
    public:     typedef forward_iterator_tag                                 iterator_category;
       typedef typename _NodeTypes::__map_value_type                value_type;
       typedef typename _NodeTypes::difference_type                 difference_type;
       typedef value_type&                                          reference;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_iterator;
       template <class> friend class _LIBCPP_TEMPLATE_VIS __hash_const_local_iterator;
   };
    template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,           class _Alloc = allocator<pair<const _Key, _Tp> > > class _LIBCPP_TEMPLATE_VIS unordered_map {
   public:     // types
    typedef _Key                                           key_type;
       typedef _Tp                                            mapped_type;
       typedef _Hash                                          hasher;
       typedef _Pred                                          key_equal;
       typedef _Alloc                                         allocator_type;
       typedef pair<const key_type, mapped_type>              value_type;
       typedef pair<key_type, mapped_type>                    __nc_value_type;
       typedef value_type&                                    reference;
       typedef const value_type&                              const_reference;
       static_assert((is_same<value_type, typename allocator_type::value_type>::value),                   "Invalid allocator::value_type");
    private:     typedef __hash_value_type<key_type, mapped_type>                 __value_type;
       typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;
       typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;
       typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,                                                  __value_type>::type __allocator_type;
        typedef __hash_table<__value_type, __hasher,                          __key_equal,  __allocator_type>   __table;
        __table __table_;
        typedef typename __table::_NodeTypes                   _NodeTypes;
       typedef typename __table::__node_pointer               __node_pointer;
       typedef typename __table::__node_const_pointer         __node_const_pointer;
       typedef typename __table::__node_traits                __node_traits;
       typedef typename __table::__node_allocator             __node_allocator;
       typedef typename __table::__node                       __node;
       typedef __hash_map_node_destructor<__node_allocator>   _Dp;
       typedef unique_ptr<__node, _Dp>                         __node_holder;
       typedef allocator_traits<allocator_type>               __alloc_traits;
        static_assert((is_same<typename __table::__container_value_type, value_type>::value), "");
       static_assert((is_same<typename __table::__node_value_type, __value_type>::value), "");
   public:     typedef typename __alloc_traits::pointer         pointer;
       typedef typename __alloc_traits::const_pointer   const_pointer;
       typedef typename __table::size_type              size_type;
       typedef typename __table::difference_type        difference_type;
        typedef __hash_map_iterator<typename __table::iterator>       iterator;
       typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
       typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
       typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;
        _LIBCPP_INLINE_VISIBILITY     unordered_map()         _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)         {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
            __get_db()->__insert_c(this);
     
#endif
        }
       explicit unordered_map(size_type __n, const hasher& __hf = hasher(),                            const key_equal& __eql = key_equal());
       unordered_map(size_type __n, const hasher& __hf,                   const key_equal& __eql,                   const allocator_type& __a);
       template <class _InputIterator>         unordered_map(_InputIterator __first, _InputIterator __last);
       template <class _InputIterator>         unordered_map(_InputIterator __first, _InputIterator __last,                       size_type __n, const hasher& __hf = hasher(),                       const key_equal& __eql = key_equal());
       template <class _InputIterator>         unordered_map(_InputIterator __first, _InputIterator __last,                       size_type __n, const hasher& __hf,                       const key_equal& __eql,                       const allocator_type& __a);
       _LIBCPP_INLINE_VISIBILITY     explicit unordered_map(const allocator_type& __a);
       unordered_map(const unordered_map& __u);
       unordered_map(const unordered_map& __u, const allocator_type& __a);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     unordered_map(unordered_map&& __u)         _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
       unordered_map(unordered_map&& __u, const allocator_type& __a);
       unordered_map(initializer_list<value_type> __il);
       unordered_map(initializer_list<value_type> __il, size_type __n,                   const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
       _LIBCPP_INLINE_VISIBILITY     unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf,        const allocator_type& __a)       : unordered_map(__il, __n, __hf, key_equal(), __a) {
  }
     
#endif
    // ~unordered_map() = default;
    _LIBCPP_INLINE_VISIBILITY     unordered_map& operator=(const unordered_map& __u)     {
     
#ifndef _LIBCPP_CXX03_LANG
        __table_ = __u.__table_;
     
#else
        if (this != &__u) {
               __table_.clear();
               __table_.hash_function() = __u.__table_.hash_function();
               __table_.key_eq() = __u.__table_.key_eq();
               __table_.max_load_factor() = __u.__table_.max_load_factor();
               __table_.__copy_assign_alloc(__u.__table_);
               insert(__u.begin(), __u.end());
           }
     
#endif
        return *this;
       }
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     unordered_map& operator=(unordered_map&& __u)         _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
       _LIBCPP_INLINE_VISIBILITY     unordered_map& operator=(initializer_list<value_type> __il);
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     allocator_type get_allocator() const _NOEXCEPT         {
  return allocator_type(__table_.__node_alloc());
  }
        _LIBCPP_INLINE_VISIBILITY     bool      empty() const _NOEXCEPT {
  return __table_.size() == 0;
  }
       _LIBCPP_INLINE_VISIBILITY     size_type size() const _NOEXCEPT  {
  return __table_.size();
  }
       _LIBCPP_INLINE_VISIBILITY     size_type max_size() const _NOEXCEPT {
  return __table_.max_size();
  }
        _LIBCPP_INLINE_VISIBILITY     iterator       begin() _NOEXCEPT        {
  return __table_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY     iterator       end() _NOEXCEPT          {
  return __table_.end();
  }
        iterator insert(const_iterator __p, const value_type& __x) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,             "unordered_map::insert(const_iterator, const value_type&) called with an iterator not"             " referring to this unordered_map");
     
#else
        ((void)__p);
       }
        template <class _Pp,               class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>         _LIBCPP_INLINE_VISIBILITY         pair<iterator, bool> insert(_Pp&& __x)             {
  return __table_.__insert_unique(_VSTD::forward<_Pp>(__x));
  }
        template <class _Pp,               class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>         _LIBCPP_INLINE_VISIBILITY         iterator insert(const_iterator __p, _Pp&& __x)         {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,                 "unordered_map::insert(const_iterator, value_type&&) called with an iterator not"                 " referring to this unordered_map");
     
#else
          ((void)__p);
     
#endif
            return insert(_VSTD::forward<_Pp>(__x)).first;
           }
        template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     pair<iterator, bool> emplace(_Args&&... __args) {
           return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...);
       }
        template <class... _Args>     _LIBCPP_INLINE_VISIBILITY     iterator emplace_hint(const_iterator __p, _Args&&... __args) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,             "unordered_map::emplace_hint(const_iterator, args...) called with an iterator not"             " referring to this unordered_map");
     
#else
          ((void)__p);
     
#endif
        return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;
       }
      
#endif  // _LIBCPP_CXX03_LANG
   
#if _LIBCPP_STD_VER > 14
    template <class... _Args>         _LIBCPP_INLINE_VISIBILITY         pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)     {
           return __table_.__emplace_unique_key_args(__k, _VSTD::piecewise_construct,             _VSTD::forward_as_tuple(__k),             _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));
       }
        template <class... _Args>         _LIBCPP_INLINE_VISIBILITY         pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)     {
           return __table_.__emplace_unique_key_args(__k, _VSTD::piecewise_construct,             _VSTD::forward_as_tuple(_VSTD::move(__k)),             _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...));
       }
        template <class... _Args>         _LIBCPP_INLINE_VISIBILITY         iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)     {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__h) == this,             "unordered_map::try_emplace(const_iterator, key, args...) called with an iterator not"             " referring to this unordered_map");
     
#else
        ((void)__h);
     
#endif
        return try_emplace(__k, _VSTD::forward<_Args>(__args)...).first;
       }
        template <class... _Args>         _LIBCPP_INLINE_VISIBILITY         iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)     {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
        _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__h) == this,             "unordered_map::try_emplace(const_iterator, key, args...) called with an iterator not"             " referring to this unordered_map");
     
#else
        ((void)__h);
     
#endif
        return try_emplace(_VSTD::move(__k), _VSTD::forward<_Args>(__args)...).first;
       }
        template <class _Vp>         _LIBCPP_INLINE_VISIBILITY         pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)     {
          return insert_or_assign(__k, _VSTD::forward<_Vp>(__v)).first;
        }
        template <class _Vp>         _LIBCPP_INLINE_VISIBILITY         iterator insert_or_assign(const_iterator, key_type&& __k, _Vp&& __v)      {
           // FIXME: Add debug mode checking for the iterator input
        return insert_or_assign(_VSTD::move(__k), _VSTD::forward<_Vp>(__v)).first;
        }
     
#endif // _LIBCPP_STD_VER > 14
     _LIBCPP_INLINE_VISIBILITY     iterator erase(const_iterator __p) {
  return __table_.erase(__p.__i_);
  }
       _LIBCPP_INLINE_VISIBILITY     iterator erase(iterator __p)       {
  return __table_.erase(__p.__i_);
  }
       _LIBCPP_INLINE_VISIBILITY     size_type erase(const key_type& __k) {
  }
        mapped_type& operator[](const key_type& __k);
     
#ifndef _LIBCPP_CXX03_LANG
    mapped_type& operator[](key_type&& __k);
     
#endif
     mapped_type&       at(const key_type& __k);
       const mapped_type& at(const key_type& __k) const;
        _LIBCPP_INLINE_VISIBILITY     size_type bucket_count() const _NOEXCEPT {
  return __table_.bucket_count();
  }
       _LIBCPP_INLINE_VISIBILITY     size_type max_bucket_count() const _NOEXCEPT {
  return __table_.max_bucket_count();
  }
        _LIBCPP_INLINE_VISIBILITY     size_type bucket_size(size_type __n) const         {
  }
       _LIBCPP_INLINE_VISIBILITY     void rehash(size_type __n) {
  __table_.rehash(__n);
  }
       _LIBCPP_INLINE_VISIBILITY     void reserve(size_type __n) {
  __table_.reserve(__n);
  }
      
#if _LIBCPP_DEBUG_LEVEL >= 2
     bool __dereferenceable(const const_iterator* __i) const         {
  return __table_.__dereferenceable(&__i->__i_);
  }
       bool __decrementable(const const_iterator* __i) const         {
  return __table_.__decrementable(&__i->__i_);
  }
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
 private:    
#ifdef _LIBCPP_CXX03_LANG
    __node_holder __construct_node_with_key(const key_type& __k);
     
#endif
};
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(         size_type __n, const hasher& __hf, const key_equal& __eql)     : __table_(__hf, __eql) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(         const allocator_type& __a)     : __table_(typename __table::allocator_type(__a)) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
}
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(         _InputIterator __first, _InputIterator __last) {
       insert(__first, __last);
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(         const unordered_map& __u)     : __table_(__u.__table_) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__u.bucket_count());
       insert(__u.begin(), __u.end());
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(         const unordered_map& __u, const allocator_type& __a)     : __table_(__u.__table_, typename __table::allocator_type(__a)) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__u.bucket_count());
       insert(__u.begin(), __u.end());
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(         unordered_map&& __u)     _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)     : __table_(_VSTD::move(__u.__table_)) {
}
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> _Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k) {
       iterator __i = find(__k);
       if (__i != end())         return __i->second;
       __node_holder __h = __construct_node_with_key(__k);
       pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
       __h.release();
    if (__i == end())         throw out_of_range("unordered_map::at: key not found");
     
#endif  // _LIBCPP_NO_EXCEPTIONS
    return __i->second;
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> const _Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const {
       const_iterator __i = find(__k);
   }
    template <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,           class _Alloc = allocator<pair<const _Key, _Tp> > > class _LIBCPP_TEMPLATE_VIS unordered_multimap {
   public:     // types
    typedef _Key                                           key_type;
       typedef _Tp                                            mapped_type;
       typedef _Hash                                          hasher;
       typedef _Pred                                          key_equal;
       typedef _Alloc                                         allocator_type;
       typedef pair<const key_type, mapped_type>              value_type;
       typedef pair<key_type, mapped_type>                    __nc_value_type;
       typedef value_type&                                    reference;
       typedef const value_type&                              const_reference;
       static_assert((is_same<value_type, typename allocator_type::value_type>::value),                   "Invalid allocator::value_type");
    private:     typedef __hash_value_type<key_type, mapped_type>                 __value_type;
       typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;
       typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;
       typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,                                                  __value_type>::type __allocator_type;
        typedef __hash_table<__value_type, __hasher,                          __key_equal,  __allocator_type>   __table;
        __table __table_;
        typedef typename __table::_NodeTypes                   _NodeTypes;
       typedef typename __table::__node_traits                __node_traits;
       typedef typename __table::__node_allocator             __node_allocator;
       typedef typename __table::__node                       __node;
       typedef __hash_map_node_destructor<__node_allocator>   _Dp;
       typedef unique_ptr<__node, _Dp>                         __node_holder;
       typedef allocator_traits<allocator_type>               __alloc_traits;
       static_assert((is_same<typename __node_traits::size_type,                           typename __alloc_traits::size_type>::value),                  "Allocator uses different size_type for different types");
   public:     typedef typename __alloc_traits::pointer         pointer;
       typedef typename __alloc_traits::const_pointer   const_pointer;
       typedef typename __table::size_type              size_type;
       typedef typename __table::difference_type        difference_type;
        typedef __hash_map_iterator<typename __table::iterator>       iterator;
       typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
       typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
       typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;
        _LIBCPP_INLINE_VISIBILITY     unordered_multimap()         _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)         {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
            __get_db()->__insert_c(this);
     
#endif
        }
       explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),                                 const key_equal& __eql = key_equal());
       unordered_multimap(size_type __n, const hasher& __hf,                                 const key_equal& __eql,                                 const allocator_type& __a);
       template <class _InputIterator>         unordered_multimap(_InputIterator __first, _InputIterator __last);
       template <class _InputIterator>         unordered_multimap(_InputIterator __first, _InputIterator __last,                       size_type __n, const hasher& __hf = hasher(),                       const key_equal& __eql = key_equal());
       template <class _InputIterator>         unordered_multimap(_InputIterator __first, _InputIterator __last,                       size_type __n, const hasher& __hf,                       const key_equal& __eql,                       const allocator_type& __a);
       _LIBCPP_INLINE_VISIBILITY     explicit unordered_multimap(const allocator_type& __a);
       unordered_multimap(const unordered_multimap& __u);
       unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     unordered_multimap(unordered_multimap&& __u)         _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
       unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);
       unordered_multimap(initializer_list<value_type> __il);
       unordered_multimap(initializer_list<value_type> __il, size_type __n,                        const hasher& __hf = hasher(),                        const key_equal& __eql = key_equal());
       unordered_multimap(initializer_list<value_type> __il, size_type __n,                        const hasher& __hf, const key_equal& __eql,                        const allocator_type& __a);
     
#endif  // _LIBCPP_CXX03_LANG
  
#if _LIBCPP_STD_VER > 11
       _LIBCPP_INLINE_VISIBILITY     unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)       : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {
  }
       _LIBCPP_INLINE_VISIBILITY     unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf,        const allocator_type& __a)       : unordered_multimap(__il, __n, __hf, key_equal(), __a) {
  }
     
#endif
    // ~unordered_multimap() = default;
    _LIBCPP_INLINE_VISIBILITY     unordered_multimap& operator=(const unordered_multimap& __u)     {
        return *this;
       }
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     unordered_multimap& operator=(unordered_multimap&& __u)         _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
       _LIBCPP_INLINE_VISIBILITY     unordered_multimap& operator=(initializer_list<value_type> __il);
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     allocator_type get_allocator() const _NOEXCEPT         {
  return allocator_type(__table_.__node_alloc());
  }
        _LIBCPP_INLINE_VISIBILITY     bool      empty() const _NOEXCEPT {
  return __table_.size() == 0;
  }
       _LIBCPP_INLINE_VISIBILITY     size_type size() const _NOEXCEPT  {
  return __table_.size();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator cbegin() const _NOEXCEPT {
  return __table_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator cend()   const _NOEXCEPT {
  return __table_.end();
  }
        _LIBCPP_INLINE_VISIBILITY     iterator insert(const value_type& __x) {
  return __table_.__insert_multi(__x);
  }
        _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p, const value_type& __x)         {
  return __table_.__insert_multi(__p.__i_, __x);
  }
        template <class _InputIterator>     _LIBCPP_INLINE_VISIBILITY     void insert(_InputIterator __first, _InputIterator __last);
      
#ifndef _LIBCPP_CXX03_LANG
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
  };
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(         size_type __n, const hasher& __hf, const key_equal& __eql)     : __table_(__hf, __eql) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(         _InputIterator __first, _InputIterator __last) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    insert(__first, __last);
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(         _InputIterator __first, _InputIterator __last, size_type __n,         const hasher& __hf, const key_equal& __eql)     : __table_(__hf, __eql) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
       insert(__first, __last);
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(         _InputIterator __first, _InputIterator __last, size_type __n,         const hasher& __hf, const key_equal& __eql, const allocator_type& __a)     : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
     
   }
      
#ifndef _LIBCPP_CXX03_LANG
 template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(         unordered_multimap&& __u)     _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)     : __table_(_VSTD::move(__u.__table_)) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
       __get_db()->swap(this, &__u);
     
#endif
}
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(         unordered_multimap&& __u, const allocator_type& __a)     : __table_(_VSTD::move(__u.__table_), typename __table::allocator_type(__a)) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    if (__a != __u.get_allocator())     {
           iterator __i = __u.begin();
           while (__u.size() != 0)         {
               __table_.__insert_multi(                       _VSTD::move(__u.__table_.remove((__i++).__i_)->__value_.__nc)                                    );
           }
       }
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    else         __get_db()->swap(this, &__u);
     
#endif
}
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(         initializer_list<value_type> __il) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    insert(__il.begin(), __il.end());
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(         initializer_list<value_type> __il, size_type __n, const hasher& __hf,         const key_equal& __eql)     : __table_(__hf, __eql) {
     
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
       insert(__il.begin(), __il.end());
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)     _NOEXCEPT_(is_nothrow_move_assignable<__table>::value) {
       __table_ = _VSTD::move(__u.__table_);
       return *this;
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(         initializer_list<value_type> __il) {
       __table_.__assign_multi(__il.begin(), __il.end());
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
   template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> inline void unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,                                                             _InputIterator __last) {
       for (;
   __first != __last;
   ++__first)         __table_.__insert_multi(*__first);
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline _LIBCPP_INLINE_VISIBILITY void swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,      unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,            const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
       if (__x.size() != __y.size())         return false;
       typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator                                                                  const_iterator;
       typedef pair<const_iterator, const_iterator> _EqRng;
       return true;
   }
    template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,            const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
       return !(__x == __y);
   }
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_UNORDERED_MAP
  
#pragma clang module end /*std.unordered_map*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "unordered_set"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.unordered_set
// -*- C++ -*-
//===-------------------------- unordered_set -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_UNORDERED_SET
  
#define _LIBCPP_UNORDERED_SET
 /*      unordered_set synopsis    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,           class _Alloc = allocator<_Value> > class _LIBCPP_TEMPLATE_VIS unordered_set {
   public:     // types
    typedef _Value                                                     key_type;
       typedef key_type                                                   value_type;
       typedef _Hash                                                      hasher;
       typedef _Pred                                                      key_equal;
       typedef _Alloc                                                     allocator_type;
       typedef value_type&                                                reference;
       typedef const value_type&                                          const_reference;
       static_assert((is_same<value_type, typename allocator_type::value_type>::value),                   "Invalid allocator::value_type");
    private:     typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;
        __table __table_;
    public:     typedef typename __table::pointer         pointer;
       typedef typename __table::const_pointer   const_pointer;
       typedef typename __table::size_type       size_type;
       typedef typename __table::difference_type difference_type;
        typedef typename __table::const_iterator       iterator;
       typedef typename __table::const_iterator       const_iterator;
       typedef typename __table::const_local_iterator local_iterator;
       typedef typename __table::const_local_iterator const_local_iterator;
        _LIBCPP_INLINE_VISIBILITY     unordered_set()         _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)         {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
            __get_db()->__insert_c(this);
     
#endif
        }
       explicit unordered_set(size_type __n, const hasher& __hf = hasher(),                            const key_equal& __eql = key_equal());
     
#if _LIBCPP_STD_VER > 11
    inline _LIBCPP_INLINE_VISIBILITY     unordered_set(size_type __n, const allocator_type& __a)         : unordered_set(__n, hasher(), key_equal(), __a) {
  }
       inline _LIBCPP_INLINE_VISIBILITY     unordered_set(size_type __n, const hasher& __hf, const allocator_type& __a)         : unordered_set(__n, __hf, key_equal(), __a) {
  }
     
#endif
    unordered_set(size_type __n, const hasher& __hf, const key_equal& __eql,                   const allocator_type& __a);
       template <class _InputIterator>         unordered_set(_InputIterator __first, _InputIterator __last);
       template <class _InputIterator>         unordered_set(_InputIterator __first, _InputIterator __last,                       size_type __n, const hasher& __hf = hasher(),                       const key_equal& __eql = key_equal());
       template <class _InputIterator>         unordered_set(_InputIterator __first, _InputIterator __last,                       size_type __n, const hasher& __hf, const key_equal& __eql,                       const allocator_type& __a);
     
    _LIBCPP_INLINE_VISIBILITY     explicit unordered_set(const allocator_type& __a);
       unordered_set(const unordered_set& __u);
       unordered_set(const unordered_set& __u, const allocator_type& __a);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     unordered_set(unordered_set&& __u)         _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
       unordered_set(unordered_set&& __u, const allocator_type& __a);
       unordered_set(initializer_list<value_type> __il);
       unordered_set(initializer_list<value_type> __il, size_type __n,                   const hasher& __hf = hasher(),                   const key_equal& __eql = key_equal());
       unordered_set(initializer_list<value_type> __il, size_type __n,                   const hasher& __hf, const key_equal& __eql,                   const allocator_type& __a);
     
#if _LIBCPP_STD_VER > 11
    inline _LIBCPP_INLINE_VISIBILITY     unordered_set(initializer_list<value_type> __il, size_type __n,                                                       const allocator_type& __a)         : unordered_set(__il, __n, hasher(), key_equal(), __a) {
  }
       inline _LIBCPP_INLINE_VISIBILITY     unordered_set(initializer_list<value_type> __il, size_type __n,                                    const hasher& __hf, const allocator_type& __a)         : unordered_set(__il, __n, __hf, key_equal(), __a) {
  }
     
#endif
  
#endif  // _LIBCPP_CXX03_LANG
    // ~unordered_set() = default;
    _LIBCPP_INLINE_VISIBILITY     unordered_set& operator=(const unordered_set& __u)     {
           __table_ = __u.__table_;
           return *this;
       }
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     unordered_set& operator=(unordered_set&& __u)         _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
       _LIBCPP_INLINE_VISIBILITY     unordered_set& operator=(initializer_list<value_type> __il);
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     allocator_type get_allocator() const _NOEXCEPT         {
  return allocator_type(__table_.__node_alloc());
  }
        _LIBCPP_INLINE_VISIBILITY     bool      empty() const _NOEXCEPT {
  return __table_.size() == 0;
  }
       _LIBCPP_INLINE_VISIBILITY     size_type size() const _NOEXCEPT  {
  return __table_.size();
  return __table_.end();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator begin()  const _NOEXCEPT {
  return __table_.begin();
  }
       _LIBCPP_INLINE_VISIBILITY     const_iterator end()    const _NOEXCEPT {
  return __table_.end();
  }
    template <class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         void insert(_InputIterator __first, _InputIterator __last);
        _LIBCPP_INLINE_VISIBILITY     iterator erase(const_iterator __p) {
  return __table_.erase(__p);
  }
       _LIBCPP_INLINE_VISIBILITY     size_type erase(const key_type& __k) {
  return __table_.__erase_unique(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     iterator erase(const_iterator __first, const_iterator __last)         {
  return __table_.erase(__first, __last);
  }
       _LIBCPP_INLINE_VISIBILITY     void clear() _NOEXCEPT {
  __table_.clear();
  }
        _LIBCPP_INLINE_VISIBILITY     void swap(unordered_set& __u)         _NOEXCEPT_(__is_nothrow_swappable<__table>::value)         {
  __table_.swap(__u.__table_);
  }
       _LIBCPP_INLINE_VISIBILITY     size_type bucket(const key_type& __k) const {
  return __table_.bucket(__k);
  }
        _LIBCPP_INLINE_VISIBILITY     local_iterator       begin(size_type __n)        {
  return __table_.begin(__n);
  }
       _LIBCPP_INLINE_VISIBILITY     local_iterator       end(size_type __n)          {
  return __table_.end(__n);
  }
       _LIBCPP_INLINE_VISIBILITY     const_local_iterator begin(size_type __n) const  {
  return __table_.cbegin(__n);
  }
       _LIBCPP_INLINE_VISIBILITY     const_local_iterator end(size_type __n) const    {
  return __table_.cend(__n);
  }
#if _LIBCPP_DEBUG_LEVEL >= 2
     bool __dereferenceable(const const_iterator* __i) const         {
  return __table_.__dereferenceable(__i);
  }
       bool __decrementable(const const_iterator* __i) const         {
  return __table_.__decrementable(__i);
  }
       bool __addable(const const_iterator* __i, ptrdiff_t __n) const         {
  return __table_.__addable(__i, __n);
  }
       bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const         {
  return __table_.__addable(__i, __n);
  }
      
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
 };
    template <class _Value, class _Hash, class _Pred, class _Alloc> unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,         const hasher& __hf, const key_equal& __eql)     : __table_(__hf, __eql) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(         _InputIterator __first, _InputIterator __last, size_type __n,         const hasher& __hf, const key_equal& __eql)     : __table_(__hf, __eql) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
       insert(__first, __last);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(         _InputIterator __first, _InputIterator __last, size_type __n,         const hasher& __hf, const key_equal& __eql, const allocator_type& __a)     : __table_(__hf, __eql, __a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
     
#endif
}
    template <class _Value, class _Hash, class _Pred, class _Alloc> unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(         const unordered_set& __u)     : __table_(__u.__table_) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__u.bucket_count());
       insert(__u.begin(), __u.end());
   }
      
#ifndef _LIBCPP_CXX03_LANG
    template <class _Value, class _Hash, class _Pred, class _Alloc> unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(         unordered_set&& __u, const allocator_type& __a)     : __table_(_VSTD::move(__u.__table_), __a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    if (__a != __u.get_allocator())     {
           iterator __i = __u.begin();
           while (__u.size() != 0)             __table_.__insert_unique(_VSTD::move(__u.__table_.remove(__i++)->__value_));
       }
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    else         __get_db()->swap(this, &__u);
     
#endif
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(         initializer_list<value_type> __il, size_type __n, const hasher& __hf,         const key_equal& __eql)     : __table_(__hf, __eql) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
       insert(__il.begin(), __il.end());
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(         initializer_list<value_type> __il, size_type __n, const hasher& __hf,         const key_equal& __eql, const allocator_type& __a)     : __table_(__hf, __eql, __a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
       insert(__il.begin(), __il.end());
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> inline unordered_set<_Value, _Hash, _Pred, _Alloc>& unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(unordered_set&& __u)     _NOEXCEPT_(is_nothrow_move_assignable<__table>::value) {
       __table_ = _VSTD::move(__u.__table_);
       return *this;
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> inline unordered_set<_Value, _Hash, _Pred, _Alloc>& unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(         initializer_list<value_type> __il) {
       __table_.__assign_unique(__il.begin(), __il.end());
       return *this;
   }
      
#endif  // _LIBCPP_CXX03_LANG
 template <class _Value, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> inline void unordered_set<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,                                                     _InputIterator __last) {
       for (;
   __first != __last;
   ++__first)         __table_.__insert_unique(*__first);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> inline _LIBCPP_INLINE_VISIBILITY void swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,      unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> bool operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,            const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y) {
       return true;
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,            const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y) {
       return !(__x == __y);
   }
    template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,           class _Alloc = allocator<_Value> > class _LIBCPP_TEMPLATE_VIS unordered_multiset {
   public:     // types
    typedef _Value                                                     key_type;
       typedef key_type                                                   value_type;
       typedef _Hash                                                      hasher;
       typedef _Pred                                                      key_equal;
       typedef _Alloc                                                     allocator_type;
       typedef value_type&                                                reference;
       typedef const value_type&                                          const_reference;
       static_assert((is_same<value_type, typename allocator_type::value_type>::value),                   "Invalid allocator::value_type");
    private:     typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;
        __table __table_;
    public:     typedef typename __table::pointer         pointer;
       typedef typename __table::const_pointer   const_pointer;
       typedef typename __table::size_type       size_type;
       typedef typename __table::difference_type difference_type;
        typedef typename __table::const_iterator       iterator;
       typedef typename __table::const_iterator       const_iterator;
       typedef typename __table::const_local_iterator local_iterator;
       typedef typename __table::const_local_iterator const_local_iterator;
        _LIBCPP_INLINE_VISIBILITY     unordered_multiset()         _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)         {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
            __get_db()->__insert_c(this);
     
#endif
        }
       explicit unordered_multiset(size_type __n, const hasher& __hf = hasher(),                                 const key_equal& __eql = key_equal());
       unordered_multiset(size_type __n, const hasher& __hf,                        const key_equal& __eql, const allocator_type& __a);
     
#if _LIBCPP_STD_VER > 11
    inline _LIBCPP_INLINE_VISIBILITY     unordered_multiset(size_type __n, const allocator_type& __a)         : unordered_multiset(__n, hasher(), key_equal(), __a) {
  }
       inline _LIBCPP_INLINE_VISIBILITY     unordered_multiset(size_type __n, const hasher& __hf, const allocator_type& __a)         : unordered_multiset(__n, __hf, key_equal(), __a) {
  }
     
#endif
    template <class _InputIterator>         unordered_multiset(_InputIterator __first, _InputIterator __last);
       template <class _InputIterator>         unordered_multiset(_InputIterator __first, _InputIterator __last,                       size_type __n, const hasher& __hf = hasher(),                       const key_equal& __eql = key_equal());
       template <class _InputIterator>         unordered_multiset(_InputIterator __first, _InputIterator __last,                       size_type __n , const hasher& __hf,                       const key_equal& __eql, const allocator_type& __a);
    _LIBCPP_INLINE_VISIBILITY     explicit unordered_multiset(const allocator_type& __a);
       unordered_multiset(const unordered_multiset& __u);
       unordered_multiset(const unordered_multiset& __u, const allocator_type& __a);
     
#ifndef _LIBCPP_CXX03_LANG
    _LIBCPP_INLINE_VISIBILITY     unordered_multiset(unordered_multiset&& __u)         _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
       unordered_multiset(unordered_multiset&& __u, const allocator_type& __a);
       unordered_multiset(initializer_list<value_type> __il);
        _LIBCPP_INLINE_VISIBILITY     iterator insert(value_type&& __x) {
  return __table_.__insert_multi(_VSTD::move(__x));
  }
       _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p, value_type&& __x)         {
  return __table_.__insert_multi(__p, _VSTD::move(__x));
  }
       _LIBCPP_INLINE_VISIBILITY     void insert(initializer_list<value_type> __il)         {
  insert(__il.begin(), __il.end());
  }
     
#endif  // _LIBCPP_CXX03_LANG
     _LIBCPP_INLINE_VISIBILITY     iterator insert(const value_type& __x) {
  return __table_.__insert_multi(__x);
  }
        _LIBCPP_INLINE_VISIBILITY     iterator insert(const_iterator __p, const value_type& __x)         {
  return __table_.__insert_multi(__p, __x);
  }
        template <class _InputIterator>         _LIBCPP_INLINE_VISIBILITY         void insert(_InputIterator __first, _InputIterator __last);
        _LIBCPP_INLINE_VISIBILITY     iterator erase(const_iterator __p) {
  return __table_.erase(__p);
  }
       _LIBCPP_INLINE_VISIBILITY     size_type erase(const key_type& __k) {
  return __table_.__erase_multi(__k);
  }
       _LIBCPP_INLINE_VISIBILITY     void rehash(size_type __n) {
  __table_.rehash(__n);
  }
       _LIBCPP_INLINE_VISIBILITY     void reserve(size_type __n) {
  __table_.reserve(__n);
  }
      
#if _LIBCPP_DEBUG_LEVEL >= 2
     bool __dereferenceable(const const_iterator* __i) const         {
  return __table_.__dereferenceable(__i);
  }
       bool __decrementable(const const_iterator* __i) const         {
  return __table_.__decrementable(__i);
  }
       bool __addable(const const_iterator* __i, ptrdiff_t __n) const         {
  return __table_.__addable(__i, __n);
  }
       bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const         {
  return __table_.__addable(__i, __n);
  }
      
#endif  // _LIBCPP_DEBUG_LEVEL >= 2
 };
    template <class _Value, class _Hash, class _Pred, class _Alloc> unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(         size_type __n, const hasher& __hf, const key_equal& __eql)     : __table_(__hf, __eql) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__n);
    __table_.rehash(__n);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(         _InputIterator __first, _InputIterator __last) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    insert(__first, __last);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(         _InputIterator __first, _InputIterator __last, size_type __n,         const hasher& __hf, const key_equal& __eql)     : __table_(__hf, __eql) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
     
#endif
    __table_.rehash(__n);
       insert(__first, __last);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> inline unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(         const allocator_type& __a)     : __table_(__a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
}
    template <class _Value, class _Hash, class _Pred, class _Alloc> unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(         const unordered_multiset& __u)     : __table_(__u.__table_) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__u.bucket_count());
       insert(__u.begin(), __u.end());
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(         const unordered_multiset& __u, const allocator_type& __a)     : __table_(__u.__table_, __a) {
     
#if _LIBCPP_DEBUG_LEVEL >= 2
    __get_db()->__insert_c(this);
     
#endif
    __table_.rehash(__u.bucket_count());
       insert(__u.begin(), __u.end());
   }
      
 template <class _Value, class _Hash, class _Pred, class _Alloc> template <class _InputIterator> inline void unordered_multiset<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,                                                          _InputIterator __last) {
       for (;
   __first != __last;
   ++__first)         __table_.__insert_multi(*__first);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> inline _LIBCPP_INLINE_VISIBILITY void swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,      unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)     _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
       __x.swap(__y);
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> bool operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,            const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y) {
       if (__x.size() != __y.size())         return false;
       typedef typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::const_iterator                                                                  const_iterator;
       typedef pair<const_iterator, const_iterator> _EqRng;
       for (const_iterator __i = __x.begin(), __ex = __x.end();
   __i != __ex;
  )     {
           _EqRng __xeq = __x.equal_range(*__i);
           _EqRng __yeq = __y.equal_range(*__i);
           if (_VSTD::distance(__xeq.first, __xeq.second) !=             _VSTD::distance(__yeq.first, __yeq.second) ||                   !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))             return false;
           __i = __xeq.second;
       }
       return true;
   }
    template <class _Value, class _Hash, class _Pred, class _Alloc> inline _LIBCPP_INLINE_VISIBILITY bool operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,            const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y) {
       return !(__x == __y);
   }
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_UNORDERED_SET
  
#pragma clang module end /*std.unordered_set*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "utility"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.utility
// -*- C++ -*-
   
#ifndef _LIBCPP_UTILITY
  
#define _LIBCPP_UTILITY
 /*     utility synopsis  namespace std {
    template <class T>     void     swap(T& a, T& b);
    namespace rel_ops {
       template<class T> bool operator!=(const T&, const T&);
   template <size_t I>   struct in_place_index_t {
       explicit in_place_index_t() = default;
     };
   template <size_t I>   inline constexpr in_place_index_t<I> in_place_index{
  };
    }
    // std
 */
   };
      
#ifndef _LIBCPP_HAS_NO_INT128
 template <> struct _LIBCPP_TEMPLATE_VIS hash<__int128_t>     : public __scalar_hash<__int128_t> {
   };
    template <> struct _LIBCPP_TEMPLATE_VIS hash<__uint128_t>     : public __scalar_hash<__uint128_t> {
   };
      
    template <class _Key, class _Hash = std::hash<_Key> > using __has_enabled_hash = integral_constant<bool,     __check_hash_requirements<_Key, _Hash>::value &&     is_default_constructible<_Hash>::value >;
      
#if _LIBCPP_STD_VER > 14
template <class _Type, class> using __enable_hash_helper_imp = _Type;
    template <class _Type, class ..._Keys> using __enable_hash_helper = __enable_hash_helper_imp<_Type,   typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type >;
     
#else
template <class _Type, class ...> using __enable_hash_helper = _Type;
     
#endif
   
#endif // !_LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_UTILITY
  
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_VALARRAY
  
#define _LIBCPP_VALARRAY
 /*     valarray synopsis  namespace std {
    template<class T> class valarray {
   public:     typedef T value_type;
        // construct/destroy:
    valarray();
       explicit valarray(size_t n);
       valarray(const value_type& x, size_t n);
       valarray(const value_type* px, size_t n);
#include <experimental/memory_resource>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.experimental.memory_resource
// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
  
#define _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE
 /**     experimental/memory_resource synopsis  // C++1y
 namespace std {
   namespace experimental {
   inline namespace fundamentals_v1 {
   namespace pmr {
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.experimental.__memory
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL___MEMORY
  
#define _LIBCPP_EXPERIMENTAL___MEMORY
   
#if 0 /* expanded by -frewrite-includes */
  
#include <experimental/__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <experimental/utility> // for erased_type
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.experimental.utility
// -*- C++ -*-
//===-------------------------- utility ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_UTILITY
  
#define _LIBCPP_EXPERIMENTAL_UTILITY
 /*     experimental/utility synopsis  // C++1y
   
#include <utility>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.utility
// -*- C++ -*-
//===-------------------------- utility -----------------------------------===//
//
#ifndef _LIBCPP_UTILITY
  
#define _LIBCPP_UTILITY
 /*     utility synopsis  namespace std {
    template <class T>     void     swap(T& a, T& b);
    namespace rel_ops {
       template<class T> bool operator!=(const T&, const T&);
       template<class T> bool operator> (const T&, const T&);
       explicit in_place_index_t() = default;
     };
   template <size_t I>   inline constexpr in_place_index_t<I> in_place_index{
  };
    }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
 template <> struct _LIBCPP_TEMPLATE_VIS hash<nullptr_t>   : public unary_function<nullptr_t, size_t> {
     _LIBCPP_INLINE_VISIBILITY   size_t operator()(nullptr_t) const _NOEXCEPT {
       return 662607004ull;
     }
   };
     
#endif
   
#ifndef _LIBCPP_CXX03_LANG
template <class _Key, class _Hash> using __check_hash_requirements = integral_constant<bool,     is_copy_constructible<_Hash>::value &&     is_move_constructible<_Hash>::value &&     __invokable_r<size_t, _Hash, _Key const&>::value >;
    template <class _Key, class _Hash = std::hash<_Key> > using __has_enabled_hash = integral_constant<bool,     __check_hash_requirements<_Key, _Hash>::value &&     is_default_constructible<_Hash>::value >;
      
#if _LIBCPP_STD_VER > 14
template <class _Type, class> using __enable_hash_helper_imp = _Type;
    template <class _Type, class ..._Keys> using __enable_hash_helper = __enable_hash_helper_imp<_Type,   typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type >;
     
#else
template <class _Type, class ...> using __enable_hash_helper = _Type;
     
#endif
   
#endif // !_LIBCPP_CXX03_LANG
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_UTILITY
  
#pragma clang module end /*std.utility*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_LFTS    struct _LIBCPP_TEMPLATE_VIS erased_type {
   };
    _LIBCPP_END_NAMESPACE_LFTS    
#endif /* _LIBCPP_EXPERIMENTAL_UTILITY */
  
#pragma clang module end /*std.experimental.utility*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__functional_base>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__functional_base
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_FUNCTIONAL_BASE
   template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_lvalue_reference<_Tp&> : public true_type {
  };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference        : public false_type {
  };
     
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_rvalue_reference<_Tp&&> : public true_type {
  };
      
#endif
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_pod_v     = is_pod<_Tp>::value;
     
#endif
 // is_literal_type;
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_literal_type   
#ifdef _LIBCPP_IS_LITERAL
    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>   
#else
    
# ifndef _LIBCPP_HAS_NO_VARIADICS
template <class... _Args> struct conjunction : __and_<_Args...> {
  };
     
# endif // _LIBCPP_HAS_NO_VARIADICS
  
#endif  // _LIBCPP_STD_VER > 14
 // These traits are used in __tree and __hash_table
  
#ifndef _LIBCPP_CXX03_LANG
struct __extract_key_fail_tag {
   }
    }
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
 _LIBCPP_BEGIN_NAMESPACE_LFTS  template <     class _Tp, class _Alloc   , bool = uses_allocator<_Tp, _Alloc>::value   , bool = __has_allocator_type<_Tp>::value   > struct __lfts_uses_allocator : public false_type {
  };
    template <class _Tp, class _Alloc> struct __lfts_uses_allocator<_Tp, _Alloc, false, false> : public false_type {
  };
    template <class _Tp, class _Alloc, bool HasAlloc> struct __lfts_uses_allocator<_Tp, _Alloc, true, HasAlloc> : public true_type {
  };
    template <class _Tp, class _Alloc> struct __lfts_uses_allocator<_Tp, _Alloc, false, true>   : public integral_constant<bool     , is_convertible<_Alloc, typename _Tp::allocator_type>::value       || is_same<erased_type, typename _Tp::allocator_type>::value     > {
  };
    template <bool _UsesAlloc, class _Tp, class _Alloc, class ..._Args> struct __lfts_uses_alloc_ctor_imp {
       static const int value = 0;
   };
    template <class _Tp, class _Alloc, class ..._Args> struct __lfts_uses_alloc_ctor_imp<true, _Tp, _Alloc, _Args...> {
       static const bool __ic_first         = is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
        static const bool __ic_second =         conditional<             __ic_first,             false_type,             is_constructible<_Tp, _Args..., _Alloc>         >::type::value;
        static_assert(__ic_first || __ic_second,                   "Request for uses allocator construction is ill-formed");
        static const int value = __ic_first ? 1 : 2;
   };
    template <class _Tp, class _Alloc, class ..._Args> struct __lfts_uses_alloc_ctor   : integral_constant<int,         __lfts_uses_alloc_ctor_imp<             __lfts_uses_allocator<_Tp, _Alloc>::value           , _Tp, _Alloc, _Args...         >::value     > {
  };
    template <class _Tp, class _Alloc, class ..._Args> inline _LIBCPP_INLINE_VISIBILITY void __lfts_user_alloc_construct(     _Tp * __store, const _Alloc & __a, _Args &&... __args) {
       _VSTD::__user_alloc_construct_impl(         typename __lfts_uses_alloc_ctor<_Tp, _Alloc, _Args...>::type()        , __store, __a, _VSTD::forward<_Args>(__args)...        );
   }
    _LIBCPP_END_NAMESPACE_LFTS    
#endif /* _LIBCPP_EXPERIMENTAL___MEMORY */
  
#pragma clang module end /*std.experimental.__memory*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <limits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.limits
// -*- C++ -*-
//===---------------------------- limits ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_LIMITS
  
#define _LIBCPP_LIMITS
 /*     limits synopsis  namespace std {
    template<class T> class numeric_limits {
   public:     static constexpr bool is_specialized = false;
       static constexpr T min() noexcept;
       static constexpr T max() noexcept;
       static constexpr T lowest() noexcept;
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  _LIBCPP_BEGIN_NAMESPACE_STD  enum float_round_style {
       round_indeterminate       = -1,     round_toward_zero         =  0,     round_to_nearest          =  1,     round_toward_infinity     =  2,     round_toward_neg_infinity =  3 };
    enum float_denorm_style {
       denorm_indeterminate = -1,     denorm_absent = 0,     denorm_present = 1 };
    template <class _Tp> struct is_destructible<_Tp[]>     : public _VSTD::false_type {
  };
    template <> struct is_destructible<void>     : public _VSTD::false_type {
  };
      
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES)
template <class _Tp> _LIBCPP_CONSTEXPR bool is_destructible_v     = is_destructible<_Tp>::value;
     
#if __has_feature(cxx_reference_qualified_functions) || \
    (defined(_GNUC_VER) && _GNUC_VER >= 409)
 template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false> {
       typedef _Class& _ClassType;
       typedef _Rp _ReturnType;
       typedef _Rp (_FnType) (_Param...);
   };
    template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false> {
    template <class _Rp, class _Class, class ..._Param> struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false> {
       typedef _Class const volatile&& _ClassType;
       typedef _Rp _ReturnType;
       typedef _Rp (_FnType) (_Param..., ...);
   };
      
#endif  // __has_feature(cxx_reference_qualified_functions) || _GNUC_VER >= 409
   private:     _LIBCPP_HIDDEN     __i_node* __insert_iterator(void* __i);
       _LIBCPP_HIDDEN     __i_node* __find_iterator(const void* __i) const;
        friend _LIBCPP_FUNC_VIS __libcpp_db* __get_db();
   };
    _LIBCPP_FUNC_VIS __libcpp_db* __get_db();
   _LIBCPP_FUNC_VIS const __libcpp_db* __get_const_db();
       
#endif // _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
//===----------------------------------------------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
 _LIBCPP_BEGIN_NAMESPACE_LFTS_PMR  // Round __s up to next multiple of __a.
inline _LIBCPP_INLINE_VISIBILITY size_t __aligned_allocation_size(size_t __s, size_t __a) _NOEXCEPT {
       _LIBCPP_ASSERT(__s + __a > __s, "aligned allocation size overflows");
       return (__s + __a - 1) & ~(__a - 1);
   }
    // 8.5, memory.resource
class _LIBCPP_TEMPLATE_VIS memory_resource {
       static const size_t __max_align = alignof(max_align_t);
    // 8.5.2, memory.resource.public
public:     virtual ~memory_resource() = default;
        _LIBCPP_INLINE_VISIBILITY     void* allocate(size_t __bytes, size_t __align = __max_align)         {
   return do_allocate(__bytes, __align);
   }
        _LIBCPP_INLINE_VISIBILITY     void deallocate(void * __p, size_t __bytes, size_t __align = __max_align)         {
   do_deallocate(__p, __bytes, __align);
   }
        _LIBCPP_INLINE_VISIBILITY     bool is_equal(memory_resource const & __other) const _NOEXCEPT         {
   return do_is_equal(__other);
   }
    // 8.5.3, memory.resource.priv
protected:     virtual void* do_allocate(size_t, size_t) = 0;
       virtual void do_deallocate(void*, size_t, size_t) = 0;
       virtual bool do_is_equal(memory_resource const &) const _NOEXCEPT = 0;
   };
    // 8.5.4, memory.resource.eq
inline _LIBCPP_INLINE_VISIBILITY bool operator==(memory_resource const & __lhs,                 memory_resource const & __rhs) _NOEXCEPT {
       return &__lhs == &__rhs || __lhs.is_equal(__rhs);
   }
    inline _LIBCPP_INLINE_VISIBILITY bool operator!=(memory_resource const & __lhs,                 memory_resource const & __rhs) _NOEXCEPT {
       return !(__lhs == __rhs);
   }
    _LIBCPP_FUNC_VIS memory_resource * new_delete_resource() _NOEXCEPT;
    _LIBCPP_FUNC_VIS memory_resource * null_memory_resource() _NOEXCEPT;
    _LIBCPP_FUNC_VIS memory_resource * get_default_resource() _NOEXCEPT;
    _LIBCPP_FUNC_VIS memory_resource * set_default_resource(memory_resource * __new_res) _NOEXCEPT;
    // 8.6, memory.polymorphic.allocator.class
 // 8.6.1, memory.polymorphic.allocator.overview
template <class _ValueType> class _LIBCPP_TEMPLATE_VIS polymorphic_allocator {
   public:     typedef _ValueType value_type;
        // 8.6.2, memory.polymorphic.allocator.ctor
    _LIBCPP_INLINE_VISIBILITY     polymorphic_allocator() _NOEXCEPT       : __res_(_VSTD_LFTS_PMR::get_default_resource())     {
  }
        _LIBCPP_INLINE_VISIBILITY     polymorphic_allocator(memory_resource * __r) _NOEXCEPT       : __res_(__r)     {
  }
        polymorphic_allocator(polymorphic_allocator const &) = default;
        template <class _Tp>     _LIBCPP_INLINE_VISIBILITY     polymorphic_allocator(polymorphic_allocator<_Tp> const & __other) _NOEXCEPT       : __res_(__other.resource())     {
       }
        template <class _T1, class _T2, class ..._Args1, class ..._Args2>     _LIBCPP_INLINE_VISIBILITY     void construct(pair<_T1, _T2>* __p, piecewise_construct_t,                    tuple<_Args1...> __x, tuple<_Args2...> __y)     {
           ::new ((void*)__p) pair<_T1, _T2>(piecewise_construct           , __transform_tuple(               typename __lfts_uses_alloc_ctor<                   _T1, memory_resource*, _Args1...               >::type()             , _VSTD::move(__x)             , typename __make_tuple_indices<sizeof...(_Args1)>::type{
  }
             )           , __transform_tuple(               typename __lfts_uses_alloc_ctor<                   _T2, memory_resource*, _Args2...               >::type()             , _VSTD::move(__y)             , typename __make_tuple_indices<sizeof...(_Args2)>::type{
  }
             )         );
       }
        _LIBCPP_INLINE_VISIBILITY     polymorphic_allocator     select_on_container_copy_construction() const _NOEXCEPT         {
   return polymorphic_allocator();
   }
        _LIBCPP_INLINE_VISIBILITY     memory_resource * resource() const _NOEXCEPT         {
   return __res_;
   }
    private:     template <class ..._Args, size_t ..._Idx>     _LIBCPP_INLINE_VISIBILITY     tuple<_Args&&...>     __transform_tuple(integral_constant<int, 0>, tuple<_Args...>&& __t,                       __tuple_indices<_Idx...>) const     {
           return _Tup(_VSTD::get<_Idx>(_VSTD::move(__t))..., resource());
       }
        _LIBCPP_INLINE_VISIBILITY     size_t __max_size() const _NOEXCEPT         {
   return numeric_limits<size_t>::max() / sizeof(value_type);
   }
        memory_resource * __res_;
   };
    // 8.6.4, memory.polymorphic.allocator.eq
template <class _CharAlloc> class _LIBCPP_TEMPLATE_VIS __resource_adaptor_imp   : public memory_resource {
       using _CTraits = allocator_traits<_CharAlloc>;
       static_assert(is_same<typename _CTraits::value_type, char>::value                && is_same<typename _CTraits::pointer, char*>::value                && is_same<typename _CTraits::void_pointer, void*>::value, "");
        static const size_t _MaxAlign = alignof(max_align_t);
        using _Alloc = typename _CTraits::template rebind_alloc<             typename aligned_storage<_MaxAlign, _MaxAlign>::type         >;
        using _ValueType = typename _Alloc::value_type;
        _Alloc __alloc_;
    public:     typedef _CharAlloc allocator_type;
        __resource_adaptor_imp() = default;
       __resource_adaptor_imp(__resource_adaptor_imp const &) = default;
       __resource_adaptor_imp(__resource_adaptor_imp &&) = default;
        // 8.7.2, memory.resource.adaptor.ctor
     _LIBCPP_INLINE_VISIBILITY     explicit __resource_adaptor_imp(allocator_type const & __a)       : __alloc_(__a)     {
  }
        _LIBCPP_INLINE_VISIBILITY     explicit __resource_adaptor_imp(allocator_type && __a)       : __alloc_(_VSTD::move(__a))     {
  }
        __resource_adaptor_imp &     operator=(__resource_adaptor_imp const &) = default;
        _LIBCPP_INLINE_VISIBILITY     allocator_type get_allocator() const     {
   return __alloc_;
   }
    // 8.7.3, memory.resource.adaptor.mem
protected:     virtual void * do_allocate(size_t __bytes, size_t)     {
           if (__bytes > __max_size()) {
               __throw_length_error(                 "std::experimental::pmr::resource_adaptor<T>::do_allocate(size_t bytes, size_t align)"                 " 'bytes' exceeds maximum supported size");
           }
           size_t __s = __aligned_allocation_size(__bytes, _MaxAlign) / _MaxAlign;
           return __alloc_.allocate(__s);
       }
        virtual void do_deallocate(void * __p, size_t __bytes, size_t)     {
           _LIBCPP_ASSERT(__bytes <= __max_size(),             "do_deallocate called for size which exceeds the maximum allocation size");
           size_t __s = __aligned_allocation_size(__bytes, _MaxAlign) / _MaxAlign;
           __alloc_.deallocate((_ValueType*)__p, __s);
       }
        virtual bool do_is_equal(memory_resource const & __other) const _NOEXCEPT {
           __resource_adaptor_imp const * __p           = dynamic_cast<__resource_adaptor_imp const *>(&__other);
           return __p  ? __alloc_ == __p->__alloc_ : false;
       }
    private:     _LIBCPP_INLINE_VISIBILITY     size_t __max_size() const _NOEXCEPT {
           return numeric_limits<size_t>::max() - _MaxAlign;
       }
   };
    template <class _Alloc> using resource_adaptor = __resource_adaptor_imp<     typename allocator_traits<_Alloc>::template rebind_alloc<char>   >;
    _LIBCPP_END_NAMESPACE_LFTS_PMR  _LIBCPP_POP_MACROS    
#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
  
#pragma clang module end /*std.experimental.memory_resource*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_LFTS_PMR  template <class _ValueT> using deque = _VSTD::deque<_ValueT, polymorphic_allocator<_ValueT>>;
    _LIBCPP_END_NAMESPACE_LFTS_PMR    
#endif /* _LIBCPP_EXPERIMENTAL_DEQUE */
  
#pragma clang module end /*std.experimental.deque*/
#pragma clang module begin std.experimental.dynarray
// -*- C++ -*-
//===-------------------------- dynarray ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_DYNARRAY
  
#define _LIBCPP_DYNARRAY
 /*     dynarray synopsis  namespace std {
        // mutating member functions:
    void fill(const T& v);
   };
    }
  }
    // std::experimental
 */
  
#if _LIBCPP_STD_VER > 11
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__functional_base>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__functional_base
// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_FUNCTIONAL_BASE
  
#define _LIBCPP_FUNCTIONAL_BASE
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
     
#endif  // _LIBCPP_DEBUG
}
    template <class _InputIterator1, class _InputIterator2, class _OutputIterator> inline _LIBCPP_INLINE_VISIBILITY _OutputIterator set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,                  _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result) {
       return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,                                   __less<typename iterator_traits<_InputIterator1>::value_type,                                          typename iterator_traits<_InputIterator2>::value_type>());
   }
    // set_difference
 template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator> _OutputIterator __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,                  _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {
   }
    template <class _BidirectionalIterator, class _Compare> inline _LIBCPP_INLINE_VISIBILITY bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
     
#ifdef _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;
       __debug_less<_Compare> __c(__comp);
       return __prev_permutation<_Comp_ref>(__first, __last, __c);
     
#else  // _LIBCPP_DEBUG
    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
       return __prev_permutation<_Comp_ref>(__first, __last, __comp);
     
#endif  // _LIBCPP_DEBUG
}
    template <class _BidirectionalIterator> inline _LIBCPP_INLINE_VISIBILITY bool prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) {
       return _VSTD::prev_permutation(__first, __last,                                   __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
   }
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_ALGORITHM
  
#pragma clang module end /*std.algorithm*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
//
//===----------------------------------------------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max")   
#else
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
 namespace std {
   namespace experimental {
   inline namespace __array_extensions_v1 {
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS _LIBCPP_AVAILABILITY_DYNARRAY dynarray {
   public:     // types:
    typedef dynarray __self;
       typedef _Tp                                   value_type;
       typedef value_type&                           reference;
       typedef const value_type&                     const_reference;
       typedef value_type*                           iterator;
       typedef const value_type*                     const_iterator;
       typedef value_type*                           pointer;
       typedef const value_type*                     const_pointer;
       typedef size_t                                size_type;
       typedef ptrdiff_t                             difference_type;
       typedef std::reverse_iterator<iterator>       reverse_iterator;
       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    private:     size_t                  __size_;
       value_type *            __base_;
       _LIBCPP_ALWAYS_INLINE dynarray () noexcept :  __size_(0), __base_(nullptr) {
  }
            static inline _LIBCPP_INLINE_VISIBILITY value_type* __allocate ( size_t count )     {
           if ( numeric_limits<size_t>::max() / sizeof (value_type) <= count )             __throw_bad_array_length();
            return static_cast<value_type *> (_VSTD::__allocate (sizeof(value_type) * count));
       }
        static inline _LIBCPP_INLINE_VISIBILITY void __deallocate_value( value_type* __ptr ) noexcept     {
           _VSTD::__libcpp_deallocate (static_cast<void *> (__ptr));
       }
    public:      _LIBCPP_INLINE_VISIBILITY     explicit dynarray(size_type __c);
       _LIBCPP_INLINE_VISIBILITY     dynarray(size_type __c, const value_type& __v);
       _LIBCPP_INLINE_VISIBILITY     dynarray(const dynarray& __d);
       _LIBCPP_INLINE_VISIBILITY     dynarray(initializer_list<value_type>);
    //  We're not implementing these right now.
//  Updated with the resolution of LWG issue #2255
//     template <typename _Alloc>
//       dynarray(allocator_arg_t, const _Alloc& __alloc, size_type __c);
//     template <typename _Alloc>
//       dynarray(allocator_arg_t, const _Alloc& __alloc, size_type __c, const value_type& __v);
//     template <typename _Alloc>
//       dynarray(allocator_arg_t, const _Alloc& __alloc, const dynarray& __d);
//     template <typename _Alloc>
//       dynarray(allocator_arg_t, const _Alloc& __alloc, initializer_list<value_type>);
     dynarray& operator=(const dynarray&) = delete;
       _LIBCPP_INLINE_VISIBILITY     ~dynarray();
        // iterators:
    inline _LIBCPP_INLINE_VISIBILITY iterator       begin()        noexcept {
   return iterator(data());
   }
       inline _LIBCPP_INLINE_VISIBILITY const_iterator begin()  const noexcept {
   return const_iterator(data());
   }
       inline _LIBCPP_INLINE_VISIBILITY const_iterator cbegin() const noexcept {
   return const_iterator(data());
   }
       inline _LIBCPP_INLINE_VISIBILITY iterator       end()          noexcept {
   return iterator(data() + __size_);
   }
       inline _LIBCPP_INLINE_VISIBILITY const_iterator end()    const noexcept {
   return const_iterator(data() + __size_);
   }
        inline _LIBCPP_INLINE_VISIBILITY reference       front()       {
   return data()[0];
   }
       inline _LIBCPP_INLINE_VISIBILITY const_reference front() const {
   return data()[0];
   }
       inline _LIBCPP_INLINE_VISIBILITY reference       back()        {
   return data()[__size_-1];
   }
       inline _LIBCPP_INLINE_VISIBILITY const_reference back()  const {
   return data()[__size_-1];
   }
        inline _LIBCPP_INLINE_VISIBILITY const_reference at(size_type __n) const;
       inline _LIBCPP_INLINE_VISIBILITY reference       at(size_type __n);
        // data access:
    inline _LIBCPP_INLINE_VISIBILITY _Tp*       data()       noexcept {
   }
   };
    template <class _Tp> inline dynarray<_Tp>::dynarray(size_type __c) : dynarray () {
       __base_ = __allocate (__c);
       value_type *__data = data ();
       for ( __size_ = 0;
   __size_ < __c;
   ++__size_, ++__data )         ::new (__data) value_type;
   }
    template <class _Tp> inline dynarray<_Tp>::dynarray(size_type __c, const value_type& __v) : dynarray () {
       __base_ = __allocate (__c);
       value_type *__data = data ();
       for ( __size_ = 0;
   __size_ < __c;
   ++__size_, ++__data )         ::new (__data) value_type (__v);
   }
    template <class _Tp> inline dynarray<_Tp>::dynarray(initializer_list<value_type> __il) : dynarray () {
       size_t sz = __il.size();
       __base_ = __allocate (sz);
       value_type *__data = data ();
       auto src = __il.begin();
       for ( __size_ = 0;
   __size_ < sz;
   ++__size_, ++__data, ++src )         ::new (__data) value_type (*src);
   }
    template <class _Tp> inline dynarray<_Tp>::dynarray(const dynarray& __d) : dynarray () {
       size_t sz = __d.size();
       __base_ = __allocate (sz);
       value_type *__data = data ();
       auto src = __d.begin();
       for ( __size_ = 0;
   __size_ < sz;
   ++__size_, ++__data, ++src )         ::new (__data) value_type (*src);
   }
    template <class _Tp> inline dynarray<_Tp>::~dynarray() {
        value_type *__data = data () + __size_;
       for ( size_t i = 0;
   i < __size_;
   ++i )         (--__data)->value_type::~value_type();
       __deallocate_value( __base_ );
   }
    template <class _Tp> inline _LIBCPP_INLINE_VISIBILITY typename dynarray<_Tp>::reference dynarray<_Tp>::at(size_type __n) {
       if (__n >= __size_)         __throw_out_of_range("dynarray::at");
        return data()[__n];
   }
  };
   _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // if _LIBCPP_STD_VER > 11 
  
#endif  // _LIBCPP_DYNARRAY
  
#pragma clang module end /*std.experimental.dynarray*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "experimental/filesystem"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.experimental.filesystem
//===----------------------------------------------------------------------===//
  
#ifndef _LIBCPP_EXPERIMENTAL_FILESYSTEM
  
#define _LIBCPP_EXPERIMENTAL_FILESYSTEM
/*     filesystem synopsis      namespace std {
   namespace experimental {
    }
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include <limits>                   // numeric_limits
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.limits
// -*- C++ -*-
   
#ifndef _LIBCPP_LIMITS
  
#define _LIBCPP_LIMITS
 /*     limits synopsis  namespace std {
    template<class T> class numeric_limits {
   public:     static constexpr bool is_specialized = false;
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
   
#if defined(_LIBCPP_COMPILER_MSVC)
  
#if 0 /* expanded by -frewrite-includes */
  
#include "support/win32/limits_msvc_win32.h"
  
#endif /* expanded by -frewrite-includes */
  
#endif // _LIBCPP_MSVCRT
   
#if defined(__IBMCPP__)
  
#if 0 /* expanded by -frewrite-includes */
  
#include "support/ibm/limits.h"
  
#endif /* expanded by -frewrite-includes */
  
#endif // __IBMCPP__
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
   template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_modulo;
   template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::traps;
   template <class _Tp>     _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;
   template <class _Tp>     _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;
    _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif  // _LIBCPP_LIMITS
  
#pragma clang module end /*std.limits*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
    
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
   
#if _LIBCPP_STD_VER > 11
 _LIBCPP_BEGIN_NAMESPACE_LFTS_V2  template <typename _Result, typename _Source, bool _IsSigned = is_signed<_Source>::value> struct __abs;
    template <typename _Result, typename _Source> struct __abs<_Result, _Source, true> {
       _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY     _Result operator()(_Source __t) const noexcept     {
       if (__t >= 0) return __t;
       if (__t == numeric_limits<_Source>::min()) return -static_cast<_Result>(__t);
       return -__t;
       }
   };
    template <typename _Result, typename _Source> struct __abs<_Result, _Source, false> {
       _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY     _Result operator()(_Source __t) const noexcept {
   return __t;
   }
   };
     template<class _Tp> _LIBCPP_CONSTEXPR _LIBCPP_HIDDEN inline _Tp __gcd(_Tp __m, _Tp __n) {
       static_assert((!is_signed<_Tp>::value), "" );
       return __n == 0 ? __m : _VSTD_LFTS_V2::__gcd<_Tp>(__n, __m % __n);
   }
     template<class _Tp, class _Up> _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY common_type_t<_Tp,_Up> gcd(_Tp __m, _Up __n) {
       static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to gcd must be integer types");
       static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), "First argument to gcd cannot be bool" );
       static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), "Second argument to gcd cannot be bool" );
       using _Rp = common_type_t<_Tp,_Up>;
       using _Wp = make_unsigned_t<_Rp>;
       return static_cast<_Rp>(_VSTD_LFTS_V2::__gcd(       static_cast<_Wp>(__abs<_Rp, _Tp>()(__m)),       static_cast<_Wp>(__abs<_Rp, _Up>()(__n))));
   }
    template<class _Tp, class _Up> _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY common_type_t<_Tp,_Up> lcm(_Tp __m, _Up __n) {
       static_assert((is_integral<_Tp>::value && is_integral<_Up>::value), "Arguments to lcm must be integer types");
       static_assert((!is_same<typename remove_cv<_Tp>::type, bool>::value), "First argument to lcm cannot be bool" );
       static_assert((!is_same<typename remove_cv<_Up>::type, bool>::value), "Second argument to lcm cannot be bool" );
       if (__m == 0 || __n == 0)         return 0;
        using _Rp = common_type_t<_Tp,_Up>;
       _Rp __val1 = __abs<_Rp, _Tp>()(__m) / _VSTD_LFTS_V2::gcd(__m, __n);
       _Rp __val2 = __abs<_Rp, _Up>()(__n);
       _LIBCPP_ASSERT((numeric_limits<_Rp>::max() / __val1 > __val2), "Overflow in lcm");
       return __val1 * __val2;
   }
    _LIBCPP_END_NAMESPACE_LFTS_V2    
#endif /* _LIBCPP_STD_VER > 11 */
 _LIBCPP_POP_MACROS    
#endif /* _LIBCPP_EXPERIMENTAL_NUMERIC */
  
#pragma clang module end /*std.experimental.numeric*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "experimental/optional"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.experimental.optional
// -*- C++ -*-
//===-------------------------- optional ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_OPTIONAL
  
#define _LIBCPP_EXPERIMENTAL_OPTIONAL
 /*     optional synopsis  // C++1y
 namespace std {
   namespace experimental {
   inline namespace fundamentals_v1 {
        // 5.3, optional for object types
    template <class T> class optional;
        // 5.4, In-place construction
    struct in_place_t{
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <functional>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.functional
// -*- C++ -*-
//===------------------------ functional ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_FUNCTIONAL
  
#define _LIBCPP_FUNCTIONAL
 /*     functional synopsis  namespace std {
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <typeinfo>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
 
#endif
}
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_STDEXCEPT
  
#pragma clang module end /*std.stdexcept*/
  
#if _LIBCPP_STD_VER > 11
#pragma clang module begin std.initializer_list
// -*- C++ -*-
//===----------------------- initializer_list -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_INITIALIZER_LIST
  
#define _LIBCPP_INITIALIZER_LIST
 /*     initializer_list synopsis  namespace std {
    template<class E> class initializer_list {
    template<class E> const E* begin(initializer_list<E> il) noexcept;
   // constexpr in C++14
template<class E> const E* end(initializer_list<E> il) noexcept;
   // constexpr in C++14
 }
    // std
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstddef>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 namespace std  // purposefully not versioned
  }
   };
      
#if _LIBCPP_STD_VER > 11
template <> struct _LIBCPP_TEMPLATE_VIS modulus<void> {
       template <class _T1, class _T2>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     auto operator()(_T1&& __t, _T2&& __u) const     _NOEXCEPT_(noexcept(_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u)))     -> decltype        (_VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u))         {
   return        _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u);
       return __not_fn_imp<decay_t<_RawFunc>>(_VSTD::forward<_RawFunc>(__fn));
   }
      
#endif
 // struct hash<T*> in <memory>
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_FUNCTIONAL
  
#pragma clang module end /*std.functional*/
 _LIBCPP_BEGIN_NAMESPACE_LFTS_V2   template <class _Tp> class propagate_const;
    template <class _Up> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR const _Up& get_underlying(const propagate_const<_Up>& __pu) _NOEXCEPT;
    template <class _Up> inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR _Up& get_underlying(propagate_const<_Up>& __pu) _NOEXCEPT;
    template <class _Tp> class propagate_const {
   public:   typedef remove_reference_t<decltype(*_VSTD::declval<_Tp&>())> element_type;
      static_assert(!is_array<_Tp>::value,       "Instantiation of propagate_const with an array type is ill-formed.");
     static_assert(!is_reference<_Tp>::value,       "Instantiation of propagate_const with a reference type is ill-formed.");
     static_assert(!(is_pointer<_Tp>::value && is_function<typename remove_pointer<_Tp>::type>::value),       "Instantiation of propagate_const with a function-pointer type is ill-formed.");
     static_assert(!(is_pointer<_Tp>::value && is_same<typename remove_cv<typename remove_pointer<_Tp>::type>::type, void>::value),       "Instantiation of propagate_const with a pointer to (possibly cv-qualified) void is ill-formed.");
    private:   template <class _Up>   static _LIBCPP_CONSTEXPR element_type* __get_pointer(_Up* __u)   {
       return __u;
     }
      template <class _Up>   static _LIBCPP_CONSTEXPR element_type* __get_pointer(_Up& __u)   {
       return __get_pointer(__u.get());
     }
      template <class _Up>   static _LIBCPP_CONSTEXPR const element_type* __get_pointer(const _Up* __u)   {
       return __u;
     }
      template <class _Up>   static _LIBCPP_CONSTEXPR const element_type* __get_pointer(const _Up& __u)   {
       return __get_pointer(__u.get());
     }
      template <class _Up>   struct __is_propagate_const : false_type   {
     };
      template <class _Up>   struct __is_propagate_const<propagate_const<_Up>> : true_type   {
     };
      _Tp __t_;
    public:    template <class _Up> friend _LIBCPP_CONSTEXPR const _Up& ::_VSTD_LFTS_V2::get_underlying(const propagate_const<_Up>& __pu) _NOEXCEPT;
     template <class _Up> friend _LIBCPP_CONSTEXPR _Up& ::_VSTD_LFTS_V2::get_underlying(propagate_const<_Up>& __pu) _NOEXCEPT;
      _LIBCPP_CONSTEXPR propagate_const() = default;
      propagate_const(const propagate_const&) = delete;
      _LIBCPP_CONSTEXPR void swap(propagate_const& __pt) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)   {
       using _VSTD::swap;
       swap(__t_, __pt.__t_);
     }
   };
     template <class _Tp> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR bool operator==(const propagate_const<_Tp>& __pt, nullptr_t) {
     return _VSTD_LFTS_V2::get_underlying(__pt) == nullptr;
     return __pt.__t_;
   }
    template <class _Tp> _LIBCPP_CONSTEXPR _Tp& get_underlying(propagate_const<_Tp>& __pt) _NOEXCEPT {
     return __pt.__t_;
   }
    _LIBCPP_END_NAMESPACE_LFTS_V2  _LIBCPP_BEGIN_NAMESPACE_STD  template <class _Tp> struct hash<experimental::fundamentals_v2::propagate_const<_Tp>> {
     typedef size_t result_type;
      bool operator()(const experimental::fundamentals_v2::propagate_const<_Tp>& __pc1,       const experimental::fundamentals_v2::propagate_const<_Tp>& __pc2) const   {
       return std::equal_to<_Tp>()(_VSTD_LFTS_V2::get_underlying(__pc1), _VSTD_LFTS_V2::get_underlying(__pc2));
     }
   };
    template <class _Tp> struct not_equal_to<experimental::fundamentals_v2::propagate_const<_Tp>> {
     typedef experimental::fundamentals_v2::propagate_const<_Tp> first_argument_type;
     typedef experimental::fundamentals_v2::propagate_const<_Tp> second_argument_type;
      bool operator()(const experimental::fundamentals_v2::propagate_const<_Tp>& __pc1,       const experimental::fundamentals_v2::propagate_const<_Tp>& __pc2) const   {
     }
   };
    template <class _Tp> struct less_equal<experimental::fundamentals_v2::propagate_const<_Tp>> {
     typedef experimental::fundamentals_v2::propagate_const<_Tp> first_argument_type;
     typedef experimental::fundamentals_v2::propagate_const<_Tp> second_argument_type;
      bool operator()(const experimental::fundamentals_v2::propagate_const<_Tp>& __pc1,       const experimental::fundamentals_v2::propagate_const<_Tp>& __pc2) const   {
       return std::less_equal<_Tp>()(_VSTD_LFTS_V2::get_underlying(__pc1), _VSTD_LFTS_V2::get_underlying(__pc2));
     }
   };
    _LIBCPP_END_NAMESPACE_STD    
#endif // _LIBCPP_STD_VER > 11
  
#endif // _LIBCPP_EXPERIMENTAL_PROPAGATE_CONST
   
#pragma clang module end /*std.experimental.propagate_const*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "experimental/ratio"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.experimental.ratio
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_RATIO
  
#define _LIBCPP_EXPERIMENTAL_RATIO
 /**     experimental/ratio synopsis     C++1y   
#include <ratio>
 namespace std {
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <experimental/__config>
  
#endif /* expanded by -frewrite-includes */
   
#if _LIBCPP_STD_VER > 11
   
#if 0 /* expanded by -frewrite-includes */
  
#include <ratio>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.ratio
// -*- C++ -*-
//===---------------------------- ratio -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_RATIO
  
#define _LIBCPP_RATIO
 /*     ratio synopsis  namespace std {
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cstdint>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <climits>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#endif  // _LIBCPP_RATIO
  
#pragma clang module end /*std.ratio*/
 _LIBCPP_BEGIN_NAMESPACE_LFTS    
#ifndef _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
 template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_equal_v     = ratio_equal<_R1, _R2>::value;
    template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_not_equal_v     = ratio_not_equal<_R1, _R2>::value;
    template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_less_v     = ratio_less<_R1, _R2>::value;
    template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_less_equal_v     = ratio_less_equal<_R1, _R2>::value;
    template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_greater_v     = ratio_greater<_R1, _R2>::value;
    template <class _R1, class _R2> _LIBCPP_CONSTEXPR bool ratio_greater_equal_v     = ratio_greater_equal<_R1, _R2>::value;
      
#endif /* _LIBCPP_HAS_NO_VARIABLE_TEMPLATES */
 _LIBCPP_END_NAMESPACE_LFTS    
#endif /* _LIBCPP_STD_VER > 11 */
   
#endif // _LIBCPP_EXPERIMENTAL_RATIO
  
#pragma clang module end /*std.experimental.ratio*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "experimental/regex"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.experimental.regex
// -*- C++ -*-
//===----------------------------- regex ----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_REGEX
  
#define _LIBCPP_EXPERIMENTAL_REGEX
/*     experimental/regex synopsis  // C++1z
namespace std {
   namespace experimental {
   inline namespace fundamentals_v1 {
   namespace pmr {
      template <class BidirectionalIterator>   using match_results =     std::match_results<BidirectionalIterator,                        polymorphic_allocator<sub_match<BidirectionalIterator>>>;
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.regex
// -*- C++ -*-
//===--------------------------- regex ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_REGEX
   
#ifndef _LIBCPP_STRING
  
#define _LIBCPP_STRING
 /*     string synopsis  namespace std {
    template <class stateT> class fpos {
   private:     stateT st;
   public:     fpos(streamoff = streamoff());
  
#endif /* expanded by -frewrite-includes */
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
 _LIBCPP_BEGIN_NAMESPACE_LFTS_PMR  // Round __s up to next multiple of __a.
inline _LIBCPP_INLINE_VISIBILITY size_t __aligned_allocation_size(size_t __s, size_t __a) _NOEXCEPT {
       _LIBCPP_ASSERT(__s + __a > __s, "aligned allocation size overflows");
       return (__s + __a - 1) & ~(__a - 1);
   }
    private:     _LIBCPP_INLINE_VISIBILITY     size_t __max_size() const _NOEXCEPT {
           return numeric_limits<size_t>::max() - _MaxAlign;
       }
   };
    template <class _Alloc> using resource_adaptor = __resource_adaptor_imp<     typename allocator_traits<_Alloc>::template rebind_alloc<char>   >;
    _LIBCPP_END_NAMESPACE_LFTS_PMR  _LIBCPP_POP_MACROS    
#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
  
   // namespace fundamentals_v1
}
   // namespace experimental
}
   // namespace std
  */
   
#if 0 /* expanded by -frewrite-includes */
   };
    _LIBCPP_FUNC_VIS __libcpp_db* __get_db();
   _LIBCPP_FUNC_VIS const __libcpp_db* __get_const_db();
       
#endif // _LIBCPP_DEBUG_LEVEL >= 2 || defined(_LIBCPP_BUILDING_LIBRARY)
 _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_DEBUG_H
   
#pragma clang module end /*std.__debug*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_PUSH_MACROS   
#if 0 /* expanded by -frewrite-includes */
  
#include <__undef_macros>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.__undef_macros
// -*- C++ -*-
//===------------------------ __undef_macros ------------------------------===//
//
#ifdef min
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro min is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing min")   
#else
  
#warning: macro min is incompatible with C++.  #undefing min
  
#endif
  
#endif
  
#undef min
  
#endif
   
#ifdef max
  
#if !defined(_LIBCPP_DISABLE_MACRO_CONFLICT_WARNINGS)
  
#if defined(_LIBCPP_WARNING)
_LIBCPP_WARNING("macro max is incompatible with C++.  Try #define NOMINMAX "                 "before any Windows header. #undefing max")   
#else
  
#warning: macro max is incompatible with C++.  #undefing max
  
#endif
  
#endif
  
#undef max
  
#endif
  
#pragma clang module end /*std.__undef_macros*/
 _LIBCPP_BEGIN_NAMESPACE_LFTS      template<class _CharT, class _Traits = _VSTD::char_traits<_CharT> >     class _LIBCPP_TEMPLATE_VIS basic_string_view {
       public:         // types
        typedef _Traits                                    traits_type;
           typedef _CharT                                     value_type;
           typedef const _CharT*                              pointer;
           typedef const _CharT*                              const_pointer;
           typedef const _CharT&                              reference;
           typedef const _CharT&                              const_reference;
           typedef const_pointer                              const_iterator;
   // See [string.view.iterators]
        typedef const_iterator                             iterator;
           typedef _VSTD::reverse_iterator<const_iterator>    const_reverse_iterator;
           typedef const_reverse_iterator                     reverse_iterator;
           typedef size_t                                     size_type;
           typedef ptrdiff_t                                  difference_type;
           static _LIBCPP_CONSTEXPR const size_type npos = -1;
   // size_type(-1);
            _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         basic_string_view(const _CharT* __s, size_type __len)             : __data(__s), __size(__len)         {
   //             _LIBCPP_ASSERT(__len == 0 || __s != nullptr, "string_view::string_view(_CharT *, size_t): received nullptr");
        }
            _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         basic_string_view(const _CharT* __s)             : __data(__s), __size(_Traits::length(__s)) {
  }
            // [string.view.iterators], iterators
        _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         const_iterator begin()  const _NOEXCEPT {
   return cbegin();
   }
            _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         const_iterator end()    const _NOEXCEPT {
   return cend();
   }
            _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         const_iterator cbegin() const _NOEXCEPT {
   return __data;
   }
            _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         const_iterator cend()   const _NOEXCEPT {
   return __data + __size;
   }
            _LIBCPP_INLINE_VISIBILITY         const_reverse_iterator rbegin()   const _NOEXCEPT {
   return const_reverse_iterator(cend());
   }
            _LIBCPP_INLINE_VISIBILITY         const_reverse_iterator rend()     const _NOEXCEPT {
   return const_reverse_iterator(cbegin());
   }
        _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         size_type size()     const _NOEXCEPT {
   return __size;
   }
            _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         size_type length()   const _NOEXCEPT {
   return __size;
   }
            _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         size_type max_size() const _NOEXCEPT {
   return _VSTD::numeric_limits<size_type>::max();
               return _LIBCPP_ASSERT(!empty(), "string_view::back(): string is empty"), __data[__size-1];
           }
            _LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY         const_pointer data() const _NOEXCEPT {
   return __data;
   }
            // [string.view.modifiers], modifiers:
        _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         void clear() _NOEXCEPT         {
               __data = nullptr;
               __size = 0;
           }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         void remove_prefix(size_type __n) _NOEXCEPT         {
               _LIBCPP_ASSERT(__n <= size(), "remove_prefix() can't remove more than size()");
               __data += __n;
               __size -= __n;
           }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         void remove_suffix(size_type __n) _NOEXCEPT         {
               _LIBCPP_ASSERT(__n <= size(), "remove_suffix() can't remove more than size()");
               __size -= __n;
           }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         void swap(basic_string_view& __other) _NOEXCEPT         {
               const value_type *__p = __data;
               __data = __other.__data;
               __other.__data = __p;
                size_type __sz = __size;
               __size = __other.__size;
               __other.__size = __sz;
   //             _VSTD::swap( __data, __other.__data );
//             _VSTD::swap( __size, __other.__size );
        }
            // [string.view.ops], string operations:
        template<class _Allocator>         _LIBCPP_INLINE_VISIBILITY         _LIBCPP_EXPLICIT operator basic_string<_CharT, _Traits, _Allocator>() const         {
   return basic_string<_CharT, _Traits, _Allocator>( begin(), end());
   }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const         {
               _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_first_of(): received nullptr");
               return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>                 (data(), size(), __s, __pos, __n);
           }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         size_type find_first_of(const _CharT* __s, size_type __pos=0) const         {
               _LIBCPP_ASSERT(__s != nullptr, "string_view::find_first_of(): received nullptr");
               return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>                 (data(), size(), __s, __pos, traits_type::length(__s));
           }
            // find_last_of
        _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         size_type find_last_of(basic_string_view __s, size_type __pos=npos) const _NOEXCEPT         {
               _LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_last_of(): received nullptr");
               return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>                 (data(), size(), __s.data(), __pos, __s.size());
           }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         size_type find_first_not_of(const _CharT* __s, size_type __pos=0) const         {
               _LIBCPP_ASSERT(__s != nullptr, "string_view::find_first_not_of(): received nullptr");
               return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>                 (data(), size(), __s, __pos, traits_type::length(__s));
           }
            // find_last_not_of
        _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         size_type find_last_not_of(basic_string_view __s, size_type __pos=npos) const _NOEXCEPT         {
               _LIBCPP_ASSERT(__s.size() == 0 || __s.data() != nullptr, "string_view::find_last_not_of(): received nullptr");
               return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>                 (data(), size(), __s.data(), __pos, __s.size());
           }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         size_type find_last_not_of(_CharT __c, size_type __pos=npos) const _NOEXCEPT         {
               return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>                 (data(), size(), __c, __pos);
           }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const         {
               _LIBCPP_ASSERT(__n == 0 || __s != nullptr, "string_view::find_last_not_of(): received nullptr");
               return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>                 (data(), size(), __s, __pos, __n);
           }
            _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY         size_type find_last_not_of(const _CharT* __s, size_type __pos=npos) const         {
               _LIBCPP_ASSERT(__s != nullptr, "string_view::find_last_not_of(): received nullptr");
               return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>                 (data(), size(), __s, __pos, traits_type::length(__s));
           }
        private:         const   value_type* __data;
           size_type           __size;
       };
         // [string.view.comparison]
    template<class _CharT, class _Traits>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator> (basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT     {
           return __lhs.compare(__rhs) > 0;
       }
        template<class _CharT, class _Traits>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator>(basic_string_view<_CharT, _Traits> __lhs,                     typename _VSTD::common_type<basic_string_view<_CharT, _Traits> >::type __rhs) _NOEXCEPT     {
           return __lhs.compare(__rhs) > 0;
       }
        template<class _CharT, class _Traits>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator>(typename _VSTD::common_type<basic_string_view<_CharT, _Traits> >::type __lhs,                      basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT     {
           return __lhs.compare(__rhs) > 0;
           return __lhs.compare(__rhs) >= 0;
       }
        template<class _CharT, class _Traits>     _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY     bool operator>=(typename _VSTD::common_type<basic_string_view<_CharT, _Traits> >::type __lhs,                      basic_string_view<_CharT, _Traits> __rhs) _NOEXCEPT     {
           return __lhs.compare(__rhs) >= 0;
       }
         // [string.view.io]
    template<class _CharT, class _Traits>     basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>& __os, basic_string_view<_CharT, _Traits> __sv)     {
           return _VSTD::__put_character_sequence(__os, __sv.data(), __sv.size());
       }
      typedef basic_string_view<char>     string_view;
     typedef basic_string_view<char16_t> u16string_view;
     typedef basic_string_view<char32_t> u32string_view;
     typedef basic_string_view<wchar_t>  wstring_view;
    _LIBCPP_END_NAMESPACE_LFTS _LIBCPP_BEGIN_NAMESPACE_STD  // [string.view.hash]
// Shamelessly stolen from <string>
#if _LIBCPP_STD_VER > 11
template <class _CharT, class _Traits> __quoted_output_proxy<_CharT, const _CharT *, _Traits> quoted ( std::experimental::basic_string_view <_CharT, _Traits> __sv,              _CharT __delim = _CharT('"'), _CharT __escape=_CharT('\\')) {
       return __quoted_output_proxy<_CharT, const _CharT *, _Traits>           ( __sv.data(), __sv.data() + __sv.size(), __delim, __escape );
   }
     
#endif
 _LIBCPP_END_NAMESPACE_STD  _LIBCPP_POP_MACROS    
#endif // _LIBCPP_LFTS_STRING_VIEW
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_SYSTEM_ERROR
  
#define _LIBCPP_EXPERIMENTAL_SYSTEM_ERROR
 /**     experimental/system_error synopsis  // C++1y
   
#include <system_error>
 namespace std {
   namespace experimental {
   inline namespace fundamentals_v1 {
      // See C++14 19.5, System error support
  template <class T> constexpr bool is_error_code_enum_v     = is_error_code_enum<T>::value;
 */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <experimental/__config>
  
#endif /* expanded by -frewrite-includes */
   
#if _LIBCPP_STD_VER > 11
   
#if 0 /* expanded by -frewrite-includes */
  
#include <system_error>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.system_error
// -*- C++ -*-
//===---------------------------- system_error ----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_SYSTEM_ERROR
  
#define _LIBCPP_SYSTEM_ERROR
 /*     system_error synopsis  namespace std {
    class error_category {
   public:     virtual ~error_category() noexcept;
        constexpr error_category();
       error_category(const error_category&) = delete;
       error_category& operator=(const error_category&) = delete;
        virtual const char* name() const noexcept = 0;
       virtual error_condition default_error_condition(int ev) const noexcept;
   
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <cerrno>
  
#endif /* expanded by -frewrite-includes */
    no_message                          = ENOMSG,     no_protocol_option                  = ENOPROTOOPT,     no_space_on_device                  = ENOSPC,   
#ifdef ENOSR
    no_stream_resources                 = ENOSR,   
#else
    no_stream_resources                 = ENOMEM,   
#endif
    no_such_device_or_address           = ENXIO,     no_such_device                      = ENODEV,     no_such_file_or_directory           = ENOENT,     no_such_process                     = ESRCH,     not_a_directory                     = ENOTDIR,     not_a_socket                        = ENOTSOCK,   
#ifdef ENOSTR
#else
    _LIBCPP_ALWAYS_INLINE     _LIBCPP_CONSTEXPR_AFTER_CXX11 error_category() _NOEXCEPT _LIBCPP_DEFAULT   
#endif
private:     error_category(const error_category&);
  // = delete;
    error_category& operator=(const error_category&);
  // = delete;
        _LIBCPP_ALWAYS_INLINE     const error_code& code() const _NOEXCEPT {
  return __ec_;
  }
    private:     static string __init(const error_code&, string);
   };
    _LIBCPP_NORETURN _LIBCPP_FUNC_VIS void __throw_system_error(int ev, const char* what_arg);
    _LIBCPP_END_NAMESPACE_STD    
#endif  // _LIBCPP_SYSTEM_ERROR
  
#pragma clang module end /*std.system_error*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_LFTS    
#ifndef _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
 template <class _Tp> _LIBCPP_CONSTEXPR bool is_error_code_enum_v     = is_error_code_enum<_Tp>::value;
    template <class _Tp> _LIBCPP_CONSTEXPR bool is_error_condition_enum_v     = is_error_condition_enum<_Tp>::value;
      
#endif /* _LIBCPP_HAS_NO_VARIABLE_TEMPLATES */
 _LIBCPP_END_NAMESPACE_LFTS    
#endif /* _LIBCPP_STD_VER > 11 */
   
#endif /* _LIBCPP_EXPERIMENTAL_SYSTEM_ERROR */
  
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_TUPLE
  
#define _LIBCPP_EXPERIMENTAL_TUPLE
 /*     experimental/tuple synopsis  // C++1y
   
#include <tuple>
 namespace std {
   namespace experimental {
   inline namespace fundamentals_v1 {
      // See C++14 20.4.2.5, tuple helper classes
  template <class T> constexpr size_t tuple_size_v     = tuple_size<T>::value;
  */
   
#if 0 /* expanded by -frewrite-includes */
  
# include <experimental/__config>
  
#endif /* expanded by -frewrite-includes */
   
#if _LIBCPP_STD_VER > 11
   
#if 0 /* expanded by -frewrite-includes */
  
# include <tuple>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.tuple
// -*- C++ -*-
//===--------------------------- tuple ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_TUPLE
  
#define _LIBCPP_TUPLE
 /*     tuple synopsis  namespace std {
   template <size_t I>   struct in_place_index_t {
       explicit in_place_index_t() = default;
     };
   template <size_t I>   inline constexpr in_place_index_t<I> in_place_index{
  };
    }
    // std
 */
#if 0 /* expanded by -frewrite-includes */
       }
       };
        template <bool _MaybeEnable>     using _CheckArgsDep = typename conditional<       _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;
        struct _CheckTupleLikeConstructor {
           template <class _Tuple>         static constexpr bool __enable_implicit() {
               return __tuple_convertible<_Tuple, pair>::value;
           }
     
#endif
 // is_trivially_constructible
   
#ifndef _LIBCPP_HAS_NO_VARIADICS
   
#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {
   };
      
#else  // !__has_feature(is_trivially_constructible)
 template <class _Tp, class... _Args> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : false_type {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp>   
#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)
    : integral_constant<bool, __has_trivial_constructor(_Tp)>   
struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&&>   
#else
struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp>   
#endif
    : integral_constant<bool, is_scalar<_Tp>::value> {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&>     : integral_constant<bool, is_scalar<_Tp>::value> {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&>     : integral_constant<bool, is_scalar<_Tp>::value> {
   };
      
#endif  // !__has_feature(is_trivially_constructible)
   
#else  // _LIBCPP_HAS_NO_VARIADICS
 template <class _Tp, class _A0 = __is_construct::__nat,                      class _A1 = __is_construct::__nat> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible     : false_type {
   };
      
#if __has_feature(is_trivially_constructible) || _GNUC_VER >= 501
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, __is_construct::__nat,                                                        __is_construct::__nat>     : integral_constant<bool, __is_trivially_constructible(_Tp)> {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp,                                                        __is_construct::__nat>     : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)> {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,                                                        __is_construct::__nat>     : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)> {
   };
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, const _Tp&,                                                        __is_construct::__nat>     : integral_constant<bool, is_scalar<_Tp>::value> {
   };
    template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_trivially_constructible<_Tp, _Tp&,                                                        __is_construct::__nat>     : integral_constant<bool, is_scalar<_Tp>::value> {
   };
      
#endif  // !__has_feature(is_trivially_constructible)
   
#endif  // _LIBCPP_HAS_NO_VARIADICS
   
#if _LIBCPP_STD_VER > 14 && !defined(_LIBCPP_HAS_NO_VARIABLE_TEMPLATES) && !defined(_LIBCPP_HAS_NO_VARIADICS)
template <class _Tp, class... _Args> _LIBCPP_CONSTEXPR bool is_trivially_constructible_v     = is_trivially_constructible<_Tp, _Args...>::value;
     
#endif
 // is_trivially_default_constructible
 template <class _Tp> struct __is_reference_wrapper_impl : public false_type {
  };
   template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {
  };
   template <class _Tp> struct __is_reference_wrapper     : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {
  };
      
#ifndef _LIBCPP_CXX03_LANG
     
#endif
   
#endif  // _LIBCPP_TYPE_TRAITS
  
#pragma clang module end /*std.type_traits*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
  
#if 0 /* expanded by -frewrite-includes */
  
#pragma GCC system_header
  
#endif /* expanded by -frewrite-includes */
  
#endif
 _LIBCPP_BEGIN_NAMESPACE_LFTS    
#ifndef _LIBCPP_HAS_NO_VARIABLE_TEMPLATES
 // C++14 20.10.4.1, primary type categories
 template <class _Tp> _LIBCPP_CONSTEXPR bool is_void_v     = is_void<_Tp>::value;
    template <class _Tp> _LIBCPP_CONSTEXPR bool is_null_pointer_v     = is_null_pointer<_Tp>::value;
    template <class _Tp> _LIBCPP_CONSTEXPR bool is_integral_v     = is_integral<_Tp>::value;
    template <class _Tp> _LIBCPP_CONSTEXPR bool is_floating_point_v     = is_floating_point<_Tp>::value;
 template <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_same_v     = is_same<_Tp, _Up>::value;
    template <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_base_of_v     = is_base_of<_Tp, _Up>::value;
    template <class _Tp, class _Up> _LIBCPP_CONSTEXPR bool is_convertible_v     = is_convertible<_Tp, _Up>::value;
      
#endif /* _LIBCPP_HAS_NO_VARIABLE_TEMPLATES */
 // 3.3.2, Other type transformations
/* template <class> class _LIBCPP_TEMPLATE_VIS raw_invocation_type;
    template <class _Fn, class ..._Args> class _LIBCPP_TEMPLATE_VIS raw_invocation_type<_Fn(_Args...)>;
    template <class> class _LIBCPP_TEMPLATE_VIS invokation_type;
    template <class _Fn, class ..._Args> class _LIBCPP_TEMPLATE_VIS invokation_type<_Fn(_Args...)>;
    template <class _Tp> using invokation_type_t = typename invokation_type<_Tp>::type;
    template <class _Tp> using raw_invocation_type_t = typename raw_invocation_type<_Tp>::type;
   */
 // 3.3.3, Logical operator traits
template <class...> using void_t = void;
   template<class _Tp> _LIBCPP_CONSTEXPR bool negation_v = negation<_Tp>::value;
    // 3.3.4, Detection idiom
template <class...> using void_t = void;
    struct nonesuch {
       nonesuch()  = delete;
       ~nonesuch() = delete;
       nonesuch      (nonesuch const&) = delete;
       void operator=(nonesuch const&) = delete;
     };
    template <class _Default, class _AlwaysVoid, template <class...> class _Op, class... _Args> struct _DETECTOR {
      using value_t = false_type;
      using type = _Default;
      };
    template <class _Default, template <class...> class _Op, class... _Args> struct _DETECTOR<_Default, void_t<_Op<_Args...>>, _Op, _Args...> {
      using value_t = true_type;
      using type = _Op<_Args...>;
      };
          template <template<class...> class _Op, class... _Args>   using is_detected = typename _DETECTOR<nonesuch, void, _Op, _Args...>::value_t;
   template <template<class...> class _Op, class... _Args>   using detected_t = typename _DETECTOR<nonesuch, void, _Op, _Args...>::type;
   template <template<class...> class _Op, class... _Args>   _LIBCPP_CONSTEXPR bool is_detected_v = is_detected<_Op, _Args...>::value;
    template <class Default, template<class...> class _Op, class... _Args>   using detected_or = _DETECTOR<Default, void, _Op, _Args...>;
   template <class Default, template<class...> class _Op, class... _Args>   using detected_or_t = typename detected_or<Default, _Op, _Args...>::type;
    template <class Expected, template<class...> class _Op, class... _Args>   using is_detected_exact = is_same<Expected, detected_t<_Op, _Args...>>;
   template <class Expected, template<class...> class _Op, class... _Args>   _LIBCPP_CONSTEXPR bool is_detected_exact_v = is_detected_exact<Expected, _Op, _Args...>::value;
    template <class To, template<class...> class _Op, class... _Args>   using is_detected_convertible = is_convertible<detected_t<_Op, _Args...>, To>;
   template <class To, template<class...> class _Op, class... _Args>   _LIBCPP_CONSTEXPR bool is_detected_convertible_v = is_detected_convertible<To, _Op, _Args...>::value;
       _LIBCPP_END_NAMESPACE_LFTS    
#endif /* _LIBCPP_STD_VER > 11 */
   
#endif /* _LIBCPP_EXPERIMENTAL_TYPE_TRAITS */
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_EXPERIMENTAL_UNORDERED_MAP
  
#define _LIBCPP_EXPERIMENTAL_UNORDERED_MAP
/*     experimental/unordered_map synopsis  // C++1z
namespace std {
   namespace experimental {
   inline namespace fundamentals_v1 {
   namespace pmr {
      template <class Key, class T,             class Hash = hash<Key>,             class Pred = equal_to<Key>>   using unordered_map =     std::unordered_map<Key, T, Hash, Pred,                        polymorphic_allocator<pair<const Key,T>>>;
      template <class Key, class T,             class Hash = hash<Key>,             class Pred = equal_to<Key>>   using unordered_multimap =     std::unordered_multimap<Key, T, Hash, Pred,                             polymorphic_allocator<pair<const Key,T>>>;
    }
  */
   
#if 0 /* expanded by -frewrite-includes */
  
#include <experimental/__config>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <unordered_map>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.unordered_map
//===----------------------------------------------------------------------===//
   
#ifndef _LIBCPP_UNORDERED_MAP
  
#define _LIBCPP_UNORDERED_MAP
 /*      unordered_map synopsis    
#include <initializer_list>
 namespace std {
#endif /* expanded by -frewrite-includes */
       static const size_t _MaxAlign = alignof(max_align_t);
        using _Alloc = typename _CTraits::template rebind_alloc<             typename aligned_storage<_MaxAlign, _MaxAlign>::type         >;
        using _ValueType = typename _Alloc::value_type;
        _Alloc __alloc_;
    public:     typedef _CharAlloc allocator_type;
        __resource_adaptor_imp() = default;
   };
    template <class _Alloc> using resource_adaptor = __resource_adaptor_imp<     typename allocator_traits<_Alloc>::template rebind_alloc<char>   >;
    _LIBCPP_END_NAMESPACE_LFTS_PMR  _LIBCPP_POP_MACROS    
#endif /* _LIBCPP_EXPERIMENTAL_MEMORY_RESOURCE */
  
#pragma clang module end /*std.experimental.memory_resource*/
   
#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#endif
 _LIBCPP_BEGIN_NAMESPACE_LFTS_PMR  template <class _ValueT> using vector = _VSTD::vector<_ValueT, polymorphic_allocator<_ValueT>>;
    _LIBCPP_END_NAMESPACE_LFTS_PMR    
#endif /* _LIBCPP_EXPERIMENTAL_VECTOR */
  
#pragma clang module end /*std.experimental.vector*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "experimental/__memory"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin std.experimental.__memory
// -*- C++ -*-
   
#ifndef _LIBCPP_EXPERIMENTAL___MEMORY
  
#define _LIBCPP_EXPERIMENTAL___MEMORY
   
#if 0 /* expanded by -frewrite-includes */
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <__functional_base>
  
#endif /* expanded by -frewrite-includes */
  
  };
    template <class _Tp, class _Alloc, class ..._Args> inline _LIBCPP_INLINE_VISIBILITY void __lfts_user_alloc_construct(     _Tp * __store, const _Alloc & __a, _Args &&... __args) {
       _VSTD::__user_alloc_construct_impl(         typename __lfts_uses_alloc_ctor<_Tp, _Alloc, _Args...>::type()        , __store, __a, _VSTD::forward<_Args>(__args)...        );
   }
    _LIBCPP_END_NAMESPACE_LFTS    
#endif /* _LIBCPP_EXPERIMENTAL___MEMORY */
  
#pragma clang module end /*std.experimental.__memory*/
  
#pragma clang module endbuild /*std*/
  
#pragma clang module build meta
  
# 1 "/home/gonzalo/mwe/test/new_test2/include/module.modulemap"
module meta {
     umbrella "meta"   export * }
     
#pragma clang module contents
  
#if 0 /* expanded by -frewrite-includes */
  
#include "meta/meta.hpp"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin meta
/// \file meta.hpp Tiny meta-programming library.
//
// Meta library
//
//
   
#ifndef META_HPP
  
#define META_HPP
   
#if 0 /* expanded by -frewrite-includes */
  
  
#include <meta/meta_fwd.hpp>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin meta
/// \file meta_fwd.hpp Forward declarations
//
//
// Project home: https://github.com/ericniebler/meta
//
   
#ifndef META_FWD_HPP
  
#define META_FWD_HPP
   
#if 0 /* expanded by -frewrite-includes */
  
#include <utility>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module import std.utility /* clang -frewrite-includes: implicit import */
   
#ifndef META_DISABLE_DEPRECATED_WARNINGS
  
#ifdef __cpp_attribute_deprecated
  
#define META_DEPRECATED(MSG) [[deprecated(MSG)]]
  
#else
  
#if defined(__clang__) || defined(__GNUC__)
  
#define META_DEPRECATED(MSG) __attribute__((deprecated(MSG)))
  
#elif defined(_MSC_VER)
  
#define META_DEPRECATED(MSG) __declspec(deprecated(MSG))
  
#else
  
#define META_DEPRECATED(MSG)
  
#endif
  
#endif
  
#else
  
#define META_DEPRECATED(MSG)
  
#endif
 namespace meta {
       inline namespace v1     {
     
#ifdef __cpp_lib_integer_sequence
        using std::integer_sequence;
     
#else
        template <typename T, T...>         struct integer_sequence;
     
#endif
         template <typename... Ts>         struct list;
            template <typename T>         struct id;
            template <template <typename...> class>         struct quote;
            template <typename T, template <T...> class F>         struct quote_i;
            template <typename... Fs>         struct compose;
            template <template <typename...> class C, typename... Ts>         struct defer;
            template <typename T, template <T...> class C, T... Is>         struct defer_i;
            namespace extension         {
               template <typename F, typename List>             struct apply;
           }
        }
   // inline namespace v1
}
   // namespace meta
   
#endif
  
#pragma clang module end /*meta*/
  
#if 0 /* expanded by -frewrite-includes */
  
  
#endif
 /// \defgroup meta Meta
///
/// A tiny metaprogramming library
 /// \defgroup trait Trait
/// Trait invocation/composition.
/// \ingroup meta
 /// Tiny metaprogramming library
namespace meta {
       /// \cond
    inline namespace v1     {
           /// \endcond
         namespace detail         {
               /// Returns a \p T nullptr
            template <typename T>             constexpr T *_nullptr_v()             {
                   return nullptr;
               }
           }
   // namespace detail
         /// An empty type.
        /// \ingroup datatype
        struct nil_         {
           };
            /// Type alias for \p T::type.
        /// \ingroup invocation
        template <typename T>         using _t = typename T::type;
      
#if defined(__cpp_variable_templates) || defined(META_DOXYGEN_INVOKED)
        /// Variable alias for \c T::type::value
        /// \note Requires C++14 or greater.
        /// \ingroup invocation
        template <typename T>         constexpr typename _t<T>::value_type _v = _t<T>::value;
     
#endif
         /// Lazy versions of meta actions
        namespace lazy         {
               /// \sa `meta::_t`
            /// \ingroup lazy_invocation
            template <typename T>             using _t = defer<_t, T>;
           }
            /// An integral constant wrapper for \c std::size_t.
        /// \ingroup integral
        template <std::size_t N>         using size_t = std::integral_constant<std::size_t, N>;
            /// An integral constant wrapper for \c bool.
        /// \ingroup integral
        template <bool B>         using bool_ = std::integral_constant<bool, B>;
            /// An integral constant wrapper for \c int.
        /// \ingroup integral
        template <int I>         using int_ = std::integral_constant<int, I>;
            /// An integral constant wrapper for \c char.
        /// \ingroup integral
        template <char Ch>         using char_ = std::integral_constant<char, Ch>;
            ///////////////////////////////////////////////////////////////////////////////////////////
        template <typename T>         using dec = std::integral_constant<decltype(T::type::value - 1), T::type::value - 1>;
            /// An integral constant wrapper around the result of adding the two wrapped
        /// integers
        /// \c T::type::value and \c U::type::value.
        /// \ingroup math
        template <typename T, typename U>         using plus = std::integral_constant<decltype(T::type::value + U::type::value),                                             T::type::value + U::type::value>;
            /// An integral constant wrapper around the result of subtracting the two
            /// A Boolean integral constant wrapper around \c true if \c T::type::value is
        /// less than \c
        /// U::type::value; \c false, otherwise.
        /// \ingroup math
        template <typename T, typename U>         using less = bool_<(T::type::value < U::type::value)>;
            /// A Boolean integral constant wrapper around \c true if \c T::type::value is
        /// greater than
        /// or equal to \c U::type::value; \c false, otherwise.
        /// \ingroup math
        template <typename T, typename U>         using bit_or = std::integral_constant<decltype(T::type::value | U::type::value),                                               T::type::value | U::type::value>;
            /// An integral constant wrapper around the result of bitwise-exclusive-or'ing
        /// the two
        /// wrapped integers \c T::type::value and \c U::type::value.
        /// \ingroup math
        template <typename T, typename U>         using bit_xor = std::integral_constant<decltype(T::type::value ^ U::type::value),                                                T::type::value ^ U::type::value>;
            /// An integral constant wrapper around the result of bitwise-complementing the
        /// wrapped
        /// integer \c T::type::value.
        /// \ingroup math
        template <typename T>         using bit_not = std::integral_constant<decltype(~T::type::value), ~T::type::value>;
            namespace lazy         {
               /// \sa 'meta::int'
            /// \ingroup lazy_math
                /// \sa 'meta::bit_xor'
            /// \ingroup lazy_math
            template <typename T, typename U>             using bit_xor = defer<bit_xor, T, U>;
                /// \sa 'meta::bit_not'
            /// \ingroup lazy_math
            template <typename T>             using bit_not = defer<bit_not, T>;
           }
            /// \cond
        namespace detail         {
               enum class indices_strategy_             {
                   done,                 repeat,                 recurse             };
                constexpr indices_strategy_ strategy_(std::size_t cur, std::size_t end)             {
                   return cur >= end ? indices_strategy_::done                                   : cur * 2 <= end ? indices_strategy_::repeat                                                    : indices_strategy_::recurse;
               }
                template <typename T>             constexpr std::size_t range_distance_(T begin, T end)             {
                   return begin <= end ? static_cast<std::size_t>(end - begin)                                     : throw "The start of the integer_sequence must not be "                                             "greater than the end";
               }
                template <std::size_t End, typename State, indices_strategy_ Status_>             struct make_indices_             {
                   using type = State;
               };
                template <typename T, T, typename>             struct coerce_indices_             {
               };
           }
   /// \endcond
 ///////////////////////////////////////////////////////////////////////////////////////////////
// integer_sequence
  
#ifndef __cpp_lib_integer_sequence
        /// A container for a sequence of compile-time integer constants.
        /// \ingroup integral
#endif
         ///////////////////////////////////////////////////////////////////////////////////////////////
        // index_sequence
        /// A container for a sequence of compile-time integer constants of type
        /// \c std::size_t
        /// \ingroup integral
        template <std::size_t... Is>         using index_sequence = integer_sequence<std::size_t, Is...>;
      
#if !defined(META_DOXYGEN_INVOKED) &&                                        \
    ((defined(__clang__) && __clang_major__ >= 3 && __clang_minor__ >= 8) || \
     (defined(_MSC_VER) && _MSC_FULL_VER >= 190023918))
        // Implement make_integer_sequence and make_index_sequence with the
        // __make_integer_seq builtin on compilers that provide it. (Redirect
        // through decltype to workaround suspected clang bug.)
        /// \cond
        namespace detail         {
               template <class T, T N>             __make_integer_seq<integer_sequence, T, N> make_integer_sequence_();
           }
           /// \endcond
         template <typename T, T N>         using make_integer_sequence = decltype(detail::make_integer_sequence_<T, N>());
            template <std::size_t N>         using make_index_sequence = make_integer_sequence<std::size_t, N>;
     
#else
        /// Generate \c index_sequence containing integer constants [0,1,2,...,N-1].
        /// \par Complexity
        /// \f$ O(log(N)) \f$.
        /// \ingroup integral
        template <std::size_t N>         using make_index_sequence =             _t<detail::make_indices_<N, index_sequence<0>, detail::strategy_(1, N)>>;
            /// Generate \c integer_sequence containing integer constants [0,1,2,...,N-1].
        /// \par Complexity
        /// \f$ O(log(N)) \f$.
        /// \ingroup integral
        template <typename T, T N>         using make_integer_sequence =             _t<detail::coerce_indices_<T, 0, make_index_sequence<static_cast<std::size_t>(N)>>>;
     
#endif
         ///////////////////////////////////////////////////////////////////////////////////////////////
        // integer_range
        /// Makes the integer sequence <tt>[From, To)</tt>.
        /// \par Complexity
        /// \f$ O(log(To - From)) \f$.
        /// \ingroup integral
        template <class T, T From, T To>         using integer_range =             _t<detail::coerce_indices_<T, From,                                        make_index_sequence<detail::range_distance_(From, To)>>>;
            /// \cond
        namespace detail         {
               template <typename, typename>             struct concat_indices_             {
               };
                template <std::size_t... Is, std::size_t... Js>             struct concat_indices_<index_sequence<Is...>, index_sequence<Js...>>             {
                   using type = index_sequence<Is..., (Js + sizeof...(Is))...>;
               };
                template <>             struct make_indices_<0u, index_sequence<0>, indices_strategy_::done>             {
                   using type = index_sequence<>;
               };
                template <std::size_t End, std::size_t... Values>             struct make_indices_<End, index_sequence<Values...>, indices_strategy_::repeat>                 : make_indices_<End, index_sequence<Values..., (Values + sizeof...(Values))...>,                                 detail::strategy_(sizeof...(Values)*2, End)>             {
               };
                template <std::size_t End, std::size_t... Values>             struct make_indices_<End, index_sequence<Values...>, indices_strategy_::recurse>                 : concat_indices_<index_sequence<Values...>,                                   make_index_sequence<End - sizeof...(Values)>>             {
               };
                template <typename T, T Offset, std::size_t... Values>             struct coerce_indices_<T, Offset, index_sequence<Values...>>             {
                   using type =                     integer_sequence<T, static_cast<T>(static_cast<T>(Values) + Offset)...>;
               };
           }
   // namespace detail
        /// \endcond
         /// Evaluate the Callable \p F with the arguments \p Args.
        /// \ingroup invocation
        template <typename F, typename... Args>         using invoke = typename F::template invoke<Args...>;
            /// Lazy versions of meta actions
        namespace lazy         {
               /// \sa `meta::invoke`
            /// \ingroup lazy_invocation
            template <typename F, typename... Args>             using invoke = defer<invoke, F, Args...>;
           }
            /// A trait that always returns its argument \p T. Also, a Callable that always
        /// returns
        /// \p T.
        /// \ingroup trait
        /// \ingroup invocation
        template <typename T>         struct id         {
     
#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 5 && !defined(META_DOXYGEN_INVOKED)
            // Redirect through decltype for compilers that have not
            // yet implemented CWG 1558:
            // <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1558>
            static id impl(void *);
                template <typename... Ts>             using invoke = _t<decltype(id::impl(static_cast<list<Ts...> *>(nullptr)))>;
     
#else
            template <typename...>             using invoke = T;
     
#endif
             using type = T;
           };
            /// An alias for type \p T. Useful in non-deduced contexts.
        /// \ingroup trait
        template <typename T>         using id_t = _t<id<T>>;
            namespace lazy         {
               /// \sa `meta::id`
            /// \ingroup lazy_trait
            /// \ingroup lazy_invocation
            template <typename T>             using id = defer<id, T>;
           }
            /// An alias for `void`.
        /// \ingroup trait
  
#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 5 && !defined(META_DOXYGEN_INVOKED)
        // Redirect through decltype for compilers that have not
        // yet implemented CWG 1558:
        // <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1558>
        template <typename... Ts>         using void_ = invoke<id<void>, Ts...>;
     
#else
        template <typename...>         using void_ = void;
     
#endif
         /// \cond
        namespace detail         {
               template <typename, typename = void>             struct is_trait_             {
                   using type = std::false_type;
               };
                template <typename T>             struct is_trait_<T, void_<typename T::type>>             {
                   using type = std::true_type;
               };
                template <typename, typename = void>             struct is_callable_             {
                   using type = std::false_type;
               };
                template <typename T>             struct is_callable_<T, void_<quote<T::template invoke>>>             {
                   using type = std::true_type;
               };
                template <template <typename...> class C, typename... Ts,                 template <typename...> class D = C>             id<D<Ts...>> try_defer_(int);
               template <template <typename...> class C, typename... Ts>             nil_ try_defer_(long);
                template <template <typename...> class C, typename... Ts>             using defer_ = decltype(detail::try_defer_<C, Ts...>(0));
                template <typename T, template <T...> class C, T... Is,                 template <T...> class D = C>             id<D<Is...>> try_defer_i_(int);
               template <typename T, template <T...> class C, T... Is>             nil_ try_defer_i_(long);
                template <typename T, template <T...> class C, T... Is>             using defer_i_ = decltype(detail::try_defer_i_<T, C, Is...>(0));
                template <typename T>             using _t_t = _t<_t<T>>;
           }
   // namespace detail
        /// \endcond
         /// An alias for `std::true_type` if `T::type` exists and names a type;
        /// otherwise, it's an alias for `std::false_type`.
        /// \ingroup trait
        template <typename T>         using is_trait = _t<detail::is_trait_<T>>;
            /// An alias for `std::true_type` if `T::invoke` exists and names a class
        /// template or alias template; otherwise, it's an alias for
        /// `std::false_type`.
        /// \ingroup trait
        template <typename T>         using is_callable = _t<detail::is_callable_<T>>;
        ///
        /// \ingroup invocation
        template <template <typename...> class C, typename... Ts>         struct defer : detail::defer_<C, Ts...>         {
           };
            ///////////////////////////////////////////////////////////////////////////////////////////
        // defer_i
        /// A wrapper that defers the instantiation of a template \p C with integral
        /// constant parameters \p Is in a \c lambda or \c let expression.
        template <template <typename...> class C>         struct quote         {
               // Indirection through defer here needed to avoid Core issue 1430
            // http://open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1430
            template <typename... Ts>             using invoke = _t<detail::defer_<C, Ts...>>;
           };
            /// Turn a class template or alias template \p C taking literals of type \p T
        /// into a Callable.
        /// \ingroup composition
        template <typename T, template <T...> class C>         struct quote_i         {
               // Indirection through defer_i here needed to avoid Core issue 1430
            // http://open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1430
            template <typename... Ts>             using invoke = _t<detail::defer_i_<T, C, Ts::type::value...>>;
           };
      
#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 8 && !defined(META_DOXYGEN_INVOKED)
        template <template <typename...> class C>         struct quote_trait         {
               template <typename... Ts>             using invoke = _t<invoke<quote<C>, Ts...>>;
           };
            template <typename T, template <T...> class C>         struct quote_trait_i         {
               template <typename... Ts>             using invoke = _t<invoke<quote_i<T, C>, Ts...>>;
           };
     
#else
        // clang-format off
        /// Turn a trait template \p C into a Callable.
        /// \code
        /// static_assert(std::is_same<invoke<quote_trait<std::add_const>, int>, int const>::value, "");
        /// \endcode
        /// \ingroup composition
        template <template <typename...> class C>         using quote_trait = compose<quote<_t>, quote<C>>;
            /// Turn a trait \p C taking literals of type \p T into a Callable.
        /// \sa 'meta::quote_trait'
        /// \ingroup composition
        template <typename T, template <T...> class C>         using quote_trait_i = compose<quote<_t>, quote_i<T, C>>;
   // clang-format on
  
#endif
         /// A Callable that partially applies the Callable
        /// \p F by binding the arguments \p Ts to the \e front of \p F.
        /// \ingroup composition
        template <typename F, typename... Ts>         struct bind_front         {
               template <typename... Us>             using invoke = invoke<F, Ts..., Us...>;
           };
            /// A Callable that partially applies the Callable \p F by binding the
        /// arguments \p Us to the \e back of \p F.
        /// \ingroup composition
        template <typename F, typename... Us>         struct bind_back         {
               template <typename... Ts>             using invoke = invoke<F, Ts..., Us...>;
           };
            namespace lazy         {
               /// \sa 'meta::bind_front'
            /// \ingroup lazy_composition
            template <typename Fn, typename... Ts>             using bind_front = defer<bind_front, Fn, Ts...>;
                /// \sa 'meta::bind_back'
            /// \ingroup lazy_composition
            template <typename Fn, typename... Ts>             using bind_back = defer<bind_back, Fn, Ts...>;
           }
            /// Extend meta with your own datatypes.
        namespace extension         {
               /// A trait that unpacks the types in the type list \p List into the Callable
            /// \p F.
            /// \ingroup extension
            template <typename F, typename List>             struct apply             {
               };
                template <typename F, typename Ret, typename... Args>             struct apply<F, Ret(Args...)> : lazy::invoke<F, Ret, Args...>             {
               };
                template <typename F, template <typename...> class T, typename... Ts>             struct apply<F, T<Ts...>> : lazy::invoke<F, Ts...>             {
               };
                template <typename F, typename T, T... Is>             struct apply<F, integer_sequence<T, Is...>>                 : lazy::invoke<F, std::integral_constant<T, Is>...>             {
               };
           }
            /// Applies the Callable \p C using the types in the type list \p List as
        /// arguments.
        /// \ingroup invocation
        template <typename C, typename List>         using apply = _t<extension::apply<C, List>>;
            namespace lazy         {
               template <typename F, typename List>             using apply = defer<apply, F, List>;
           }
            /// A Callable that takes a bunch of arguments, bundles them into a type list,
        /// and
        /// then calls the Callable \p F with the type list \p Q.
        /// \ingroup composition
        template <typename F, typename Q = quote<list>>         using curry = compose<F, Q>;
            /// A Callable that takes a type list, unpacks the types, and then calls the
        /// Callable \p F with the types.
        /// \ingroup composition
        template <typename F>         using uncurry = bind_front<quote<apply>, F>;
            namespace lazy         {
               /// \sa 'meta::curry'
            /// \ingroup lazy_composition
            template <typename F, typename Q = quote<list>>             using curry = defer<curry, F, Q>;
                /// \sa 'meta::uncurry'
            /// \ingroup lazy_composition
            template <typename F>             using uncurry = defer<uncurry, F>;
           }
            /// A Callable that reverses the order of the first two arguments.
        /// \ingroup composition
        template <typename F>         struct flip         {
           private:             template <typename... Ts>             struct impl             {
               };
               template <typename A, typename B, typename... Ts>             struct impl<A, B, Ts...> : lazy::invoke<F, B, A, Ts...>             {
               };
            public:             template <typename... Ts>             using invoke = _t<impl<Ts...>>;
           };
            namespace lazy         {
               /// \sa 'meta::flip'
            /// \ingroup lazy_composition
            template <typename F>             using flip = defer<flip, F>;
           }
            /// \cond
        namespace detail         {
               template <typename...>             struct on_             {
               };
               template <typename F, typename... Gs>             struct on_<F, Gs...>             {
                   template <typename... Ts>                 using invoke = invoke<F, invoke<compose<Gs...>, Ts>...>;
               };
             
#ifdef __clang__
            // Clang is faster with this implementation
            template <typename, typename = bool>             struct _if_             {
               };
                template <typename If>             struct _if_<list<If>, decltype(bool(If::type::value))> : std::enable_if<If::type::value>             {
               };
                template <typename If, typename Then>             struct _if_<list<If, Then>, decltype(bool(If::type::value))>                 : std::enable_if<If::type::value, Then>             {
               };
                template <typename If, typename Then, typename Else>             struct _if_<list<If, Then, Else>, decltype(bool(If::type::value))>                 : std::conditional<If::type::value, Then, Else>             {
               };
             
#else
            // GCC seems to prefer this implementation
            template <typename, typename = std::true_type>             struct _if_             {
               };
                   using type = Then;
               };
                template <typename If, typename Then, typename Else>             struct _if_<list<If, Then, Else>, bool_<!If::type::value>>             {
                   using type = Else;
               };
             
#endif
        }
   // namespace detail
        /// \endcond
         /// Select one type or another depending on a compile-time Boolean.
        /// \ingroup logical
        template <typename... Args>         using if_ = _t<detail::_if_<list<Args...>>>;
            /// Select one type or another depending on a compile-time Boolean.
        /// \ingroup logical
        template <bool If, typename... Args>         using if_c = _t<detail::_if_<list<bool_<If>, Args...>>>;
            namespace lazy         {
               /// \sa 'meta::if_'
            /// \ingroup lazy_logical
            template <typename... Args>             using if_ = defer<if_, Args...>;
                /// \sa 'meta::if_c'
            /// \ingroup lazy_logical
            template <bool If, typename... Args>             using if_c = if_<bool_<If>, Args...>;
           }
            /// \cond
        namespace detail         {
               template <bool>             struct _and_             {
                   template <class = void>                 using invoke = std::true_type;
               };
                template <>             struct _and_<false>             {
                   template <typename Bool_, typename... Bools>                 using invoke = invoke<                     if_c<!Bool_::type::value,                          id<std::false_type>,                          _and_<0==sizeof...(Bools)>>, Bools...>;
               };
                template <bool>             struct _or_             {
                   template <class = void>                 using invoke = std::false_type;
               };
                template <>             struct _or_<false>             {
                   template <typename Bool_, typename... Bools>                 using invoke = invoke<                     if_c<Bool_::type::value,                          id<std::true_type>,                          _or_<0 == sizeof...(Bools)>>, Bools...>;
               };
           }
   // namespace detail
        /// \endcond
         /// Logically negate the Boolean parameter
        /// \ingroup logical
        template <bool Bool_>         using not_c = bool_<!Bool_>;
            /// Logically negate the integral constant-wrapped Boolean parameter.
        /// \ingroup logical
        template <typename Bool_>         using not_ = not_c<Bool_::type::value>;
    /// Logically and together all the Boolean parameters
/// \ingroup logical
  
#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ == 5 && __GNUC_MINOR__ == 1
        // Alternative formulation of and_c to workaround
        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66405
        template <bool... Bools>         using and_c = std::is_same<integer_sequence<bool, true, Bools...>,                                    integer_sequence<bool, Bools..., true>>;
     
#else
        template <bool... Bools>         using and_c = std::is_same<integer_sequence<bool, Bools...>,                                    integer_sequence<bool, (Bools || true)...>>;
     
#endif
         /// Logically and together all the integral constant-wrapped Boolean parameters,
        /// \e without
        /// doing short-circuiting.
        /// \ingroup logical
        template <typename... Bools>         using strict_and = and_c<Bools::type::value...>;
            /// Logically and together all the integral constant-wrapped Boolean parameters,
        /// \e with
        /// short-circuiting.
        /// \ingroup logical
        // Make a trip through defer<> to avoid CWG1430
        template <typename... Bools>         using and_ = _t<defer<detail::_and_<0 == sizeof...(Bools)>::template invoke, Bools...>>;
            /// Logically or together all the Boolean parameters
        /// \ingroup logical
        template <bool... Bools>         using or_c = not_<std::is_same<integer_sequence<bool, Bools...>,                                        integer_sequence<bool, (Bools && false)...>>>;
            /// Logically or together all the integral constant-wrapped Boolean parameters,
        /// \e without
        /// doing short-circuiting.
        /// \ingroup logical
        template <typename... Bools>         using strict_or = or_c<Bools::type::value...>;
            /// Logically or together all the integral constant-wrapped Boolean parameters,
        /// \e with
        /// short-circuiting.
        /// \ingroup logical
        // Make a trip through defer<> to avoid CWG1430
        template <typename... Bools>         using or_ = _t<defer<detail::_or_<0 == sizeof...(Bools)>:: template invoke, Bools...>>;
            namespace lazy         {
               /// \sa 'meta::and_'
            /// \ingroup lazy_logical
            template <typename... Bools>             using and_ = defer<and_, Bools...>;
                /// \sa 'meta::or_'
            /// \ingroup lazy_logical
            template <typename... Bools>             using or_ = defer<or_, Bools...>;
                /// \sa 'meta::not_'
            /// \ingroup lazy_logical
            template <typename Bool_>             using not_ = defer<not_, Bool_>;
                /// \sa 'meta::strict_and'
            /// \ingroup lazy_logical
            template <typename... Bools>             using strict_and = defer<strict_and, Bools...>;
                /// \sa 'meta::strict_or'
            /// \ingroup lazy_logical
            template <typename... Bools>             using strict_or = defer<strict_or, Bools...>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // fold
        /// \cond
        namespace detail         {
               template <typename Fun, typename T0>             struct compose1_             {
                   template <typename X>                 using invoke = invoke<Fun, _t<X>, T0>;
               };
                template <typename Fun, typename T0, typename T1, typename T2, typename T3, typename T4,                       typename T5, typename T6, typename T7, typename T8, typename T9>             struct compose10_             {
                   template <typename X, typename Y>                 using F = invoke<Fun, X, Y>;
                    template <typename S>                 using invoke =                     F<F<F<F<F<F<F<F<F<F<_t<S>, T0>, T1>, T2>, T3>, T4>, T5>, T6>, T7>, T8>, T9>;
               };
                template <typename, typename, typename>             struct fold_             {
               };
                template <typename State, typename Fun>             struct fold_<list<>, State, Fun> : State             {
               };
                template <typename Head, typename... List, typename State, typename Fun>             struct fold_<list<Head, List...>, State, Fun>                 : fold_<list<List...>, lazy::invoke<compose1_<Fun, Head>, State>, Fun>             {
               };
                template <typename T0, typename T1, typename T2, typename T3, typename T4, typename T5,                       typename T6, typename T7, typename T8, typename T9, typename... List,                       typename State, typename Fun>             struct fold_<list<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, List...>, State, Fun>                 : fold_<                       list<List...>,                       lazy::invoke<compose10_<Fun, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>, State>,                       Fun>             {
               };
           }
   // namespace detail
        /// \endcond
         /// Return a new \c meta::list constructed by doing a left fold of the list \p List using
        /// binary Callable \p Fun and initial state \p State. That is, the \c State_N for the list
        /// element \c A_N is computed by `Fun(State_N-1, A_N) -> State_N`.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup transformation
        template <typename List, typename State, typename Fun>         using fold = _t<detail::fold_<List, id<State>, Fun>>;
            /// An alias for `meta::fold`.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup transformation
        template <typename List, typename State, typename Fun>         using accumulate = fold<List, State, Fun>;
            namespace lazy         {
               /// \sa 'meta::foldl'
            /// \ingroup lazy_transformation
            template <typename List, typename State, typename Fun>             using fold = defer<fold, List, State, Fun>;
                /// \sa 'meta::accumulate'
            /// \ingroup lazy_transformation
            template <typename List, typename State, typename Fun>             using accumulate = defer<accumulate, List, State, Fun>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // reverse_fold
        using npos = meta::size_t<std::size_t(-1)>;
            ///////////////////////////////////////////////////////////////////////////////////////////
        // list
        /// A list of types.
        /// \ingroup list
        template <typename... Ts>         struct list         {
               using type = list;
               /// \return `sizeof...(Ts)`
            static constexpr std::size_t size() noexcept {
   return sizeof...(Ts);
   }
           };
            ///////////////////////////////////////////////////////////////////////////////////////////
        // size
        /// An integral constant wrapper that is the size of the \c meta::list
        /// \p List.
        /// \ingroup list
        template <typename List>         using size = meta::size_t<List::size()>;
            namespace lazy         {
               /// \sa 'meta::size'
            /// \ingroup lazy_list
            template <typename List>             using size = defer<size, List>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // concat
        /// \cond
        namespace detail         {
               template <typename... Lists>             struct concat_             {
               };
                template <>             struct concat_<>             {
                   using type = list<>;
               };
           }
   // namespace detail
        /// \endcond
         /// Concatenates several lists into a single list.
        /// \pre The parameters must all be instantiations of \c meta::list.
        /// \par Complexity
        /// \f$ O(L) \f$ where \f$ L \f$ is the number of lists in the list of lists.
        /// \ingroup transformation
        template <typename... Lists>         using concat = _t<detail::concat_<Lists...>>;
            namespace lazy         {
               /// \sa 'meta::concat'
            /// \ingroup lazy_transformation
            template <typename... Lists>             using concat = defer<concat, Lists...>;
           }
            /// Joins a list of lists into a single list.
        /// \pre The parameter must be an instantiation of \c meta::list\<T...\>
        /// where each \c T is itself an instantiation of \c meta::list.
        /// \par Complexity
        /// \f$ O(L) \f$ where \f$ L \f$ is the number of lists in the list of
        /// lists.
        /// \ingroup transformation
        template <typename ListOfLists>         using join = apply<quote<concat>, ListOfLists>;
            namespace lazy         {
               /// \sa 'meta::join'
            /// \ingroup lazy_transformation
            template <typename ListOfLists>             using join = defer<join, ListOfLists>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // transform
        /// \cond
        namespace detail         {
               template <typename, typename = void>             struct transform_             {
               };
                template <typename... Ts, typename Fun>             struct transform_<list<list<Ts...>, Fun>, void_<invoke<Fun, Ts>...>>             {
                   using type = list<invoke<Fun, Ts>...>;
               };
                template <typename... Ts0, typename... Ts1, typename Fun>             struct transform_<list<list<Ts0...>, list<Ts1...>, Fun>,                               void_<invoke<Fun, Ts0, Ts1>...>>             {
                   using type = list<invoke<Fun, Ts0, Ts1>...>;
               };
           }
   // namespace detail
        /// \endcond
         /// Return a new \c meta::list constructed by transforming all the elements in
        /// \p List with
        /// the unary Callable \p Fun. \c transform can also be called with two lists of
        /// the same length and a binary Callable, in which case it returns a new list
        /// constructed with the results of calling \c Fun with each element in the
        /// lists,
        /// pairwise.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup transformation
        template <typename... Args>         using transform = _t<detail::transform_<list<Args...>>>;
        /// \cond
        namespace detail         {
               template <typename T, std::size_t>             using first_ = T;
                template <typename T, typename Ints>             struct repeat_n_c_             {
               };
                template <typename T, std::size_t... Is>             struct repeat_n_c_<T, index_sequence<Is...>>             {
                   using type = list<first_<T, Is>...>;
               };
           }
           /// \endcond
         /// Generate `list<T,T,T...T>` of size \p N arguments.
        /// \par Complexity
        /// \f$ O(log N) \f$.
        /// \ingroup list
        template <std::size_t N, typename T = void>         using repeat_n_c = _t<detail::repeat_n_c_<T, make_index_sequence<N>>>;
            /// Generate `list<T,T,T...T>` of size \p N arguments.
        /// \par Complexity
        /// \f$ O(log N) \f$.
        /// \ingroup list
        template <typename N, typename T = void>         using repeat_n = repeat_n_c<N::type::value, T>;
            namespace lazy         {
               /// \sa 'meta::repeat_n'
            /// \ingroup lazy_list
            template <typename N, typename T = void>             using repeat_n = defer<repeat_n, N, T>;
                /// \sa 'meta::repeat_n_c'
            /// \ingroup lazy_list
            template <std::size_t N, typename T = void>             using repeat_n_c = defer<repeat_n, meta::size_t<N>, T>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // at
        /// \cond
        namespace detail         {
               template <typename VoidPtrs>             struct at_impl_;
                template <typename... VoidPtrs>             struct at_impl_<list<VoidPtrs...>>             {
                   static nil_ eval(...);
                    template <typename T, typename... Us>                 static T eval(VoidPtrs..., T *, Us *...);
               };
                template <typename List, typename N>             struct at_             {
               };
                template <typename... Ts, typename N>             struct at_<list<Ts...>, N>                 : decltype(at_impl_<repeat_n<N, void *>>::eval(static_cast<id<Ts> *>(nullptr)...))             {
               };
           }
   // namespace detail
        /// \endcond
         ///////////////////////////////////////////////////////////////////////////////////////////
        // at
        /// Return the \p N th element in the \c meta::list \p List.
        /// \par Complexity
        /// Amortized \f$ O(1) \f$.
        /// \ingroup list
        template <typename List, typename N>         using at = _t<detail::at_<List, N>>;
            /// Return the \p N th element in the \c meta::list \p List.
        /// \par Complexity
        /// Amortized \f$ O(1) \f$.
        /// \ingroup list
        template <typename List, std::size_t N>         using at_c = at<List, meta::size_t<N>>;
            namespace lazy         {
               /// \sa 'meta::at'
            /// \ingroup lazy_list
            template <typename List, typename N>             using at = defer<at, List, N>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // drop
        /// \cond
        namespace detail         {
               ///////////////////////////////////////////////////////////////////////////////////////
            /// drop_impl_
            template <typename VoidPtrs>             struct drop_impl_             {
                   static nil_ eval(...);
               };
                template <typename... VoidPtrs>             struct drop_impl_<list<VoidPtrs...>>             {
                   static nil_ eval(...);
                    template <typename... Ts>                 static id<list<Ts...>> eval(VoidPtrs..., id<Ts> *...);
               };
                template <>             struct drop_impl_<list<>>             {
                   template <typename... Ts>                 static id<list<Ts...>> eval(id<Ts> *...);
               };
                template <typename List, typename N>             struct drop_             {
               };
                template <typename... Ts, typename N>             struct drop_<list<Ts...>, N>                 : decltype(drop_impl_<repeat_n<N, void *>>::eval(detail::_nullptr_v<id<Ts>>()...))             {
               };
           }
   // namespace detail
        /// \endcond
         /// Return a new \c meta::list by removing the first \p N elements from \p List.
        /// \par Complexity
        /// \f$ O(1) \f$.
        /// \ingroup transformation
        template <typename List, typename N>         using drop = _t<detail::drop_<List, N>>;
            /// Return a new \c meta::list by removing the first \p N elements from \p List.
        /// \par Complexity
        /// \f$ O(1) \f$.
        /// \ingroup transformation
        template <typename List, std::size_t N>         using drop_c = _t<detail::drop_<List, meta::size_t<N>>>;
            namespace lazy         {
               /// \sa 'meta::drop'
            /// \ingroup lazy_transformation
            template <typename List, typename N>             using drop = defer<drop, List, N>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // front
        /// \cond
        namespace detail         {
               template <typename List>             struct front_             {
               };
                template <typename Head, typename... List>             struct front_<list<Head, List...>>             {
                   using type = Head;
               };
           }
   // namespace detail
        /// \endcond
         /// Return the first element in \c meta::list \p List.
        /// \par Complexity
        /// \f$ O(1) \f$.
        /// \ingroup list
        template <typename List>         using front = _t<detail::front_<List>>;
            namespace lazy         {
               /// \sa 'meta::front'
            /// \ingroup lazy_list
            template <typename List>             using front = defer<front, List>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // back
        /// \cond
        namespace detail         {
               template <typename List>             struct back_             {
               };
                template <typename Head, typename... List>             struct back_<list<Head, List...>>             {
                   using type = at_c<list<Head, List...>, sizeof...(List)>;
               };
           }
   // namespace detail
        /// \endcond
         /// Return the last element in \c meta::list \p List.
        /// \par Complexity
        /// Amortized \f$ O(1) \f$.
        /// \ingroup list
        template <typename List>         using back = _t<detail::back_<List>>;
        namespace detail         {
               template <typename List, typename T>             struct push_front_             {
               };
                template <typename... List, typename T>             struct push_front_<list<List...>, T>             {
                   using type = list<T, List...>;
               };
           }
   // namespace detail
        /// \endcond
         /// Return a new \c meta::list by adding the element \c T to the front of \p
        /// List.
        /// \par Complexity
        /// \f$ O(1) \f$.
        /// \ingroup transformation
        template <typename List, typename T>         using push_front = _t<detail::push_front_<List, T>>;
        namespace detail         {
               template <typename List>             struct pop_front_             {
               };
                template <typename Head, typename... List>             struct pop_front_<list<Head, List...>>             {
                   using type = list<List...>;
               };
           }
   // namespace detail
        /// \endcond
         /// Return a new \c meta::list by removing the first element from the front of
        /// \p List.
        /// \par Complexity
        /// \f$ O(1) \f$.
        /// \ingroup transformation
        template <typename List>         using pop_front = _t<detail::pop_front_<List>>;
        namespace detail         {
               template <typename List, typename T>             struct push_back_             {
               };
                template <typename... List, typename T>             struct push_back_<list<List...>, T>             {
                   using type = list<List..., T>;
               };
           }
   // namespace detail
        template <typename List, typename T>         using push_back = _t<detail::push_back_<List, T>>;
            namespace lazy         {
               /// \sa 'meta::push_back'
            /// \ingroup lazy_transformation
            template <typename List, typename T>             using push_back = defer<push_back, List, T>;
           }
            /// \cond
        namespace detail         {
               template <typename T, typename U>             using min_ = if_<less<U, T>, U, T>;
                template <typename T, typename U>             using max_ = if_<less<U, T>, T, U>;
           }
           /// \endcond
         /// An integral constant wrapper around the minimum of `Ts::type::value...`
        /// \ingroup math
        template <typename... Ts>         using min = fold<pop_front<list<Ts...>>, front<list<Ts...>>, quote<detail::min_>>;
        /// false, otherwise.
        /// \par Complexity
        /// \f$ O(1) \f$.
        /// \ingroup list
        template <typename List>         using empty = bool_<0 == size<List>::type::value>;
            namespace lazy         {
               /// \sa 'meta::empty'
            /// \ingroup lazy_list
            template <typename List>             using empty = defer<empty, List>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // pair
        /// A list with exactly two elements
        /// \ingroup list
        template <typename F, typename S>         using pair = list<F, S>;
            /// Retrieve the first element of the \c pair \p Pair
        /// \ingroup list
        template <typename Pair>         using first = front<Pair>;
            /// Retrieve the first element of the \c pair \p Pair
        /// \ingroup list
        template <typename Pair>         using second = front<pop_front<Pair>>;
            namespace lazy         {
               /// \sa 'meta::first'
            /// \ingroup lazy_list
            template <typename Pair>             using first = defer<first, Pair>;
                /// \sa 'meta::second'
            /// \ingroup lazy_list
            template <typename Pair>             using second = defer<second, Pair>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // find_index
        /// \cond
        namespace detail         {
               // With thanks to Peter Dimov:
            constexpr std::size_t find_index_i_(bool const *const first, bool const *const last,                                                 std::size_t N = 0)             {
                   return first == last ? npos::value                                      : *first ? N : find_index_i_(first + 1, last, N + 1);
               }
                template <typename List, typename T>             struct find_index_             {
               };
                template <typename V>             struct find_index_<list<>, V>             {
                   using type = npos;
               };
                template <typename... T, typename V>             struct find_index_<list<T...>, V>             {
                   
#if defined(__clang__) && __cplusplus > 201402L
                // work-around clang bug: https://llvm.org/bugs/show_bug.cgi?id=28385
#else
                static constexpr bool s_v[] = {
  std::is_same<T, V>::value...};
                   using type = size_t<find_index_i_(s_v, s_v + sizeof...(T))>;
                   
#endif
            };
           }
        /// \ingroup query
        /// \sa `meta::npos`
        template <typename List, typename T>         using find_index = _t<detail::find_index_<List, T>>;
            namespace lazy         {
               /// \sa 'meta::find_index'
            /// \ingroup lazy_query
            template <typename List, typename T>             using find_index = defer<find_index, List, T>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // reverse_find_index
        /// \cond
        namespace detail         {
               // With thanks to Peter Dimov:
            constexpr std::size_t reverse_find_index_i_(bool const *const first,                                                         bool const *const last, std::size_t N)             {
                   return first == last                            ? npos::value                            : *(last - 1) ? N - 1 : reverse_find_index_i_(first, last - 1, N - 1);
               }
                template <typename List, typename T>             struct reverse_find_index_             {
               };
                template <typename V>             struct reverse_find_index_<list<>, V>             {
                   using type = npos;
               };
                template <typename... T, typename V>             struct reverse_find_index_<list<T...>, V>             {
                   
#if defined(__clang__) && __cplusplus > 201402L
                   
#else
                static constexpr bool s_v[] = {
  std::is_same<T, V>::value...};
                   using type = size_t<reverse_find_index_i_(s_v, s_v + sizeof...(T), sizeof...(T))>;
                   
#endif
            };
           }
   // namespace detail
        /// \endcond
         /// Finds the index of the last occurrence of the type \p T within the list \p
        /// List. Returns
        /// `#meta::npos` if the type \p T was not found.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup query
        /// \sa `#meta::npos`
        template <typename List, typename T>         using reverse_find_index = _t<detail::reverse_find_index_<List, T>>;
            namespace lazy         {
               /// \sa 'meta::reverse_find_index'
            /// \ingroup lazy_query
            template <typename List, typename T>             using reverse_find_index = defer<reverse_find_index, List, T>;
           }
            ////////////////////////////////////////////////////////////////////////////////////
        // find
        /// Return the tail of the list \p List starting at the first occurrence of \p
        /// T, if any
        /// such element exists; the empty list, otherwise.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup query
        template <typename List, typename T>         using find = drop<List, min<find_index<List, T>, size<List>>>;
            namespace lazy         {
               /// \sa 'meta::find'
            /// \ingroup lazy_query
            template <typename List, typename T>             using find = defer<find, List, T>;
           }
        /// \cond
        namespace detail         {
               constexpr bool const *find_if_i_(bool const *const begin, bool const *const end)             {
                   return begin == end || *begin ? begin : find_if_i_(begin + 1, end);
               }
                template <typename List, typename Fun, typename = void>             struct find_if_             {
               };
                template <typename Fun>             struct find_if_<list<>, Fun>             {
                   using type = list<>;
               };
                template <typename... List, typename Fun>             struct find_if_<list<List...>, Fun,                             void_<integer_sequence<bool, bool(invoke<Fun, List>::type::value)...>>>             {
                   
#if defined(__clang__) && __cplusplus > 201402L
                // work-around clang bug: https://llvm.org/bugs/show_bug.cgi?id=28385
                static constexpr std::size_t index_()                 {
                       constexpr bool s_v[] = {
  invoke<Fun, List>::type::value...};
                       return detail::find_if_i_(s_v, s_v + sizeof...(List)) - s_v;
                   }
                   using type = drop_c<list<List...>, index_()>;
                   
#else
                static constexpr bool s_v[] = {
  invoke<Fun, List>::type::value...};
                   using type =                     drop_c<list<List...>, detail::find_if_i_(s_v, s_v + sizeof...(List)) - s_v>;
                   
#endif
            };
           }
   // namespace detail
        /// \endcond
        /// \ingroup query
        template <typename List, typename Fun>         using find_if = _t<detail::find_if_<List, Fun>>;
            namespace lazy         {
               /// \sa 'meta::find_if'
            /// \ingroup lazy_query
            template <typename List, typename Fun>             using find_if = defer<find_if, List, Fun>;
           }
            ////////////////////////////////////////////////////////////////////////////////////
        // reverse_find_if
        /// \cond
        namespace detail         {
               constexpr bool const *reverse_find_if_i_(bool const *const begin, bool const *const pos,                                                      bool const *const end)             {
                   return begin == pos                            ? end                            : *(pos - 1) ? pos - 1 : reverse_find_if_i_(begin, pos - 1, end);
               }
                template <typename List, typename Fun, typename = void>             struct reverse_find_if_             {
               };
                template <typename Fun>             struct reverse_find_if_<list<>, Fun>             {
                   using type = list<>;
               };
                template <typename... List, typename Fun>             struct reverse_find_if_<                 list<List...>, Fun,                 void_<integer_sequence<bool, bool(invoke<Fun, List>::type::value)...>>>             {
                   
#if defined(__clang__) && __cplusplus > 201402L
                // work-around clang bug: https://llvm.org/bugs/show_bug.cgi?id=28385
                static constexpr std::size_t index_()                 {
                       constexpr bool s_v[] = {
  invoke<Fun, List>::type::value...};
                       return detail::reverse_find_if_i_(s_v, s_v + sizeof...(List),                                                       s_v + sizeof...(List)) - s_v;
                   }
                   using type = drop_c<list<List...>, index_()>;
                   
#else
                static constexpr bool s_v[] = {
  invoke<Fun, List>::type::value...};
                   using type =                   drop_c<list<List...>, detail::reverse_find_if_i_(s_v, s_v + sizeof...(List),                                                                    s_v + sizeof...(List)) - s_v>;
                   
#endif
            };
           }
           /// \endcond
        // replace
        /// \cond
        namespace detail         {
               template <typename List, typename T, typename U>             struct replace_             {
               };
                template <typename... List, typename T, typename U>             struct replace_<list<List...>, T, U>             {
                   using type = list<if_<std::is_same<T, List>, U, List>...>;
               };
           }
   // namespace detail
        /// \endcond
         /// Return a new \c meta::list where all instances of type \p T have been
        /// replaced with
        /// \p U.
        /// \par Complexity
            ///////////////////////////////////////////////////////////////////////////////////////////
        // replace_if
        /// \cond
        namespace detail         {
               template <typename List, typename C, typename U, typename = void>             struct replace_if_             {
               };
                template <typename... List, typename C, typename U>             struct replace_if_<list<List...>, C, U,                                void_<integer_sequence<bool, bool(invoke<C, List>::type::value)...>>>             {
                   using type = list<if_<invoke<C, List>, U, List>...>;
               };
           }
   // namespace detail
        /// \endcond
         /// Return a new \c meta::list where all elements \c A of the list \p List for
        /// which
        /// `invoke<C,A>::%value` is \c true have been replaced with \p U.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup transformation
        template <typename List, typename C, typename U>         using replace_if = _t<detail::replace_if_<List, C, U>>;
            namespace lazy         {
               /// \sa 'meta::replace_if'
            /// \ingroup lazy_transformation
            template <typename List, typename C, typename U>             using replace_if = defer<replace_if, C, U>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////
        // count
        namespace detail         {
               constexpr std::size_t count_i_(bool const *const begin, bool const *const end,                                            std::size_t n)             {
                   return begin == end ? n : detail::count_i_(begin + 1, end, n + *begin);
               }
                template <typename List, typename T, typename = void>             struct count_             {
               };
                template <typename T>             struct count_<list<>, T>             {
                   using type = meta::size_t<0>;
               };
                template <typename... List, typename T>             struct count_<list<List...>, T>             {
                   
#if defined(__clang__) && __cplusplus > 201402L
                   
#else
                static constexpr bool s_v[] = {
  std::is_same<T, List>::value...};
                   using type = meta::size_t<detail::count_i_(s_v, s_v + sizeof...(List), 0u)>;
                   
#endif
            };
               template <typename T>             struct static_const             {
                   static constexpr T value{
  };
               };
                // Avoid potential ODR violations with global objects:
            template <typename T>             constexpr T static_const<T>::value;
           }
   // namespace detail
         ///\endcond
         ///////////////////////////////////////////////////////////////////////////////////////////
        // for_each
        /// \cond
        namespace detail         {
               struct for_each_fn             {
                   template <class UnaryFunction, class... Args>                 constexpr auto operator()(list<Args...>, UnaryFunction f) const -> UnaryFunction                 {
                       return (void)std::initializer_list<int>{
  ((void)f(Args{
  }
  ), 0)...}
  , f;
                   }
               };
           }
   // namespace detail
        /// \endcond
         ///\cond
        namespace         {
               /// \endcond
             /// `for_each(List, UnaryFunction)` calls the \p UnaryFunction for each
            /// argument in the \p List.
            /// \ingroup runtime
            constexpr auto &&for_each = detail::static_const<detail::for_each_fn>::value;
                /// \cond
        }
           /// \endcond
         ///////////////////////////////////////////////////////////////////////////////////////////
        // transpose
        /// Given a list of lists of types \p ListOfLists, transpose the elements from
        /// the lists.
        /// \par Complexity
        /// \f$ O(N \times M) \f$, where \f$ N \f$ is the size of the outer list, and
        /// \f$ M \f$ is the size of the inner lists.
        /// \ingroup transformation
        template <typename ListOfLists>         using transpose = fold<ListOfLists, repeat_n<size<front<ListOfLists>>, list<>>,                                bind_back<quote<transform>, quote<push_back>>>;
            namespace lazy         {
               /// \sa 'meta::transpose'
            /// \ingroup lazy_transformation
            template <typename ListOfLists>             using transpose = defer<transpose, ListOfLists>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // zip_with
        /// Given a list of lists of types \p ListOfLists and a Callable \p Fun,
        /// construct
        /// a new list by calling \p Fun with the elements from the lists pairwise.
        /// \par Complexity
        /// \f$ O(N \times M) \f$, where \f$ N \f$ is the size of the outer list, and
        /// \f$ M \f$ is the size of the inner lists.
        /// \ingroup transformation
        template <typename Fun, typename ListOfLists>         using zip_with = transform<transpose<ListOfLists>, uncurry<Fun>>;
            namespace lazy         {
               /// \sa 'meta::zip_with'
            /// \ingroup lazy_transformation
            template <typename Fun, typename ListOfLists>             using zip_with = defer<zip_with, Fun, ListOfLists>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // zip
        /// Given a list of lists of types \p ListOfLists, construct a new list by
        /// grouping the
        /// elements from the lists pairwise into `meta::list`s.
        /// \par Complexity
        /// \f$ O(N \times M) \f$, where \f$ N \f$ is the size of the outer list, and
        /// \f$ M \f$
        /// is the size of the inner lists.
        /// \ingroup transformation
        template <typename ListOfLists>         using zip = transpose<ListOfLists>;
            namespace lazy         {
               /// \sa 'meta::zip'
               template <typename T>             using uncvref_t = _t<std::remove_cv<_t<std::remove_reference<T>>>>;
                // Indirection here needed to avoid Core issue 1430
            // http://open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1430
            template <typename Sequence>             struct as_list_ : lazy::invoke<uncurry<curry<quote_trait<id>>>, uncvref_t<Sequence>>             {
               };
           }
   // namespace detail
        /// \endcond
        /// A Boolean integral constant wrapper around \c true if `invoke<F, A>::%value`
        /// is
        /// \c true for any element \c A in \c meta::list \p List; \c false, otherwise.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup query
        template <typename List, typename F>         using any_of = not_<empty<find_if<List, F>>>;
            namespace lazy         {
               /// \sa 'meta::any_of'
            /// \ingroup lazy_query
            template <typename List, typename Fn>             using any_of = defer<any_of, List, Fn>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // none_of
        /// A Boolean integral constant wrapper around \c true if `invoke<F, A>::%value`
        /// is
        /// \c false for all elements \c A in \c meta::list \p List; \c false,
        /// otherwise.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup query
        template <typename List, typename F>         using none_of = empty<find_if<List, F>>;
            namespace lazy         {
               /// \sa 'meta::none_of'
            /// \ingroup lazy_query
            template <typename List, typename Fn>             using none_of = defer<none_of, List, Fn>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // in
        /// A Boolean integral constant wrapper around \c true if there is at least one
        /// occurrence
        /// of \p T in \p List.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup query
        template <typename List, typename T>         using in = not_<empty<find<List, T>>>;
            namespace lazy         {
               /// \sa 'meta::in'
            /// \ingroup lazy_query
            template <typename List, typename T>             using in = defer<in, List, T>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // inherit
        /// \cond
        namespace detail         {
               template <typename List>             struct inherit_             {
               };
                template <typename... List>             struct inherit_<list<List...>> : List...             {
                   using type = inherit_;
               };
           }
           /// \endcond
         /// A type that inherits from all the types in the list
        /// \pre The types in the list must be unique
        /// \pre All the types in the list must be non-final class types
        /// \ingroup datatype
        template <typename List>         using inherit = meta::_t<detail::inherit_<List>>;
            namespace lazy         {
               /// \sa 'meta::inherit'
            /// \ingroup lazy_datatype
            template <typename List>             using inherit = defer<inherit, List>;
           }
   // namespace detail
        /// \endcond
         ///////////////////////////////////////////////////////////////////////////////////////////
        // unique
        /// Return a new \c meta::list where all duplicate elements have been removed.
        /// \par Complexity
        /// \f$ O(N^2) \f$.
        // partition
        /// \cond
        namespace detail         {
               template <typename Pred>             struct partition_             {
                   template <typename, typename, typename = void>                 struct impl                 {
                   };
                   template <typename... Yes, typename... No, typename A>                 struct impl<pair<list<Yes...>, list<No...>>, A,                             void_<bool_<invoke<Pred, A>::type::value>>>                 {
                       using type = if_<invoke<Pred, A>, pair<list<Yes..., A>, list<No...>>,                                      pair<list<Yes...>, list<No..., A>>>;
                   };
                   template <typename State, typename A>                 using invoke = _t<impl<State, A>>;
               };
           }
   // namespace detail
        /// \endcond
         /// Returns a pair of lists, where the elements of \p List that satisfy the
        /// Callable \p Pred such that `invoke<Pred,A>::%value` is \c true are present
        /// in the
        /// first list and the rest are in the second.
        /// \par Complexity
        /// \f$ O(N) \f$.
        /// \ingroup transformation
        template <typename List, typename Pred>         using partition = fold<List, pair<list<>, list<>>, detail::partition_<Pred>>;
            namespace lazy         {
               /// \sa 'meta::partition'
            /// \ingroup lazy_transformation
            template <typename List, typename Pred>             using partition = defer<partition, List, Pred>;
           }
            ///////////////////////////////////////////////////////////////////////////////////////////
        // sort
        /// \cond
        namespace detail         {
               template <typename, typename, typename = void>             struct sort_             {
               };
                template <typename Pred>             struct sort_<list<>, Pred>             {
                   using type = list<>;
               };
                template <typename A, typename Pred>             struct sort_<list<A>, Pred>             {
                   using type = list<A>;
               };
                template <typename A, typename B, typename... List, typename Pred>             struct sort_<                 list<A, B, List...>, Pred,                 void_<_t<sort_<first<partition<list<B, List...>, bind_back<Pred, A>>>, Pred>>>>             {
                   using P = partition<list<B, List...>, bind_back<Pred, A>>;
                   using type = concat<_t<sort_<first<P>, Pred>>, list<A>, _t<sort_<second<P>, Pred>>>;
               };
           }
           /// \endcond
         // clang-format off
        /// \endcode
        /// \ingroup transformation
        // clang-format on
        template <typename List, typename Pred>         using sort = _t<detail::sort_<List, Pred>>;
            namespace lazy         {
               /// \sa 'meta::sort'
            /// \ingroup lazy_transformation
            template <typename List, typename Pred>             using sort = defer<sort, List, Pred>;
           }
            ////////////////////////////////////////////////////////////////////////////
        // lambda_
        /// \cond
        namespace detail         {
               template <typename T, int = 0>             struct protect_;
                template <typename, int = 0>             struct vararg_;
                template <typename T, int = 0>             struct is_valid_;
                // Returns which branch to evaluate
            template <typename If, typename... Ts>             using lazy_if_ = lazy::_t<defer<_if_, list<If, protect_<Ts>...>>>;
                template <typename A, typename T, typename F, typename Ts>             struct subst1_             {
                   using type = list<list<T>>;
               };
               template <typename T, typename F, typename Ts>             struct subst1_<F, T, F, Ts>             {
                   using type = list<>;
               };
               template <typename A, typename T, typename F, typename Ts>             struct subst1_<vararg_<A>, T, F, Ts>             {
                   using type = list<Ts>;
               };
                template <typename As, typename Ts>             using substitutions_ = push_back<                 join<transform<                     concat<As, repeat_n_c<size<Ts>{
  }
   + 2 - size<As>{
  }
  , back<As>>>,                     concat<Ts, repeat_n_c<2, back<As>>>,                     bind_back<quote_trait<subst1_>, back<As>, drop_c<Ts, size<As>{
  }
   - 2>>>>,                 list<back<As>>>;
                template <typename As, typename Ts>             using substitutions =                 invoke<if_c<(size<Ts>{
  }
   + 2 >= size<As>{
  }
  ), quote<substitutions_>>, As, Ts>;
                template <typename T>             struct is_vararg_ : std::false_type             {
               };
               template <typename T>             struct is_vararg_<vararg_<T>> : std::true_type             {
               };
                template <typename Tags>             using is_variadic_ = is_vararg_<at<push_front<Tags, void>, dec<size<Tags>>>>;
                template <typename Tags, bool IsVariadic = is_variadic_<Tags>::value>             struct lambda_;
                // Non-variadic lambda implementation
            template <typename... As>             struct lambda_<list<As...>, false>             {
               private:                 static constexpr std::size_t arity = sizeof...(As)-1;
                   using Tags = list<As...>;
   // Includes the lambda body as the last arg!
                using F = back<Tags>;
                   template <typename T, typename Args>                 struct impl;
                   template <typename T, typename Args>                 using lazy_impl_ = lazy::_t<defer<impl, T, protect_<Args>>>;
                   template <typename, typename, typename = void>                 struct subst_                 {
                   };
                   template <template <typename...> class C, typename... Ts, typename Args>                 struct subst_<defer<C, Ts...>, Args, void_<C<_t<impl<Ts, Args>>...>>>                 {
                       using type = C<_t<impl<Ts, Args>>...>;
                   };
                   template <typename T, template <T...> class C, T... Is, typename Args>                 struct subst_<defer_i<T, C, Is...>, Args, void_<C<Is...>>>                 {
                       using type = C<Is...>;
                   };
                   template <typename If, typename... Ts, typename Args>                 struct impl<defer<if_, If, Ts...>, Args> // Short-circuit if_
                    : impl<lazy_impl_<lazy_if_<If, Ts...>, Args>, Args>                 {
                   };
                   template <typename Bool_, typename... Ts, typename Args>                 struct impl<defer<and_, Bool_, Ts...>, Args> // Short-circuit and_
                    : impl<lazy_impl_<lazy_if_<Bool_, lazy::and_<Ts...>, protect_<std::false_type>>,                                       Args>,                            Args>                 {
                   };
                   template <typename Bool_, typename... Ts, typename Args>                 struct impl<defer<or_, Bool_, Ts...>, Args> // Short-circuit or_
                    : impl<lazy_impl_<lazy_if_<Bool_, protect_<std::true_type>, lazy::or_<Ts...>>,                                       Args>,                            Args>                 {
                   };
                   template <template <typename...> class C, typename... Ts, typename Args>                 struct impl<defer<C, Ts...>, Args> : subst_<defer<C, Ts...>, Args>                 {
                   };
                   template <typename T, template <T...> class C, T... Is, typename Args>                 struct impl<defer_i<T, C, Is...>, Args> : subst_<defer_i<T, C, Is...>, Args>                 {
                   };
                   template <template <typename...> class C, typename... Ts, typename Args>                 struct impl<C<Ts...>, Args> : subst_<defer<C, Ts...>, Args>                 {
                   };
                   template <typename... Ts, typename Args>                 struct impl<lambda_<list<Ts...>, false>, Args>                 {
                       using type = compose<uncurry<lambda_<list<As..., Ts...>, false>>,                                          curry<bind_front<quote<concat>, Args>>>;
                   };
                   template <typename... Bs, typename Args>                 struct impl<lambda_<list<Bs...>, true>, Args>                 {
                       using type = compose<typename lambda_<list<As..., Bs...>, true>::thunk,                                          bind_front<quote<concat>, transform<Args, quote<list>>>,                                          curry<bind_front<quote<substitutions>, list<Bs...>>>>;
                   };
                public:                 template <typename... Ts>                 using invoke = _t<if_c<sizeof...(Ts) == arity, impl<F, list<Ts..., F>>>>;
               };
                // Lambda with variadic placeholder (broken out due to less efficient
            // compile-time
            // resource usage)
            template <typename... As>             struct lambda_<list<As...>, true>             {
               private:                 template <typename T, bool IsVar>                 friend struct lambda_;
                   using Tags = list<As...>;
   // Includes the lambda body as the last arg!
                template <typename T, typename Args>                 struct impl;
                   template <typename Args>                 using eval_impl_ = bind_back<quote_trait<impl>, Args>;
                   template <typename T, typename Args>                 using lazy_impl_ = lazy::_t<defer<impl, T, protect_<Args>>>;
                   template <template <typename...> class C, typename Args, typename Ts>                 using try_subst_ = apply<quote<C>, join<transform<Ts, eval_impl_<Args>>>>;
                   template <typename, typename, typename = void>                 struct subst_                 {
                   };
                   template <template <typename...> class C, typename... Ts, typename Args>                 struct subst_<defer<C, Ts...>, Args, void_<try_subst_<C, Args, list<Ts...>>>>                 {
                       using type = list<try_subst_<C, Args, list<Ts...>>>;
                   };
                   template <typename T, template <T...> class C, T... Is, typename Args>                 struct subst_<defer_i<T, C, Is...>, Args, void_<C<Is...>>>                 {
                       using type = list<C<Is...>>;
                   };
                   template <typename T, typename Args>                 struct impl : if_c<(reverse_find_index<Tags, T>() != npos()),                                    lazy::at<Args, reverse_find_index<Tags, T>>, id<list<T>>>                 {
                   };
                   template <typename T, typename Args>                 struct impl<protect_<T>, Args>                 {
                       using type = list<T>;
                   };
                   template <typename T, typename Args>                 struct impl<is_valid_<T>, Args>                 {
                       using type = list<is_trait<impl<T, Args>>>;
                   };
                   template <typename If, typename... Ts, typename Args>                 struct impl<defer<if_, If, Ts...>, Args> // Short-circuit if_
                    : impl<lazy_impl_<lazy_if_<If, Ts...>, Args>, Args>                 {
                   };
                   template <typename T, template <T...> class C, T... Is, typename Args>                 struct impl<defer_i<T, C, Is...>, Args> : subst_<defer_i<T, C, Is...>, Args>                 {
                   };
                   template <template <typename...> class C, typename... Ts, typename Args>                 struct impl<C<Ts...>, Args> : subst_<defer<C, Ts...>, Args>                 {
                   };
                   template <typename... Bs, bool IsVar, typename Args>                 struct impl<lambda_<list<Bs...>, IsVar>, Args>                 {
                       using type =                         list<compose<typename lambda_<list<As..., Bs...>, true>::thunk,                                      bind_front<quote<concat>, Args>,                                      curry<bind_front<quote<substitutions>, list<Bs...>>>>>;
                   };
                   struct thunk                 {
                       template <typename S, typename R = _t<impl<back<Tags>, S>>>                     using invoke = if_c<size<R>{
  }
   == 1, front<R>>;
                   };
                public:                 template <typename... Ts>                 using invoke = invoke<thunk, substitutions<Tags, list<Ts...>>>;
               };
           }
        /// "");
        /// \endcode
        /// \ingroup trait
        template <typename... Ts>         using lambda = if_c<(sizeof...(Ts) > 0), detail::lambda_<list<Ts...>>>;
            ///////////////////////////////////////////////////////////////////////////////////////////
        // is_valid
        /// For testing whether a deferred computation will succeed in a \c let or a \c
        /// For use when defining local variables in \c meta::let expressions
        /// \sa `meta::let`
        template <typename Tag, typename Value>         struct var;
            /// \cond
        namespace detail         {
               template <typename... As>             struct let_             {
               };
               template <typename Fn>             struct let_<Fn>             {
                   using type = lazy::invoke<lambda<Fn>>;
               };
               template <typename Tag, typename Value, typename... Rest>             struct let_<var<Tag, Value>, Rest...>             {
                   using type = lazy::invoke<lambda<Tag, _t<let_<Rest...>>>, Value>;
               };
           }
           /// \endcond
         /// A lexically scoped expression with local variables.
        template <typename... As>         using let = _t<_t<detail::let_<As...>>>;
            namespace lazy         {
               /// \sa `meta::let`
            /// \ingroup lazy_trait
            template <typename... As>             using let = defer<let, As...>;
           }
            // Some argument placeholders for use in \c lambda expressions.
        /// \ingroup trait
        inline namespace placeholders         {
               // regular placeholders:
            struct _a;
               struct _b;
               struct _c;
               struct _d;
               struct _e;
               struct _f;
           }
   // namespace placeholders
         ///////////////////////////////////////////////////////////////////////////////////////////
        // cartesian_product
        /// \cond
        namespace detail         {
               template <typename M2, typename M>             struct cartesian_product_fn             {
                   template <typename X>                 struct lambda0                 {
                       template <typename Xs>                     using lambda1 = list<push_front<Xs, X>>;
                       using type = join<transform<M2, quote<lambda1>>>;
                   };
                   using type = join<transform<M, quote_trait<lambda0>>>;
               };
           }
   // namespace detail
        // add_const_if
        namespace detail         {
               template <bool>             struct add_const_if             {
                   template <typename T>                 using invoke = T const;
               };
               template <>             struct add_const_if<false>             {
                   template <typename T>                 using invoke = T;
               };
           }
   // namespace detail
        template <bool If>         using add_const_if_c = detail::add_const_if<If>;
           template <typename If>         using add_const_if = add_const_if_c<If::type::value>;
           /// \endcond
         /// \cond
        ///////////////////////////////////////////////////////////////////////////////////////////
        // const_if
        template <bool If, typename T>         using const_if_c = invoke<add_const_if_c<If>, T>;
           template <typename If, typename T>         using const_if = invoke<add_const_if<If>, T>;
           /// \endcond
         /// \cond
        namespace detail         {
               template <typename State, typename Ch>             using atoi_ = if_c<(Ch::value >= '0' && Ch::value <= '9'),                                std::integral_constant<typename State::value_type,                                                       State::value * 10 + (Ch::value - '0')>>;
           }
           /// \endcond
         inline namespace literals         {
               /// A user-defined literal that generates objects of type \c meta::size_t.
            /// \ingroup integral
            template <char... Chs>             constexpr fold<list<char_<Chs>...>, meta::size_t<0>, quote<detail::atoi_>>                 operator"" _z()             {
                   return {
  };
               }
           }
           /// \cond
    }
   // namespace v1
      /// \endcond
}
   // namespace meta
 /// \cond
  
#if defined(__clang__) && defined(_LIBCPP_VERSION) && _LIBCPP_VERSION <= 1101
 _LIBCPP_BEGIN_NAMESPACE_STD template <class> class _LIBCPP_TYPE_VIS_ONLY allocator;
   template <class, class> struct _LIBCPP_TYPE_VIS_ONLY pair;
   template <class> struct _LIBCPP_TYPE_VIS_ONLY hash;
   template <class> struct _LIBCPP_TYPE_VIS_ONLY less;
  
#pragma GCC diagnostic pop
  
#endif
  
#endif
  
#pragma clang module end /*meta*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "meta/meta_fwd.hpp"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin meta
/// \file meta_fwd.hpp Forward declarations
//
// Meta library
//
//  Copyright Eric Niebler 2014-2015
//
#ifndef META_FWD_HPP
  
#define META_FWD_HPP
   
#if 0 /* expanded by -frewrite-includes */
  
#include <utility>
  
#endif /* expanded by -frewrite-includes */
   
#ifndef META_DISABLE_DEPRECATED_WARNINGS
  
#ifdef __cpp_attribute_deprecated
  
#define META_DEPRECATED(MSG) [[deprecated(MSG)]]
  
#endif
  
#else
  
#define META_DEPRECATED(MSG)
  
        template <typename T, T...>         struct integer_sequence;
     
#endif
         template <typename... Ts>         struct list;
            template <typename T>         struct id;
            template <template <typename...> class>         struct quote;
            template <typename T, template <T...> class F>         struct quote_i;
            template <typename... Fs>         struct compose;
   // namespace meta
   
#endif
  
#pragma clang module end /*meta*/
  
#pragma clang module endbuild /*meta*/
  
#pragma clang module build range
  
# 1 "/home/gonzalo/mwe/test/new_test2/include/module.modulemap"
module range {
     umbrella "range"   export * }
     
#pragma clang module contents
  
#if 0 /* expanded by -frewrite-includes */
  
#include "range/v3/range_concepts.hpp"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin range
//  http://www.boost.org/LICENSE_1_0.txt)
//
// Project home: https://github.com/ericniebler/range-v3
//
   
#ifndef RANGES_V3_RANGE_CONCEPTS_HPP
  
#define RANGES_V3_RANGE_CONCEPTS_HPP
   
#if 0 /* expanded by -frewrite-includes */
  
#include <initializer_list>
  
#endif /* expanded by -frewrite-includes */
  
  
#pragma clang module import meta /* clang -frewrite-includes: implicit import */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <range/v3/begin_end.hpp>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014
//
#ifndef RANGES_V3_BEGIN_END_HPP
  
#define RANGES_V3_BEGIN_END_HPP
   
#if 0 /* expanded by -frewrite-includes */
  
#include <functional>
  
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014
//
   
#ifndef RANGES_V3_RANGE_FWD_HPP
  
#define RANGES_V3_RANGE_FWD_HPP
   
#if 0 /* expanded by -frewrite-includes */
  
#include <climits>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module import std.compat.climits /* clang -frewrite-includes: implicit import */
  
#if 0 /* expanded by -frewrite-includes */
  
  
#include <range/v3/detail/config.hpp>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin range
/// \file
//  http://www.boost.org/LICENSE_1_0.txt)
//
// Project home: https://github.com/ericniebler/range-v3
//
   
#ifndef RANGES_V3_DETAIL_CONFIG_HPP
  
#define RANGES_V3_DETAIL_CONFIG_HPP
   
#if 0 /* expanded by -frewrite-includes */
  
#include <iosfwd>
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module import std.iosfwd /* clang -frewrite-includes: implicit import */
  
#if (defined(NDEBUG) && !defined(RANGES_ENSURE_MSG)) || \
    (!defined(NDEBUG) && !defined(RANGES_ASSERT) && \
     defined(__GNUC__) && !defined(__clang__) && \
     (__GNUC__ < 5 || defined(__MINGW32__)))
  
#if 0 /* expanded by -frewrite-includes */
   
#define	_ASSERT_H	1
  
#if 0 /* expanded by -frewrite-includes */
  
#include <features.h>
  
#undef	__KERNEL_STRICT_NAMES
 /* Suppress kernel-name space pollution unless user expressedly asks    for it.  */
  
#ifndef _LOOSE_KERNEL_NAMES
  
# define __KERNEL_STRICT_NAMES
  
# undef  _ATFILE_SOURCE
# define _ATFILE_SOURCE	1
#endif

#ifdef	_XOPEN_SOURCE
# define __USE_XOPEN	1
# if (_XOPEN_SOURCE - 0) >= 500
#  define __USE_XOPEN_EXTENDED	1
#  ifdef _XOPEN_SOURCE_EXTENDED
#   define __USE_XOPEN_EXTENDED	1
#  endif
# endif
#endif

#ifdef _LARGEFILE_SOURCE
# define __USE_ATFILE	1
#endif

#ifdef	_GNU_SOURCE
# define __USE_GNU	1
#endif

#if defined _REENTRANT || defined _THREAD_SAFE
# define __USE_REENTRANT	1
#endif

#if defined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0
# if !defined __OPTIMIZE__ || __OPTIMIZE__ <= 0
#  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
# elif !__GNUC_PREREQ (4, 1)
#  warning _FORTIFY_SOURCE requires GCC 4.1 or later
# elif _FORTIFY_SOURCE > 1
#  define __USE_FORTIFY_LEVEL 2
# else
#  define __USE_FORTIFY_LEVEL 1
# endif
#endif
#ifndef __USE_FORTIFY_LEVEL
# define __USE_FORTIFY_LEVEL 0
#endif

/* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  */
#if 0 /* expanded by -frewrite-includes */
#include <stdc-predef.h>
#endif /* expanded by -frewrite-includes */
# undef static_assert
# define static_assert _Static_assert
#endif

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#if 0 /* expanded by -frewrite-includes */
#pragma GCC system_header
#endif /* expanded by -frewrite-includes */
#endif
#define RANGES_ASSERT assert
#endif
#endif

#ifndef RANGES_ASSUME
#if defined(__clang__) || defined(__GNUC__)
#define RANGES_ASSUME(COND) static_cast<void>((COND) ? void(0) : __builtin_unreachable())
#elif defined(_MSC_VER)
#define RANGES_ASSUME(COND) static_cast<void>(__assume(COND))
#else
#define RANGES_ASSUME(COND) static_cast<void>(COND)
#endif
#endif // RANGES_ASSUME
#define RANGES_DECLTYPE_AUTO_RETURN(...)                        \
    -> decltype(__VA_ARGS__)                                    \
    { return (__VA_ARGS__); }                                   \
    /**/

#define RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(...)               \
    noexcept(noexcept(decltype(__VA_ARGS__)(__VA_ARGS__))) ->   \
    decltype(__VA_ARGS__)                                       \
    { return (__VA_ARGS__); }                                   \
    /**/

#define RANGES_AUTO_RETURN_NOEXCEPT(...)                        \
    noexcept(noexcept(decltype(__VA_ARGS__)(__VA_ARGS__)))      \
    { return (__VA_ARGS__); }                                   \
    /**/

#define RANGES_DECLTYPE_NOEXCEPT(...)                           \
    noexcept(noexcept(decltype(__VA_ARGS__)(__VA_ARGS__))) ->   \
    decltype(__VA_ARGS__)                                       \
    /**/

// Non-portable forward declarations of standard containers
#ifdef _LIBCPP_VERSION
#define RANGES_BEGIN_NAMESPACE_STD _LIBCPP_BEGIN_NAMESPACE_STD
#define RANGES_END_NAMESPACE_STD _LIBCPP_END_NAMESPACE_STD
#else
#define RANGES_BEGIN_NAMESPACE_STD namespace std {
#define RANGES_END_NAMESPACE_STD }
#endif

// Database of feature versions
#if defined(_MSC_VER) && !defined(__clang__)
#if _MSC_VER >= 1900
#ifndef RANGES_CXX_VARIABLE_TEMPLATES
#define RANGES_CXX_VARIABLE_TEMPLATES RANGES_CXX_VARIABLE_TEMPLATES_14
#endif
#ifndef RANGES_CXX_ATTRIBUTE_DEPRECATED
#define RANGES_CXX_ATTRIBUTE_DEPRECATED RANGES_CXX_ATTRIBUTE_DEPRECATED_14
#endif
#if !defined(RANGES_CXX_RANGE_BASED_FOR) && defined(_MSVC_LANG) && _MSVC_LANG > 201402
#define RANGES_CXX_RANGE_BASED_FOR RANGES_CXX_RANGE_BASED_FOR_17
#endif
#ifndef RANGES_CXX_LIB_IS_FINAL
#define RANGES_CXX_LIB_IS_FINAL RANGES_CXX_LIB_IS_FINAL_14
#endif
#ifndef RANGES_CXX_RETURN_TYPE_DEDUCTION
#define RANGES_CXX_RETURN_TYPE_DEDUCTION RANGES_CXX_RETURN_TYPE_DEDUCTION_14
#endif
#ifndef RANGES_CXX_GENERIC_LAMBDAS
#define RANGES_CXX_GENERIC_LAMBDAS RANGES_CXX_GENERIC_LAMBDAS_14
#endif

#else // _MSC_VER < 1900
#error Unsupported version of Visual C++
#endif // _MSC_VER switch

#define RANGES_DIAGNOSTIC_PUSH __pragma(warning(push))
#define RANGES_DIAGNOSTIC_POP __pragma(warning(pop))
#define RANGES_DIAGNOSTIC_IGNORE(X) __pragma(warning(disable:X))
#define RANGES_DIAGNOSTIC_IGNORE_SHADOWING RANGES_DIAGNOSTIC_IGNORE(4456)
#define RANGES_DIAGNOSTIC_IGNORE_PRAGMAS RANGES_DIAGNOSTIC_IGNORE(4068)
#define RANGES_DIAGNOSTIC_IGNORE_INDENTATION
#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL

#else // ^^^ defined(_MSC_VER) ^^^ / vvv !defined(_MSC_VER) vvv
// Generic configuration using SD-6 feature test macros with fallback to __cplusplus
#if defined(__GNUC__) || defined(__clang__)
#define RANGES_PRAGMA(X) _Pragma(#X)
#define RANGES_DIAGNOSTIC_PUSH RANGES_PRAGMA(GCC diagnostic push)
#define RANGES_DIAGNOSTIC_POP RANGES_PRAGMA(GCC diagnostic pop)
#define RANGES_DIAGNOSTIC_IGNORE(X) RANGES_PRAGMA(GCC diagnostic ignored X)
#define RANGES_DIAGNOSTIC_IGNORE_SHADOWING RANGES_DIAGNOSTIC_IGNORE("-Wshadow")
#define RANGES_DIAGNOSTIC_IGNORE_PRAGMAS RANGES_DIAGNOSTIC_IGNORE("-Wunknown-pragmas") RANGES_DIAGNOSTIC_IGNORE("-Wpragmas")
#define RANGES_DIAGNOSTIC_IGNORE_INDENTATION RANGES_DIAGNOSTIC_IGNORE("-Wmisleading-indentation")
#define RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL RANGES_DIAGNOSTIC_IGNORE("-Wundefined-internal")
#define RANGES_DIAGNOSTIC_IGNORE_MISMATCHED_TAGS RANGES_DIAGNOSTIC_IGNORE("-Wmismatched-tags")
#define RANGES_DIAGNOSTIC_IGNORE_SIGN_CONVERSION RANGES_DIAGNOSTIC_IGNORE("-Wsign-conversion")
#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL RANGES_DIAGNOSTIC_IGNORE("-Wfloat-equal")
#ifdef __clang__
#define RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS RANGES_DIAGNOSTIC_IGNORE("-Wglobal-constructors")
#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL RANGES_DIAGNOSTIC_IGNORE("-Wunneeded-internal-declaration")
#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER RANGES_DIAGNOSTIC_IGNORE("-Wunneeded-member-function")
#define RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY RANGES_DIAGNOSTIC_IGNORE("-Wzero-length-array")
#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT
#else
#define RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS
#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL
#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER
#define RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY
#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT RANGES_DIAGNOSTIC_IGNORE("-Wc++1z-compat")
#endif
#else
#define RANGES_DIAGNOSTIC_PUSH
#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL
#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_MEMBER
#define RANGES_DIAGNOSTIC_IGNORE_ZERO_LENGTH_ARRAY
#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT
#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL
#endif
#endif // MSVC/Generic configuration switch

#define RANGES_CXX_FEATURE_CONCAT2(y, z) RANGES_CXX_ ## y ## _ ## z
#define RANGES_CXX_FEATURE_CONCAT(y, z) RANGES_CXX_FEATURE_CONCAT2(y, z)
#define RANGES_CXX_FEATURE(x) RANGES_CXX_FEATURE_CONCAT(x, RANGES_CXX_STD_NAME)

#if __cplusplus >= RANGES_CXX_STD_14
#define RANGES_CXX_STD_NAME 14
#define RANGES_CXX_STD RANGES_CXX_STD_14
#else
#define RANGES_CXX_STD_NAME 11
#define RANGES_CXX_STD RANGES_CXX_STD_11
#endif

#ifndef RANGES_CXX_STATIC_ASSERT
#ifdef __cpp_static_assert
#define RANGES_CXX_VARIABLE_TEMPLATES __cpp_variable_templates
#else
#define RANGES_CXX_VARIABLE_TEMPLATES RANGES_CXX_FEATURE(VARIABLE_TEMPLATES)
#endif
#endif

#ifndef RANGES_CXX_ATTRIBUTE_DEPRECATED
#ifdef __has_cpp_attribute
#define RANGES_CXX_ATTRIBUTE_DEPRECATED __has_cpp_attribute(deprecated)
#elif defined(__cpp_attribute_deprecated)
#define RANGES_CXX_ATTRIBUTE_DEPRECATED __cpp_attribute_deprecated
#else
#define RANGES_CXX_ATTRIBUTE_DEPRECATED RANGES_CXX_FEATURE(ATTRIBUTE_DEPRECATED)
#endif
#endif

#ifndef RANGES_CXX_LIB_IS_FINAL
#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
#pragma clang module import std.type_traits /* clang -frewrite-includes: implicit import */
#ifdef __cpp_lib_is_final
#define RANGES_CXX_RETURN_TYPE_DEDUCTION __cpp_return_type_deduction
#else
#define RANGES_CXX_RETURN_TYPE_DEDUCTION RANGES_CXX_FEATURE(RETURN_TYPE_DEDUCTION)
#endif
#endif

#ifndef RANGES_CXX_GENERIC_LAMBDAS
#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED <= 70100
#define RANGES_CXX_THREAD_LOCAL 0
#elif defined(__IPHONE_OS_VERSION_MIN_REQUIRED) || \
    (defined(__clang__) && (defined(__CYGWIN__) || defined(__apple_build_version__)))
// BUGBUG avoid unresolved __cxa_thread_atexit
#define RANGES_CXX_THREAD_LOCAL RANGES_CXX_THREAD_LOCAL_PRE_STANDARD
#else
#define RANGES_CXX_THREAD_LOCAL RANGES_CXX_FEATURE(THREAD_LOCAL)
#endif
#endif

#ifndef RANGES_DISABLE_DEPRECATED_WARNINGS
#if RANGES_CXX_ATTRIBUTE_DEPRECATED &&            \
   !((defined(__clang__) || defined(__GNUC__)) && \
     RANGES_CXX_STD < RANGES_CXX_STD_14)
#define RANGES_DEPRECATED(MSG) [[deprecated(MSG)]]
#elif defined(__clang__) || defined(__GNUC__)
#define RANGES_DEPRECATED(MSG) __attribute__((deprecated(MSG)))
#elif defined(_MSC_VER)
#define RANGES_DEPRECATED(MSG) __declspec(deprecated(MSG))
#else
#define RANGES_DEPRECATED(MSG)
#endif
#else
#define RANGES_DEPRECATED(MSG)
#endif

#ifndef RANGES_CXX_COROUTINES
#ifdef __cpp_coroutines
#define RANGES_CXX_COROUTINES __cpp_coroutines
#else
#define RANGES_CXX_COROUTINES RANGES_CXX_FEATURE(COROUTINES)
#endif
#endif

// RANGES_CXX14_CONSTEXPR macro (see also BOOST_CXX14_CONSTEXPR)
// Note: constexpr implies inline, to retain the same visibility
// C++14 constexpr functions are inline in C++11
#if RANGES_CXX_CONSTEXPR >= RANGES_CXX_CONSTEXPR_14
#define RANGES_CXX14_CONSTEXPR constexpr
#else
#define RANGES_CXX14_CONSTEXPR inline
#endif

#ifdef NDEBUG
#define RANGES_NDEBUG_CONSTEXPR constexpr
        inline namespace                                                \
        {                                                               \
            constexpr auto &name = ::ranges::static_const<type>::value; \
        }                                                               \
    }

#else  // RANGES_CXX_INLINE_VARIABLES >= RANGES_CXX_INLINE_VARIABLES_17
#define RANGES_INLINE_VARIABLE(type, name) \
    inline namespace function_objects      \
    {                                      \
        inline constexpr type name{};      \
    }
#endif // RANGES_CXX_INLINE_VARIABLES

#ifdef RANGES_FEWER_WARNINGS
#define RANGES_DISABLE_WARNINGS                 \
    RANGES_DIAGNOSTIC_PUSH                      \
    RANGES_DIAGNOSTIC_IGNORE_PRAGMAS            \
    RANGES_DIAGNOSTIC_IGNORE_SHADOWING          \
    RANGES_DIAGNOSTIC_IGNORE_UNDEFINED_INTERNAL \
    RANGES_DIAGNOSTIC_IGNORE_INDENTATION        \
    RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT

#define RANGES_RE_ENABLE_WARNINGS RANGES_DIAGNOSTIC_POP
#else
#define RANGES_DISABLE_WARNINGS
#define RANGES_RE_ENABLE_WARNINGS
#endif

namespace ranges {
    inline namespace v3 {
        namespace detail {
            namespace ebo_test {
                struct empty1 {};
                struct empty2 {};
                struct empty3 {};
                struct refines : empty1, empty2, empty3 {};
            }
            constexpr bool broken_ebo = sizeof(ebo_test::refines) > sizeof(ebo_test::empty1);
        }
    }
}

#endif
#pragma clang module end /*range*/

/// \defgroup group-concepts Concepts
/// Concept-checking classes and utilities

RANGES_DIAGNOSTIC_PUSH
RANGES_DIAGNOSTIC_IGNORE_PRAGMAS
RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT

namespace ranges
{
    inline namespace v3
    {
        inline namespace function_objects {}

        namespace aux
        {
            inline namespace function_objects {}
        }

        namespace view
        {
            inline namespace function_objects {}
        }

        namespace action
        {
            inline namespace function_objects {}
        }

        namespace detail
        {
            inline namespace function_objects {}
        }

        /// \cond
        namespace _end_
        {
            struct fn;
        }
        using end_fn = _end_::fn;
        template<typename...>
        struct variant;

        template<typename I = void>
        struct dangling;

        template<typename ...Ts>
        struct common_type;

        template<typename ...Ts>
        using common_type_t = meta::_t<common_type<Ts...>>;

        template<typename T, typename U, typename TQual, typename UQual>
        struct basic_common_reference;

        template<typename ...Ts>
        struct common_reference;

        template<typename ...Ts>
        using common_reference_t = meta::_t<common_reference<Ts...>>;

        template<typename, typename = void>
        struct result_of;
        template<typename Sig>
        using result_of_t = meta::_t<result_of<Sig>>;

        struct make_pipeable_fn;

        template<typename Derived>
        struct pipeable;

        template<typename First, typename Second>
        struct composed;

        template<typename ...Fns>
        struct overloaded;

        namespace action
        {
            struct view;
        }

        namespace adl_advance_detail
        {
            struct advance_fn;
        }
        using adl_advance_detail::advance_fn;
        template<typename T>
        struct size_type;

        struct view_base
        {};

        /// \cond
        namespace detail
        {
            template<typename T = void>
            struct any_
            {
                any_() = default;
                any_(T &&)
                {}
            };

            template<>
            struct any_<void>
            {
                any_() = default;
                template<typename T>
                any_(T &&)
                {}
            };

            using any = any_<>;

            struct value_init
            {
                template<typename T>
                operator T () const
                {
                    return T{};
                }
            };

            struct make_compressed_pair_fn;

            template<typename T>
            constexpr T && forward(meta::_t<std::remove_reference<T>> & t) noexcept
            {
                return static_cast<T &&>(t);
            }

            template<typename T>
            constexpr T && forward(meta::_t<std::remove_reference<T>> && t) noexcept
            {
                // This is to catch way sketchy stuff like: forward<int const &>(42)
                static_assert(!std::is_lvalue_reference<T>::value, "You didn't just do that!");
                return static_cast<T &&>(t);
            }

            template<typename T>
            constexpr meta::_t<std::remove_reference<T>> &&
            move(T && t) noexcept
            {
                return static_cast<meta::_t<std::remove_reference<T>> &&>(t);
            }

            template<typename T>
            constexpr T const &as_const(T & t) noexcept
            {
                return t;
            }
            template<typename T>
            void as_const(T const &&) = delete;

            template<typename T>
            using decay_t = meta::_t<std::decay<T>>;

            template<typename T, typename R = meta::_t<std::remove_reference<T>>>
            using as_ref_t =
                meta::_t<std::add_lvalue_reference<meta::_t<std::remove_const<R>>>>;

            template<typename T, typename R = meta::_t<std::remove_reference<T>>>
            using as_cref_t =
                meta::_t<std::add_lvalue_reference<meta::_t<std::add_const<R>>>>;

            struct get_first;
            struct get_second;

            template<typename Val1, typename Val2>
            struct replacer_fn;

            template<typename Pred, typename Val>
            struct replacer_if_fn;

            template<typename I>
            struct move_into_cursor;

            template<typename Int>
            struct from_end_;

            template<typename ...Ts>
            constexpr int ignore_unused(Ts &&...)
            {
                return 42;
            }

            template<int I>
            struct priority_tag
              : priority_tag<I - 1>
            {};

            template<>
            struct priority_tag<0>
            {};

        #if defined(__clang__) && !defined(_LIBCPP_VERSION)
            template<typename T, typename... Args>
            using is_trivially_constructible =
                meta::bool_<__is_trivially_constructible(T, Args...)>;
            template<typename T>
            using is_trivially_default_constructible =
                is_trivially_constructible<T>;
            struct is_function
              : meta::bool_<sizeof(detail::is_function_impl_<T>(priority_tag<3>{})) == 1>
            {};
        #endif

            template<typename T>
            struct remove_rvalue_reference
            {
                using type = T;
            };

            template<typename T>
            struct remove_rvalue_reference<T &&>
            {
                using type = T;
            };

            template<typename T>
            using remove_rvalue_reference_t = meta::_t<remove_rvalue_reference<T>>;
        }
        /// \endcond

        namespace concepts
        {
            template<typename Concept, typename...Ts>
            struct models;
        }

        struct begin_tag {};
        struct end_tag {};
        struct copy_tag {};
        struct move_tag {};

        template<typename T>
        using uncvref_t =
            meta::_t<std::remove_cv<meta::_t<std::remove_reference<T>>>>;

        struct not_equal_to;
        struct equal_to;
        struct less;
        struct ordered_less;
        struct ident;

        enum cardinality
        {
            infinite = -3,
            unknown = -2,
            finite = -1,
            _max_ = INT_MAX
        };

        template<typename Rng, typename Void = void>
        struct range_cardinality;
        template<typename Cur>
        struct basic_mixin;

        /// \cond

        template<cardinality>
        struct basic_view : view_base
        {};
        struct sized_iterator_range;

        template<typename T, bool RValue = false>
        struct reference_wrapper;

        template<typename>
        struct is_reference_wrapper;

        template<typename T>
        using rvalue_reference_wrapper = reference_wrapper<T, true>;

        // Views
        //
        template<typename Rng, typename Pred>
        struct adjacent_filter_view;


        template<typename Rng>
        struct move_view;

        namespace view
        {
            struct move_fn;
            struct single_fn;
        }

        template<typename Rng>
        struct stride_view;

        namespace view
        {
            struct take_fn;
        }

        /// \cond
        namespace detail
        {
            template<typename Rng>
            struct is_random_access_bounded_;

            template<typename Rng,
                bool IsRandomAccessBounded = is_random_access_bounded_<Rng>::value>
            struct take_exactly_view_;
        }
        /// \endcond


        template<typename Rng, typename Pred>
        struct iter_take_while_view;

        template<typename Rng, typename Pred>
        struct take_while_view;

        namespace view
        {
            struct iter_take_while_fn;
            struct take_while_fn;
        }

        template<typename Rng, typename Regex, typename SubMatchRange>
        struct tokenize_view;

        namespace view
        {
            struct tokenize_fn;
        }

        template<typename Rng, typename Fun>
        struct iter_transform_view;

        template<typename Rng, typename Fun>
        struct transform_view;

        namespace view
        {
            struct transform_fn;
        }

        template<typename Rng, typename Val1, typename Val2>
        using replace_view = iter_transform_view<Rng, detail::replacer_fn<Val1, Val2>>;

        template<typename Rng, typename Pred, typename Val>
        using replace_if_view = iter_transform_view<Rng, detail::replacer_if_fn<Pred, Val>>;

        namespace view
        {
            struct replace_fn;

            struct replace_if_fn;
        }

        template<typename I>
        struct unbounded_view;

        namespace view
        {
            struct unbounded_fn;
        }

        template<typename Rng>
        using unique_view = adjacent_filter_view<Rng, not_equal_to>;

        namespace view
        {
            struct unique_fn;
        }

        template<typename Rng>
        using keys_range_view = transform_view<Rng, detail::get_first>;

        template<typename Rng>
        using values_view = transform_view<Rng, detail::get_second>;

        namespace view
        {
            struct iter_zip_with_fn;

            struct zip_with_fn;

            struct zip_fn;
        }
    }
}

RANGES_DIAGNOSTIC_POP

#endif
#pragma clang module end /*range*/
#if 0 /* expanded by -frewrite-includes */
#include <range/v3/utility/iterator_concepts.hpp>
#endif /* expanded by -frewrite-includes */
#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014
//
#ifndef RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP
#define RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP

#if 0 /* expanded by -frewrite-includes */
#include <iterator>
#endif /* expanded by -frewrite-includes */
#pragma clang module import std.iterator /* clang -frewrite-includes: implicit import */
#if 0 /* expanded by -frewrite-includes */
#include <range/v3/utility/move.hpp>
#endif /* expanded by -frewrite-includes */
#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014

#ifndef RANGES_V3_UTILITY_MOVE_HPP
#define RANGES_V3_UTILITY_MOVE_HPP

#if 0 /* expanded by -frewrite-includes */
#include <utility>
#endif /* expanded by -frewrite-includes */
#pragma clang module import meta /* clang -frewrite-includes: implicit import */
#if 0 /* expanded by -frewrite-includes */
#include <range/v3/range_fwd.hpp>
#endif /* expanded by -frewrite-includes */
#pragma clang module begin range
/// \file
// Range v3 library
// Project home: https://github.com/ericniebler/range-v3
//

#ifndef RANGES_V3_RANGE_FWD_HPP
#define RANGES_V3_RANGE_FWD_HPP

#if 0 /* expanded by -frewrite-includes */
#include <climits>
#endif /* expanded by -frewrite-includes */
#if 0 /* expanded by -frewrite-includes */
#include <utility>
#endif /* expanded by -frewrite-includes */
#if 0 /* expanded by -frewrite-includes */
#include <type_traits>
#endif /* expanded by -frewrite-includes */
          /// \ingroup group-utility
        /// \sa `static_const`
        template<typename T>         constexpr T static_const<T>::value;
     }
 }
  
#endif

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/associated_types.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014, 2016
//  Copyright Casey Carter 2016
 
#ifndef RANGES_V3_UTILITY_ASSOCIATED_TYPES_HPP

#define RANGES_V3_UTILITY_ASSOCIATED_TYPES_HPP
 
#if 0 /* expanded by -frewrite-includes */


#include <range/v3/range_fwd.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_RANGE_FWD_HPP

#define RANGES_V3_RANGE_FWD_HPP
 
#if 0 /* expanded by -frewrite-includes */

#include <climits>

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#include <meta/meta.hpp>

#endif /* expanded by -frewrite-includes */

#endif

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/nullptr_v.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013,2014.
//
 
#ifndef RANGES_V3_UTILITY_NULLVAL_HPP

#define RANGES_V3_UTILITY_NULLVAL_HPP
 
#if 0 /* expanded by -frewrite-includes */

#include <range/v3/detail/config.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
//
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_DETAIL_CONFIG_HPP

#define RANGES_V3_DETAIL_CONFIG_HPP
 
#if 0 /* expanded by -frewrite-includes */

#include <iosfwd>

#endif /* expanded by -frewrite-includes */

#if (defined(NDEBUG) && !defined(RANGES_ENSURE_MSG)) || \
    (!defined(NDEBUG) && !defined(RANGES_ASSERT) && \

#endif
 
#ifndef RANGES_ASSUME

#if defined(__clang__) || defined(__GNUC__)


#endif

#endif
 
#ifndef RANGES_ENSURE

#define RANGES_ENSURE(...) RANGES_ENSURE_MSG((__VA_ARGS__), #__VA_ARGS__)

#endif
 
#define RANGES_DECLTYPE_AUTO_RETURN(...)                        \
    -> decltype(__VA_ARGS__)                                    \
    { return (__VA_ARGS__); }                                   \
    /**/
#if defined(_MSC_VER) && !defined(__clang__)

#if _MSC_VER >= 1900

#ifndef RANGES_CXX_VARIABLE_TEMPLATES

#define RANGES_CXX_VARIABLE_TEMPLATES RANGES_CXX_VARIABLE_TEMPLATES_14

#endif

#ifndef RANGES_CXX_ATTRIBUTE_DEPRECATED

#define RANGES_CXX_ATTRIBUTE_DEPRECATED RANGES_CXX_ATTRIBUTE_DEPRECATED_14

#endif

#if !defined(RANGES_CXX_RANGE_BASED_FOR) && defined(_MSVC_LANG) && _MSVC_LANG > 201402

#define RANGES_CXX_RANGE_BASED_FOR RANGES_CXX_RANGE_BASED_FOR_17

#endif

#ifndef RANGES_CXX_LIB_IS_FINAL
#endif
 
#else // _MSC_VER < 1900

#error Unsupported version of Visual C++

#endif // _MSC_VER switch
 
#if defined(__GNUC__) || defined(__clang__)

#define RANGES_PRAGMA(X) _Pragma(#X)

#define RANGES_DIAGNOSTIC_PUSH RANGES_PRAGMA(GCC diagnostic push)

#define RANGES_DIAGNOSTIC_POP RANGES_PRAGMA(GCC diagnostic pop)
#define RANGES_DIAGNOSTIC_IGNORE_FLOAT_EQUAL RANGES_DIAGNOSTIC_IGNORE("-Wfloat-equal")

#ifdef __clang__

#define RANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS RANGES_DIAGNOSTIC_IGNORE("-Wglobal-constructors")

#define RANGES_DIAGNOSTIC_IGNORE_UNNEEDED_INTERNAL RANGES_DIAGNOSTIC_IGNORE("-Wunneeded-internal-declaration")


#define RANGES_DIAGNOSTIC_IGNORE_CXX17_COMPAT RANGES_DIAGNOSTIC_IGNORE("-Wc++1z-compat")

#endif

#else

#define RANGES_DIAGNOSTIC_PUSH

#define RANGES_CXX_LIB_IS_FINAL RANGES_CXX_FEATURE(LIB_IS_FINAL)

#endif

#endif
 
#ifndef RANGES_CXX_RETURN_TYPE_DEDUCTION
#ifdef __cpp_generic_lambdas

#define RANGES_CXX_GENERIC_LAMBDAS __cpp_generic_lambdas

#else

#define RANGES_CXX_GENERIC_LAMBDAS RANGES_CXX_FEATURE(GENERIC_LAMBDAS)

#endif

#endif
 
#ifndef RANGES_CXX_THREAD_LOCAL

#if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED <= 70100

#else

#define RANGES_CXX_THREAD_LOCAL RANGES_CXX_FEATURE(THREAD_LOCAL)

#endif

#endif
 
#ifndef RANGES_DISABLE_DEPRECATED_WARNINGS

#if RANGES_CXX_ATTRIBUTE_DEPRECATED &&            \
   !((defined(__clang__) || defined(__GNUC__)) && \
     RANGES_CXX_STD < RANGES_CXX_STD_14)

#define RANGES_DEPRECATED(MSG) __declspec(deprecated(MSG))

#else

#define RANGES_DEPRECATED(MSG)

#endif

#define RANGES_RE_ENABLE_WARNINGS

#endif
 namespace ranges {
     inline namespace v3 {
         namespace detail {
#endif

#pragma clang module end /*range*/
 namespace ranges {
     inline namespace v3     {
         /// \ingroup group-utility
        template<typename T>         constexpr T *_nullptr_v()         {
             return nullptr;
         }
      
#if RANGES_CXX_VARIABLE_TEMPLATES
        /// \ingroup group-utility
        template<typename T>         constexpr T *nullptr_v = nullptr;
     
#endif
    }
 }
  
#endif

#pragma clang module end /*range*/
 namespace ranges {
     inline namespace v3     {
         /// \addtogroup group-concepts
        /// @{
         ////////////////////////////////////////////////////////////////////////////////////////
        /// \cond
        namespace detail         {
             template<typename T, typename Enable = void>             struct difference_type2             {
};
              template<typename T>             struct difference_type2<T,                 meta::if_<std::is_integral<                     decltype(std::declval<const T>() - std::declval<const T>())>>>               : std::make_signed<decltype(std::declval<const T>() - std::declval<const T>())>             {
};
              template<typename T, typename Enable = void>             struct difference_type1             : detail::difference_type2<T>             {
};
              template<typename T>             struct difference_type1<T *>             : meta::lazy::if_<std::is_object<T>, std::ptrdiff_t>             {
};
              template<typename T>             struct difference_type1<T, meta::void_<typename T::difference_type>>             {
                 using type = typename T::difference_type;
             };
         }
         /// \endcond
         template<typename T>         struct difference_type         : detail::difference_type1<T>         {
};
          template<typename T>         struct difference_type<T const>         : difference_type<T>         {
};
          ////////////////////////////////////////////////////////////////////////////////////////
        template<typename T>         struct size_type           : meta::lazy::let<std::make_unsigned<meta::lazy::_t<difference_type<T>>>>         {
};
          /// \cond
        namespace detail         {
 
#if !defined(__GNUC__) || defined(__clang__)
            // GCC does not implement CWG393
            // per https://gcc.gnu.org/bugzilla/show_bug.cgi?id=69316
            template<typename T>             std::remove_cv<T> value_type_helper(T (*)[]);
 
#endif
            template<typename T, std::size_t N>             std::remove_cv<T> value_type_helper(T (*)[N]);
              template<typename T>             using object_remove_cv = meta::if_<std::is_object<T>, std::remove_cv<T>>;
              template<typename T>             object_remove_cv<T> value_type_helper(T **);
              template<typename T>             object_remove_cv<typename T::value_type> value_type_helper(T *);
              template<typename T>             object_remove_cv<typename T::element_type> value_type_helper(T *);
              template<typename T>             meta::if_<std::is_base_of<std::ios_base, T>, std::remove_cv<typename T::char_type>>             value_type_helper(T *);
              template<typename T>             using value_type_ = meta::_t<decltype(detail::value_type_helper(_nullptr_v<T>()))>;
         }
         /// \endcond
         ////////////////////////////////////////////////////////////////////////////////////////
        // Not to spec:
        // * arrays of unknown bound have no value type on compilers that do not implement
        //   CWG 393 (http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#393).
        // * For class types with member type element_type, value type is element_type with any
        //   cv-qualifiers stripped (See ericniebler/stl2#299).
        // * using member "char_type" as the value type of class types derived from
        //   std::ios_base is an extension.
        template<typename T>         struct value_type           : meta::defer<detail::value_type_, T>         {
};
          template<typename T>         struct value_type<T const>           : value_type<T>         {
};
          template<typename S, typename I>         struct disable_sized_sentinel : std::false_type {
};
         /// @}
    }
 }
  
#endif

#pragma clang module end /*range*/
 namespace ranges {
     inline namespace v3     {
         namespace aux         {
                        /// \ingroup group-utility
            struct move_fn : move_tag             {
                 template<typename T,                     typename U = meta::_t<std::remove_reference<T>>>                 U && operator()(T && t) const noexcept                 {
                     return static_cast<U &&>(t);
                 }
             };
              /// \ingroup group-utility
            /// \sa `move_fn`
            RANGES_INLINE_VARIABLE(move_fn, move)              /// \ingroup group-utility
            /// \sa `move_fn`
            template<typename T>             meta::_t<std::remove_reference<T>> && operator|(T && t, move_fn move) noexcept             {
                 return move(t);
             }
              /// \ingroup group-utility
            /// \sa `move_fn`
            template<typename R>             using move_t =                 meta::if_<                     std::is_reference<R>,                     meta::_t<std::remove_reference<R>> &&,                     detail::decay_t<R>>;
         }
          /// \cond
        namespace adl_move_detail         {
             template<typename T,                 typename = decltype(iter_move(std::declval<T &&>()))>             std::true_type try_adl_iter_move_(int);
              template<typename T>             std::false_type try_adl_iter_move_(long);
              template<typename T>             struct is_adl_indirectly_movable_               : meta::id_t<decltype(adl_move_detail::try_adl_iter_move_<T>(42))>             {
};
              // TODO: investigate the breakage when these are made constexpr.
            // (Results in ODR-use of projected_readable::operator*)
            struct iter_move_fn             {
                 template<typename I,                     typename = meta::if_c<is_adl_indirectly_movable_<I &>::value>>                 auto operator()(I &&i) const                 RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT                 (                     iter_move(i)                 )                  template<typename I,                     typename = meta::if_c<!is_adl_indirectly_movable_<I &>::value>,                     typename R = decltype(*std::declval<I &>())>                 auto operator()(I &&i) const                 RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT                 (                     static_cast<aux::move_t<R>>(aux::move(*i))                 )             };
         }
         /// \endcond
         RANGES_INLINE_VARIABLE(adl_move_detail::iter_move_fn, iter_move)      }
 }
  
#endif

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/concepts.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014
//
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_UTILITY_CONCEPTS_HPP

#define RANGES_V3_UTILITY_CONCEPTS_HPP
 

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/common_type.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
//  file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_UTILITY_COMMON_TYPE_HPP


#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014
//
//  Use, modification and distribution is subject to the
#ifndef RANGES_V3_RANGE_FWD_HPP

#define RANGES_V3_RANGE_FWD_HPP
 
#if 0 /* expanded by -frewrite-includes */

#include <climits>


#endif /* expanded by -frewrite-includes */
 /// \defgroup group-utility Utility
/// Utility classes
 /// \defgroup group-core Core
/// Core range functionality
 /// \defgroup group-algorithms Algorithms
/// Iterator- and range-based algorithms, like the standard algorithms
         }
     }
 }
  RANGES_DIAGNOSTIC_POP  
#endif

#pragma clang module end /*range*/
 // Sadly, this is necessary because of:
//  - std::common_type is not SFINAE-friendly, and
//  - The specification of std::common_type makes it impossibly
//    difficult to specialize on user-defined types without spamming
//    out a bajillion copies to handle all combinations of cv and ref
//    qualifiers.
 
#ifndef RANGES_NO_STD_FORWARD_DECLARATIONS
// Non-portable forward declarations of standard containers
RANGES_BEGIN_NAMESPACE_STD     template<typename...Ts>     class tuple;
 RANGES_END_NAMESPACE_STD 
#else

#if 0 /* expanded by -frewrite-includes */

#include <tuple>

#endif /* expanded by -frewrite-includes */

#endif
 namespace ranges {
     inline namespace v3     {
         /// \cond
        namespace detail         {
             template<typename From, typename To>             struct _copy_cv_             {
                 using type = To;
             };
             template<typename From, typename To>             struct _copy_cv_<From const, To>             {
                 using type = To const;
             };
             template<typename From, typename To>             struct _copy_cv_<From volatile, To>             {
                 using type = To volatile;
             };
             template<typename From, typename To>             struct _copy_cv_<From const volatile, To>             {
                 using type = To const volatile;
             };
             template<typename From, typename To>             using _copy_cv = meta::_t<_copy_cv_<From, To>>;
              ////////////////////////////////////////////////////////////////////////////////////////
            template<typename T, typename U, typename = void>             struct _builtin_common;
              template<typename T, typename U>             using _builtin_common_t = meta::_t<_builtin_common<T, U>>;
              template<typename T, typename U>             using _cond_res = decltype(true ? std::declval<T>() : std::declval<U>());
              template<typename T, typename U, typename R = _builtin_common_t<T &, U &>>             using _rref_res =                 meta::if_<std::is_reference<R>, meta::_t<std::remove_reference<R>> &&, R>;
              template<class T, class U>             using _lref_res = _cond_res<_copy_cv<T, U> &, _copy_cv<U, T> &>;
          
#if !defined(__GNUC__) || defined(__clang__)
            template<typename T, typename U, typename /*= void*/>             struct _builtin_common               : meta::lazy::let<                     meta::defer<decay_t, meta::defer<_cond_res, as_cref_t<T>, as_cref_t<U>>>>             {
};
             template<typename T, typename U>             struct _builtin_common<T &&, U &&, meta::if_<meta::and_<                 std::is_convertible<T &&, _rref_res<T, U>>,                 std::is_convertible<U &&, _rref_res<T, U>>>>>             {
                 using type = _rref_res<T, U>;
             };
             template<typename T, typename U>             struct _builtin_common<T &, U &>               : meta::defer<_lref_res, T, U>             {
};
             template<typename T, typename U>             struct _builtin_common<T &, U &&, meta::if_<                 std::is_convertible<U &&, _builtin_common_t<T &, U const &>>>>               : _builtin_common<T &, U const &>             {
};
             template<typename T, typename U>             struct _builtin_common<T &&, U &>               : _builtin_common<U &, T &&>             {
};
         
#else
            template<typename T, typename U, typename = void>             struct _builtin_common_             {
};
             template<typename T, typename U>             struct _builtin_common_<T, U, meta::void_<_cond_res<as_cref_t<T>, as_cref_t<U>>>>               : std::decay<_cond_res<as_cref_t<T>, as_cref_t<U>>>             {
};
};
             template<typename T, typename U>             struct _builtin_common<T &&, U &>               : _builtin_common<U &, T &&>             {
};
         
#endif
        }
         /// \endcond
         /// \addtogroup group-utility Utility
        namespace detail         {
             using _rref =                 meta::quote_trait<std::add_rvalue_reference>;
             using _lref =                 meta::quote_trait<std::add_lvalue_reference>;
              template<typename T>             struct _xref             {
                 using type = meta::quote_trait<meta::id>;
             };
             template<typename T>             struct _xref<T &&>             {
                 using type = meta::compose<_rref, meta::_t<_xref<T>>>;
             };
             template<typename T>             struct _xref<T &>             {
                 using type = meta::compose<_lref, meta::_t<_xref<T>>>;
             };
             template<typename T>             struct _xref<T const>             {
                 using type = meta::quote_trait<std::add_const>;
             };
             template<typename T>             struct _xref<T volatile>             {
                 using type = meta::quote_trait<std::add_volatile>;
             };
             template<typename T>             struct _xref<T const volatile>             {
                 using type = meta::quote_trait<std::add_cv>;
             };
              template<typename T, typename U>             using _basic_common_reference =                 basic_common_reference<                     uncvref_t<T>,                     uncvref_t<U>,                     meta::_t<_xref<T>>,                     meta::_t<_xref<U>>>;
              template<typename T, typename U, typename = void>             struct _common_reference2               : meta::if_<                     meta::is_trait<_basic_common_reference<T, U>>,                     _basic_common_reference<T, U>,                     common_type<T, U>>             {
};
          
#if 0 //!defined(__clang__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 8
            template<typename T, typename U>             struct _common_reference2<T, U, meta::if_<meta::is_trait<_builtin_common<T, U>>>>               : _builtin_common<T, U>             {
};
         
#else
            template<typename T, typename U>             struct _common_reference2<T, U, meta::if_<std::is_reference<_builtin_common_t<T, U>>>>               : _builtin_common<T, U>             {
};
         
#endif
        }
         /// \endcond
         /// Users can specialize this to hook the \c CommonReference concept.
        /// \sa `basic_common_reference`
        template<typename ...Ts>         struct common_reference         {
};
          template<typename T>         struct common_reference<T>         {
             using type = T;
         };
          template<typename T, typename U>         struct common_reference<T, U>           : detail::_common_reference2<T, U>         {
};
          template<typename T, typename U, typename... Vs>         struct common_reference<T, U, Vs...>           : meta::lazy::fold<meta::list<U, Vs...>, T, meta::quote<common_reference_t>>         {
};
          /// @}
         /// \cond
        // Specializations for pair and tuple
        template<typename F, typename S>         struct common_pair;
          template<typename ...Ts>         struct common_tuple;
          // common_type for std::pairs
        template<typename F1, typename S1, typename F2, typename S2>         struct common_type<std::pair<F1, S1>, common_pair<F2, S2>>;
    }
 }
  
#endif

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/nullptr_v.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
//
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_UTILITY_NULLVAL_HPP

#define RANGES_V3_UTILITY_NULLVAL_HPP
 
         /// \ingroup group-utility
        template<typename T>         constexpr T *_nullptr_v()         {
             return nullptr;
         }
      
#if RANGES_CXX_VARIABLE_TEMPLATES
        /// \ingroup group-utility
        template<typename T>         constexpr T *nullptr_v = nullptr;
     
#endif
    }
 }
  
#endif

#pragma clang module end /*range*/
 namespace ranges {
     inline namespace v3     {
          using std::swap;
         using std::iter_swap;
           /// \cond
        namespace detail         {
             constexpr struct void_tester             {
                 template<typename T>                 friend int operator,(T &&, void_tester);
             }
 void_ {
};
              constexpr struct is_void_t             {
                 int operator()(detail::void_tester) const;
             }
 is_void {
};
              constexpr struct valid_expr_t             {
                 template<typename ...T>                 void operator()(T &&...) const;
             }
 valid_expr {
};
              constexpr struct same_type_t             {
                 template<typename T, typename U>                 auto operator()(T &&, U &&) const ->                     meta::if_<std::is_same<T,U>, int>;
             }
 same_type {
};
              constexpr struct is_true_t             {
                 template<typename Bool_>                 auto operator()(Bool_) const ->                     meta::if_c<Bool_::value, int>;
             }
 is_true {
};
              constexpr struct is_false_t             {
                 template<typename Bool_>                 auto operator()(Bool_) const ->                     meta::if_c<!Bool_::value, int>;
             }
 is_false {
};
              template<typename Concept>             struct base_concept             {
                 using type = Concept;
             };
              template<typename Concept, typename ...Args>             struct base_concept<Concept(Args...)>             {
                 using type = Concept;
             };
              template<typename Concept>             using base_concept_t = typename base_concept<Concept>::type;
              template<typename Concept, typename Enable = void>             struct base_concepts_of             {
                 using type = meta::list<>;
             };
              template<typename Concept>             struct base_concepts_of<Concept, meta::void_<typename Concept::base_concepts_t>>             {
                 using type = typename Concept::base_concepts_t;
             };
              template<typename Concept>             using base_concepts_of_t = meta::_t<base_concepts_of<Concept>>;
              template<typename T>             T gcc_bugs_bugs_bugs(T);
              template<typename...Ts>             auto models_(any) ->                 std::false_type;
              template<typename...Ts, typename Concept,                 typename = decltype(gcc_bugs_bugs_bugs(&Concept::template requires_<Ts...>))>             auto models_(Concept *) ->                 meta::apply<                     meta::quote<meta::lazy::strict_and>,                     meta::transform<                         base_concepts_of_t<Concept>,                         meta::bind_back<meta::quote<concepts::models>, Ts...>>>;
              template<typename List>             struct most_refined_             {
};
              template<typename Head, typename...Tail>             struct most_refined_<meta::list<Head, Tail...>>             {
                 using type = Head;
                 constexpr operator Head*() const {
 return nullptr;
 }
                 constexpr Head* operator()() const {
 return nullptr;
 }
             };
         }
         /// \endcond
         /// \addtogroup group-concepts
        /// @{
        ///
        namespace concepts         {
             using detail::void_;
             using detail::is_void;
             using detail::valid_expr;
             using detail::same_type;
             using detail::is_true;
             using detail::is_false;
             using ranges::uncvref_t;
              using _1 = std::integral_constant<int, 0>;
             using _2 = std::integral_constant<int, 1>;
             using _3 = std::integral_constant<int, 2>;
             using _4 = std::integral_constant<int, 3>;
             using _5 = std::integral_constant<int, 4>;
             using _6 = std::integral_constant<int, 5>;
             using _7 = std::integral_constant<int, 6>;
             using _8 = std::integral_constant<int, 7>;
             using _9 = std::integral_constant<int, 8>;
              template<typename Ret, typename T>             Ret returns_(T const &);
              template<typename T, typename U>             auto convertible_to(U && u) ->                 decltype(concepts::returns_<int>(static_cast<T>((U &&) u)));
              template<typename T, typename U>             auto has_type(U &&) ->                 meta::if_<std::is_same<T, U>, int>;
              ////////////////////////////////////////////////////////////////////////////////////////////
            // refines
            template<typename ...Concepts>             struct refines               : virtual detail::base_concept_t<Concepts>...             {
                 // So that we don't create these by accident, since it's surprisingly expensive to set
                // up the vtable, given all the virtual bases.
                refines() = delete;
                  using base_concepts_t = meta::list<Concepts...>;
                  template<typename...Ts>                 void requires_();
             };
              ////////////////////////////////////////////////////////////////////////////////////////////
            // models
            template<typename Concept, typename...Ts>             struct models               : meta::bool_<meta::_t<decltype(detail::models_<Ts...>(_nullptr_v<Concept>()))>::value>             {
};
              template<typename Concept, typename...Args, typename...Ts>             struct models<Concept(Args...), Ts...>               : models<Concept, meta::at<meta::list<Ts...>, Args>...>             {
};
              ////////////////////////////////////////////////////////////////////////////////////////////
            // model_of
            template<typename Concept, typename ...Ts>             auto model_of(Ts &&...) ->                 meta::if_c<concepts::models<Concept, Ts...>::value, int>;
              template<typename Concept, typename ...Ts>             auto model_of() ->                 meta::if_c<concepts::models<Concept, Ts...>::value, int>;
              ////////////////////////////////////////////////////////////////////////////////////////////
            // most_refined
            // Find the first concept in a list of concepts that is modeled by the Args
            template<typename Concepts, typename...Ts>             struct most_refined               : detail::most_refined_<                     meta::find_if<                         Concepts,                         meta::bind_back<meta::quote<models>, Ts...>>>             {
};
              template<typename Concepts, typename...Ts>             using most_refined_t = meta::_t<most_refined<Concepts, Ts...>>;
              ////////////////////////////////////////////////////////////////////////////////////////////
            // Core language concepts
            ////////////////////////////////////////////////////////////////////////////////////////////
             struct Same             {
                 template<typename ...Ts>                 struct same : std::true_type {
};
                 template<typename T, typename ...Us>                 struct same<T, Us...> : meta::and_c<std::is_same<T, Us>::value...> {
};
                 template<typename ...Ts>                 using same_t = meta::_t<same<Ts...>>;
                  template<typename ...Ts>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(same_t<Ts...>{
}
)                     ));
             };
              /// \cond
            struct ImplicitlyConvertibleTo             {
                 template<typename From, typename To>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_convertible<From, To>{
}
)                     ));
             };
              struct ExplicitlyConvertibleTo             {
                 template<typename From, typename To>                 auto requires_(From (&from)()) -> decltype(                     concepts::valid_expr(                         ((void) static_cast<To>(from()), 42)                     ));
             };
             /// \endcond
             struct ConvertibleTo               : refines<ImplicitlyConvertibleTo, ExplicitlyConvertibleTo>             {
};
              struct DerivedFrom             {
                 template<typename T, typename U>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_base_of<U, T>{
}
),                         concepts::is_true(std::is_convertible<                             meta::_t<std::remove_cv<T>> *, meta::_t<std::remove_cv<U>> *>{
}
)                     ));
             };
              struct CommonReference             {
                 template<typename T, typename U, typename...Rest>                 using reference_t = common_reference_t<T, U, Rest...>;
                  template<typename T, typename U>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Same, reference_t<T, U>, reference_t<U, T>>(),                         concepts::model_of<ConvertibleTo, T, reference_t<T, U>>(),                         concepts::model_of<ConvertibleTo, U, reference_t<T, U>>()                     ));
                  template<typename T, typename U, typename...Rest,                     typename CommonReference_ = CommonReference>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<CommonReference_, T, U>(),                         concepts::model_of<CommonReference_, reference_t<T, U>, Rest...>()                     ));
             };
              struct Common             {
                 template<typename T, typename U, typename...Rest>                 using value_t = common_type_t<T, U, Rest...>;
                  template<typename T, typename U>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_same<uncvref_t<T>, uncvref_t<U>>{
}
)                     ));
                  template<typename T, typename U>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_false(std::is_same<uncvref_t<T>, uncvref_t<U>>{
}
),                         concepts::model_of<Same, value_t<T, U>, value_t<U, T>>(),                         concepts::model_of<ConvertibleTo, T, value_t<T, U>>(),                         concepts::model_of<ConvertibleTo, U, value_t<T, U>>(),                         concepts::model_of<                             CommonReference, detail::as_cref_t<T>, detail::as_cref_t<U>>(),                         concepts::model_of<                             CommonReference,                             value_t<T, U> &,                             common_reference_t<detail::as_cref_t<T>, detail::as_cref_t<U>>>()                     ));
                  template<typename T, typename U, typename...Rest,                     typename Common_ = Common>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Common_, T, U>(),                         concepts::model_of<Common_, value_t<T, U>, Rest...>()                     ));
             };
              struct Integral             {
                 template<typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_integral<T>{
}
)                     ));
             };
              struct SignedIntegral               : refines<Integral>             {
                 template<typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_signed<T>{
}
)                     ));
             };
              struct UnsignedIntegral               : refines<Integral>             {
                 template<typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_false(std::is_signed<T>{
}
)                     ));
             };
              struct Assignable             {
                 template<typename T, typename U>                 auto requires_(T &&t, U &&u) -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_lvalue_reference<T>{
}
),                         concepts::model_of<                             CommonReference, detail::as_cref_t<T>, detail::as_cref_t<U>>(),                         concepts::has_type<T>((T &&) t = (U &&) u)                     ));
             };
              struct Swappable             {
                 template<typename T>                 auto requires_(T &&t) -> decltype(                     concepts::valid_expr(                         ((void)ranges::swap((T &&) t, (T &&) t), 42)                     ));
                  template<typename T, typename U>                 auto requires_(T && t, U && u) -> decltype(                     concepts::valid_expr(                         concepts::model_of<Swappable, T>(),                         concepts::model_of<Swappable, U>(),                         concepts::model_of<                             CommonReference, detail::as_cref_t<T>, detail::as_cref_t<U>>(),                         ((void)ranges::swap((T &&) t, (U &&) u), 42),                         ((void)ranges::swap((U &&) u, (T &&) t), 42)                     ));
             };
              ////////////////////////////////////////////////////////////////////////////////////////////
            // Comparison concepts
            ////////////////////////////////////////////////////////////////////////////////////////////
            struct WeaklyEqualityComparable             {
                 template<typename T, typename U>                 auto requires_(detail::as_cref_t<T> t, detail::as_cref_t<U> u) -> decltype(                     // Not to spec: doesn't compare to a Boolean trait
                    concepts::valid_expr(                         concepts::convertible_to<bool>(t == u),                         concepts::convertible_to<bool>(t != u),                         concepts::convertible_to<bool>(u == t),                         concepts::convertible_to<bool>(u != t)                     ));
             };
              struct EqualityComparable             {
                 template<typename T>                 auto requires_(detail::as_cref_t<T> t) -> decltype(                     concepts::valid_expr(                         concepts::convertible_to<bool>(t == t),                         concepts::convertible_to<bool>(t != t)                     ));
                  template<typename T, typename U>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_same<T, U>{
}
),                         concepts::model_of<EqualityComparable, T>()                     ));
                  // Cross-type equality comparison from N3351:
                // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf
                template<typename T, typename U,                     typename C = common_reference_t<detail::as_cref_t<T>, detail::as_cref_t<U>>>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_false(std::is_same<T, U>{
}
),                         concepts::model_of<EqualityComparable, T>(),                         concepts::model_of<EqualityComparable, U>(),                         concepts::model_of<WeaklyEqualityComparable, T, U>(),                         concepts::model_of<                             CommonReference, detail::as_cref_t<T>, detail::as_cref_t<U>>(),                         concepts::model_of<EqualityComparable, C>()                     ));
             };
              struct WeaklyOrdered             {
                 template<typename T>                 auto requires_(T && t) -> decltype(                     concepts::valid_expr(                         concepts::convertible_to<bool>(t < t),                         concepts::convertible_to<bool>(t > t),                         concepts::convertible_to<bool>(t <= t),                         concepts::convertible_to<bool>(t >= t)                     ));
                  template<typename T, typename U,                     typename C = common_reference_t<detail::as_cref_t<T>, detail::as_cref_t<U>>>                 auto requires_(detail::as_cref_t<T> t, detail::as_cref_t<U> u) -> decltype(                     concepts::valid_expr(                         concepts::model_of<WeaklyOrdered, T>(),                         concepts::model_of<WeaklyOrdered, U>(),                         concepts::model_of<                             CommonReference, detail::as_cref_t<T>, detail::as_cref_t<U>>(),                         concepts::model_of<WeaklyOrdered, C>(),                         concepts::convertible_to<bool>(t < u),                         concepts::convertible_to<bool>(u < t),                         concepts::convertible_to<bool>(t > u),                         concepts::convertible_to<bool>(u > t),                         concepts::convertible_to<bool>(t <= u),                         concepts::convertible_to<bool>(u <= t),                         concepts::convertible_to<bool>(t >= u),                         concepts::convertible_to<bool>(u >= t)                     ));
             };
              struct TotallyOrdered               : refines<EqualityComparable, WeaklyOrdered>             {
                 template<typename T>                 void requires_();
                  template<typename T, typename U>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<TotallyOrdered, T>(),                         concepts::model_of<TotallyOrdered, U>()                     ));
             };
              ////////////////////////////////////////////////////////////////////////////////////////////
            // Object concepts
            ////////////////////////////////////////////////////////////////////////////////////////////
             struct Destructible             {
                 template<typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_nothrow_destructible<T>())                     ));
             };
              struct Constructible               : refines<Destructible(_1)>             {
                 template<typename T, typename... Args>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_constructible<T, Args...>{
}
)                     ));
             };
              struct DefaultConstructible               : refines<Constructible>             {
                 template<typename T>                 void requires_();
             };
              struct MoveConstructible             {
                 template<typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Constructible, T, T>(),                         concepts::model_of<ConvertibleTo, T, T>()                     ));
             };
              struct CopyConstructible               : refines<MoveConstructible>             {
                 template<typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Constructible, T, T &>(),                         concepts::model_of<Constructible, T, T const &>(),                         concepts::model_of<Constructible, T, T const>(),                         concepts::model_of<ConvertibleTo, T &, T>(),                         concepts::model_of<ConvertibleTo, T const &, T>(),                         concepts::model_of<ConvertibleTo, T const, T>()                     ));
             };
              struct Movable               : refines<MoveConstructible>             {
                 template<typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_object<T>{
}
),                         concepts::model_of<Assignable, T &, T>(),                         concepts::model_of<Swappable, T &>()                     ));
             };
              struct Copyable               : refines<Movable, CopyConstructible>             {
                 template<typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         // Spec requires this to be validated
                        concepts::model_of<Assignable, T &, T const &>(),                         // Spec does not require these to be validated
                        concepts::model_of<Assignable, T &, T &>(),                         concepts::model_of<Assignable, T &, T const>()                     ));
             };
              struct SemiRegular               : refines<Copyable, DefaultConstructible>             {
                 // Axiom: copies are independent. See Fundamentals of Generic Programming
                // http://www.stepanovpapers.com/DeSt98.pdf
            };
              struct Regular               : refines<SemiRegular, EqualityComparable>             {
};
         }
          template<typename ...Ts>         using Same = concepts::Same::same_t<Ts...>;
 // This handles void better than using the Same concept
         template<typename T, typename U>         using ImplicitlyConvertibleTo =             concepts::models<concepts::ImplicitlyConvertibleTo, T, U>;
          template<typename T, typename U>         using ExplicitlyConvertibleTo =             concepts::models<concepts::ExplicitlyConvertibleTo, T, U>;
          template<typename T, typename U>         using ConvertibleTo = concepts::models<concepts::ConvertibleTo, T, U>;
          template<typename T, typename U>         using DerivedFrom = concepts::models<concepts::DerivedFrom, T, U>;
          template<typename T, typename U, typename...Rest>         using CommonReference =             concepts::models<concepts::CommonReference, T, U, Rest...>;
          template<typename T, typename U, typename...Rest>         using Common =             concepts::models<concepts::Common, T, U, Rest...>;
          template<typename T>         using Integral = concepts::models<concepts::Integral, T>;
          template<typename T>         using SignedIntegral = concepts::models<concepts::SignedIntegral, T>;
          template<typename T>         using UnsignedIntegral = concepts::models<concepts::UnsignedIntegral, T>;
          template<typename T>         using Destructible = concepts::models<concepts::Destructible, T>;
          template<typename T, typename ...Args>         using Constructible = concepts::models<concepts::Constructible, T, Args...>;
          template<typename T>         using DefaultConstructible = concepts::models<concepts::DefaultConstructible, T>;
          template<typename T>         using MoveConstructible = concepts::models<concepts::MoveConstructible, T>;
          template<typename T>         using CopyConstructible = concepts::models<concepts::CopyConstructible, T>;
          template<typename T, typename U>         using Assignable = concepts::models<concepts::Assignable, T, U>;
          template<typename T>         using Movable = concepts::models<concepts::Movable, T>;
          template<typename T>         using Copyable = concepts::models<concepts::Copyable, T>;
          template<typename T, typename U>         using WeaklyEqualityComparable = concepts::models<concepts::WeaklyEqualityComparable, T, U>;
          template<typename T, typename U = T>         using EqualityComparable = concepts::models<concepts::EqualityComparable, T, U>;
          template<typename T, typename U = T>         using WeaklyOrdered = concepts::models<concepts::WeaklyOrdered, T, U>;
          template<typename T, typename U = T>         using TotallyOrdered = concepts::models<concepts::TotallyOrdered, T, U>;
          template<typename T>         using SemiRegular = concepts::models<concepts::SemiRegular, T>;
          template<typename T>         using Regular = concepts::models<concepts::Regular, T>;
          template<typename T, typename U = T>         using Swappable = concepts::models<concepts::Swappable, T, U>;
     }
 }
  
#define CONCEPT_PP_CAT_(X, Y) X ## Y

#define CONCEPT_PP_CAT(X, Y)  CONCEPT_PP_CAT_(X, Y)
 /// \addtogroup group-concepts
/// @{

#define CONCEPT_REQUIRES_(...)                                                      \
    int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42,                          \
    typename std::enable_if<                                                        \
        (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__),      \
        int                                                                         \
    >::type = 0                                                                     \
    /**/
 
#define CONCEPT_REQUIRES(...)                                                       \
    template<                                                                       \
        int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42,                      \
        typename std::enable_if<                                                    \
            (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__),  \
            int                                                                     \
        >::type = 0>                                                                \
    /**/
 
#if RANGES_CXX_STATIC_ASSERT >= RANGES_CXX_STATIC_ASSERT_17

#define CONCEPT_ASSERT static_assert

#else

#define CONCEPT_ASSERT(...) static_assert((__VA_ARGS__), "Concept check failed: " #__VA_ARGS__)

#endif
/// @}
 
#define CONCEPT_ASSERT_MSG static_assert
/// @}
 
#endif // RANGES_V3_UTILITY_CONCEPTS_HPP

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/functional.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014
//

#ifndef RANGES_V3_UTILITY_FUNCTIONAL_HPP

#define RANGES_V3_UTILITY_FUNCTIONAL_HPP
 
#if 0 /* expanded by -frewrite-includes */


#include <range/v3/utility/concepts.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
//
// Acknowledgements: Thanks for Paul Fultz for the suggestions that
//                   concepts can be ordinary Boolean metafunctions.
//
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_UTILITY_CONCEPTS_HPP
#if 0 /* expanded by -frewrite-includes */

#include <type_traits>

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/nullptr_v.hpp>

#endif /* expanded by -frewrite-includes */
            int                                                                     \
        >::type = 0>                                                                \
    /**/
 
#if RANGES_CXX_STATIC_ASSERT >= RANGES_CXX_STATIC_ASSERT_17

#define CONCEPT_ASSERT static_assert

#else

#define CONCEPT_ASSERT(...) static_assert((__VA_ARGS__), "Concept check failed: " #__VA_ARGS__)

#endif
/// @}
 
#define CONCEPT_ASSERT_MSG static_assert
/// @}
 
#endif // RANGES_V3_UTILITY_CONCEPTS_HPP

#pragma clang module end /*range*/
 RANGES_DISABLE_WARNINGS  namespace ranges {
     inline namespace v3     {
          /// \addtogroup group-concepts
        /// @{
        namespace concepts         {
             struct Invocable             {
                 template<typename Fun, typename... Args>                 using result_t = result_of_t<Fun &&(Args &&...)>;
                  template<typename Fun, typename... Args>                 auto requires_() ->                     meta::void_<result_of_t<Fun &&(Args &&...)>>;
             };
              struct RegularInvocable               : refines<Invocable>             {
                 // Axiom: equality_preserving(invoke(f, args...))
            };
              struct Predicate               : refines<RegularInvocable>             {
                 template<typename Fun, typename... Args>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<ConvertibleTo, Invocable::result_t<Fun, Args...>, bool>()                     ));
             };
              struct Relation             {
                 template<typename Fun, typename T>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Predicate, Fun, T, T>()                     ));
                  template<typename Fun, typename T, typename U>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_same<T, U>{
}
),                         concepts::model_of<Predicate, Fun, T, U>()                     ));
                  template<typename Fun, typename T, typename U,                     typename C =                         common_reference_t<detail::as_cref_t<T>, detail::as_cref_t<U>>>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::is_false(std::is_same<T, U>{
}
),                         concepts::model_of<Relation, Fun, T, T>(),                         concepts::model_of<Relation, Fun, U, U>(),                         concepts::model_of<                             CommonReference, detail::as_cref_t<T>, detail::as_cref_t<U>>(),                         concepts::model_of<Relation, Fun, C, C>(),                         concepts::model_of<Predicate, Fun, T, U>(),                         concepts::model_of<Predicate, Fun, U, T>()                     ));
             };
         }
          template<typename Fun, typename...Args>         using Invocable = concepts::models<concepts::Invocable, Fun, Args...>;
          template<typename Fun, typename...Args>         using RegularInvocable = concepts::models<concepts::RegularInvocable, Fun, Args...>;
          template<typename Fun, typename...Args>         using Predicate = concepts::models<concepts::Predicate, Fun, Args...>;
          template<typename Fun, typename T, typename U = T>         using Relation = concepts::models<concepts::Relation, Fun, T, U>;
         /// @}
    }
 }
  RANGES_RE_ENABLE_WARNINGS  
#endif

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/associated_types.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014, 2016
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_UTILITY_ASSOCIATED_TYPES_HPP

#define RANGES_V3_UTILITY_ASSOCIATED_TYPES_HPP
 
#if 0 /* expanded by -frewrite-includes */

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#include <utility>

#endif /* expanded by -frewrite-includes */
         /// \ingroup group-utility
        template<typename T>         constexpr T *_nullptr_v()         {
             return nullptr;
         }
      
#if RANGES_CXX_VARIABLE_TEMPLATES
        /// \ingroup group-utility
        template<typename T>         constexpr T *nullptr_v = nullptr;
     
#endif
    }
 }
  
#endif

#pragma clang module end /*range*/
 namespace ranges {
     inline namespace v3     {
         /// \addtogroup group-core
        /// @{
        struct input_iterator_tag         {
};
          struct forward_iterator_tag           : input_iterator_tag         {
};
          struct bidirectional_iterator_tag           : forward_iterator_tag         {
};
          struct random_access_iterator_tag           : bidirectional_iterator_tag         {
};
         /// @}
         /// \cond
        namespace detail         {
             ////////////////////////////////////////////////////////////////////////////////////////
            template<typename T>             T upgrade_iterator_category_(T *, void *);
              template<typename T>             ranges::input_iterator_tag upgrade_iterator_category_(T *, std::input_iterator_tag *);
              template<typename T>             ranges::forward_iterator_tag upgrade_iterator_category_(T *, std::forward_iterator_tag *);
              template<typename T>             ranges::bidirectional_iterator_tag upgrade_iterator_category_(T *, std::bidirectional_iterator_tag *);
              template<typename T>             ranges::random_access_iterator_tag upgrade_iterator_category_(T *, std::random_access_iterator_tag *);
              template<typename T>             struct upgrade_iterator_category             {
                 using type = decltype(detail::upgrade_iterator_category_(_nullptr_v<T>(), _nullptr_v<T>()));
             };
              ////////////////////////////////////////////////////////////////////////////////////////
            template<typename T, typename B>             meta::nil_ downgrade_iterator_category_(T *, void *, B);
              template<typename T, typename B>             meta::id<T>             downgrade_iterator_category_(T *, std::input_iterator_tag *, B);
              template<typename T, typename B>             meta::id<T>             downgrade_iterator_category_(T *, std::output_iterator_tag *, B);
              template<typename T, typename B>             meta::id<std::input_iterator_tag>             downgrade_iterator_category_(T *, ranges::input_iterator_tag *, B);
              template<typename T>             meta::id<std::forward_iterator_tag>             downgrade_iterator_category_(T *, ranges::forward_iterator_tag *, std::true_type);
              template<typename T>             meta::id<std::bidirectional_iterator_tag>             downgrade_iterator_category_(T *, ranges::bidirectional_iterator_tag *, std::true_type);
              template<typename T>             meta::id<std::random_access_iterator_tag>             downgrade_iterator_category_(T *, ranges::random_access_iterator_tag *, std::true_type);
              template<typename Tag, typename Reference>             struct downgrade_iterator_category               : decltype(detail::downgrade_iterator_category_(_nullptr_v<Tag>(), _nullptr_v<Tag>(),                     std::integral_constant<bool, std::is_reference<Reference>::value>()))             {
};
              ////////////////////////////////////////////////////////////////////////////////////////
            template<typename T>             meta::if_<std::is_object<T>, ranges::random_access_iterator_tag>             iterator_category_helper(T **);
              template<typename T>             meta::_t<upgrade_iterator_category<typename T::iterator_category>>             iterator_category_helper(T *);
              template<class T>             using iterator_category_ = decltype(detail::iterator_category_helper(_nullptr_v<T>()));
         }
         /// \endcond
         /// \addtogroup group-concepts
        /// @{
        template<typename T>         struct iterator_category           : meta::defer<detail::iterator_category_, T>         {
};
          template<typename T>         struct iterator_category<T const>           : iterator_category<T>         {
};
          namespace concepts         {
             struct Readable             {
             private:                 template<typename I,                     typename R = decltype(*std::declval<I &>()),                     typename = R&>                 using reference_t_ = R;
                  template<typename I,                     typename = reference_t_<I>,                     typename R = decltype(iter_move(std::declval<I &>())),                     typename = R&>                 using rvalue_reference_t_ = R;
             public:                 // Associated types
                template<typename I>                 using value_t = meta::_t<value_type<I>>;
                  template<typename I>                 using reference_t = reference_t_<I>;
                  template<typename I>                 using rvalue_reference_t = rvalue_reference_t_<I>;
                  template<typename I>                 using common_reference_t =                     ranges::common_reference_t<reference_t<I>, value_t<I> &>;
                  template<typename I>                 auto requires_() -> decltype(                     concepts::valid_expr(                         // The value, reference and rvalue reference types are related
                        // through the CommonReference concept.
                        concepts::model_of<CommonReference, reference_t<I> &&, value_t<I> &>(),                         concepts::model_of<CommonReference, reference_t<I> &&, rvalue_reference_t<I> &&>(),                         concepts::model_of<CommonReference, rvalue_reference_t<I> &&, value_t<I> const &>()                     ));
             };
              struct Writable             {
                 template<typename Out>                 using reference_t = Readable::reference_t<Out>;
                  template<typename Out, typename T>                 auto requires_(Out& o, T &&t) -> decltype(                     concepts::valid_expr(                         ((void)(*o = (T &&) t), 42),                         ((void)(const_cast<reference_t<Out> const &&>(*o) = (T &&)t), 42)                     ));
             };
              struct IndirectlyMovable             {
                 template<typename I, typename O>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Readable, I>(),                         concepts::model_of<Writable, O, Readable::rvalue_reference_t<I>>()                     ));
             };
              struct IndirectlyMovableStorable               : refines<IndirectlyMovable>             {
                 template<typename I, typename O>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Movable, Readable::value_t<I>>(),                         concepts::model_of<Constructible, Readable::value_t<I>,                             Readable::rvalue_reference_t<I>>(),                         concepts::model_of<Assignable, Readable::value_t<I> &,                             Readable::rvalue_reference_t<I>>(),                         concepts::model_of<Writable, O, Readable::value_t<I>>()                     ));
             };
              struct IndirectlyCopyable             {
                 template<typename I, typename O>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Readable, I>(),                         concepts::model_of<Writable, O, Readable::reference_t<I>>()                     ));
             };
              struct IndirectlyCopyableStorable               : refines<IndirectlyCopyable>             {
                 template<typename I, typename O>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<Copyable, Readable::value_t<I>>(),                         concepts::model_of<Constructible, Readable::value_t<I>,                             Readable::reference_t<I>>(),                         concepts::model_of<Assignable, Readable::value_t<I> &,                             Readable::reference_t<I>>(),                         concepts::model_of<Writable, O, Readable::common_reference_t<I>>(),                         concepts::model_of<Writable, O, Readable::value_t<I> const &>()                     ));
             };
              struct IndirectlySwappable             {
                 template<typename I1, typename I2>                 auto requires_(I1&& i1, I2&& i2) -> decltype(                     concepts::valid_expr(                         concepts::model_of<Readable, I1>(),                         concepts::model_of<Readable, I2>(),                         ((void)ranges::iter_swap((I1 &&) i1, (I2 &&) i2), 42),                         ((void)ranges::iter_swap((I1 &&) i1, (I1 &&) i1), 42),                         ((void)ranges::iter_swap((I2 &&) i2, (I2 &&) i2), 42),                         ((void)ranges::iter_swap((I2 &&) i2, (I1 &&) i1), 42)                     ));
             };
              struct WeaklyIncrementable               : refines<SemiRegular>             {
                 // Associated types
                template<typename I>                 using difference_t = meta::_t<difference_type<I>>;
                  template<typename I>                 auto requires_(I i) -> decltype(                     concepts::valid_expr(                         concepts::is_true(std::is_integral<difference_t<I>>{
}
),                         concepts::has_type<I &>(++i),                         ((void)i++, 42)                     ));
             };
              struct Incrementable               : refines<Regular, WeaklyIncrementable>             {
                 template<typename I>                 auto requires_(I i) -> decltype(                     concepts::valid_expr(                         concepts::has_type<I>(i++)                     ));
             };
              struct Iterator               : refines<WeaklyIncrementable, Copyable>             {
                 template<typename I>                 auto requires_(I i) -> decltype(                     concepts::valid_expr(                         ((void)*i, 42)                     ));
             };
              struct Sentinel               : refines<SemiRegular(_1), Iterator(_2), WeaklyEqualityComparable>             {
};
              struct SizedSentinel               : refines<Sentinel>             {
                 template<typename S, typename I,                     typename D = WeaklyIncrementable::difference_t<I>>                 auto requires_(S s, I i) -> decltype(                     concepts::valid_expr(                         concepts::is_false(                             disable_sized_sentinel<uncvref_t<S>, uncvref_t<I>>()),                         concepts::has_type<D>(s - i),                         concepts::has_type<D>(i - s)                     ));
             };
              struct OutputIterator               : refines<Iterator(_1), Writable>             {
                 template<typename Out, typename T>                 auto requires_(Out o, T &&t) -> decltype(                     concepts::valid_expr(                         ((void)(*o++ = (T &&) t), 42)                     ));
             };
              struct InputIterator               : refines<Iterator, Readable>             {
                 // Associated types
                // value_t from Readable
                // distance_t from WeaklyIncrementable
                template<typename I>                 using category_t = meta::_t<ranges::iterator_category<I>>;
                  template<typename I>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<DerivedFrom, category_t<I>, ranges::input_iterator_tag>()                     ));
             };
              struct ForwardIterator               : refines<InputIterator, Incrementable, Sentinel(_1, _1)>             {
                 template<typename I>                 auto requires_() -> decltype(                     concepts::valid_expr(                         concepts::model_of<DerivedFrom, category_t<I>, ranges::forward_iterator_tag>()                     ));
             };
              struct BidirectionalIterator               : refines<ForwardIterator>             {
                 template<typename I>                 auto requires_(I i) -> decltype(                     concepts::valid_expr(                         concepts::model_of<DerivedFrom, category_t<I>, ranges::bidirectional_iterator_tag>(),                         concepts::has_type<I &>(--i),                         concepts::has_type<I>(i--),                         concepts::same_type(*i, *i--)                     ));
             };
              struct RandomAccessIterator               : refines<BidirectionalIterator, TotallyOrdered, SizedSentinel(_1, _1)>             {
                 template<typename I>                 auto requires_(I i) -> decltype(                     concepts::valid_expr(                         concepts::model_of<DerivedFrom, category_t<I>, ranges::random_access_iterator_tag>(),                         concepts::has_type<I>(i + (i - i)),                         concepts::has_type<I>((i - i) + i),                         concepts::has_type<I>(i - (i - i)),                         concepts::has_type<I &>(i += (i-i)),                         concepts::has_type<I &>(i -= (i - i)),                         concepts::model_of<Same, reference_t<I>, decltype(i[i - i])>()                     ));
             };
         }
          template<typename T>         using Readable = concepts::models<concepts::Readable, T>;
          template<typename Out, typename T>         using Writable = concepts::models<concepts::Writable, Out, T>;
          template<typename I, typename O>         using IndirectlyMovable = concepts::models<concepts::IndirectlyMovable, I, O>;
          template<typename I, typename O>         using IndirectlyMovableStorable = concepts::models<concepts::IndirectlyMovableStorable, I, O>;
          template<typename I, typename O>         using IndirectlyCopyable = concepts::models<concepts::IndirectlyCopyable, I, O>;
          template<typename I, typename O>         using IndirectlyCopyableStorable = concepts::models<concepts::IndirectlyCopyableStorable, I, O>;
          template<typename I1, typename I2>         using IndirectlySwappable = concepts::models<concepts::IndirectlySwappable, I1, I2>;
          template<typename T>         using WeaklyIncrementable = concepts::models<concepts::WeaklyIncrementable, T>;
          template<typename T>         using Incrementable = concepts::models<concepts::Incrementable, T>;
          template<typename I>         using Iterator = concepts::models<concepts::Iterator, I>;
          template<typename S, typename I>         using Sentinel = concepts::models<concepts::Sentinel, S, I>;
          template<typename S, typename I>         using SizedSentinel = concepts::models<concepts::SizedSentinel, S, I>;
          template<typename I, typename S>         using IteratorRange RANGES_DEPRECATED("Please use Sentinel<S, I>() instead") =             Sentinel<S, I>;
          template<typename I, typename S>         using SizedIteratorRange RANGES_DEPRECATED("Please use SizedSentinel<S, I>() instead") =             SizedSentinel<S, I>;
          template<typename Out, typename T>         using OutputIterator = concepts::models<concepts::OutputIterator, Out, T>;
          template<typename I>         using InputIterator = concepts::models<concepts::InputIterator, I>;
          template<typename I>         using ForwardIterator = concepts::models<concepts::ForwardIterator, I>;
          template<typename I>         using BidirectionalIterator = concepts::models<concepts::BidirectionalIterator, I>;
          template<typename I>         using RandomAccessIterator = concepts::models<concepts::RandomAccessIterator, I>;
          ////////////////////////////////////////////////////////////////////////////////////////////
        // iterator_concept
        template<typename T>         using iterator_concept =             concepts::most_refined<                 meta::list<                     concepts::RandomAccessIterator,                     concepts::BidirectionalIterator,                     concepts::ForwardIterator,                     concepts::InputIterator>, T>;
          template<typename T>         using iterator_concept_t = meta::_t<iterator_concept<T>>;
          // Generally useful to know if an iterator is single-pass or not:
        template<typename I>         using SinglePass = meta::strict_and<Iterator<I>, meta::not_<ForwardIterator<I>>>;
                  ////////////////////////////////////////////////////////////////////////////////////////////
        // Composite concepts for use defining algorithms:
         template<typename S, typename I>         using sized_sentinel_concept =             concepts::most_refined<                 meta::list<                     concepts::SizedSentinel,                     concepts::Sentinel>, S, I>;
          template<typename S, typename I>         using sized_sentinel_concept_t = meta::_t<sized_sentinel_concept<S, I>>;
         /// @}
    }
 }
   
#endif // RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/iterator_traits.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
//  http://www.boost.org/LICENSE_1_0.txt)
//
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP

#define RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP
 
#if 0 /* expanded by -frewrite-includes */

#include <type_traits>

#endif /* expanded by -frewrite-includes */


#pragma clang module begin range
/// \file
// Range v3 library
//
//  Copyright Eric Niebler 2013-2014
//
#ifndef RANGES_V3_RANGE_FWD_HPP

#define RANGES_V3_RANGE_FWD_HPP
 
#if 0 /* expanded by -frewrite-includes */

#include <climits>

#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#include <utility>

#endif /* expanded by -frewrite-includes */

   
#endif // RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP

#pragma clang module end /*range*/
 namespace ranges {
     inline namespace v3     {
         /// \addtogroup group-core
        /// @{
        ////////////////////////////////////////////////////////////////////////////////////////////
        // iterator traits
        template<typename I>         using value_type_t = concepts::Readable::value_t<I>;
          template<typename I>         using reference_t = concepts::Readable::reference_t<I>;
          template<typename I>         using rvalue_reference_t = concepts::Readable::rvalue_reference_t<I>;
          template<typename I>         using iter_common_reference_t = concepts::Readable::common_reference_t<I>;
          template<typename I>         using iterator_category_t = concepts::InputIterator::category_t<I>;
          template<typename I>         using difference_type_t = concepts::WeaklyIncrementable::difference_t<I>;
          template<typename I>         using size_type_t = meta::_t<std::make_unsigned<difference_type_t<I>>>;
         /// @}
         namespace detail         {
             template<typename I>             using arrow_type_ = decltype(std::declval<I &>().operator->());
              template<typename I>             struct pointer_type_               : meta::if_<                     meta::is_trait<meta::defer<arrow_type_, I>>,                     meta::defer<arrow_type_, I>,                     std::add_pointer<reference_t<I>>>             {
};
         }
         /// \endcond
    }
 }
  
#endif // RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/utility/static_const.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
//
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_UTILITY_STATIC_CONST_HPP

#define RANGES_V3_UTILITY_STATIC_CONST_HPP
 
#if 0 /* expanded by -frewrite-includes */

#include <range/v3/range_fwd.hpp>

#endif /* expanded by -frewrite-includes */
 namespace ranges {
     inline namespace v3     {
     }
 }
  
#endif

#pragma clang module end /*range*/
 namespace ranges {
 inline namespace v3 {
           namespace aux          {
            struct copy_fn : copy_tag            {
              template<typename T,                       CONCEPT_REQUIRES_(Constructible<detail::decay_t<T>, T>())>              detail::decay_t<T> operator()(T && t) const              {
                return static_cast<T &&>(t);
              }
            };
             /// \ingroup group-utility
           /// \sa `copy_fn`
           RANGES_INLINE_VARIABLE(copy_fn, copy)             /// \ingroup group-utility
           /// \sa `copy_fn`
           template<typename T,                     CONCEPT_REQUIRES_(Constructible<detail::decay_t<T>, T>())>            detail::decay_t<T> operator|(T && t, copy_fn)            {
              return static_cast<T &&>(t);
            }
          }
            /// \cond
namespace _begin_ {
 // Poison pill for std::begin. (See the detailed discussion at
// https://github.com/ericniebler/stl2/issues/139)
template <typename T> void begin(T &) = delete;
 template <typename T> void begin(T const &) = delete;
  struct fn {
 private:   template <typename R, std::size_t N>   static constexpr R *impl_(R (&array)[N], int) noexcept {
     return array;
   }
    // Prefer member if it returns Iterator.
  template <typename R,             typename I = decltype(aux::copy(std::declval<R &>().begin())),             CONCEPT_REQUIRES_(Iterator<I>())>   static constexpr I impl_(R &r, int) RANGES_AUTO_RETURN_NOEXCEPT(r.begin())        // Use ADL if it returns Iterator.
      template <typename R,                 typename I = decltype(aux::copy(begin(std::declval<R &>()))),                 CONCEPT_REQUIRES_(Iterator<I>())>       static constexpr I impl_(R &r, long) RANGES_AUTO_RETURN_NOEXCEPT(begin(r))            public       : template <typename R>         constexpr auto         operator()(R &r) const         RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(fn::impl_(r, 42))              template <typename R>             RANGES_DEPRECATED(                 "Passing an rvalue to ranges::begin is deprecated.")             constexpr auto             operator()(const R &&r) const         RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(fn::impl_(r, 42))              template <typename T, typename Fn = fn>             constexpr auto             operator()(std::reference_wrapper<T> ref) const         RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(Fn()(ref.get()))              template <typename T, bool RValue, typename Fn = fn>             constexpr auto             operator()(ranges::reference_wrapper<T, RValue> ref) const         RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(Fn()(ref.get())) };
 }
 // namespace _begin_
/// \endcond
 /// \ingroup group-core
/// \param r
/// \return \c r, if \c r is an array. Otherwise, `r.begin()` if that expression
/// is
///   well-formed and returns an Iterator. Otherwise, `begin(r)` if that
///   expression returns an Iterator.
RANGES_INLINE_VARIABLE(_begin_::fn, begin)  /// \cond
namespace _end_ {
 // Poison pill for std::end. (See the detailed discussion at
// https://github.com/ericniebler/stl2/issues/139)
template <typename T> void end(T &) = delete;
 template <typename T> void end(T const &) = delete;
  struct fn {
 private:   template <typename R, std::size_t N>   static constexpr R *impl_(R (&array)[N], int) noexcept {
     return array + N;
   }
    // Prefer member if it returns Sentinel.
  template <typename R,             typename I = decltype(ranges::begin(std::declval<R &>())),             typename S = decltype(aux::copy(std::declval<R &>().end())),             CONCEPT_REQUIRES_(Sentinel<S, I>())>   static constexpr S impl_(R &r, int) RANGES_AUTO_RETURN_NOEXCEPT(r.end())        // Use ADL if it returns Sentinel.
      template <typename R,                 typename I = decltype(ranges::begin(std::declval<R &>())),                 typename S = decltype(aux::copy(end(std::declval<R &>()))),                 CONCEPT_REQUIRES_(Sentinel<S, I>())>       static constexpr S impl_(R &r, long) RANGES_AUTO_RETURN_NOEXCEPT(end(r))            public       : template <typename R>         constexpr auto         operator()(R &r) const         RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(fn::impl_(r, 42))              template <typename R>             RANGES_DEPRECATED("Passing an rvalue to ranges::end is deprecated.")             constexpr auto             operator()(const R &&r) const         RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(fn::impl_(r, 42))              template <typename T, typename Fn = fn>             constexpr auto             operator()(std::reference_wrapper<T> ref) const         RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(Fn()(ref.get()))              template <typename T, bool RValue, typename Fn = fn>             constexpr auto             operator()(ranges::reference_wrapper<T, RValue> ref) const         RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT(Fn()(ref.get())) };
 }
 // namespace _end_
/// \endcond
 /// \ingroup group-core
/// \param r
/// \return \c r+size(r), if \c r is an array. Otherwise, `r.end()` if that
/// expression is
///   well-formed and returns an Iterator. Otherwise, `end(r)` if that
///   expression returns an Iterator.
RANGES_INLINE_VARIABLE(_end_::fn, end)  }
 // namespace v3
}
 // namespace ranges
 
#endif

#pragma clang module end /*range*/

#if 0 /* expanded by -frewrite-includes */

#include <range/v3/range_fwd.hpp>

#endif /* expanded by -frewrite-includes */

#pragma clang module begin range
/// \file
// Range v3 library
// Project home: https://github.com/ericniebler/range-v3
//
 
#ifndef RANGES_V3_RANGE_FWD_HPP

#define RANGES_V3_RANGE_FWD_HPP
 
#if 0 /* expanded by -frewrite-includes */
#endif /* expanded by -frewrite-includes */

#if 0 /* expanded by -frewrite-includes */

#include <meta/meta.hpp>

#endif /* expanded by -frewrite-includes */

        // Composite concepts for use defining algorithms:
         template<typename S, typename I>         using sized_sentinel_concept =             concepts::most_refined<                 meta::list<                     concepts::SizedSentinel,                     concepts::Sentinel>, S, I>;
            template<typename S, typename I>         using sized_sentinel_concept_t = meta::_t<sized_sentinel_concept<S, I>>;
           /// @}
    }
   }
       
#endif // RANGES_V3_UTILITY_ITERATOR_CONCEPTS_HPP
   
#ifndef RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP
  
#define RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP
   
#if 0 /* expanded by -frewrite-includes */
  
#include <type_traits>
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
#include <range/v3/range_fwd.hpp>
  
#endif /* expanded by -frewrite-includes */
  
           }
           /// \endcond
    }
   }
      
#endif // RANGES_V3_UTILITY_ITERATOR_TRAITS_HPP
  
#pragma clang module end /*range*/
#pragma clang module import std.utility /* clang -frewrite-includes: implicit import */
 namespace ranges {
   inline namespace v3 {
    namespace concepts {
   ///
/// Range concepts below
///
 struct Range {
     template <typename T>   auto requires_(T &t)       -> decltype(concepts::valid_expr(concepts::model_of<Sentinel>(end(t),                                                                     begin(t))));
   };
   }
   // namespace concepts
 template <typename T> using Range = concepts::models<concepts::Range, T>;
    }
   // namespace v3
  /// \endcond
}
   // namespace ranges
   
#endif
  
#pragma clang module end /*range*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "range/v3/begin_end.hpp"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin range
/// \file
//  http://www.boost.org/LICENSE_1_0.txt)
//
// Project home: https://github.com/ericniebler/range-v3
//
   
#ifndef RANGES_V3_BEGIN_END_HPP
  
#define RANGES_V3_BEGIN_END_HPP
#if 0 /* expanded by -frewrite-includes */
  
#include <initializer_list>
  
#endif /* expanded by -frewrite-includes */
  
#if 0 /* expanded by -frewrite-includes */
  
  
#endif /* expanded by -frewrite-includes */
 namespace ranges {
   inline namespace v3 {
             namespace aux          {
              struct copy_fn : copy_tag            {
                template<typename T,                       CONCEPT_REQUIRES_(Constructible<detail::decay_t<T>, T>())>              detail::decay_t<T> operator()(T && t) const              {
    RANGES_RE_ENABLE_WARNINGS    
#endif
  
#pragma clang module end /*range*/
  
#if 0 /* expanded by -frewrite-includes */
  
#include "range/v3/utility/iterator.hpp"
  
#endif /* expanded by -frewrite-includes */
  
#pragma clang module begin range
/// \file
// Range v3 library
//
// Project home: https://github.com/ericniebler/range-v3
//
   
#ifndef RANGES_V3_UTILITY_ITERATOR_HPP
  
#define RANGES_V3_UTILITY_ITERATOR_HPP
     
#pragma clang module import std.new /* clang -frewrite-includes: implicit import */
#pragma clang module import meta /* clang -frewrite-includes: implicit import */
        namespace ranges {
       inline namespace v3     {
           /// \addtogroup group-utility
        /// @{
        namespace adl_advance_detail         {
               using std::advance;
                template<typename I>             RANGES_CXX14_CONSTEXPR             void advance_impl(I &i, difference_type_t<I> n, concepts::InputIterator *)             {
                   RANGES_EXPECT(n >= 0);
                   for(;
   n > 0;
   --n)                     ++i;
               }
               template<typename I>             RANGES_CXX14_CONSTEXPR             void advance_impl(I &i, difference_type_t<I> n, concepts::BidirectionalIterator *)             {
                   if(n > 0)                     for(;
   n > 0;
   --n)                         ++i;
                   else                     for(;
   n < 0;
   ++n)                         --i;
               }
               template<typename I>             RANGES_CXX14_CONSTEXPR             void advance_impl(I &i, difference_type_t<I> n, concepts::RandomAccessIterator *)             {
                   i += n;
               }
               // Hijack std::advance for raw pointers, since std::advance is not constexpr
            template<typename T>             RANGES_CXX14_CONSTEXPR             void advance(T*& i, difference_type_t<T*> n)             {
                   adl_advance_detail::advance_impl(i, n, iterator_concept<T*>{
  }
  );
               }
                struct advance_fn             {
               private:                 template<typename I, typename S>                 RANGES_CXX14_CONSTEXPR                 static void to_(I &i, S s, concepts::Sentinel*);
                   template<typename I, typename S>                 RANGES_CXX14_CONSTEXPR                 static void to_(I &i, S s, concepts::SizedSentinel*);
                   template<typename I, typename D, typename S>                 RANGES_CXX14_CONSTEXPR                 static D bounded_(I &it, D n, S bound, concepts::Sentinel*,                     concepts::InputIterator*);
                   template<typename I, typename D>                 RANGES_CXX14_CONSTEXPR                 static D bounded_(I &it, D n, I bound, concepts::Sentinel*,                     concepts::BidirectionalIterator*);
                   template<typename I, typename D, typename S, typename Concept>                 RANGES_CXX14_CONSTEXPR                 static D bounded_(I &it, D n, S bound, concepts::SizedSentinel*,                     Concept);
               public:                 // Advance a certain number of steps:
                template<typename I,                     CONCEPT_REQUIRES_(Iterator<I>())>                 RANGES_CXX14_CONSTEXPR                 void operator()(I &i, difference_type_t<I> n) const                 {
                       // Use ADL here to give custom iterator types (like counted_iterator)
                    // a chance to optimize it (see utility/counted_iterator.hpp)
                    advance(i, n);
                   }
                   // Advance to a certain position:
                template<typename I, typename S,                     CONCEPT_REQUIRES_(Sentinel<S, I>() && Assignable<I&, S>())>                 RANGES_CXX14_CONSTEXPR                 void operator()(I &i, S s) const                 {
                       i = std::move(s);
                   }
                   template<typename I, typename S,                     CONCEPT_REQUIRES_(Sentinel<S, I>() && !Assignable<I&, S>())>                 RANGES_CXX14_CONSTEXPR                 void operator()(I &i, S s) const                 {
                       advance_fn::to_(i, std::move(s), sized_sentinel_concept<S, I>());
                   }
                   // Advance a certain number of times, with a bound:
                template<typename I, typename S,                     CONCEPT_REQUIRES_(Sentinel<S, I>())>                 RANGES_CXX14_CONSTEXPR                 difference_type_t<I> operator()(I &it, difference_type_t<I> n, S bound) const                 {
                       return advance_fn::bounded_(it, n, std::move(bound),                         sized_sentinel_concept<S, I>(), iterator_concept<I>());
                   }
               };
           }
            /// \ingroup group-utility
        /// \sa `advance_fn`
        RANGES_INLINE_VARIABLE(adl_advance_detail::advance_fn, advance)          namespace adl_advance_detail         {
               template<typename I, typename S>             RANGES_CXX14_CONSTEXPR             void advance_fn::to_(I &i, S s, concepts::Sentinel*)             {
                   while(i != s)                     ++i;
               }
               template<typename I, typename S>             RANGES_CXX14_CONSTEXPR             void advance_fn::to_(I &i, S s, concepts::SizedSentinel*)             {
                   difference_type_t<I> d = s - i;
                   RANGES_EXPECT(0 <= d);
                   ranges::advance(i, d);
               }
               template<typename I, typename D, typename S>             RANGES_CXX14_CONSTEXPR             D advance_fn::bounded_(I &it, D n, S bound, concepts::Sentinel*,                 concepts::InputIterator*)             {
                   RANGES_EXPECT(0 <= n);
                   for(;
   0 != n && it != bound;
   --n)                     ++it;
                   return n;
               }
               template<typename I, typename D>             RANGES_CXX14_CONSTEXPR             D advance_fn::bounded_(I &it, D n, I bound, concepts::Sentinel*,                 concepts::BidirectionalIterator*)             {
                   if(0 <= n)                     for(;
   0 != n && it != bound;
   --n)                         ++it;
               }
           }
            struct next_fn         {
               template<typename I,                 CONCEPT_REQUIRES_(Iterator<I>())>             RANGES_CXX14_CONSTEXPR             I operator()(I it) const             {
                   return ++it;
               }
               template<typename I,                 CONCEPT_REQUIRES_(Iterator<I>())>             RANGES_CXX14_CONSTEXPR             I operator()(I it, difference_type_t<I> n) const             {
                   advance(it, n);
                   return it;
               }
               template<typename I, typename S,                 CONCEPT_REQUIRES_(Sentinel<S, I>())>             RANGES_CXX14_CONSTEXPR             I operator()(I it, S s) const             {
                   advance(it, std::move(s));
                   return it;
               }
               template<typename I, typename S,                 CONCEPT_REQUIRES_(Sentinel<S, I>())>             RANGES_CXX14_CONSTEXPR             I operator()(I it, difference_type_t<I> n, S bound) const             {
                   advance(it, n, std::move(bound));
                   return it;
               }
           };
            /// \ingroup group-utility
        /// \sa `next_fn`
        RANGES_INLINE_VARIABLE(next_fn, next)          struct prev_fn         {
               template<typename I,                 CONCEPT_REQUIRES_(BidirectionalIterator<I>())>             RANGES_CXX14_CONSTEXPR             I operator()(I it, difference_type_t<I> n = 1) const             {
                   advance(it, -n);
                   return it;
               }
               template<typename I,                 CONCEPT_REQUIRES_(BidirectionalIterator<I>())>             RANGES_CXX14_CONSTEXPR             I operator()(I it, difference_type_t<I> n, I bound) const             {
                   advance(it, -n, std::move(bound));
                   return it;
               }
           };
            /// \ingroup group-utility
        /// \sa `prev_fn`
        RANGES_INLINE_VARIABLE(prev_fn, prev)          struct iter_enumerate_fn         {
           private:             template<typename I, typename S, typename D,                 CONCEPT_REQUIRES_(!SizedSentinel<I, I>())>             RANGES_CXX14_CONSTEXPR             std::pair<D, I> impl_i(I begin, S end, D d, concepts::Sentinel*) const             {
                   for(;
   begin != end;
   ++begin)                     ++d;
                   return {
  d, begin};
               }
               template<typename I, typename S, typename D,                 CONCEPT_REQUIRES_(SizedSentinel<I, I>())>             RANGES_CXX14_CONSTEXPR             std::pair<D, I> impl_i(I begin, S end_, D d, concepts::Sentinel*) const             {
                   I end = ranges::next(begin, end_);
                   auto n = static_cast<D>(end - begin);
                   RANGES_EXPECT((Same<I, S>() || 0 <= n));
                   return {
  n + d, end};
               }
               template<typename I, typename S, typename D>             RANGES_CXX14_CONSTEXPR             std::pair<D, I> impl_i(I begin, S end, D d, concepts::SizedSentinel*) const             {
                   auto n = static_cast<D>(end - begin);
                   RANGES_EXPECT((Same<I, S>() || 0 <= n));
                   return {
  n + d, ranges::next(begin, end)};
               }
           public:             template<typename I, typename S, typename D = difference_type_t<I>,                 CONCEPT_REQUIRES_(Iterator<I>() && Sentinel<S, I>() && Integral<D>())>             RANGES_CXX14_CONSTEXPR             std::pair<D, I> operator()(I begin, S end, D d = 0) const             {
                   return this->impl_i(std::move(begin), std::move(end), d,                     sized_sentinel_concept<S, I>());
               }
           };
            /// \ingroup group-utility
        /// \sa `iter_enumerate_fn`
        RANGES_INLINE_VARIABLE(iter_enumerate_fn, iter_enumerate)          struct iter_distance_fn         {
           private:             template<typename I, typename S, typename D>             RANGES_CXX14_CONSTEXPR             D impl_i(I begin, S end, D d, concepts::Sentinel*) const             {
                   return iter_enumerate(std::move(begin), std::move(end), d).first;
               }
               template<typename I, typename S, typename D>             RANGES_CXX14_CONSTEXPR             D impl_i(I begin, S end, D d, concepts::SizedSentinel*) const             {
                   auto n = static_cast<D>(end - begin);
                   RANGES_EXPECT((Same<I, S>() || 0 <= n));
                   return n + d;
               }
           public:             template<typename I, typename S, typename D = difference_type_t<I>,                 CONCEPT_REQUIRES_(Iterator<I>() && Sentinel<S, I>() && Integral<D>())>             RANGES_CXX14_CONSTEXPR             D operator()(I begin, S end, D d = 0) const             {
                   return this->impl_i(std::move(begin), std::move(end), d,                     sized_sentinel_concept<S, I>());
               }
           };
            /// \ingroup group-utility
        /// \sa `iter_distance_fn`
        RANGES_INLINE_VARIABLE(iter_distance_fn, iter_distance)          struct iter_distance_compare_fn         {
           private:             template<typename I, typename S>             RANGES_CXX14_CONSTEXPR             int impl_i(I begin, S end, difference_type_t<I> n, concepts::Sentinel*) const             {
                   if(n < 0)                     return 1;
                   for(;
   n > 0;
   --n, ++begin)                 {
                       if(begin == end)                         return -1;
                   }
                   return begin == end ? 0 : 1;
               }
               template<typename I, typename S>             RANGES_CXX14_CONSTEXPR             int impl_i(I begin, S end, difference_type_t<I> n, concepts::SizedSentinel*) const             {
                   difference_type_t<I> dist = end - begin;
                   if(n < dist)                     return  1;
                   if(dist < n)                     return -1;
                   return  0;
               }
           public:             template<typename I, typename S,                 CONCEPT_REQUIRES_(InputIterator<I>() && Sentinel<S, I>())>             RANGES_CXX14_CONSTEXPR             int operator()(I begin, S end, difference_type_t<I> n) const             {
                   return this->impl_i(std::move(begin), std::move(end), n,                     sized_sentinel_concept<S, I>());
               }
           };
            /// \ingroup group-utility
        /// \sa `iter_distance_compare_fn`
        RANGES_INLINE_VARIABLE(iter_distance_compare_fn, iter_distance_compare)          // Like distance(b,e), but guaranteed to be O(1)
        struct iter_size_fn         {
               template<typename I, typename S,                 CONCEPT_REQUIRES_(SizedSentinel<S, I>())>             RANGES_CXX14_CONSTEXPR             size_type_t<I> operator()(I const& begin, S end) const             {
                   difference_type_t<I> n = end - begin;
                   RANGES_EXPECT(0 <= n);
                   return static_cast<size_type_t<I>>(n);
               }
           };
            /// \ingroup group-utility
        /// \sa `iter_size_fn`
        RANGES_INLINE_VARIABLE(iter_size_fn, iter_size)          template<typename Container>         struct back_insert_iterator         {
               using container_type = Container;
               using difference_type = std::ptrdiff_t;
                constexpr back_insert_iterator() = default;
               explicit back_insert_iterator(Container &x)               : container_(std::addressof(x))             {
  }
               back_insert_iterator &operator=(typename Container::value_type const &value)             {
                   container_->push_back(value);
                   return *this;
               }
               back_insert_iterator &operator++()             {
                   return *this;
               }
               back_insert_iterator operator++(int)             {
                   return *this;
               }
           private:             Container *container_ = nullptr;
           };
            struct back_inserter_fn         {
               template<typename Container>             constexpr back_insert_iterator<Container> operator()(Container &x) const             {
                   return back_insert_iterator<Container>{
  x};
               }
           };
            /// \ingroup group-utility
        /// \sa `back_inserter_fn`
        RANGES_INLINE_VARIABLE(back_inserter_fn, back_inserter)          template<typename Container>         struct front_insert_iterator         {
               using container_type = Container;
               using difference_type = std::ptrdiff_t;
                constexpr front_insert_iterator() = default;
               explicit front_insert_iterator(Container &x)               : container_(std::addressof(x))             {
  }
               front_insert_iterator &operator=(typename Container::value_type const &value)             {
                   container_->push_front(value);
                   return *this;
               }
               front_insert_iterator &operator=(typename Container::value_type &&value)             {
                   container_->push_front(std::move(value));
                   return *this;
                   return *this;
               }
           private:             Container *container_ = nullptr;
           };
            struct front_inserter_fn         {
               template<typename Cont>             front_insert_iterator<Cont> operator()(Cont &cont) const             {
                   return front_insert_iterator<Cont>{
  cont};
               }
           };
            /// \ingroup group-utility
        /// \sa `front_inserter_fn`
        RANGES_INLINE_VARIABLE(front_inserter_fn, front_inserter)          template<typename Container>         struct insert_iterator         {
               using container_type = Container;
               using difference_type = std::ptrdiff_t;
                constexpr insert_iterator() = default;
               explicit insert_iterator(Container &x, typename Container::iterator w)               : container_(std::addressof(x)), where_(w)             {
  }
               insert_iterator &operator=(typename Container::value_type const &value)             {
                   where_ = ranges::next(container_->insert(where_, value));
                   return *this;
               }
               insert_iterator &operator=(typename Container::value_type &&value)             {
               }
               insert_iterator &operator++(int)             {
                   return *this;
               }
           private:             Container* container_ = nullptr;
               typename Container::iterator where_ = detail::value_init{
  };
           };
            struct inserter_fn         {
               template<typename Cont>             insert_iterator<Cont> operator()(Cont &cont, typename Cont::iterator where) const             {
                   return insert_iterator<Cont>{
  cont, std::move(where)};
               }
           };
            /// \ingroup group-utility
        /// \sa `inserter_fn`
        RANGES_INLINE_VARIABLE(inserter_fn, inserter)          template<typename T = void, typename Char = char, typename Traits = std::char_traits<Char>>         struct ostream_iterator         {
               using difference_type = std::ptrdiff_t;
               using char_type = Char;
               using traits_type = Traits;
               using ostream_type = std::basic_ostream<Char, Traits>;
                constexpr ostream_iterator() = default;
               ostream_iterator& operator*()             {
                   return *this;
               }
               ostream_iterator& operator++()             {
                   return *this;
               }
               ostream_iterator& operator++(int)             {
                   return *this;
               }
           private:             ostream_type *sout_;
               Char const *delim_;
           };
            template<typename Char, typename Traits = std::char_traits<Char>>         struct ostreambuf_iterator         {
           public:             typedef ptrdiff_t difference_type;
               typedef Char char_type;
               typedef Traits traits_type;
               typedef std::basic_streambuf<Char, Traits> streambuf_type;
               typedef std::basic_ostream<Char, Traits> ostream_type;
                constexpr ostreambuf_iterator() = default;
               ostreambuf_iterator(ostream_type &s) noexcept               : ostreambuf_iterator(s.rdbuf())             {
               }
               ostreambuf_iterator(streambuf_type *s) noexcept               : sbuf_(s)             {
                   RANGES_ASSERT(s != nullptr);
               }
               ostreambuf_iterator &operator++()             {
                   return *this;
               }
               ostreambuf_iterator &operator++(int)             {
                   return *this;
               }
               bool failed() const noexcept             {
                   return failed_;
               }
           private:             streambuf_type *sbuf_ = nullptr;
               bool failed_ = false;
           };
            /// \cond
        namespace detail         {
               template<typename I>             struct reverse_cursor             {
               private:                 CONCEPT_ASSERT(BidirectionalIterator<I>());
                   template<typename OtherI>                 friend struct reverse_cursor;
                   struct mixin : basic_mixin<reverse_cursor>                 {
                       mixin() = default;
                       using basic_mixin<reverse_cursor>::basic_mixin;
                       RANGES_CXX14_CONSTEXPR                     mixin(I it)                       : mixin{
  reverse_cursor{
  it}
  }
                       {
  }
                       RANGES_CXX14_CONSTEXPR                     I base() const                     {
                           return this->get().base();
                       }
                   };
                    I it_;
                    RANGES_CXX14_CONSTEXPR                 reverse_cursor(I it)                   : it_(std::move(it))                 {
  }
                   RANGES_CXX14_CONSTEXPR                 auto read() const -> reference_t<I>                 {
                       return *arrow();
                   }
                   RANGES_CXX14_CONSTEXPR                 I arrow() const                 {
                       I tmp(it_);
                       --tmp;
                       return tmp;
                   }
                   RANGES_CXX14_CONSTEXPR                 I base() const                 {
                       return it_;
                   }
                   RANGES_CXX14_CONSTEXPR                 bool equal(reverse_cursor const& that) const                 {
                       return it_ == that.it_;
                   }
                   RANGES_CXX14_CONSTEXPR                 void next()                 {
                       --it_;
                   }
                   RANGES_CXX14_CONSTEXPR                 void prev()                 {
                       ++it_;
                   }
                   CONCEPT_REQUIRES(RandomAccessIterator<I>())                 RANGES_CXX14_CONSTEXPR                 void advance(difference_type_t<I> n)                 {
                       it_ -= n;
                   }
                   CONCEPT_REQUIRES(SizedSentinel<I, I>())                 RANGES_CXX14_CONSTEXPR                 difference_type_t<I>                 distance_to(reverse_cursor const &that) const                 {
                       return it_ - that.base();
                   }
                   RANGES_CXX14_CONSTEXPR                 auto move() const                 RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT                 (                     iter_move(it_)                 )             public:                 reverse_cursor() = default;
                   template<typename U,                     CONCEPT_REQUIRES_(ConvertibleTo<U, I>())>                 RANGES_CXX14_CONSTEXPR                 reverse_cursor(reverse_cursor<U> const &u)                   : it_(u.base())                 {
  }
               };
           }
    // namespace detail
        /// \endcond
          template<typename I>         struct move_iterator         {
           private:             CONCEPT_ASSERT(InputIterator<I>());
               I current_ = detail::value_init{
  };
           public:             using iterator_type = I;
               using difference_type = difference_type_t<I>;
               using value_type = value_type_t<I>;
               using iterator_category = input_iterator_tag;
               using reference = rvalue_reference_t<I>;
                constexpr move_iterator() = default;
               explicit move_iterator(I i)               : current_(i)             {
  }
               template<typename O,                 CONCEPT_REQUIRES_(ConvertibleTo<O, I>())>             move_iterator(move_iterator<O> const &i)               : current_(i.base())             {
  }
               template<typename O,                 CONCEPT_REQUIRES_(ConvertibleTo<O, I>())>             move_iterator &operator=(move_iterator<O> const & i)             {
                   current_ = i.base();
                   return *this;
               }
               I base() const             {
                   return current_;
               }
               auto operator*() const             RANGES_DECLTYPE_AUTO_RETURN_NOEXCEPT             (                 iter_move(current_)             )             move_iterator &operator++()             {
                   ++current_;
                   return *this;
               }
               CONCEPT_REQUIRES(!ForwardIterator<I>())             void operator++(int)             {
                   ++current_;
               }
               CONCEPT_REQUIRES(ForwardIterator<I>())             move_iterator operator++(int)             {
                   return move_iterator(current_++);
               }
               CONCEPT_REQUIRES(BidirectionalIterator<I>())             move_iterator &operator--()             {
                   --current_;
                   return *this;
               }
               CONCEPT_REQUIRES(BidirectionalIterator<I>())             move_iterator operator--(int)             {
                   return move_iterator(current_--);
               }
               CONCEPT_REQUIRES(RandomAccessIterator<I>())             move_iterator operator+(difference_type n) const             {
                   return move_iterator(current_ + n);
               }
               CONCEPT_REQUIRES(RandomAccessIterator<I>())             move_iterator &operator-=(difference_type n)             {
                   current_ -= n;
                   return *this;
               }
               CONCEPT_REQUIRES(RandomAccessIterator<I>())             reference operator[](difference_type n) const             {
                   return iter_move(current_ + n);
               }
           };
           template<typename I1, typename I2,             CONCEPT_REQUIRES_(TotallyOrdered<I1, I2>())>         bool operator>=(move_iterator<I1> const &x, move_iterator<I2> const &y)         {
               return !(x < y);
           }
            template<typename I1, typename I2,             CONCEPT_REQUIRES_(SizedSentinel<I1, I2>())>         difference_type_t<I2> operator-(move_iterator<I1> const &x, move_iterator<I2> const &y)         {
               return x.base() - y.base();
           }
           template<typename I,             CONCEPT_REQUIRES_(RandomAccessIterator<I>())>         move_iterator<I> operator+(difference_type_t<I> n, move_iterator<I> const &x)         {
               return x + n;
           }
            CONCEPT_ASSERT(InputIterator<move_iterator<int*>>());
            struct make_move_iterator_fn         {
               template<typename I,                 CONCEPT_REQUIRES_(InputIterator<I>())>             constexpr move_iterator<I> operator()(I it) const             {
                   return move_iterator<I>{
  detail::move(it)};
               }
           };
            RANGES_INLINE_VARIABLE(make_move_iterator_fn, make_move_iterator)          template<typename S>         struct move_sentinel         {
           private:             S sent_;
           public:             constexpr move_sentinel()               : sent_{
  }
               {
  }
               constexpr explicit move_sentinel(S s)               : sent_(detail::move(s))             {
                   return sent_;
               }
           };
            template<typename I, typename S,             CONCEPT_REQUIRES_(Sentinel<S, I>())>         bool operator==(move_iterator<I> const &i, move_sentinel<S> const &s)         {
               return i.base() == s.base();
           }
           template<typename I, typename S,             CONCEPT_REQUIRES_(Sentinel<S, I>())>         bool operator==(move_sentinel<S> const &s, move_iterator<S> const &i)         {
               return s.base() == i.base();
           }
           template<typename I, typename S,             CONCEPT_REQUIRES_(Sentinel<S, I>())>         bool operator!=(move_iterator<S> const &i, move_sentinel<S> const &s)         {
               return i.base() != s.base();
           }
           template<typename I, typename S,             CONCEPT_REQUIRES_(Sentinel<S, I>())>         bool operator!=(move_sentinel<S> const &s, move_iterator<S> const &i)         {
               return s.base() != i.base();
           }
            struct make_move_sentinel_fn         {
               template<typename I,                 CONCEPT_REQUIRES_(InputIterator<I>())>             constexpr move_iterator<I> operator()(I i) const             {
                   return move_iterator<I>{
  detail::move(i)};
               }
                template<typename S,                 CONCEPT_REQUIRES_(SemiRegular<S>() && !InputIterator<S>())>             constexpr move_sentinel<S> operator()(S s) const             {
                   return move_sentinel<S>{
  detail::move(s)};
               }
           };
            RANGES_INLINE_VARIABLE(make_move_sentinel_fn, make_move_sentinel)          /// \cond
        namespace detail         {
               template<typename I, bool IsReadable = (bool) Readable<I>()>             struct move_into_cursor_types             {
  };
                template<typename I>             struct move_into_cursor_types<I, true>             {
                   using value_type = value_type_t<I>;
                   using single_pass = SinglePass<I>;
               };
                template<typename I>             struct move_into_cursor               : move_into_cursor_types<I>             {
               private:                 struct mixin : basic_mixin<move_into_cursor>                 {
                       mixin() = default;
                       using basic_mixin<move_into_cursor>::basic_mixin;
                       explicit mixin(I it)                       : mixin{
  move_into_cursor{
  std::move(it)}
  }
                       {
  }
                       I base() const                     {
                           return this->get().it_;
                       }
                   };
                    I it_;
                    explicit move_into_cursor(I it)                   : it_(std::move(it))                 {
  }
                   void next()                 {
                       ++it_;
                   }
                   template<typename T,                     CONCEPT_REQUIRES_(Writable<I, aux::move_t<T>>())>                 void write(T &&t) noexcept(noexcept(*it_ = std::move(t)))                 {
                       *it_ = std::move(t);
                   }
                   template<typename T,                     CONCEPT_REQUIRES_(Writable<I, aux::move_t<T>>())>                 void write(T &&t) const noexcept(noexcept(*it_ = std::move(t)))                 {
                       *it_ = std::move(t);
                   }
                   CONCEPT_REQUIRES(Readable<I>())                 reference_t<I> read() const                     noexcept(noexcept(*std::declval<I const&>()))                 {
                       return *it_;
                   }
               public:                 constexpr move_into_cursor()                   : it_{
  }
                   {
  }
               };
           }
           /// \endcond
         /// @}
         /// \cond
        namespace adl_uncounted_recounted_detail         {
               template<typename I>             constexpr I uncounted(I i)             {
                   return i;
               }
                template<typename I>             constexpr I recounted(I const &, I i, difference_type_t<I>)             {
                   return i;
               }
                struct uncounted_fn             {
                   template<typename I>                 constexpr                 auto operator()(I i) const ->                     decltype(uncounted((I&&)i))                 {
                       return uncounted((I&&)i);
                   }
               };
                struct recounted_fn             {
                   template<typename I, typename J>                 constexpr                 auto operator()(I i, J j, difference_type_t<J> n) const ->                     decltype(recounted((I&&)i, (J&&)j, n))                 {
                       return recounted((I&&)i, (J&&)j, n);
                   }
               };
           }
           /// \endcond
         /// \addtogroup group-utility
        /// @{
        RANGES_INLINE_VARIABLE(adl_uncounted_recounted_detail::uncounted_fn,                                uncounted)         RANGES_INLINE_VARIABLE(adl_uncounted_recounted_detail::recounted_fn,                                recounted)         /// @}
         /// \cond
        namespace detail         {
               struct std_output_iterator_traits             {
                   using iterator_category = std::output_iterator_tag;
                   using difference_type = std::ptrdiff_t;
                   using value_type = void;
                   using reference = void;
                   using pointer = void;
               };
           }
           /// \endcond
    }
   }
    /// \cond
namespace std {
       template<typename Container>     struct iterator_traits< ::ranges::back_insert_iterator<Container>>       : ::ranges::detail::std_output_iterator_traits     {
  };
        template<typename Container>     struct iterator_traits< ::ranges::front_insert_iterator<Container>>       : ::ranges::detail::std_output_iterator_traits     {
  };
        template<typename Container>     struct iterator_traits< ::ranges::insert_iterator<Container>>       : ::ranges::detail::std_output_iterator_traits     {
  };
        template<typename T, typename Char, typename Traits>     struct iterator_traits< ::ranges::ostream_iterator<T, Char, Traits>>       : ::ranges::detail::std_output_iterator_traits     {
           using pointer = meta::_t<std::add_pointer<reference>>;
       };
   }
   /// \endcond
   
#endif
   
#pragma clang module end /*range*/
   
#pragma clang module begin range
   
#ifndef RANGES_V3_RANGE_CONCEPTS_HPP
  
#define RANGES_V3_RANGE_CONCEPTS_HPP
      namespace ranges {
   inline namespace v3 {
 }
  
#endif
    
#pragma clang module end /*range*/

#pragma clang module endbuild /*range*/
  
#pragma clang module import range /* clang -frewrite-includes: implicit import */
    struct array {
   constexpr int const * begin() const noexcept {
 return nullptr;
  }
   constexpr int const * end() const noexcept {
 return nullptr;
 }
 };
  static_assert(ranges::Range<array>{
}
, "");
 int main() {
 return 0;
 }
    